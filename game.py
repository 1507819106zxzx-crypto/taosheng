from __future__ import annotations

from array import array
import json
import math
import os
import random
import sys
import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import Callable, Sequence

import pygame

# Enable native IME UI (candidate window) for TEXTINPUT/TEXTEDITING on SDL2.
# Must be set before pygame.init().
os.environ.setdefault("SDL_IME_SHOW_UI", "1")

BASE_INTERNAL_W = 480
BASE_INTERNAL_H = 270

# Internal render resolution (dynamically extended on ultrawide windows).
INTERNAL_W = BASE_INTERNAL_W
INTERNAL_H = BASE_INTERNAL_H
FPS = 60
GRID_MARKS = (10, 50, 100, 200, 300, 400)

SETTINGS_PATH = Path(__file__).with_name("settings.json")


def pick_ui_font_path() -> str | None:
    candidates = [
        "Microsoft YaHei",
        "MicrosoftYaHei",
        "msyh",
        "SimHei",
        "simhei",
        "SimSun",
        "simsun",
        "NSimSun",
        "PingFang SC",
        "Noto Sans CJK SC",
        "Source Han Sans CN",
    ]
    for name in candidates:
        try:
            path = pygame.font.match_font(name)
        except Exception:
            path = None
        if path:
            return path

    windir = os.environ.get("WINDIR") or os.environ.get("SystemRoot")
    if windir:
        fonts_dir = Path(windir) / "Fonts"
        for filename in ("msyh.ttc", "msyh.ttf", "simhei.ttf", "simsun.ttc", "simsun.ttf"):
            p = fonts_dir / filename
            if p.exists():
                return str(p)
    return None


def clamp(value: float, low: float, high: float) -> float:
    return low if value < low else high if value > high else value


def iround(x: float) -> int:
    # Python's round() uses bankers rounding (ties to even) which can cause
    # visible 1px jitter when positions sit on .5 boundaries (e.g. odd-sized
    # sprites/colliders). Use a "round half away from zero" instead.
    x = float(x)
    if x >= 0.0:
        return int(math.floor(x + 0.5))
    return int(math.ceil(x - 0.5))


def format_time(seconds: float) -> str:
    seconds = max(0, int(seconds))
    return f"{seconds // 60:02d}:{seconds % 60:02d}"


def draw_text(
    surface: pygame.Surface,
    font: pygame.font.Font,
    text: str,
    pos: tuple[int, int],
    color: pygame.Color,
    *,
    anchor: str = "topleft",  # topleft | center | topright
) -> pygame.Rect:
    img = font.render(text, False, color)
    rect = img.get_rect()
    if anchor == "center":
        rect.center = pos
    elif anchor == "topright":
        rect.topright = pos
    else:
        rect.topleft = pos
    surface.blit(img, rect)
    return rect


def draw_button(
    surface: pygame.Surface,
    font: pygame.font.Font,
    label: str,
    rect: pygame.Rect,
    *,
    selected: bool = False,
    disabled: bool = False,
) -> pygame.Rect:
    if disabled:
        bg = (18, 18, 22)
        border = (50, 50, 60)
        text = pygame.Color(120, 120, 130)
    else:
        bg = (34, 34, 42) if selected else (24, 24, 30)
        border = (110, 110, 130) if selected else (70, 70, 86)
        text = pygame.Color(240, 240, 240) if selected else pygame.Color(200, 200, 210)

    pygame.draw.rect(surface, bg, rect, border_radius=6)
    pygame.draw.rect(surface, border, rect, 2, border_radius=6)
    draw_text(surface, font, label, rect.center, text, anchor="center")
    return rect


def sprite_from_pixels(pixels: Sequence[str], palette: dict[str, tuple[int, int, int]]) -> pygame.Surface:
    height = len(pixels)
    width = max((len(row) for row in pixels), default=0)
    surf = pygame.Surface((width, height), pygame.SRCALPHA)
    for y, row in enumerate(pixels):
        for x, ch in enumerate(row):
            if ch == " ":
                continue
            color = palette.get(ch)
            if color is None:
                continue
            surf.set_at((x, y), color)
    return surf


_BLEED_CACHE: dict[int, pygame.Surface] = {} 
_ROTATE_CACHE: dict[tuple[int, int], pygame.Surface] = {} 
_ROTATE_CRISP_CACHE: dict[tuple[int, int, int], pygame.Surface] = {}  
_ROTATE_WEAPON_CACHE: dict[tuple[int, int, int, int], pygame.Surface] = {}
_ROTATE_WEAPON_TEX_CACHE: dict[tuple[int, int, int], pygame.Surface] = {}
_FLIPX_CACHE: dict[int, pygame.Surface] = {}  
_PALETTE_CACHE: dict[int, tuple[tuple[int, int, int], ...]] = {}  
_SCALE_CACHE: dict[tuple[int, int, int], pygame.Surface] = {}
_SMOOTHSCALE_CACHE: dict[tuple[int, int, int], pygame.Surface] = {}
_FURNITURE_SPR_CACHE: dict[tuple[int, tuple[tuple[int, int], ...], int], pygame.Surface] = {} 
_SPRITE_GRIP_CACHE: dict[int, tuple[int, int]] = {}


def _scale_cached(sprite: pygame.Surface, size: tuple[int, int]) -> pygame.Surface:
    w, h = int(size[0]), int(size[1])
    if w <= 0 or h <= 0:
        return sprite
    key = (id(sprite), w, h)
    cached = _SCALE_CACHE.get(key)
    if cached is not None:
        return cached
    out = pygame.transform.scale(sprite, (w, h))
    _SCALE_CACHE[key] = out
    return out


def _smoothscale_cached(sprite: pygame.Surface, size: tuple[int, int]) -> pygame.Surface:
    w, h = int(size[0]), int(size[1])
    if w <= 0 or h <= 0:
        return sprite
    key = (id(sprite), w, h)
    cached = _SMOOTHSCALE_CACHE.get(key)
    if cached is not None:
        return cached
    out = pygame.transform.smoothscale(sprite, (w, h))
    _SMOOTHSCALE_CACHE[key] = out
    return out


def _alpha_bleed(sprite: pygame.Surface, *, passes: int = 2) -> pygame.Surface:
    cached = _BLEED_CACHE.get(id(sprite))
    if cached is not None and cached.get_size() == sprite.get_size():
        return cached

    surf = sprite.copy()
    w, h = surf.get_size()
    passes = max(0, int(passes))
    if passes <= 0 or w <= 0 or h <= 0:
        _BLEED_CACHE[id(sprite)] = surf
        return surf

    for _ in range(passes):
        base = surf.copy()
        for y in range(h):
            for x in range(w):
                _r, _g, _b, a = base.get_at((x, y))
                if a != 0:
                    continue
                found: tuple[int, int, int] | None = None
                for dy in (-1, 0, 1):
                    ny = y + dy
                    if ny < 0 or ny >= h:
                        continue
                    for dx in (-1, 0, 1):
                        if dx == 0 and dy == 0:
                            continue
                        nx = x + dx
                        if nx < 0 or nx >= w:
                            continue
                        nr, ng, nb, na = base.get_at((nx, ny))
                        if na != 0:
                            found = (nr, ng, nb)
                            break
                    if found is not None:
                        break
                if found is not None:
                    surf.set_at((x, y), (*found, 0))

    _BLEED_CACHE[id(sprite)] = surf
    return surf


def _clamp_alpha(sprite: pygame.Surface, *, threshold: int = 150) -> pygame.Surface:
    w, h = sprite.get_size()
    if w <= 0 or h <= 0:
        return sprite
    threshold = int(clamp(int(threshold), 1, 254))
    for y in range(h):
        for x in range(w):
            r, g, b, a = sprite.get_at((x, y))
            if a == 0:
                continue
            if a < threshold:
                sprite.set_at((x, y), (0, 0, 0, 0))
            else:
                sprite.set_at((x, y), (r, g, b, 255))
    return sprite


def flip_x_pixel_sprite(sprite: pygame.Surface) -> pygame.Surface:
    cached = _FLIPX_CACHE.get(id(sprite))
    if cached is not None:
        return cached
    try:
        flipped = pygame.transform.flip(sprite, True, False)
    except Exception:
        flipped = sprite
    _FLIPX_CACHE[id(sprite)] = flipped
    return flipped


def rotate_pixel_sprite(sprite: pygame.Surface, deg: float, *, step_deg: float = 5.0) -> pygame.Surface: 
    step_deg = float(step_deg) if step_deg else 5.0
    step_deg = float(clamp(step_deg, 1.0, 45.0))
    qdeg = int(round(float(deg) / step_deg) * step_deg) % 360
    key = (id(sprite), qdeg)
    cached = _ROTATE_CACHE.get(key)
    if cached is not None:
        return cached

    src = _alpha_bleed(sprite, passes=2)
    rot = pygame.transform.rotate(src, qdeg)
    rot = _clamp_alpha(rot, threshold=150)
    _ROTATE_CACHE[key] = rot 
    return rot 


def _quantize_rotation_deg(deg: float, step_deg: float) -> int:
    step_deg = float(step_deg) if step_deg else 10.0
    step_deg = float(clamp(step_deg, 1.0, 45.0))
    return int(round(float(deg) / step_deg) * step_deg) % 360


def _rotate_vec_screen_ccw(v: pygame.Vector2, deg: float) -> pygame.Vector2:
    # Match pygame.transform.rotate(): positive degrees rotate counterclockwise on screen.
    rad = math.radians(float(deg))
    c = math.cos(rad)
    s = math.sin(rad)
    return pygame.Vector2(v.x * c + v.y * s, -v.x * s + v.y * c)


def rotate_weapon_sprite(
    sprite: pygame.Surface,
    deg: float,
    *,
    step_deg: float = 2.0,
    outline_diagonal: bool = True,
) -> pygame.Surface:
    # xiaotou-style "stable" weapon rotation: supersample + rotate + smoothscale down.
    # This intentionally breaks the pixel grid at diagonals so pixels don't look like they fall apart.
    outline_diagonal = bool(outline_diagonal)

    step_deg = float(step_deg) if step_deg else 2.0
    step_deg = float(clamp(step_deg, 0.5, 45.0))
    qdeg = int(round(round(float(deg) / step_deg) * step_deg)) % 360

    # Supersampling is expensive on large sprites; adapt.
    max_dim = max(int(sprite.get_width()), int(sprite.get_height()))
    if max_dim >= 160:
        supersample = 2
    elif max_dim >= 120:
        supersample = 3
    elif max_dim >= 84:
        supersample = 4
    elif max_dim >= 60:
        supersample = 5
    else:
        supersample = 6

    key = (id(sprite), int(qdeg), int(supersample), 1 if outline_diagonal else 0)
    cached = _ROTATE_WEAPON_CACHE.get(key)
    if cached is not None:
        return cached

    # Keep axis-aligned angles perfectly crisp.
    if int(qdeg) % 90 == 0:
        rot = sprite if int(qdeg) == 0 else pygame.transform.rotate(sprite, int(qdeg))
        _ROTATE_WEAPON_CACHE[key] = rot
        return rot

    src = _alpha_bleed(sprite, passes=6)
    if supersample != 1:
        src = pygame.transform.scale(src, (src.get_width() * supersample, src.get_height() * supersample))

    pad = 10
    padded = pygame.Surface(
        (src.get_width() + pad * 2 * supersample, src.get_height() + pad * 2 * supersample),
        pygame.SRCALPHA,
    )
    padded.blit(src, (pad * supersample, pad * supersample))
    rot = pygame.transform.rotate(padded, int(qdeg))
    if supersample != 1:
        nw = max(1, int(round(rot.get_width() / float(supersample))))
        nh = max(1, int(round(rot.get_height() / float(supersample))))
        rot = pygame.transform.smoothscale(rot, (nw, nh))

    _ROTATE_WEAPON_CACHE[key] = rot
    return rot


def rotate_weapon_texture(
    sprite: pygame.Surface,
    deg: float,
    *,
    step_deg: float = 2.0,
    outline_diagonal: bool = True,
) -> pygame.Surface:
    # Texture-like rotation (no smoothing): alpha-bleed -> rotate -> clamp alpha -> palette quantize -> outline.
    outline_diagonal = bool(outline_diagonal)
    step_deg = float(step_deg) if step_deg else 2.0
    step_deg = float(clamp(step_deg, 0.5, 45.0))
    qdeg = int(round(round(float(deg) / step_deg) * step_deg)) % 360
    key = (id(sprite), int(qdeg), 1 if outline_diagonal else 0)
    cached = _ROTATE_WEAPON_TEX_CACHE.get(key)
    if cached is not None:
        return cached

    if int(qdeg) % 90 == 0:
        out = sprite if int(qdeg) == 0 else pygame.transform.rotate(sprite, int(qdeg))
    else:
        pal = _sprite_palette_rgb(sprite, max_colors=96)
        src = _alpha_bleed(sprite, passes=6)
        pad = max(10, int(round(max(src.get_width(), src.get_height()) * 0.35)))
        padded = pygame.Surface((src.get_width() + pad * 2, src.get_height() + pad * 2), pygame.SRCALPHA)
        padded.blit(src, (pad, pad))
        out = pygame.transform.rotate(padded, int(qdeg))
        out = _clamp_alpha(out, threshold=150)
        if pal:
            _quantize_rgb_to_palette(out, pal)
            _remove_isolated_pixels(out)
        if outline_diagonal:
            ensure_black_outline_inplace(out, outline_rgb=(16, 16, 16), alpha_threshold=1, diagonal=True)

    _ROTATE_WEAPON_TEX_CACHE[key] = out
    return out


def _sprite_grip_point(sprite: pygame.Surface) -> tuple[int, int]:
    # Heuristic: find a stable "handle" point near the bottom of the opaque
    # silhouette (works well for our small gun/bat/pipe icons). This is used as
    # the pivot when rotating weapons, so stability matters more than precision.
    cached = _SPRITE_GRIP_CACHE.get(id(sprite))
    if cached is not None:
        return cached
    w, h = sprite.get_size()
    if w <= 0 or h <= 0:
        _SPRITE_GRIP_CACHE[id(sprite)] = (0, 0)
        return (0, 0)

    maxy = -1
    for yy in range(int(h)):
        for xx in range(int(w)):
            try:
                if int(sprite.get_at((int(xx), int(yy))).a) <= 0:
                    continue
            except Exception:
                continue
            if int(yy) > int(maxy):
                maxy = int(yy)

    if maxy < 0:
        pt = (int(w // 2), int(h // 2))
        _SPRITE_GRIP_CACHE[id(sprite)] = pt
        return pt

    band_y0 = max(0, int(maxy) - 1)
    xs: list[int] = []
    for yy in range(int(band_y0), int(h)):
        for xx in range(int(w)):
            try:
                if int(sprite.get_at((int(xx), int(yy))).a) <= 0:
                    continue
            except Exception:
                continue
            xs.append(int(xx))

    if not xs:
        pt = (int(w // 2), int(h // 2))
        _SPRITE_GRIP_CACHE[id(sprite)] = pt
        return pt

    xs.sort()
    gx = int(xs[len(xs) // 2])
    gy = int(clamp(int(maxy) - 1, 0, int(h) - 1))
    pt = (int(gx), int(gy))
    _SPRITE_GRIP_CACHE[id(sprite)] = pt
    return pt


def _sprite_palette_rgb(sprite: pygame.Surface, *, max_colors: int = 64) -> tuple[tuple[int, int, int], ...]: 
    cached = _PALETTE_CACHE.get(id(sprite)) 
    if cached is not None: 
        return cached 
    w, h = sprite.get_size() 
    if w <= 0 or h <= 0: 
        _PALETTE_CACHE[id(sprite)] = () 
        return () 
    max_colors = int(clamp(int(max_colors), 1, 512)) 
    out: list[tuple[int, int, int]] = [] 
    seen: set[tuple[int, int, int]] = set() 
    for y in range(h): 
        for x in range(w): 
            r, g, b, a = sprite.get_at((x, y)) 
            if a == 0: 
                continue 
            c = (int(r), int(g), int(b)) 
            if c in seen: 
                continue 
            seen.add(c) 
            out.append(c) 
            if len(out) >= max_colors: 
                _PALETTE_CACHE[id(sprite)] = tuple(out) 
                return _PALETTE_CACHE[id(sprite)] 
    _PALETTE_CACHE[id(sprite)] = tuple(out) 
    return _PALETTE_CACHE[id(sprite)] 


def _quantize_rgb_to_palette(sprite: pygame.Surface, palette: tuple[tuple[int, int, int], ...]) -> pygame.Surface:  
    if not palette: 
        return sprite 
    w, h = sprite.get_size() 
    if w <= 0 or h <= 0: 
        return sprite 
    cache: dict[tuple[int, int, int], tuple[int, int, int]] = {} 
    for y in range(h): 
        for x in range(w): 
            r, g, b, a = sprite.get_at((x, y)) 
            if a == 0: 
                continue 
            src = (int(r), int(g), int(b)) 
            dst = cache.get(src) 
            if dst is None: 
                br, bg, bb = palette[0] 
                best_d2 = (src[0] - br) * (src[0] - br) + (src[1] - bg) * (src[1] - bg) + (src[2] - bb) * (src[2] - bb) 
                for pr, pg, pb in palette[1:]: 
                    d2 = (src[0] - pr) * (src[0] - pr) + (src[1] - pg) * (src[1] - pg) + (src[2] - pb) * (src[2] - pb) 
                    if d2 < best_d2: 
                        br, bg, bb = pr, pg, pb 
                        best_d2 = d2 
                dst = (int(br), int(bg), int(bb)) 
                cache[src] = dst 
            sprite.set_at((x, y), (int(dst[0]), int(dst[1]), int(dst[2]), 255)) 
    return sprite  
 
 
def _remove_isolated_pixels(sprite: pygame.Surface) -> None: 
    w, h = sprite.get_size() 
    if w <= 2 or h <= 2: 
        return 
    keep = [[False] * w for _ in range(h)] 
    for y in range(h): 
        for x in range(w): 
            _r, _g, _b, a = sprite.get_at((x, y)) 
            keep[y][x] = a != 0 
    for y in range(1, h - 1): 
        for x in range(1, w - 1): 
            if not keep[y][x]: 
                continue 
            n = 0 
            for dy in (-1, 0, 1): 
                for dx in (-1, 0, 1): 
                    if dx == 0 and dy == 0: 
                        continue 
                    if keep[y + dy][x + dx]: 
                        n += 1 
            if n == 0: 
                sprite.set_at((x, y), (0, 0, 0, 0)) 
 
 
def ensure_black_outline_inplace( 
    sprite: pygame.Surface, 
    *, 
    outline_rgb: tuple[int, int, int] = (10, 10, 12), 
    alpha_threshold: int = 1, 
    diagonal: bool = True, 
) -> None: 
    w, h = sprite.get_size() 
    if w <= 0 or h <= 0: 
        return 
 
    alpha_threshold = int(alpha_threshold) 
    if alpha_threshold <= 0: 
        alpha_threshold = 1 
 
    src = sprite.copy() 
 
    # Body pixels exclude the existing outline color; avoids double-thick borders. 
    body = [[False] * w for _ in range(h)] 
    alpha = [[0] * w for _ in range(h)] 
    for yy in range(h): 
        for xx in range(w): 
            r, g, b, a = src.get_at((xx, yy)) 
            a = int(a) 
            alpha[yy][xx] = a 
            if a >= alpha_threshold and (int(r), int(g), int(b)) != outline_rgb: 
                body[yy][xx] = True 
 
    outside = [[False] * w for _ in range(h)] 
    stack: list[tuple[int, int]] = [] 
 
    def push(xx: int, yy: int) -> None: 
        if outside[yy][xx]: 
            return 
        if alpha[yy][xx] >= alpha_threshold: 
            return 
        outside[yy][xx] = True 
        stack.append((xx, yy)) 
 
    for xx in range(w): 
        push(xx, 0) 
        push(xx, h - 1) 
    for yy in range(h): 
        push(0, yy) 
        push(w - 1, yy) 
 
    while stack: 
        xx, yy = stack.pop() 
        if xx > 0: 
            push(xx - 1, yy) 
        if xx + 1 < w: 
            push(xx + 1, yy) 
        if yy > 0: 
            push(xx, yy - 1) 
        if yy + 1 < h: 
            push(xx, yy + 1) 
 
    col = (outline_rgb[0], outline_rgb[1], outline_rgb[2], 255) 
 
    if diagonal: 
        neighbors = [(dx, dy) for dy in (-1, 0, 1) for dx in (-1, 0, 1) if not (dx == 0 and dy == 0)] 
    else: 
        neighbors = [(-1, 0), (1, 0), (0, -1), (0, 1)] 
 
    for yy in range(h): 
        for xx in range(w): 
            if not outside[yy][xx]: 
                continue 
            found = False 
            for dx, dy in neighbors: 
                nx = xx + dx 
                ny = yy + dy 
                if nx < 0 or nx >= w or ny < 0 or ny >= h: 
                    continue 
                if body[ny][nx]: 
                    found = True 
                    break 
            if found: 
                sprite.set_at((xx, yy), col) 
 
    # If the body touches the edge, force outline pixels so the border closes. 
    for xx in range(w): 
        if body[0][xx]: 
            sprite.set_at((xx, 0), col) 
        if body[h - 1][xx]: 
            sprite.set_at((xx, h - 1), col) 
    for yy in range(h): 
        if body[yy][0]: 
            sprite.set_at((0, yy), col) 
        if body[yy][w - 1]: 
            sprite.set_at((w - 1, yy), col) 
 
 
def rotate_pixel_sprite_crisp(sprite: pygame.Surface, deg: float, *, step_deg: float = 5.0, upscale: int = 3) -> pygame.Surface: 
    # Pixel-perfect rotation for small sprites (weapons/tools). Inspired by the xiaotou pipeline: 
    # alpha-bleed -> supersample rotate -> downsample -> clamp alpha -> palette quantize -> outline. 
    step_deg = float(step_deg) if step_deg else 5.0 
    step_deg = float(clamp(step_deg, 1.0, 45.0)) 
    qdeg = int(round(float(deg) / step_deg) * step_deg) % 360 
    pixel_scale = int(clamp(int(upscale), 1, 8)) 
    key = (id(sprite), int(qdeg), int(pixel_scale)) 
    cached = _ROTATE_CRISP_CACHE.get(key) 
    if cached is not None: 
        return cached 
 
    if int(qdeg) % 90 == 0: 
        out = sprite if int(qdeg) == 0 else pygame.transform.rotate(sprite, int(qdeg)) 
        _ROTATE_CRISP_CACHE[key] = out 
        return out 
 
    w, h = sprite.get_size() 
    if w <= 0 or h <= 0: 
        _ROTATE_CRISP_CACHE[key] = sprite 
        return sprite 
 
    pad = 10 
    src = _alpha_bleed(sprite, passes=6) 
    pal = _sprite_palette_rgb(sprite, max_colors=48) 
    if int(pixel_scale) != 1: 
        try: 
            src = pygame.transform.scale(src, (int(src.get_width()) * int(pixel_scale), int(src.get_height()) * int(pixel_scale))) 
        except Exception: 
            pixel_scale = 1 
    padded = pygame.Surface( 
        (int(src.get_width()) + int(pad) * 2 * int(pixel_scale), int(src.get_height()) + int(pad) * 2 * int(pixel_scale)), 
        pygame.SRCALPHA, 
    ) 
    padded.blit(src, (int(pad) * int(pixel_scale), int(pad) * int(pixel_scale))) 
    rot = pygame.transform.rotate(padded, int(qdeg)) 
    if int(pixel_scale) != 1: 
        nw = max(1, int(round(float(rot.get_width()) / float(pixel_scale)))) 
        nh = max(1, int(round(float(rot.get_height()) / float(pixel_scale)))) 
        rot = pygame.transform.scale(rot, (int(nw), int(nh))) 
    rot = _clamp_alpha(rot, threshold=210) 
    if pal: 
        _quantize_rgb_to_palette(rot, pal) 
        _remove_isolated_pixels(rot) 
    ensure_black_outline_inplace(rot, outline_rgb=(10, 10, 12), alpha_threshold=1, diagonal=True) 
    _ROTATE_CRISP_CACHE[key] = rot 
    return rot 


def _make_sound(samples: array, *, volume: float = 0.35) -> pygame.mixer.Sound | None:
    if pygame.mixer.get_init() is None:
        return None
    try:
        snd = pygame.mixer.Sound(buffer=samples.tobytes())
        snd.set_volume(float(volume))
        return snd
    except Exception:
        return None


def _sfx_shot(rate: int) -> pygame.mixer.Sound | None:
    dur_s = 0.085
    n = max(1, int(rate * dur_s))
    out = array("h")
    max_amp = 32767
    for i in range(n):
        t = i / rate
        env = math.exp(-t * 55.0)
        noise = random.uniform(-1.0, 1.0) * 0.65
        thump = math.sin(math.tau * 120.0 * t) * 0.35
        click = (1.0 if i < 18 else 0.0) * 0.8
        v = (noise + thump + click) * env
        v = clamp(v, -1.0, 1.0)
        out.append(int(v * max_amp))
    return _make_sound(out, volume=0.32)


def _sfx_swing(rate: int) -> pygame.mixer.Sound | None:
    dur_s = 0.14
    n = max(1, int(rate * dur_s))
    out = array("h")
    max_amp = 32767
    for i in range(n):
        t = i / rate
        u = t / max(1e-6, dur_s)
        env = math.exp(-t * 28.0) * (1.0 if u < 1.0 else 0.0)
        sweep = 1400.0 + (260.0 - 1400.0) * u
        tone = math.sin(math.tau * sweep * t) * 0.25
        noise = random.uniform(-1.0, 1.0) * 0.45
        v = (tone + noise) * env
        v = clamp(v, -1.0, 1.0)
        out.append(int(v * max_amp))
    return _make_sound(out, volume=0.26)


def _sfx_hit(rate: int) -> pygame.mixer.Sound | None:
    # Short "thump" for melee hits.
    dur_s = 0.075
    n = max(1, int(rate * dur_s))
    out = array("h")
    max_amp = 32767
    for i in range(n):
        t = i / rate
        u = t / max(1e-6, dur_s)
        env = math.exp(-t * 75.0) * (1.0 if u < 1.0 else 0.0)
        thump = math.sin(math.tau * 90.0 * t) * 0.45
        noise = random.uniform(-1.0, 1.0) * 0.35
        v = (thump + noise) * env
        v = clamp(v, -1.0, 1.0)
        out.append(int(v * max_amp))
    return _make_sound(out, volume=0.34)


class SFX:
    def __init__(self) -> None:
        self.enabled = pygame.mixer.get_init() is not None
        self.shot: pygame.mixer.Sound | None = None
        self.swing: pygame.mixer.Sound | None = None
        self.hit: pygame.mixer.Sound | None = None
        if not self.enabled:
            return
        rate = pygame.mixer.get_init()[0] if pygame.mixer.get_init() else 22050
        self.shot = _sfx_shot(int(rate))
        self.swing = _sfx_swing(int(rate))
        self.hit = _sfx_hit(int(rate))

    def play(self, name: str) -> None:
        if not self.enabled:
            return
        snd = getattr(self, name, None)
        if snd is not None:
            try:
                snd.play()
            except Exception:
                return


@dataclass
class GameConfig:
    scale: int = 2
    fullscreen: bool = True
    show_grid: bool = True
    # Lighting (tile radius + intensity/opacity scale).
    lamp_world_radius_tiles: int = 3
    lamp_world_intensity: float = 1.0
    lamp_world_halo: float = 0.35
    lamp_hr_radius_tiles: int = 5
    lamp_hr_intensity: float = 1.0
    lamp_hr_halo: float = 0.35

    @classmethod
    def load(cls) -> "GameConfig":
        try:
            data = json.loads(SETTINGS_PATH.read_text(encoding="utf-8"))
            return cls(
                scale=int(data.get("scale", 2)),
                fullscreen=bool(data.get("fullscreen", True)),
                show_grid=bool(data.get("show_grid", True)),
                lamp_world_radius_tiles=int(data.get("lamp_world_radius_tiles", 5)),
                lamp_world_intensity=float(data.get("lamp_world_intensity", 1.0)),
                lamp_world_halo=float(data.get("lamp_world_halo", data.get("lamp_world_opacity", 0.35))),
                lamp_hr_radius_tiles=int(data.get("lamp_hr_radius_tiles", 5)),
                lamp_hr_intensity=float(data.get("lamp_hr_intensity", 1.0)),
                lamp_hr_halo=float(data.get("lamp_hr_halo", data.get("lamp_hr_opacity", 0.35))),
            )
        except Exception:
            return cls()

    def save(self) -> None:
        SETTINGS_PATH.write_text(
            json.dumps(
                {
                    "scale": int(self.scale),
                    "fullscreen": bool(self.fullscreen),
                    "show_grid": bool(self.show_grid),
                    "lamp_world_radius_tiles": int(self.lamp_world_radius_tiles),
                    "lamp_world_intensity": float(self.lamp_world_intensity),
                    "lamp_world_halo": float(self.lamp_world_halo),
                    "lamp_hr_radius_tiles": int(self.lamp_hr_radius_tiles),
                    "lamp_hr_intensity": float(self.lamp_hr_intensity),
                    "lamp_hr_halo": float(self.lamp_hr_halo),
                },
                ensure_ascii=False,
                indent=2,
            ),
            encoding="utf-8",
        )


@dataclass(frozen=True)
class CharacterDef:
    id: str
    name: str
    desc: str
    sprite: pygame.Surface
    base_hp: int
    move_speed: float
    start_weapon: str
    regen: float = 0.0
    damage_mult: float = 1.0
    cooldown_mult: float = 1.0
    frames: tuple[pygame.Surface, ...] | None = None
    skeleton_frames: tuple[dict[str, tuple[int, int]], ...] | None = None


@dataclass(frozen=True)
class MapDef:
    id: str
    name: str
    desc: str
    base_color: tuple[int, int, int]
    accent_color: tuple[int, int, int]
    enemy_pool: tuple[str, ...]


@dataclass(frozen=True)
class EnemyDef:
    id: str
    name: str
    color: tuple[int, int, int]
    hp: int
    speed: float
    size: int
    contact_damage: int
    xp_value: int
    frames: tuple[pygame.Surface, ...] | None = None


@dataclass(frozen=True)
class WeaponDef:
    id: str
    name: str
    desc: str
    kind: str  # melee | orbit | gun
    color: tuple[int, int, int]
    cooldown_s: float
    damage: int
    proj_speed: float = 0.0
    proj_size: int = 2
    pierce: int = 0
    magazine: int = 0
    reload_s: float = 0.0
    proj_ttl_s: float = 2.5
    spread_rad: float = 0.0
    knockback: float = 0.0
    aoe_radius: float = 0.0
    aoe_damage_mult: float = 1.0
    recoil_per_shot: float = 0.0
    recoil_decay: float = 0.0
    recoil_max: float = 0.0
    shots_per_fire: int = 1
    sprite: pygame.Surface | None = None


@dataclass(frozen=True)
class Upgrade:
    title: str
    desc: str
    apply: Callable[["Player", "GameState"], None]


class Player:
    def __init__(self, char_def: CharacterDef) -> None:
        self.char_def = char_def
        self.frames = char_def.frames or (char_def.sprite,)
        self.skeleton_frames = char_def.skeleton_frames or ()
        self._flip_cache: dict[int, pygame.Surface] = {}
        self.facing = 1
        self.anim_time = 0.0
        self.anim_index = 0
        self.draw_offset = pygame.Vector2(0, 0)
        self.sprite = self.frames[0]
        self.w = self.sprite.get_width()
        self.h = self.sprite.get_height()

        self.skeleton_nodes: dict[str, tuple[int, int]] = self._current_skeleton_nodes()

        self.pos = pygame.Vector2(INTERNAL_W // 2 - self.w // 2, INTERNAL_H // 2 - self.h // 2)
        self.max_hp = int(char_def.base_hp)
        self.hp = float(self.max_hp)
        self.regen = float(char_def.regen)

        self.move_speed = float(char_def.move_speed)
        self.damage_mult = float(char_def.damage_mult)
        self.cooldown_mult = float(char_def.cooldown_mult)
        self.xp_mult = 1.0

        self.level = 1
        self.xp = 0.0
        self.xp_to_next = 12.0

        self.invuln_s = 0.0
        self.hurt_s = 0.0
        self.last_move_dir = pygame.Vector2(1, 0)

        self.weapons: list[WeaponInstance] = []

    def _base_frame(self, index: int) -> pygame.Surface:
        if not self.frames:
            return self.char_def.sprite
        idx = max(0, min(int(index), len(self.frames) - 1))
        return self.frames[idx]

    def _current_skeleton_nodes(self) -> dict[str, tuple[int, int]]:
        if not self.skeleton_frames:
            return {}
        idx = max(0, min(int(self.anim_index), len(self.skeleton_frames) - 1))
        nodes = self.skeleton_frames[idx]
        if self.facing >= 0:
            return dict(nodes)
        w = self._base_frame(idx).get_width()
        return {name: (w - 1 - x, y) for name, (x, y) in nodes.items()}

    def _frame_for_facing(self, index: int) -> pygame.Surface:
        base = self._base_frame(index)
        if self.facing >= 0:
            return base
        cached = self._flip_cache.get(index)
        if cached is None or cached.get_size() != base.get_size():
            cached = pygame.transform.flip(base, True, False)
            self._flip_cache[index] = cached
        return cached

    def update_visual(self, dt: float, move_dir: pygame.Vector2) -> None:
        if move_dir.length_squared() > 0.0001:
            if move_dir.x < -0.1:
                self.facing = -1
            elif move_dir.x > 0.1:
                self.facing = 1

            if len(self.frames) >= 3:
                self.anim_time += dt * (7.0 + self.move_speed * 0.02)
                step = int(self.anim_time) % 2
                self.anim_index = 1 + step
            elif len(self.frames) == 2:
                self.anim_time += dt * (6.0 + self.move_speed * 0.02)
                self.anim_index = int(self.anim_time) % 2
            else:
                self.anim_index = 0
            self.draw_offset.y = -1 if self.anim_index == 1 else 0
        else:
            self.anim_time = 0.0
            self.anim_index = 0
            self.draw_offset.update(0.0, 0.0)

        self.sprite = self._frame_for_facing(self.anim_index)
        self.w = self.sprite.get_width()
        self.h = self.sprite.get_height()
        self.skeleton_nodes = self._current_skeleton_nodes()

    def rect(self) -> pygame.Rect:
        return pygame.Rect(int(self.pos.x), int(self.pos.y), self.w, self.h)

    def center(self) -> pygame.Vector2:
        r = self.rect()
        return pygame.Vector2(r.centerx, r.centery)

    def orbit_center(self) -> pygame.Vector2:
        chest = self.skeleton_nodes.get("chest")
        if chest is not None:
            cx, cy = chest
            return pygame.Vector2(int(self.pos.x) + cx, int(self.pos.y) + cy) + self.draw_offset
        return self.center() + self.draw_offset

    def hand_pos(self) -> pygame.Vector2:
        hand = self.skeleton_nodes.get("r_hand")
        if hand is not None:
            hx, hy = hand
            return pygame.Vector2(int(self.pos.x) + hx, int(self.pos.y) + hy) + self.draw_offset
        return self.orbit_center()


class Enemy:
    _next_uid = 1

    def __init__(self, enemy_def: EnemyDef, pos: pygame.Vector2) -> None:
        self.enemy_def = enemy_def
        self.pos = pos
        self.hp = float(enemy_def.hp)
        self.size = int(enemy_def.size)
        self.uid = Enemy._next_uid
        Enemy._next_uid += 1
        self.anim_time = random.random() * 10.0
        self.vel = pygame.Vector2(0, 0)

        self.frames: tuple[pygame.Surface, ...] | None = None
        self.sprite: pygame.Surface | None = None
        if enemy_def.frames:
            scaled: list[pygame.Surface] = []
            for frame in enemy_def.frames:
                if frame.get_size() == (self.size, self.size):
                    scaled.append(frame)
                else:
                    scaled.append(pygame.transform.scale(frame, (self.size, self.size)))
            self.frames = tuple(scaled)
            self.sprite = self.frames[0] if self.frames else None

    def rect(self) -> pygame.Rect:
        return pygame.Rect(int(self.pos.x), int(self.pos.y), self.size, self.size)

    def center(self) -> pygame.Vector2:
        r = self.rect()
        return pygame.Vector2(r.centerx, r.centery)

    def update_visual(self, dt: float) -> None:
        if not self.frames or len(self.frames) <= 1:
            return
        self.anim_time += dt
        rate = 4.5 if self.enemy_def.id == "slime" else 6.0
        idx = int(self.anim_time * rate) % len(self.frames)
        self.sprite = self.frames[idx]


class Projectile:
    def __init__(
        self,
        pos: pygame.Vector2,
        vel: pygame.Vector2,
        *,
        size: int,
        color: tuple[int, int, int],
        damage: float,
        pierce: int = 0,
        knockback: float = 0.0,
        aoe_radius: float = 0.0,
        aoe_damage_mult: float = 1.0,
        ttl_s: float = 3.0,
    ) -> None:
        self.pos = pygame.Vector2(pos)
        self.vel = pygame.Vector2(vel)
        self.size = int(size)
        self.color = color
        self.damage = float(damage)
        self.pierce = int(pierce)
        self.knockback = float(knockback)
        self.aoe_radius = float(aoe_radius)
        self.aoe_damage_mult = float(aoe_damage_mult)
        self.ttl_s = float(ttl_s)
        self.hit_uids: set[int] = set()

    def rect(self) -> pygame.Rect:
        return pygame.Rect(int(self.pos.x), int(self.pos.y), self.size, self.size)


class Swing:
    def __init__(self, rect: pygame.Rect, damage: float, ttl_s: float = 0.12) -> None:
        self.rect = rect
        self.damage = float(damage)
        self.ttl_s = float(ttl_s)
        self.hit_uids: set[int] = set()


class WeaponInstance:
    def __init__(self, weapon_def: WeaponDef) -> None:
        self.weapon_def = weapon_def
        self.level = 1
        self.cooldown_left = 0.0
        self.angle = random.random() * math.tau
        self.orbit_radius = 18.0
        self.orbit_speed = 2.6
        self.size = 8
        self.orbit_rect = pygame.Rect(0, 0, self.size, self.size)
        self.aim_angle = 0.0
        self.ammo = max(0, int(weapon_def.magazine))
        self.reload_left = 0.0
        self.reload_total = 0.0
        self.reload_spin = 0.0
        self.recoil = 0.0
        self.muzzle_flash_s = 0.0
        self.swinging = False
        self.swing_t = 0.0
        self.swing_duration_s = 0.16
        self.swing_a0 = 0.0
        self.swing_a1 = 0.0
        self.swing_hit_uids: set[int] = set()
        self.sword_poly: list[tuple[int, int]] = []
        self.sword_base = pygame.Vector2(0, 0)
        self.sword_tip = pygame.Vector2(0, 0)
        self.trail: list[tuple[pygame.Vector2, float]] = []

    def level_bonus(self) -> float:
        return 1.0 + 0.25 * (self.level - 1)

    def cooldown_bonus(self) -> float:
        return 0.92 ** (self.level - 1)

    def damage(self, player: Player) -> float:
        return float(self.weapon_def.damage) * self.level_bonus() * player.damage_mult

    def cooldown_s(self, player: Player) -> float:
        return max(0.08, float(self.weapon_def.cooldown_s) * self.cooldown_bonus() * player.cooldown_mult)

    def update(self, dt: float, player: Player, game: "GameState") -> None:
        if self.weapon_def.kind == "melee":
            self.cooldown_left -= dt

            if self.trail:
                updated: list[tuple[pygame.Vector2, float]] = []
                for pos, age in self.trail:
                    age += dt
                    if age <= 0.18:
                        updated.append((pos, age))
                self.trail = updated

            length = float(12 + max(0, self.level - 1) * 2)
            thickness = float(4 + max(0, self.level - 1) // 2)
            hand = player.hand_pos()

            if not self.swinging and self.cooldown_left <= 0.0:
                self.swinging = True
                self.swing_t = 0.0
                self.swing_hit_uids.clear()
                self.cooldown_left = self.cooldown_s(player)
                game.app.play_sfx("swing")

                base = 0.0 if player.facing >= 0 else math.pi
                arc = 1.08
                self.swing_a0 = base - arc
                self.swing_a1 = base + arc

            if self.swinging:
                self.swing_t += dt
                t = 1.0 if self.swing_duration_s <= 0 else clamp(self.swing_t / self.swing_duration_s, 0.0, 1.0)
                t = t * t * (3.0 - 2.0 * t)
                ang = self.swing_a0 + (self.swing_a1 - self.swing_a0) * t
                if self.swing_t >= self.swing_duration_s:
                    self.swinging = False
            else:
                ang = 0.12 if player.facing >= 0 else math.pi - 0.12

            d = pygame.Vector2(math.cos(ang), math.sin(ang))
            if d.length_squared() <= 0.001:
                d = pygame.Vector2(1, 0 if player.facing >= 0 else -1)
            perp = pygame.Vector2(-d.y, d.x)
            half = thickness * 0.5

            base = pygame.Vector2(hand)
            tip = base + d * length
            p1 = base + perp * half
            p2 = base - perp * half
            p3 = tip - perp * half
            p4 = tip + perp * half

            self.sword_base = base
            self.sword_tip = tip
            self.sword_poly = [(int(p1.x), int(p1.y)), (int(p2.x), int(p2.y)), (int(p3.x), int(p3.y)), (int(p4.x), int(p4.y))]

            min_x = int(min(p1.x, p2.x, p3.x, p4.x))
            min_y = int(min(p1.y, p2.y, p3.y, p4.y))
            max_x = int(max(p1.x, p2.x, p3.x, p4.x))
            max_y = int(max(p1.y, p2.y, p3.y, p4.y))
            self.orbit_rect = pygame.Rect(min_x, min_y, max(1, max_x - min_x + 1), max(1, max_y - min_y + 1))

            if self.swinging:
                if not self.trail or (self.trail[-1][0] - tip).length_squared() > 1.0:
                    self.trail.append((pygame.Vector2(tip), 0.0))

                for e in game.enemies:
                    if e.uid in self.swing_hit_uids:
                        continue
                    if not self.orbit_rect.colliderect(e.rect()):
                        continue
                    self.swing_hit_uids.add(e.uid)
                    dmg = self.damage(player)
                    e.hp -= dmg
                    game.add_damage_text(e.center(), dmg, color=(255, 240, 200))

                    knock = 180.0 if e.enemy_def.id == "slime" else 90.0
                    away = (e.center() - player.center())
                    if away.length_squared() > 0.01:
                        e.vel += away.normalize() * knock
                    else:
                        rand = pygame.Vector2(random.uniform(-1, 1), random.uniform(-1, 1))
                        if rand.length_squared() <= 0.001:
                            rand = pygame.Vector2(1, 0)
                        e.vel += rand.normalize() * knock
            return
        c = player.orbit_center()
        offset = pygame.Vector2(math.cos(self.angle), math.sin(self.angle)) * self.orbit_radius
        pos = c + offset

        if self.weapon_def.kind == "gun":
            self.muzzle_flash_s = max(0.0, self.muzzle_flash_s - dt)
            size = int(10 + max(0, self.level - 1) // 2)
            self.orbit_rect.size = (size, size)
            self.orbit_rect.center = (int(pos.x), int(pos.y))

            target = game.closest_enemy_to(pos)
            if target is not None:
                aim = (target.center() - pos)
                if aim.length_squared() > 0.01:
                    aim = aim.normalize()
                else:
                    aim = pygame.Vector2(1, 0)
            else:
                aim = pygame.Vector2(player.last_move_dir)
                if aim.length_squared() <= 0.01:
                    aim = pygame.Vector2(1, 0)
                else:
                    aim = aim.normalize()
            self.aim_angle = math.atan2(aim.y, aim.x)

            if self.weapon_def.recoil_decay > 0:
                self.recoil = max(0.0, self.recoil - float(self.weapon_def.recoil_decay) * dt)

            mag = max(1, int(self.weapon_def.magazine + max(0, self.level - 1) // 3))
            reload_s = max(0.35, float(self.weapon_def.reload_s) * (0.96 ** max(0, self.level - 1)))

            if self.reload_left > 0.0:
                self.reload_left = max(0.0, self.reload_left - dt)
                self.reload_spin = (self.reload_spin + dt * 11.0) % math.tau
                if self.reload_left <= 0.0:
                    self.ammo = mag
                    self.reload_total = 0.0
                    self.reload_spin = 0.0
                    self.cooldown_left = max(self.cooldown_left, 0.06)
                return

            self.cooldown_left -= dt
            if self.cooldown_left > 0.0:
                return

            if self.ammo <= 0:
                self.reload_total = reload_s
                self.reload_left = reload_s
                self.reload_spin = 0.0
                return

            spread = float(self.weapon_def.spread_rad) + float(self.recoil)
            base_kb = float(self.weapon_def.knockback)
            if base_kb <= 0.0:
                base_kb = 70.0 + float(self.weapon_def.damage) * 4.0
            knock = base_kb * (1.0 + 0.10 * max(0, self.level - 1))

            bullet_speed = max(10.0, float(self.weapon_def.proj_speed))
            shots = max(1, int(self.weapon_def.shots_per_fire))
            for _ in range(shots):
                a = self.aim_angle
                if spread > 0:
                    a += random.uniform(-spread, spread)
                d = pygame.Vector2(math.cos(a), math.sin(a))
                if d.length_squared() <= 0.001:
                    d = pygame.Vector2(1, 0)

                game.projectiles.append(
                    Projectile(
                        pos,
                        d * bullet_speed,
                        size=max(1, int(self.weapon_def.proj_size)),
                        color=self.weapon_def.color,
                        damage=self.damage(player),
                        pierce=int(self.weapon_def.pierce),
                        knockback=knock,
                        aoe_radius=float(self.weapon_def.aoe_radius),
                        aoe_damage_mult=float(self.weapon_def.aoe_damage_mult),
                        ttl_s=float(self.weapon_def.proj_ttl_s),
                    )
                )
            game.app.play_sfx("shot")
            self.muzzle_flash_s = 0.06 if self.weapon_def.aoe_radius <= 0.0 else 0.10
            if self.weapon_def.recoil_per_shot > 0 and self.weapon_def.recoil_max > 0:
                self.recoil = min(float(self.weapon_def.recoil_max), self.recoil + float(self.weapon_def.recoil_per_shot))

            self.ammo -= 1
            self.cooldown_left = self.cooldown_s(player)
            if self.ammo <= 0:
                self.reload_total = reload_s
                self.reload_left = reload_s
                self.reload_spin = 0.0
            return

        size = int(self.size + max(0, self.level - 1))
        self.orbit_rect.size = (size, size)
        self.orbit_rect.center = (int(pos.x), int(pos.y))

        self.cooldown_left -= dt
        if self.cooldown_left > 0:
            return

        for e in game.enemies:
            if self.orbit_rect.colliderect(e.rect()):
                dmg = self.damage(player)
                e.hp -= dmg
                game.add_damage_text(e.center(), dmg, color=(220, 240, 255))
                self.cooldown_left = self.cooldown_s(player)
                break


@dataclass
class WeaponPickup:
    weapon_id: str
    pos: pygame.Vector2
    bob_t: float = 0.0

    def rect(self) -> pygame.Rect:
        return pygame.Rect(int(self.pos.x), int(self.pos.y), 10, 10)

    def level_bonus(self) -> float:
        return 1.0 + 0.25 * (self.level - 1)

    def cooldown_bonus(self) -> float:
        return 0.92 ** (self.level - 1)

    def damage(self, player: Player) -> float:
        return float(self.weapon_def.damage) * self.level_bonus() * player.damage_mult

    def cooldown_s(self, player: Player) -> float:
        return max(0.08, float(self.weapon_def.cooldown_s) * self.cooldown_bonus() * player.cooldown_mult)

    def update(self, dt: float, player: Player, game: "GameState") -> None:     
        if self.weapon_def.kind == "melee":
            self.cooldown_left -= dt

            if self.trail:
                updated: list[tuple[pygame.Vector2, float]] = []
                for pos, age in self.trail:
                    age += dt
                    if age <= 0.18:
                        updated.append((pos, age))
                self.trail = updated

            length = float(12 + max(0, self.level - 1) * 2)
            thickness = float(4 + max(0, self.level - 1) // 2)
            hand = player.hand_pos()

            if not self.swinging and self.cooldown_left <= 0.0:
                self.swinging = True
                self.swing_t = 0.0
                self.swing_hit_uids.clear()
                self.cooldown_left = self.cooldown_s(player)

                base = 0.0 if player.facing >= 0 else math.pi
                arc = 1.08
                self.swing_a0 = base - arc
                self.swing_a1 = base + arc

            if self.swinging:
                self.swing_t += dt
                t = 1.0 if self.swing_duration_s <= 0 else clamp(self.swing_t / self.swing_duration_s, 0.0, 1.0)
                t = t * t * (3.0 - 2.0 * t)
                ang = self.swing_a0 + (self.swing_a1 - self.swing_a0) * t
                if self.swing_t >= self.swing_duration_s:
                    self.swinging = False
            else:
                ang = 0.12 if player.facing >= 0 else math.pi - 0.12

            d = pygame.Vector2(math.cos(ang), math.sin(ang))
            if d.length_squared() <= 0.001:
                d = pygame.Vector2(1, 0 if player.facing >= 0 else -1)
            perp = pygame.Vector2(-d.y, d.x)
            half = thickness * 0.5

            base = pygame.Vector2(hand)
            tip = base + d * length
            p1 = base + perp * half
            p2 = base - perp * half
            p3 = tip - perp * half
            p4 = tip + perp * half

            self.sword_base = base
            self.sword_tip = tip
            self.sword_poly = [(int(p1.x), int(p1.y)), (int(p2.x), int(p2.y)), (int(p3.x), int(p3.y)), (int(p4.x), int(p4.y))]

            min_x = int(min(p1.x, p2.x, p3.x, p4.x))
            min_y = int(min(p1.y, p2.y, p3.y, p4.y))
            max_x = int(max(p1.x, p2.x, p3.x, p4.x))
            max_y = int(max(p1.y, p2.y, p3.y, p4.y))
            self.orbit_rect = pygame.Rect(min_x, min_y, max(1, max_x - min_x + 1), max(1, max_y - min_y + 1))

            if self.swinging:
                if not self.trail or (self.trail[-1][0] - tip).length_squared() > 1.0:
                    self.trail.append((pygame.Vector2(tip), 0.0))

                for e in game.enemies:
                    if e.uid in self.swing_hit_uids:
                        continue
                    if not self.orbit_rect.colliderect(e.rect()):
                        continue
                    self.swing_hit_uids.add(e.uid)
                    e.hp -= self.damage(player)

                    knock = 180.0 if e.enemy_def.id == "slime" else 90.0
                    away = (e.center() - player.center())
                    if away.length_squared() > 0.01:
                        e.vel += away.normalize() * knock
                    else:
                        rand = pygame.Vector2(random.uniform(-1, 1), random.uniform(-1, 1))
                        if rand.length_squared() <= 0.001:
                            rand = pygame.Vector2(1, 0)
                        e.vel += rand.normalize() * knock
            return

        self.angle = (self.angle + dt * self.orbit_speed) % math.tau
        c = player.orbit_center()
        offset = pygame.Vector2(math.cos(self.angle), math.sin(self.angle)) * self.orbit_radius
        pos = c + offset

        size = int(self.size + max(0, self.level - 1))
        self.orbit_rect.size = (size, size)
        self.orbit_rect.center = (int(pos.x), int(pos.y))

        self.cooldown_left -= dt
        if self.cooldown_left > 0:
            return

        for e in game.enemies:
            if self.orbit_rect.colliderect(e.rect()):
                e.hp -= self.damage(player)
                self.cooldown_left = self.cooldown_s(player)
                break


@dataclass
class WeaponDrop:
    weapon_id: str
    pos: pygame.Vector2
    bob_t: float = 0.0

    def rect(self) -> pygame.Rect:
        return pygame.Rect(int(self.pos.x) - 4, int(self.pos.y) - 4, 8, 8)


class DamageText:
    def __init__(self, pos: pygame.Vector2, amount: float, *, color: pygame.Color) -> None:
        self.pos = pygame.Vector2(pos)
        self.vel = pygame.Vector2(random.uniform(-10.0, 10.0), random.uniform(-28.0, -40.0))
        self.amount = float(amount)
        self.text = str(max(0, int(round(amount))))
        self.color = color
        self.ttl_s = 0.60


class ExplosionFx:
    def __init__(self, pos: pygame.Vector2, *, radius: float, color: tuple[int, int, int]) -> None:
        self.pos = pygame.Vector2(pos)
        self.radius = float(radius)
        self.color = pygame.Color(*color)
        self.ttl_s = 0.22


def make_defs() -> tuple[list[CharacterDef], list[MapDef], dict[str, EnemyDef], dict[str, WeaponDef]]:
    palette = {
        "K": (16, 16, 16),
        "W": (240, 240, 240),
        "G": (96, 192, 96),
        "B": (96, 160, 220),
        "Y": (220, 200, 80),
        "P": (180, 120, 220),
        "S": (220, 180, 140),
        "D": (34, 34, 44),
        "M": (120, 130, 150),
        "L": (170, 180, 205),
        "H": (235, 235, 245),
        "O": (70, 70, 82),
        "R": (240, 120, 80),
    }

    warrior_frames = (
        sprite_from_pixels(
            [
                "    KKK     ",
                "   KWWWWK   ",
                "   KWOOWK   ",
                "   KSSSSK   ",
                "   KSSSSK   ",
                "   KWWWWK   ",
                "  KKWWWWKK  ",
                "  KWWYYWWK  ",
                "   KWWWWK   ",
                "   KWWWWK   ",
                "   KYY YYK  ",
                "   KY   YK  ",
                "   KY   YK  ",
                "  KYY  YYK  ",
            ],
            palette,
        ),
        sprite_from_pixels(
            [
                "    KKK     ",
                "   KWWWWK   ",
                "   KWOOWK   ",
                "   KSSSSK   ",
                "   KSSSSK   ",
                "   KWWWWK   ",
                "  KKWWWWKK  ",
                "  KWWYYWWK  ",
                "   KWWWWK   ",
                "   KWWWWK   ",
                "   KYY YYK  ",
                "   KYY  YK  ",
                "   KY  YYK  ",
                "  KYY   K   ",
            ],
            palette,
        ),
        sprite_from_pixels(
            [
                "    KKK     ",
                "   KWWWWK   ",
                "   KWOOWK   ",
                "   KSSSSK   ",
                "   KSSSSK   ",
                "   KWWWWK   ",
                "  KKWWWWKK  ",
                "  KWWYYWWK  ",
                "   KWWWWK   ",
                "   KWWWWK   ",
                "   KYY YYK  ",
                "   KY  YYK  ",
                "   KYY  YK  ",
                "  K   YYK   ",
            ],
            palette,
        ),
    )
    warrior = warrior_frames[0]
    warrior_skeleton = (
        {
            "head": (5, 3),
            "chest": (5, 7),
            "hip": (5, 10),
            "l_hand": (3, 8),
            "r_hand": (7, 8),
            "l_foot": (4, 13),
            "r_foot": (7, 13),
        },
        {
            "head": (5, 3),
            "chest": (5, 7),
            "hip": (5, 10),
            "l_hand": (3, 8),
            "r_hand": (7, 8),
            "l_foot": (4, 13),
            "r_foot": (8, 12),
        },
        {
            "head": (5, 3),
            "chest": (5, 7),
            "hip": (5, 10),
            "l_hand": (3, 8),
            "r_hand": (7, 8),
            "l_foot": (5, 12),
            "r_foot": (7, 13),
        },
    )
    mage = sprite_from_pixels(
        [
            "    PP      ",
            "   PPPP     ",
            "   PSSP     ",
            "   PWWP     ",
            "  PPPPPP    ",
            "  PWWWWP    ",
            "  PWWWWP    ",
            "   PBBP     ",
            "   PBBP     ",
            "    BB      ",
            "    BB      ",
            "            ",
        ],
        palette,
    )
    dragonkin = sprite_from_pixels(
        [
            "   GGGG     ",
            "  GGGGGG    ",
            "  GSSSSG    ",
            "  GKKKKG    ",
            "  GGGGGG    ",
            "  GGGGGG    ",
            "  GGYYGG    ",
            "   GYYG     ",
            "   G  G     ",
            "  GG  GG    ",
            "  G    G    ",
            "            ",
        ],
        palette,
    )
    undead = sprite_from_pixels(
        [
            "   GGGG     ",
            "  GWWWWG    ",
            "  GWKKWG    ",
            "  GWWWWG    ",
            "  GGGGGG    ",
            "  GWWWWG    ",
            "  GWWWWG    ",
            "   GWWG     ",
            "   G  G     ",
            "  GG  GG    ",
            "  G    G    ",
            "            ",
        ],
        palette,
    )
    elf = sprite_from_pixels(
        [
            "   G  G     ",
            "  GGGGGG    ",
            "  GSSSSG    ",
            "  GWWWWG    ",
            "  GGGGGG    ",
            "  GWWWWG    ",
            "  GWWWWG    ",
            "   GGGG     ",
            "   G  G     ",
            "  GG  GG    ",
            "  G    G    ",
            "            ",
        ],
        palette,
    )

    chars = [
        CharacterDef(
            id="warrior",
            name="",
            desc="",
            sprite=warrior,
            base_hp=120,
            move_speed=92.0,
            start_weapon="sword",
            regen=0.25,
            damage_mult=1.05,
            frames=warrior_frames,
            skeleton_frames=warrior_skeleton,
        ),
        CharacterDef(
            id="mage",
            name="",
            desc="",
            sprite=mage,
            base_hp=90,
            move_speed=90.0,
            start_weapon="sword",
            regen=0.15,
            cooldown_mult=0.92,
        ),
        CharacterDef(
            id="dragonkin",
            name="",
            desc="",
            sprite=dragonkin,
            base_hp=130,
            move_speed=86.0,
            start_weapon="sword",
            regen=0.22,
            damage_mult=1.08,
        ),
        CharacterDef(
            id="undead",
            name="",
            desc="",
            sprite=undead,
            base_hp=110,
            move_speed=88.0,
            start_weapon="sword",
            regen=0.45,
            damage_mult=0.95,
        ),
        CharacterDef(
            id="elf",
            name="",
            desc="",
            sprite=elf,
            base_hp=95,
            move_speed=104.0,
            start_weapon="sword",
            regen=0.18,
            cooldown_mult=0.90,
        ),
    ]

    maps = [
        MapDef(
            id="grass",
            name="",
            desc="",
            base_color=(56, 120, 64),
            accent_color=(84, 180, 96),
            enemy_pool=("slime", "slime", "runner"),
        ),
        MapDef(
            id="ocean",
            name="",
            desc="",
            base_color=(20, 70, 120),
            accent_color=(60, 140, 200),
            enemy_pool=("fish", "fish", "puffer"),
        ),
        MapDef(
            id="grave",
            name="",
            desc="",
            base_color=(38, 38, 44),
            accent_color=(120, 120, 140),
            enemy_pool=("skeleton", "skeleton", "wraith"),
        ),
    ]

    def squish_frame(base: pygame.Surface, sx: float, sy: float) -> pygame.Surface:
        w, h = base.get_size()
        sw = max(1, int(round(w * sx)))
        sh = max(1, int(round(h * sy)))
        scaled = pygame.transform.scale(base, (sw, sh))
        out = pygame.Surface((w, h), pygame.SRCALPHA)
        out.fill((0, 0, 0, 0))
        out.blit(scaled, scaled.get_rect(center=(w // 2, h // 2)))
        return out

    slime_base = sprite_from_pixels(
        [
            "   KKKK   ",
            "  KGGGGK  ",
            " KGGGGGGK ",
            " KGGW WGGK",
            " KGGGGGGK ",
            "  KGGGGK  ",
            "   KGGK   ",
            "    KK    ",
            "          ",
            "          ",
        ],
        palette,
    )
    slime_frames = (
        slime_base,
        squish_frame(slime_base, 1.10, 0.92),
        squish_frame(slime_base, 0.92, 1.10),
    )
    runner = sprite_from_pixels(
        [
            "  K  K  ",
            "  KYYK  ",
            " KYYYYK ",
            " KYYWYYK",
            "  KYYYYK",
            "   KYYK ",
            "   K  K ",
            "        ",
        ],
        palette,
    )
    fish = sprite_from_pixels(
        [
            "          ",
            "   KKKK   ",
            "  KBBBBKK ",
            " KBBBBBBKK",
            "KBBBBWBBKK",
            " KBBBBBBKK",
            "  KBBBBKK ",
            "   KKKK   ",
            "          ",
            "          ",
        ],
        palette,
    )
    puffer = sprite_from_pixels(
        [
            "     K      ",
            "   KKKKK    ",
            "  KKYYYYKK  ",
            " KKYYYYYYKK ",
            "KKYYYYYYYYKK",
            "KKYYWYYWYYKK",
            "KKYYYYYYYYKK",
            " KKYYYYYYKK ",
            "  KKYYYYKK  ",
            "   KKKKK    ",
            "     K      ",
            "            ",
        ],
        palette,
    )
    skeleton = sprite_from_pixels(
        [
            "   KKKK   ",
            "  KWWWWK  ",
            " KWWKKWWK ",
            " KWWWWWWK ",
            "  KWWWWK  ",
            "   KWWK   ",
            "  KWWWWK  ",
            "  KW  WK  ",
            "   K  K   ",
            "  K    K  ",
        ],
        palette,
    )
    wraith = sprite_from_pixels(
        [
            "   KKK   ",
            "  KPPPK  ",
            " KPPPPPK ",
            " KPW WPK ",
            " KPPPPPK ",
            "  KPPPK  ",
            "  KPPPK  ",
            "  KPKPK  ",
            "   K K   ",
        ],
        palette,
    )

    enemies = {
        "slime": EnemyDef("slime", "", (90, 210, 120), hp=18, speed=34.0, size=10, contact_damage=10, xp_value=3, frames=slime_frames),
        "runner": EnemyDef("runner", "", (200, 220, 120), hp=12, speed=58.0, size=8, contact_damage=8, xp_value=3, frames=(runner,)),
        "fish": EnemyDef("fish", "", (90, 180, 230), hp=16, speed=40.0, size=10, contact_damage=10, xp_value=3, frames=(fish,)),
        "puffer": EnemyDef("puffer", "", (220, 210, 110), hp=28, speed=26.0, size=12, contact_damage=14, xp_value=5, frames=(puffer,)),
        "skeleton": EnemyDef("skeleton", "", (210, 210, 220), hp=20, speed=36.0, size=10, contact_damage=12, xp_value=4, frames=(skeleton,)),
        "wraith": EnemyDef("wraith", "", (170, 120, 220), hp=14, speed=62.0, size=9, contact_damage=10, xp_value=4, frames=(wraith,)),
    }

    pistol_sprite = sprite_from_pixels(
        [
            "     DDDDDDD",
            "DDDDDLLLLLDDD",
            "DDLLHHHHHLLDD",
            "DDLLLMMMMMLDD",
            "   DOOOODDD",
            "   DOOOOD",
            "    DDDD",
        ],
        palette,
    )
    uzi_sprite = sprite_from_pixels(
        [
            "      DDDDDDDDDDD",
            "DDDDDDLLLLLLLLLDDD",
            "DDLLHHHHHHHHHLLDD",
            "DDLLLMMMMMMMMMLDD",
            "   DOOOOODDD",
            "   DOOOOOD",
            "    DDDD",
        ],
        palette,
    )
    ak47_sprite = sprite_from_pixels(
        [
            "      DDDDDDDDDDDDDDDD",
            "DDDDDDLLLLLLLLLLLLLLLDDD",
            "DDLLHHHHHHHHHHHHHHLLDD",
            "DDLLLMMMMMMMMMMMMMMLDD",
            "DDDDDOOOOODDDDDDD",
            "    OOOO",
            "    OOO",
            "    DDD",
        ],
        palette,
    )
    scar_sprite = sprite_from_pixels(
        [
            "   DDDDDDDDDDDDDDDDDDD",
            "DDDDDLLLLLLLLLLLLLLLLDDDD",
            "DDLLHHHHHHHHHHHHHHLLDD",
            "DDLLLMMMMMMMMMMMMMMLDD",
            "DDDDDOOOO OOOODDDD",
            "     OOOO",
            "     OOOO",
            "      DDD",
        ],
        palette,
    )
    sniper_sprite = sprite_from_pixels(
        [
            "        HHHH",
            "DDDDDDDLLLLLLLLLLLLLLLLLLDDDD",
            "DDLLHHHHHHHHHHHHHHHHHHLLDD",
            "DDLLLMMMMMMMMMMMMMMMMMMLDD",
            "      OOOO",
            "      OOO",
            "       DDD",
        ],
        palette,
    )
    rocket_sprite = sprite_from_pixels(
        [
            "       RRRR",
            "DDDDDDDLLLLLLLLLLLLDDDDRR",
            "DDLLHHHHHHHHHHHHLLDDRRR",
            "DDLLLMMMMMMMMMMMMLDDDD",
            "    OOOO",
            "    OOO",
            "     DDD",
        ],
        palette,
    )

    weapons = {
        "sword": WeaponDef("sword", "", "", "melee", (220, 220, 220), cooldown_s=0.45, damage=10),
        "wand": WeaponDef("wand", "", "", "orbit", (120, 170, 240), cooldown_s=0.35, damage=7, proj_speed=240, proj_size=3),
        "bow": WeaponDef("bow", "", "", "orbit", (220, 190, 120), cooldown_s=0.30, damage=6, proj_speed=290, proj_size=2),
        "fireball": WeaponDef("fireball", "", "", "orbit", (240, 120, 80), cooldown_s=0.65, damage=12, proj_speed=210, proj_size=4),
        "spear": WeaponDef("spear", "", "", "orbit", (235, 235, 255), cooldown_s=0.75, damage=9, proj_speed=320, proj_size=3, pierce=2),
        "dagger": WeaponDef("dagger", "", "", "orbit", (200, 200, 200), cooldown_s=0.22, damage=4, proj_speed=330, proj_size=2),
        "pistol": WeaponDef(
            "pistol",
            "",
            "",
            "gun",
            (230, 230, 200),
            cooldown_s=0.20,
            damage=7,
            proj_speed=380,
            proj_size=2,
            magazine=8,
            reload_s=1.10,
            proj_ttl_s=1.4,
            spread_rad=0.06,
            knockback=160.0,
            recoil_per_shot=0.030,
            recoil_decay=0.20,
            recoil_max=0.18,
            sprite=pistol_sprite,
        ),
        "uzi": WeaponDef(
            "uzi",
            "Uzi",
            "",
            "gun",
            (190, 230, 230),
            cooldown_s=0.060,
            damage=3,
            proj_speed=420,
            proj_size=1,
            magazine=28,
            reload_s=1.60,
            proj_ttl_s=1.1,
            spread_rad=0.14,
            knockback=85.0,
            recoil_per_shot=0.050,
            recoil_decay=0.18,
            recoil_max=0.36,
            sprite=uzi_sprite,
        ),
        "ak47": WeaponDef(
            "ak47",
            "AK47",
            "",
            "gun",
            (230, 190, 140),
            cooldown_s=0.11,
            damage=5,
            proj_speed=450,
            proj_size=2,
            magazine=30,
            reload_s=1.85,
            proj_ttl_s=1.4,
            spread_rad=0.10,
            knockback=120.0,
            recoil_per_shot=0.040,
            recoil_decay=0.20,
            recoil_max=0.30,
            sprite=ak47_sprite,
        ),
        "scarl": WeaponDef(
            "scarl",
            "SCAR-L",
            "",
            "gun",
            (200, 230, 170),
            cooldown_s=0.12,
            damage=6,
            proj_speed=470,
            proj_size=2,
            magazine=20,
            reload_s=1.95,
            proj_ttl_s=1.5,
            spread_rad=0.08,
            knockback=135.0,
            recoil_per_shot=0.034,
            recoil_decay=0.22,
            recoil_max=0.26,
            sprite=scar_sprite,
        ),
        "sniper": WeaponDef(
            "sniper",
            "",
            "",
            "gun",
            (230, 230, 240),
            cooldown_s=0.85,
            damage=28,
            proj_speed=700,
            proj_size=2,
            pierce=3,
            magazine=5,
            reload_s=2.60,
            proj_ttl_s=1.8,
            spread_rad=0.01,
            knockback=260.0,
            recoil_per_shot=0.018,
            recoil_decay=0.45,
            recoil_max=0.07,
            sprite=sniper_sprite,
        ),
        "rocket": WeaponDef(
            "rocket",
            "",
            "",
            "gun",
            (240, 120, 80),
            cooldown_s=1.25,
            damage=18,
            proj_speed=220,
            proj_size=4,
            magazine=1,
            reload_s=2.35,
            proj_ttl_s=2.4,
            spread_rad=0.04,
            knockback=320.0,
            aoe_radius=28.0,
            aoe_damage_mult=1.35,
            recoil_per_shot=0.020,
            recoil_decay=0.30,
            recoil_max=0.10,
            sprite=rocket_sprite,
        ),
    }

    return chars, maps, enemies, weapons


CHARS, MAPS, ENEMY_DEFS, WEAPON_DEFS = make_defs()


class State:
    def __init__(self, app: "App") -> None:
        self.app = app

    def on_enter(self) -> None:
        pass

    def handle_event(self, event: pygame.event.Event) -> None:
        pass

    def update(self, dt: float) -> None:
        pass

    def draw(self, surface: pygame.Surface) -> None:
        pass


class App:
    def __init__(self) -> None:
        try:
            pygame.mixer.pre_init(22050, -16, 1, 256)
        except Exception:
            pass
        pygame.init()
        pygame.font.init()
        try:
            if pygame.mixer.get_init() is None:
                pygame.mixer.init(22050, -16, 1, 256)
            pygame.mixer.set_num_channels(16)
        except Exception:
            pass
        self.sfx = SFX()

        self.config = GameConfig.load()
        self.config.scale = int(clamp(self.config.scale, 1, 6))
        self.config.lamp_world_radius_tiles = int(clamp(int(self.config.lamp_world_radius_tiles), 2, 18))
        self.config.lamp_hr_radius_tiles = int(clamp(int(self.config.lamp_hr_radius_tiles), 2, 18))
        self.config.lamp_world_intensity = float(clamp(float(self.config.lamp_world_intensity), 0.0, 3.0))
        self.config.lamp_hr_intensity = float(clamp(float(self.config.lamp_hr_intensity), 0.0, 3.0))
        self.config.lamp_world_halo = float(clamp(float(self.config.lamp_world_halo), 0.0, 1.5))
        self.config.lamp_hr_halo = float(clamp(float(self.config.lamp_hr_halo), 0.0, 1.5))

        self.clock = pygame.time.Clock()
        self.render = pygame.Surface((INTERNAL_W, INTERNAL_H))
        self._scaled: pygame.Surface | None = None
        self._grid_overlay: pygame.Surface | None = None
        self._grid_overlay_key: tuple[int, int, int, int] | None = None

        pygame.display.set_caption(" Demo (pygame)")
        self._apply_display()

        font_path = pick_ui_font_path()
        self.font_s = pygame.font.Font(font_path, 12) if font_path else pygame.font.Font(None, 12)
        self.font_m = pygame.font.Font(font_path, 16) if font_path else pygame.font.Font(None, 16)
        self.font_l = pygame.font.Font(font_path, 28) if font_path else pygame.font.Font(None, 28)

        # Player name (set by NameInputState for hardcore survival).
        self.player_name: str = ""

        self.state: State = StartScreenState(self)
        self.state.on_enter()

    def play_sfx(self, name: str) -> None:
        self.sfx.play(name)

    def _apply_display(self) -> None:
        if self.config.fullscreen:
            # //
            self.screen = pygame.display.set_mode(
                (BASE_INTERNAL_W * self.config.scale, BASE_INTERNAL_H * self.config.scale),
                pygame.RESIZABLE,
            )
            self._maximize_window()
        else:
            self.screen = pygame.display.set_mode((BASE_INTERNAL_W * self.config.scale, BASE_INTERNAL_H * self.config.scale))
        self._scaled = None
        self._update_view_transform()

    def _maximize_window(self) -> None:
        if sys.platform != "win32":
            return
        try:
            import ctypes

            pygame.event.pump()
            hwnd = pygame.display.get_wm_info().get("window")
            if not hwnd:
                return
            SW_MAXIMIZE = 3
            ctypes.windll.user32.ShowWindow(int(hwnd), SW_MAXIMIZE)
        except Exception:
            return

    def _update_view_transform(self) -> None:
        global INTERNAL_W, INTERNAL_H
        sw, sh = self.screen.get_size()
        sw = max(1, int(sw))
        sh = max(1, int(sh))
        base_w = int(BASE_INTERNAL_W)
        base_h = int(BASE_INTERNAL_H)

        # Prefer integer scaling to keep pixels perfect. When the window is
        # larger than the base size, extend the internal resolution to fill
        # the extra space (more world shown, no stretching).
        fit_scale = min(sw / max(1, base_w), sh / max(1, base_h))
        if fit_scale >= 1.0:
            scale_i = int(max(1, int(fit_scale)))
            scale = float(scale_i)
            internal_w = int(max(base_w, int(sw // scale_i)))
            internal_h = int(max(base_h, int(sh // scale_i)))
        else:
            scale = float(fit_scale)
            internal_w = int(base_w)
            internal_h = int(base_h)

        if int(INTERNAL_W) != int(internal_w) or int(INTERNAL_H) != int(internal_h):
            INTERNAL_W = int(internal_w)
            INTERNAL_H = int(internal_h)
            self.render = pygame.Surface((int(INTERNAL_W), int(INTERNAL_H)))
            self._scaled = None
            self._grid_overlay = None
            self._grid_overlay_key = None

        dest_w = max(1, int(round(INTERNAL_W * scale)))
        dest_h = max(1, int(round(INTERNAL_H * scale)))
        offset_x = max(0, (sw - dest_w) // 2)
        offset_y = max(0, (sh - dest_h) // 2)
        dest_size = (dest_w, dest_h)

        self.view_scale_x = dest_w / max(1, INTERNAL_W)
        self.view_scale_y = dest_h / max(1, INTERNAL_H)
        self.view_offset = (offset_x, offset_y)
        self.view_rect = pygame.Rect(offset_x, offset_y, dest_w, dest_h)
        if self._scaled is None or self._scaled.get_size() != dest_size:
            self._scaled = pygame.Surface(dest_size)

        if not self.config.show_grid:
            self._grid_overlay = None
            self._grid_overlay_key = None
            return

        if self._grid_overlay is not None and self._grid_overlay_key == (dest_size[0], dest_size[1], int(INTERNAL_W), int(INTERNAL_H)):
            return

        overlay = pygame.Surface(dest_size, pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 0))
        w, h = dest_size
        cell_px = min(self.view_scale_x, self.view_scale_y)
        alpha = 18 if cell_px <= 2.5 else 26 if cell_px <= 4.5 else 34
        minor = (0, 0, 0, alpha)

        if w > 1 and h > 1:
            # Draw the full INTERNAL_W x INTERNAL_H grid.
            for x_cell in range(INTERNAL_W + 1):
                x = (x_cell * (w - 1)) // INTERNAL_W
                pygame.draw.line(overlay, minor, (x, 0), (x, h - 1))
            for y_cell in range(INTERNAL_H + 1):
                y = (y_cell * (h - 1)) // INTERNAL_H
                pygame.draw.line(overlay, minor, (0, y), (w - 1, y))

        # Major marker lines for quick counting (10/50/100/200/300).
        major_alpha = min(120, alpha * 4)
        major = (255, 220, 100, major_alpha)
        major_w = 1 if cell_px <= 3.5 else 2
        for x_cell in GRID_MARKS:
            if not (0 <= x_cell <= INTERNAL_W):
                continue
            x = (x_cell * (w - 1)) // INTERNAL_W
            if 0 <= x < w:
                pygame.draw.line(overlay, major, (x, 0), (x, h - 1), major_w)
        for y_cell in GRID_MARKS:
            if not (0 <= y_cell <= INTERNAL_H):
                continue
            y = (y_cell * (h - 1)) // INTERNAL_H
            if 0 <= y < h:
                pygame.draw.line(overlay, major, (0, y), (w - 1, y), major_w)

        self._grid_overlay = overlay
        self._grid_overlay_key = (dest_size[0], dest_size[1], int(INTERNAL_W), int(INTERNAL_H))

    def screen_to_internal(self, screen_pos: tuple[int, int]) -> tuple[int, int] | None:
        if not hasattr(self, "view_rect"):
            self._update_view_transform()
        if not self.view_rect.collidepoint(screen_pos):
            return None
        w = max(1, int(self.view_rect.w))
        h = max(1, int(self.view_rect.h))
        x = int((screen_pos[0] - self.view_rect.x) * INTERNAL_W / w)
        y = int((screen_pos[1] - self.view_rect.y) * INTERNAL_H / h)
        if 0 <= x < INTERNAL_W and 0 <= y < INTERNAL_H:
            return x, y
        return None

    def internal_rect_to_screen(self, rect: pygame.Rect) -> pygame.Rect:
        rect = pygame.Rect(rect)
        if not hasattr(self, "view_rect"):
            self._update_view_transform()
        vr = self.view_rect
        sx = int(vr.x + int(rect.x) * int(vr.w) / max(1, int(INTERNAL_W)))
        sy = int(vr.y + int(rect.y) * int(vr.h) / max(1, int(INTERNAL_H)))
        sw = int(max(1, int(rect.w) * int(vr.w) / max(1, int(INTERNAL_W))))
        sh = int(max(1, int(rect.h) * int(vr.h) / max(1, int(INTERNAL_H))))
        return pygame.Rect(int(sx), int(sy), int(sw), int(sh))

    def set_state(self, state: State) -> None:
        self.state = state
        self.state.on_enter()

    def set_config(self, *, scale: int | None = None, fullscreen: bool | None = None, show_grid: bool | None = None) -> None:
        if scale is not None:
            self.config.scale = int(clamp(scale, 1, 6))
        if fullscreen is not None:
            self.config.fullscreen = bool(fullscreen)
        if show_grid is not None:
            self.config.show_grid = bool(show_grid)
        self.config.save()
        self._apply_display()

    def blit_scaled(self) -> None:
        self._update_view_transform()
        pygame.transform.scale(self.render, self._scaled.get_size(), self._scaled)
        if self._grid_overlay is not None:
            self._scaled.blit(self._grid_overlay, (0, 0))
            self._draw_grid_markers(self._scaled)
        # Optional post-scale overlay hook (xiaotou-style): lets gameplay draw
        # pixel-perfect rotated weapons on the *scaled* surface so diagonals
        # don't look like magnified jaggies.
        try:
            draw_scaled_overlay = getattr(self.state, "draw_scaled_overlay", None)
            if callable(draw_scaled_overlay):
                draw_scaled_overlay(self._scaled)
        except Exception:
            pass
        self.screen.fill((0, 0, 0))
        self.screen.blit(self._scaled, getattr(self, "view_offset", (0, 0)))

    def _draw_grid_markers(self, surface: pygame.Surface) -> None:
        w, h = surface.get_size()
        cell_px = float(min(getattr(self, "view_scale_x", 1.0), getattr(self, "view_scale_y", 1.0)))
        ui_scale = max(1, int(round(cell_px)))
        tick_len = max(6, int(cell_px * 4))
        col = pygame.Color(255, 220, 100)
        text_col = pygame.Color(255, 240, 180)

        marks = GRID_MARKS

        def scale_text(img: pygame.Surface) -> pygame.Surface:
            if ui_scale == 1:
                return img
            return pygame.transform.scale(img, (img.get_width() * ui_scale, img.get_height() * ui_scale))

        info = f"GRID {INTERNAL_W}x{INTERNAL_H}"
        info_img = scale_text(self.font_s.render(info, False, pygame.Color(230, 230, 240)))
        info_rect = info_img.get_rect(topright=(w - 2, 2))
        surface.blit(info_img, info_rect)

        # X-axis markers (top/bottom)
        for x_cell in marks:
            if not (0 <= x_cell <= INTERNAL_W):
                continue
            x = (x_cell * (w - 1)) // INTERNAL_W
            if not (0 <= x < w):
                continue
            pygame.draw.line(surface, col, (x, 0), (x, min(h - 1, tick_len)))
            pygame.draw.line(surface, col, (x, h - 1), (x, max(0, h - 1 - tick_len)))

            label = str(x_cell)
            img = scale_text(self.font_s.render(label, False, text_col))
            lx = x + 2
            ly = 2
            if lx + img.get_width() > w - 1:
                lx = max(0, w - 1 - img.get_width())
            surface.blit(img, (lx, ly))

        # Y-axis markers (left/right)
        for y_cell in marks:
            if not (0 <= y_cell <= INTERNAL_H):
                continue
            y = (y_cell * (h - 1)) // INTERNAL_H
            if not (0 <= y < h):
                continue
            pygame.draw.line(surface, col, (0, y), (min(w - 1, tick_len), y))
            pygame.draw.line(surface, col, (w - 1, y), (max(0, w - 1 - tick_len), y))

            label = str(y_cell)
            img = scale_text(self.font_s.render(label, False, text_col))
            lx = 2
            ly = y + 2
            if ly + img.get_height() > h - 1:
                ly = max(0, y - 2 - img.get_height())
            surface.blit(img, (lx, ly))

    def run(self, *, max_frames: int | None = None) -> None:
        running = True
        frames = 0
        while running:
            # Fixed-step timing: keeps pixel motion consistent and avoids the
            # subtle "lurch" you get from variable dt + pixel snapping.
            self.clock.tick_busy_loop(FPS)
            dt = 1.0 / float(FPS)
            self._update_view_transform()
            for event in pygame.event.get():
                if event.type == pygame.VIDEORESIZE:
                    # Keep the display surface in sync with the resized window.
                    self.screen = pygame.display.set_mode(event.size, pygame.RESIZABLE)
                    self._scaled = None
                    self._update_view_transform()
                    continue
                if event.type == pygame.QUIT:
                    running = False
                    break
                self.state.handle_event(event)

            if not running:
                break

            self.state.update(dt)
            self.state.draw(self.render)
            self.blit_scaled()
            pygame.display.flip()

            frames += 1
            if max_frames is not None and int(frames) >= int(max_frames):
                running = False

        pygame.quit()


SURVIVAL_GENDER_OPTIONS = ("", "")
SURVIVAL_HEIGHT_OPTIONS = ("", "", "")
SURVIVAL_FACE_OPTIONS = ("", "", "")
SURVIVAL_EYE_OPTIONS = ("", "", "", "")
SURVIVAL_HAIR_OPTIONS = ("", "", "", "", "", "", "", "")
SURVIVAL_NOSE_OPTIONS = ("", "", "")
SURVIVAL_SKIN_OPTIONS = ("", "", "", "")
SURVIVAL_HAIR_COLOR_OPTIONS = ("", "", "", "", "", "")
SURVIVAL_EYE_COLOR_OPTIONS = ("", "", "", "", "")
SURVIVAL_MOUTH_OPTIONS = ("", "", "", "")
SURVIVAL_BEARD_OPTIONS = ("", "", "", "")
SURVIVAL_MAKEUP_OPTIONS = ("", "", "", "")
SURVIVAL_ACCESSORY_OPTIONS = ("", "", "", "")
SURVIVAL_OUTFIT_OPTIONS = (
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
)


@dataclass
class SurvivalAvatar:
    gender: int = 0
    height: int = 1
    face: int = 0
    eyes: int = 0
    hair: int = 0
    nose: int = 0
    skin: int = 0
    hair_color: int = 0
    eye_color: int = 0
    mouth: int = 0
    beard: int = 0
    makeup: int = 0
    accessory: int = 0
    outfit: int = 0

    def clamp_all(self) -> None:
        self.gender = int(self.gender) % len(SURVIVAL_GENDER_OPTIONS)
        self.height = int(self.height) % len(SURVIVAL_HEIGHT_OPTIONS)
        self.face = int(self.face) % len(SURVIVAL_FACE_OPTIONS)
        self.eyes = int(self.eyes) % len(SURVIVAL_EYE_OPTIONS)
        self.hair = int(self.hair) % len(SURVIVAL_HAIR_OPTIONS)
        self.nose = int(self.nose) % len(SURVIVAL_NOSE_OPTIONS)
        self.skin = int(self.skin) % len(SURVIVAL_SKIN_OPTIONS)
        self.hair_color = int(self.hair_color) % len(SURVIVAL_HAIR_COLOR_OPTIONS)
        self.eye_color = int(self.eye_color) % len(SURVIVAL_EYE_COLOR_OPTIONS)
        self.mouth = int(self.mouth) % len(SURVIVAL_MOUTH_OPTIONS)
        self.beard = int(self.beard) % len(SURVIVAL_BEARD_OPTIONS)
        self.makeup = int(self.makeup) % len(SURVIVAL_MAKEUP_OPTIONS)
        self.accessory = int(self.accessory) % len(SURVIVAL_ACCESSORY_OPTIONS)
        self.outfit = int(self.outfit) % len(SURVIVAL_OUTFIT_OPTIONS)


class StartScreenState(State):
    def on_enter(self) -> None:
        self.t = 0.0

    def _start(self) -> None:
        self.app.set_state(MainMenuState(self.app))

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            if event.key in (pygame.K_ESCAPE,):
                pygame.event.post(pygame.event.Event(pygame.QUIT))
                return
            self._start()
            return

        if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
            self._start()
            return

        if event.type == pygame.JOYBUTTONDOWN:
            self._start()
            return

    def update(self, dt: float) -> None:
        self.t += dt

    def draw(self, surface: pygame.Surface) -> None:
        surface.fill((12, 12, 16))

        draw_text(
            surface,
            self.app.font_l,
            " DEMO",
            (INTERNAL_W // 2, 92),
            pygame.Color(240, 240, 240),
            anchor="center",
        )
        draw_text(
            surface,
            self.app.font_s,
            f" {INTERNAL_W}x{INTERNAL_H}",
            (INTERNAL_W // 2, 122),
            pygame.Color(170, 170, 180),
            anchor="center",
        )

        blink = int(self.t * 2.0) % 2 == 0
        prompt_col = pygame.Color(230, 230, 240) if blink else pygame.Color(120, 120, 135)
        draw_text(
            surface,
            self.app.font_m,
            "",
            (INTERNAL_W // 2, 168),
            prompt_col,
            anchor="center",
        )
        draw_text(
            surface,
            self.app.font_s,
            "Esc ",
            (INTERNAL_W // 2, INTERNAL_H - 18),
            pygame.Color(120, 120, 135),
            anchor="center",
        )


class MainMenuState(State):
    def on_enter(self) -> None:
        self.items = ["()", "Demo", "", ""]
        self.index = 0
        self.item_rects: list[pygame.Rect] = []

    def _activate(self) -> None:
        if self.index == 0:
            self.app.set_state(SurvivalCreateState(self.app))
        elif self.index == 1:
            self.app.set_state(CharacterSelectState(self.app))
        elif self.index == 2:
            self.app.set_state(SettingsState(self.app))
        else:
            pygame.event.post(pygame.event.Event(pygame.QUIT))

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            if event.key in (pygame.K_UP, pygame.K_w):
                self.index = (self.index - 1) % len(self.items)
            elif event.key in (pygame.K_DOWN, pygame.K_s):
                self.index = (self.index + 1) % len(self.items)
            elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                self._activate()
            return

        if event.type not in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONDOWN):
            return
        if not hasattr(event, "pos"):
            return

        internal = self.app.screen_to_internal(event.pos)
        if internal is None:
            return

        for i, rect in enumerate(self.item_rects):
            if rect.collidepoint(internal):
                self.index = i
                if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
                    self._activate()
                break

    def draw(self, surface: pygame.Surface) -> None:
        surface.fill((18, 18, 22))
        draw_text(
            surface,
            self.app.font_l,
            " DEMO",
            (INTERNAL_W // 2, 30),
            pygame.Color(240, 240, 240),
            anchor="center",
        )
        draw_text(
            surface,
            self.app.font_s,
            "/ | Enter/",
            (INTERNAL_W // 2, 50),
            pygame.Color(180, 180, 190),
            anchor="center",
        )

        self.item_rects = []
        y0 = 88
        for i, label in enumerate(self.items):
            rect = pygame.Rect(0, 0, 180, 22)
            rect.center = (INTERNAL_W // 2, y0 + i * 28)
            self.item_rects.append(draw_button(surface, self.app.font_m, label, rect, selected=(i == self.index)))


class SurvivalCreateState(State):
    def on_enter(self) -> None:
        self.avatar = SurvivalAvatar()
        self.avatar.clamp_all()
        self.fields: list[tuple[str, str, tuple[str, ...]]] = [
            ("", "gender", SURVIVAL_GENDER_OPTIONS),
            ("", "height", SURVIVAL_HEIGHT_OPTIONS),
            ("", "skin", SURVIVAL_SKIN_OPTIONS),
            ("", "face", SURVIVAL_FACE_OPTIONS),
            ("", "eyes", SURVIVAL_EYE_OPTIONS),
            ("", "eye_color", SURVIVAL_EYE_COLOR_OPTIONS),
            ("", "hair", SURVIVAL_HAIR_OPTIONS),
            ("", "hair_color", SURVIVAL_HAIR_COLOR_OPTIONS),
            ("", "nose", SURVIVAL_NOSE_OPTIONS),
            ("", "mouth", SURVIVAL_MOUTH_OPTIONS),
            ("", "beard", SURVIVAL_BEARD_OPTIONS),
            ("", "makeup", SURVIVAL_MAKEUP_OPTIONS),
            ("", "accessory", SURVIVAL_ACCESSORY_OPTIONS),
            ("", "outfit", SURVIVAL_OUTFIT_OPTIONS),
        ]
        self.index = 0
        self.scroll = 0
        self._dirty = True
        self._preview_frames: dict[str, list[pygame.Surface]] | None = None
        self.row_rects: list[pygame.Rect] = []
        self.left_rects: list[pygame.Rect] = []
        self.right_rects: list[pygame.Rect] = []

    def _rebuild_preview(self) -> None:
        self.avatar.clamp_all()
        self._preview_frames = HardcoreSurvivalState.build_avatar_player_frames(self.avatar, run=False)
        self._dirty = False

    def _change_value(self, delta: int) -> None:
        label, attr, options = self.fields[int(self.index)]
        cur = int(getattr(self.avatar, attr, 0))
        nxt = (cur + int(delta)) % max(1, len(options))
        setattr(self.avatar, attr, int(nxt))
        if str(attr) == "gender":
            try:
                g = int(getattr(self.avatar, "gender", 0)) % len(SURVIVAL_GENDER_OPTIONS)
                # Make "" immediately read differently by nudging a few defaults.
                if g != 0:
                    self.avatar.beard = 0
                    if int(getattr(self.avatar, "hair", 0)) in (0, 1):
                        self.avatar.hair = 4  # 
                    if int(getattr(self.avatar, "mouth", 0)) == 0:
                        self.avatar.mouth = 1  # 
                    if int(getattr(self.avatar, "makeup", 0)) == 0:
                        self.avatar.makeup = 1  # 
                    if int(getattr(self.avatar, "accessory", 0)) == 0:
                        self.avatar.accessory = 3  # 
                    if int(getattr(self.avatar, "outfit", 0)) == 0:
                        self.avatar.outfit = 6  # 
                else:
                    # Male defaults: keep it clean.
                    self.avatar.makeup = 0
                    if int(getattr(self.avatar, "beard", 0)) == 0:
                        self.avatar.beard = 1  # 
                    if int(getattr(self.avatar, "accessory", 0)) == 3:
                        self.avatar.accessory = 0
                    # Make "" read clearly (avoid keeping very feminine defaults).
                    if int(getattr(self.avatar, "hair", 0)) in (4, 5, 6, 7):
                        self.avatar.hair = 0  # 
                    if int(getattr(self.avatar, "mouth", 0)) == 1:
                        self.avatar.mouth = 0  # 
                    if int(getattr(self.avatar, "outfit", 0)) in (6, 15):
                        self.avatar.outfit = 0  # 
            except Exception:
                pass
        self._dirty = True

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            key = int(event.key)
            if key in (pygame.K_ESCAPE,):
                self.app.set_state(MainMenuState(self.app))
                return
            if key in (pygame.K_UP, pygame.K_w):
                self.index = (int(self.index) - 1) % len(self.fields)
                return
            if key in (pygame.K_DOWN, pygame.K_s):
                self.index = (int(self.index) + 1) % len(self.fields)
                return
            if key in (pygame.K_LEFT, pygame.K_a):
                self._change_value(-1)
                return
            if key in (pygame.K_RIGHT, pygame.K_d):
                self._change_value(1)
                return
            if key in (pygame.K_RETURN, pygame.K_SPACE):
                self.avatar.clamp_all()
                self.app.set_state(NameInputState(self.app, avatar=self.avatar))
                return
            return

        if event.type not in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONDOWN):
            return
        if not hasattr(event, "pos"):
            return
        internal = self.app.screen_to_internal(event.pos)
        if internal is None:
            return

        # Arrow buttons first.
        for i, r in enumerate(self.left_rects):
            if r.collidepoint(internal):
                self.index = int(i) + int(getattr(self, "scroll", 0))
                if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
                    self._change_value(-1)
                return
        for i, r in enumerate(self.right_rects):
            if r.collidepoint(internal):
                self.index = int(i) + int(getattr(self, "scroll", 0))
                if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
                    self._change_value(1)
                return

        for i, r in enumerate(self.row_rects):
            if r.collidepoint(internal):
                self.index = int(i) + int(getattr(self, "scroll", 0))
                return

    def update(self, dt: float) -> None:
        pass

    def draw(self, surface: pygame.Surface) -> None:
        if self._dirty or self._preview_frames is None:
            self._rebuild_preview()

        surface.fill((14, 14, 18))
        draw_text(surface, self.app.font_l, " / ", (INTERNAL_W // 2, 26), pygame.Color(240, 240, 240), anchor="center")
        draw_text(surface, self.app.font_s, "    Enter  Esc", (INTERNAL_W // 2, 48), pygame.Color(170, 170, 180), anchor="center")

        # Options (left)
        x0 = 22
        y0 = 74
        row_w = 220
        row_h = 20
        gap = 4
        btn_w = 20
        btn_gap = 2

        self.row_rects = []
        self.left_rects = []
        self.right_rects = []
        visible_rows = int((INTERNAL_H - y0 - 10) // max(1, (row_h + gap)))
        visible_rows = int(clamp(int(visible_rows), 6, 10))
        max_scroll = max(0, len(self.fields) - int(visible_rows))
        scroll = int(clamp(int(getattr(self, "scroll", 0)), 0, int(max_scroll)))
        if int(self.index) < int(scroll):
            scroll = int(self.index)
        if int(self.index) >= int(scroll) + int(visible_rows):
            scroll = int(self.index) - int(visible_rows) + 1
        scroll = int(clamp(int(scroll), 0, int(max_scroll)))
        self.scroll = int(scroll)

        for local_i, (label, attr, options) in enumerate(self.fields[int(scroll) : int(scroll) + int(visible_rows)]):
            i = int(scroll) + int(local_i)
            v = int(getattr(self.avatar, attr, 0)) % max(1, len(options))
            selected = i == int(self.index)
            text = f"{label}: {options[v]}"
            r = pygame.Rect(x0, y0 + int(local_i) * (row_h + gap), row_w, row_h)

            bg = (34, 34, 42) if selected else (24, 24, 30)
            border = (110, 110, 130) if selected else (70, 70, 86)
            text_col = pygame.Color(240, 240, 240) if selected else pygame.Color(200, 200, 210)
            pygame.draw.rect(surface, bg, r, border_radius=6)
            pygame.draw.rect(surface, border, r, 2, border_radius=6)

            left_btn = pygame.Rect(r.right - btn_w * 2 - btn_gap, r.y, btn_w, r.h)
            right_btn = pygame.Rect(r.right - btn_w, r.y, btn_w, r.h)
            draw_button(surface, self.app.font_m, "<", left_btn, selected=selected)
            draw_button(surface, self.app.font_m, ">", right_btn, selected=selected)
            draw_text(surface, self.app.font_m, text, (r.x + 8, r.y + 2), text_col, anchor="topleft")

            self.row_rects.append(r)
            self.left_rects.append(left_btn)
            self.right_rects.append(right_btn)

        if int(max_scroll) > 0:
            draw_text(
                surface,
                self.app.font_s,
                f"{int(scroll) + 1}-{min(int(scroll) + int(visible_rows), len(self.fields))}/{len(self.fields)}",
                (x0, y0 + int(visible_rows) * (row_h + gap) + 2),
                pygame.Color(160, 160, 175),
                anchor="topleft",
            )

        # Preview (right)
        panel = pygame.Rect(250, 70, 208, 170)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (70, 70, 86), panel, 2, border_radius=12)
        frames = self._preview_frames or {}
        spr_down = frames.get("down", [None])[0]
        spr_right = frames.get("right", [None])[0]
        scale = 7
        if spr_down is not None:
            img = pygame.transform.scale(spr_down, (spr_down.get_width() * scale, spr_down.get_height() * scale))
            surface.blit(img, img.get_rect(center=(panel.centerx - 40, panel.centery + 10)))
        if spr_right is not None:
            img = pygame.transform.scale(spr_right, (spr_right.get_width() * scale, spr_right.get_height() * scale))
            surface.blit(img, img.get_rect(center=(panel.centerx + 48, panel.centery + 10)))
        draw_text(surface, self.app.font_s, ":  / ", (panel.centerx, panel.top + 10), pygame.Color(200, 200, 210), anchor="center")


class NameInputState(State):
    def __init__(self, app: "App", *, avatar: SurvivalAvatar) -> None:
        super().__init__(app)
        self.avatar = avatar

    def on_enter(self) -> None:
        self.name = str(getattr(self.app, "player_name", "") or "").strip()
        if not self.name:
            # Keep it simple: a few "town-friendly" defaults.
            self.name = random.choice(("", "", "", "", "", "", "", ""))
        self.msg = ""
        self.ime_text = ""
        self.blink_t = 0.0
        try:
            pygame.key.start_text_input()
        except Exception:
            pass

    def _stop_text_input(self) -> None:
        self.ime_text = ""
        try:
            pygame.key.stop_text_input()
        except Exception:
            pass

    def _sanitize_name(self, text: str) -> str:
        text = str(text).strip()
        # Remove control chars.
        text = "".join(ch for ch in text if (ord(ch) >= 32 and ch not in ("\u007f",)))
        # Clamp length (unicode chars count).
        text = text[:10]
        return text

    def _confirm(self) -> None:
        name = self._sanitize_name(getattr(self, "name", ""))
        if len(name) < 2:
            self.msg = " 2 "
            return
        self._stop_text_input()
        self.app.player_name = name
        self.app.set_state(HardcoreSurvivalState(self.app, avatar=self.avatar, player_name=name))

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            key = int(getattr(event, "key", 0))
            if key in (pygame.K_ESCAPE,):
                self._stop_text_input()
                self.app.set_state(SurvivalCreateState(self.app))
                return
            if key in (pygame.K_RETURN, pygame.K_KP_ENTER):
                self._confirm()
                return
            if key in (pygame.K_BACKSPACE,):
                try:
                    if str(getattr(self, "ime_text", "")):
                        self.ime_text = ""
                    else:
                        self.name = str(getattr(self, "name", ""))[:-1]
                except Exception:
                    self.name = ""
                return
            return

        if event.type == getattr(pygame, "TEXTINPUT", None):
            text = str(getattr(event, "text", "") or "")
            if not text:
                return
            cur = str(getattr(self, "name", "") or "")
            cur = cur + text
            self.name = self._sanitize_name(cur)
            self.ime_text = ""
            return

        if event.type == getattr(pygame, "TEXTEDITING", None):
            # IME composing text (e.g. Pinyin) - show it so input doesn't feel broken.
            self.ime_text = str(getattr(event, "text", "") or "")

    def update(self, dt: float) -> None:
        self.blink_t = float(getattr(self, "blink_t", 0.0)) + float(dt)

    def draw(self, surface: pygame.Surface) -> None:
        surface.fill((14, 14, 18))
        draw_text(surface, self.app.font_l, "", (INTERNAL_W // 2, 34), pygame.Color(240, 240, 240), anchor="center")
        draw_text(
            surface,
            self.app.font_s,
            "Enter  | Esc  | Backspace ",
            (INTERNAL_W // 2, 56),
            pygame.Color(180, 180, 190),
            anchor="center",
        )

        box = pygame.Rect(0, 0, 300, 34)
        box.center = (INTERNAL_W // 2, 110)
        pygame.draw.rect(surface, (22, 22, 28), box, border_radius=8)
        pygame.draw.rect(surface, (90, 90, 110), box, 2, border_radius=8)

        name = self._sanitize_name(getattr(self, "name", ""))
        ime = str(getattr(self, "ime_text", "") or "")
        cursor = "|" if int(float(getattr(self, "blink_t", 0.0)) * 2.0) % 2 == 0 else " "

        # IME candidate window position (needs screen-space rect).
        try:
            pygame.key.set_text_input_rect(self.app.internal_rect_to_screen(box))
        except Exception:
            pass

        if ime:
            # Left-align inside the box so we can draw a composition segment.
            pad_x = 10
            x0 = int(box.x + pad_x)
            y0 = int(box.centery - 1)
            base = name if name else ""
            base_img = self.app.font_m.render(base, False, pygame.Color(240, 240, 240))
            surface.blit(base_img, (x0, y0 - base_img.get_height() // 2))
            bw = int(base_img.get_width())

            ime_img = self.app.font_m.render(ime, False, pygame.Color(18, 18, 22))
            iw = int(ime_img.get_width())
            ime_bg = pygame.Rect(int(x0 + bw), int(y0 - ime_img.get_height() // 2 - 1), int(iw + 10), int(ime_img.get_height() + 2))
            pygame.draw.rect(surface, (255, 220, 140), ime_bg, border_radius=6)
            surface.blit(ime_img, (int(ime_bg.x + 5), int(y0 - ime_img.get_height() // 2)))

            cur_x = int(ime_bg.right + 2) if cursor == "|" else int(ime_bg.right)
            if cursor == "|":
                pygame.draw.line(surface, pygame.Color(240, 240, 240), (cur_x, ime_bg.top + 2), (cur_x, ime_bg.bottom - 2), 2)
        else:
            shown = (name if name else "") + cursor
            col = pygame.Color(240, 240, 240) if name else pygame.Color(150, 150, 165)
            draw_text(surface, self.app.font_m, shown, (box.centerx, box.centery - 1), col, anchor="center")

        if str(getattr(self, "msg", "")).strip():
            draw_text(surface, self.app.font_s, str(self.msg), (INTERNAL_W // 2, 148), pygame.Color(255, 220, 140), anchor="center")


class HardcoreSurvivalState(State):
    TILE_SIZE = 10
    CHUNK_SIZE = 32
    ROAD_PERIOD = CHUNK_SIZE * 4
    ROAD_HALF = ROAD_PERIOD // 2
    ROAD_W = 2

    T_GRASS = 1
    T_FOREST = 2
    T_WATER = 3
    T_ROAD = 4
    T_FLOOR = 5
    T_WALL = 6
    T_DOOR = 7
    T_TABLE = 8
    T_SHELF = 9
    T_BED = 10
    T_PAVEMENT = 11
    T_PARKING = 12
    T_COURT = 13
    T_SIDEWALK = 14
    T_BRICK = 15
    T_CONCRETE = 16
    T_SAND = 17
    T_BOARDWALK = 18
    T_MARSH = 19
    T_HIGHWAY = 20
    T_STAIRS_UP = 21
    T_STAIRS_DOWN = 22
    T_ELEVATOR = 23
    T_BARRICADE = 24
    # Furniture / home markers (world-map interiors)
    T_DOOR_HOME = 25
    T_SOFA = 26
    T_FRIDGE = 27
    T_TV = 28
    T_CHAIR = 29
    # Locked doors (require keys)
    T_DOOR_LOCKED = 30
    T_DOOR_HOME_LOCKED = 31
    # Extra furniture
    T_PC = 32
    T_LAMP = 33
    T_SWITCH = 34
    T_TOILET = 35
    T_CABINET = 36
    T_SINK = 37
    T_DOOR_BROKEN = 38
    T_GAS_PUMP = 39
    T_STEER = 40
    # Outdoor biomes
    T_WHEAT = 41
    T_MOUNTAIN = 42

    # World furniture durability/drops (tables/chairs/etc). HP is per connected block.
    _WORLD_FURNITURE_HP_DEFAULTS: dict[int, int] = {
        T_TABLE: 26,
        T_CHAIR: 18,
        T_SHELF: 24,
        T_CABINET: 24,
        T_BED: 34,
        T_SOFA: 32,
        T_FRIDGE: 28,
        T_TV: 20,
        T_PC: 22,
        T_LAMP: 10,
        T_SWITCH: 10,
        T_TOILET: 24,
        T_SINK: 20,
    }
    _WORLD_FURNITURE_WOOD_TILES: set[int] = {
        T_TABLE,
        T_CHAIR,
        T_SHELF,
        T_CABINET,
        T_BED,
        T_SOFA,
    }
    _WORLD_FURNITURE_METAL_TILES: set[int] = {
        T_FRIDGE,
        T_TV,
        T_PC,
        T_LAMP,
        T_SWITCH,
        T_TOILET,
        T_SINK,
    }

    DAY_LENGTH_S = 8 * 60.0
    SEASON_LENGTH_DAYS = 7
    SEASONS = ("", "", "", "")
    START_DAY_FRACTION = 0.30  # ~07:12

    WEATHER_TRANSITION_S = 18.0
    WEATHER_KINDS = ("clear", "cloudy", "rain", "storm", "snow")
    WEATHER_NAMES: dict[str, str] = {
        "clear": "",
        "cloudy": "",
        "rain": "",
        "storm": "",
        "snow": "",
    }

    def __init__(self, app: "App", *, avatar: SurvivalAvatar | None = None, player_name: str | None = None) -> None:
        super().__init__(app)
        self.avatar = avatar if avatar is not None else SurvivalAvatar()
        self.avatar.clamp_all()
        self.player_name = str(player_name or getattr(app, "player_name", "") or "").strip()[:10]
        if len(self.player_name) < 2:
            self.player_name = ""

    @dataclass(frozen=True)
    class _TileDef:
        name: str
        color: tuple[int, int, int]
        solid: bool
        slow: float = 1.0

    _TILES: dict[int, _TileDef] = {
        T_GRASS: _TileDef("grass", (32, 120, 56), solid=False),
        T_FOREST: _TileDef("forest", (22, 86, 42), solid=False, slow=0.82),
        T_WATER: _TileDef("water", (22, 56, 98), solid=True),
        T_ROAD: _TileDef("road", (72, 72, 74), solid=False),
        T_HIGHWAY: _TileDef("highway", (58, 58, 62), solid=False),
        T_FLOOR: _TileDef("floor", (58, 56, 52), solid=False),
        T_WALL: _TileDef("wall", (28, 28, 30), solid=True),
        T_DOOR: _TileDef("door", (120, 96, 52), solid=False),
        T_TABLE: _TileDef("table", (78, 62, 44), solid=True),
        T_SHELF: _TileDef("shelf", (50, 50, 54), solid=True),
        T_BED: _TileDef("bed", (84, 84, 110), solid=True),
        T_PAVEMENT: _TileDef("pavement", (92, 92, 96), solid=False),
        T_PARKING: _TileDef("parking", (66, 66, 78), solid=False),
        T_COURT: _TileDef("court", (116, 86, 66), solid=False),
        T_SIDEWALK: _TileDef("sidewalk", (156, 132, 86), solid=False),
        T_BRICK: _TileDef("brick", (140, 94, 80), solid=False),
        T_CONCRETE: _TileDef("concrete", (112, 112, 118), solid=False),
        T_SAND: _TileDef("sand", (192, 176, 112), solid=False, slow=0.92),
        T_BOARDWALK: _TileDef("boardwalk", (156, 116, 68), solid=False),
        T_MARSH: _TileDef("marsh", (56, 92, 62), solid=False, slow=0.78),
        T_WHEAT: _TileDef("wheat", (184, 168, 74), solid=False, slow=0.88),
        T_MOUNTAIN: _TileDef("mountain", (98, 100, 108), solid=False, slow=0.74),
        T_STAIRS_UP: _TileDef("stairs_up", (84, 76, 62), solid=False),   
        T_STAIRS_DOWN: _TileDef("stairs_down", (84, 76, 62), solid=False),
        T_ELEVATOR: _TileDef("elevator", (82, 82, 96), solid=False),     
        T_BARRICADE: _TileDef("barricade", (96, 78, 52), solid=True),
        T_DOOR_HOME: _TileDef("door_home", (56, 156, 96), solid=False),
        T_SOFA: _TileDef("sofa", (94, 78, 112), solid=True),
        T_FRIDGE: _TileDef("fridge", (182, 186, 194), solid=True),
        T_TV: _TileDef("tv", (34, 34, 40), solid=True),
        T_CHAIR: _TileDef("chair", (92, 72, 54), solid=True),
        T_DOOR_LOCKED: _TileDef("door_locked", (120, 96, 52), solid=True),
        T_DOOR_HOME_LOCKED: _TileDef("door_home_locked", (56, 156, 96), solid=True),
        T_PC: _TileDef("pc", (78, 68, 56), solid=True),
        T_LAMP: _TileDef("lamp", (196, 186, 120), solid=False),
        T_SWITCH: _TileDef("switch", (170, 170, 176), solid=False),
        T_TOILET: _TileDef("toilet", (240, 240, 245), solid=True),
        T_CABINET: _TileDef("cabinet", (92, 72, 54), solid=True),
        T_SINK: _TileDef("sink", (184, 188, 196), solid=True),
        T_DOOR_BROKEN: _TileDef("door_broken", (120, 96, 52), solid=False),
        T_GAS_PUMP: _TileDef("gas_pump", (200, 70, 70), solid=True),
        # Steering wheel marker (used in RV world-interior). Keep non-solid so the player
        # won't get shoved out of the RV when walking to the very front edge.
        T_STEER: _TileDef("steer", (90, 90, 96), solid=False),
    }

    _PLAYER_PAL = {
        "H": (26, 26, 30),  # hair
        "S": (220, 190, 160),  # skin
        "C": (72, 92, 160),  # coat
        "P": (52, 52, 62),  # pants
        "B": (22, 22, 26),  # boots
        "E": (6, 6, 8),  # eye
    }

    # Side-walk gait tables (6 steps). "Near" is the leg closer to the camera
    # when facing right; "far" is the back leg. Offsets are in pixels from the
    # hip X, lifts drive knee bend (and a small 1px foot raise).
    #
    # Default gait is WALK; sprint (Shift) switches to RUN.
    _SIDE_WALK_WALK_NEAR_OFFSETS = (1, 1, 0, -1, 0, 2)
    _SIDE_WALK_WALK_FAR_OFFSETS = (-1, 0, 2, 1, 1, 0)
    _SIDE_WALK_WALK_NEAR_LIFTS = (0, 0, 0, 0, 1, 2)
    _SIDE_WALK_WALK_FAR_LIFTS = (0, 1, 2, 0, 0, 0)

    _SIDE_WALK_RUN_NEAR_OFFSETS = (2, 1, -1, -1, 1, 3)
    _SIDE_WALK_RUN_FAR_OFFSETS = (-2, 1, 3, 2, 1, -1)
    _SIDE_WALK_RUN_NEAR_LIFTS = (0, 0, 0, 1, 3, 4)
    _SIDE_WALK_RUN_FAR_LIFTS = (1, 3, 4, 0, 0, 0)

    @classmethod
    def _side_walk_tables(
        cls,
        *,
        run: bool,
    ) -> tuple[tuple[int, ...], tuple[int, ...], tuple[int, ...], tuple[int, ...]]:
        if bool(run):
            return (
                cls._SIDE_WALK_RUN_NEAR_OFFSETS,
                cls._SIDE_WALK_RUN_FAR_OFFSETS,
                cls._SIDE_WALK_RUN_NEAR_LIFTS,
                cls._SIDE_WALK_RUN_FAR_LIFTS,
            )
        return (
            cls._SIDE_WALK_WALK_NEAR_OFFSETS,
            cls._SIDE_WALK_WALK_FAR_OFFSETS,
            cls._SIDE_WALK_WALK_NEAR_LIFTS,
            cls._SIDE_WALK_WALK_FAR_LIFTS,
        )

    _SURVIVOR_SKELETON_BONES: tuple[tuple[str, str], ...] = (
        ("head", "chest"),
        ("chest", "hip"),
        ("hip", "l_knee"),
        ("l_knee", "l_foot"),
        ("hip", "r_knee"),
        ("r_knee", "r_foot"),
        ("chest", "l_hand"),
        ("chest", "r_hand"),
    )

    @staticmethod
    def _solve_two_bone_knee(
        hip_x: float,
        hip_y: float,
        foot_x: float,
        foot_y: float,
        upper_len: float,
        lower_len: float,
        *,
        prefer_forward: bool = True,
    ) -> tuple[int, int]:
        dx = float(foot_x) - float(hip_x)
        dy = float(foot_y) - float(hip_y)
        d = float(math.hypot(dx, dy))
        if d <= 1e-4:
            return int(round(float(hip_x))), int(round(float(hip_y) + float(upper_len)))

        max_d = float(upper_len + lower_len) - 1e-3
        min_d = float(abs(float(upper_len) - float(lower_len))) + 1e-3
        d = float(clamp(float(d), float(min_d), float(max_d)))

        ux = dx / d
        uy = dy / d

        a = (float(upper_len) * float(upper_len) - float(lower_len) * float(lower_len) + d * d) / (2.0 * d)
        h2 = float(upper_len) * float(upper_len) - a * a
        h = math.sqrt(max(0.0, float(h2)))

        px = float(hip_x) + a * ux
        py = float(hip_y) + a * uy

        vx = -uy
        vy = ux
        k1x = px + h * vx
        k1y = py + h * vy
        k2x = px - h * vx
        k2y = py - h * vy

        if prefer_forward:
            kx, ky = (k1x, k1y) if k1x >= k2x else (k2x, k2y)
        else:
            kx, ky = (k1x, k1y) if k1x <= k2x else (k2x, k2y)
        return int(round(float(kx))), int(round(float(ky)))

    @classmethod
    def _survivor_skeleton_nodes(
        cls,
        direction: str,
        step: int,
        *,
        idle: bool,
        height_delta: int = 0,
        run: bool = False,
    ) -> dict[str, tuple[int, int]]:
        direction = str(direction)
        w, h = 12, 16

        step = int(step) % 6
        if idle:
            step = 2

        height_delta = int(height_delta)
        nodes: dict[str, tuple[int, int]] = {}

        if direction in ("right", "left"):
            leg_top = int(clamp(10 + height_delta, 8, 12))
            hip_y = int(leg_top)
            far_hip_x = 5
            near_hip_x = 6

            if idle:
                step_idx = 0
                near_off = 0
                far_off = 0
                near_lift = 0
                far_lift = 0
            else:
                step_idx = int(step) % 6
                near_offsets, far_offsets, near_lifts, far_lifts = cls._side_walk_tables(run=bool(run))
                near_off = int(near_offsets[step_idx])
                far_off = int(far_offsets[step_idx])
                near_lift = int(near_lifts[step_idx])
                far_lift = int(far_lifts[step_idx])

            def leg_joints(hip_x: int, foot_x: int, lift: int) -> tuple[tuple[int, int], tuple[int, int], tuple[int, int]]:
                hip_x = int(clamp(int(hip_x), 0, w - 1))
                foot_x = int(clamp(int(foot_x), 0, w - 1))
                lift_px = int(clamp(int(min(int(lift), 4)), 0, 4))

                raise_px = 1 if int(lift_px) > 0 else 0
                foot_y = int(max(int(hip_y) + 1, 15 - int(raise_px)))
                foot_y = int(clamp(int(foot_y), 0, 15))

                mid_x = float(hip_x + foot_x) * 0.5
                mid_y = float(hip_y + foot_y) * 0.5

                if lift_px <= 0:
                    knee_x = int(round((float(hip_x) + float(foot_x)) * 0.5))
                    knee_y = int(round((float(hip_y) + float(foot_y)) * 0.5))
                else:
                    dist = float(15 - int(hip_y))
                    total = float(max(4.0, float(dist) + 1.0))
                    upper = float(total * 0.5)
                    lower = float(total * 0.5)
                    ik_x, ik_y = cls._solve_two_bone_knee(
                        float(hip_x),
                        float(hip_y),
                        float(foot_x),
                        float(foot_y),
                        float(upper),
                        float(lower),
                        prefer_forward=True,
                    )
                    # Blend toward IK as the lift increases to avoid a too-sharp knee on small lifts.
                    t = float(clamp((float(lift_px) / 4.0) ** 0.85, 0.0, 1.0))
                    knee_x = int(round(mid_x + (float(ik_x) - mid_x) * t))
                    knee_y = int(round(mid_y + (float(ik_y) - mid_y) * t))

                kmin = min(int(hip_x), int(foot_x)) - 1
                kmax = max(int(hip_x), int(foot_x)) + 2
                knee_x = int(clamp(int(knee_x), int(kmin), int(kmax)))
                knee_x = int(clamp(int(knee_x), 0, w - 1))
                knee_y = int(clamp(int(knee_y), int(hip_y), int(foot_y)))
                return (int(hip_x), int(hip_y)), (int(knee_x), int(knee_y)), (int(foot_x), int(foot_y))

            far_foot_x = int(far_hip_x + int(far_off))
            near_foot_x = int(near_hip_x + int(near_off))

            l_hip, l_knee, l_foot = leg_joints(int(far_hip_x), int(far_foot_x), int(far_lift))
            r_hip, r_knee, r_foot = leg_joints(int(near_hip_x), int(near_foot_x), int(near_lift))

            nodes.update(
                {
                    "head": (7, 3),
                    "chest": (6, 8),
                    "hip": (int(round((float(far_hip_x) + float(near_hip_x)) * 0.5)), int(hip_y)),
                    "l_hip": l_hip,
                    "l_knee": l_knee,
                    "l_foot": l_foot,
                    "r_hip": r_hip,
                    "r_knee": r_knee,
                    "r_foot": r_foot,
                    "l_hand": (4, 9),
                    "r_hand": (8, 9),
                }
            )

            if direction == "left":
                nodes = {name: (int(w - 1 - x), int(y)) for name, (x, y) in nodes.items()}
            return nodes

        if direction in ("down", "up"):
            leg_top = int(clamp((11 if direction == "up" else 10) + height_delta, 8, 12))
            if direction == "down":
                left_hip = 4
                right_hip = 7
                head = (6, 3)
                l_hand = (2, 9)
                r_hand = (9, 9)
            else:
                left_hip = 5
                right_hip = 6
                head = (6, 2)
                l_hand = (2, 8)
                r_hand = (9, 8)

            left_lift = 2 if step == 1 else 1 if step == 0 else 0
            right_lift = 2 if step == 4 else 1 if step == 3 else 0

            left_x = int(left_hip - (1 if left_lift else 0))
            right_x = int(right_hip + (1 if right_lift else 0))
            left_knee_y = int(13 - left_lift)
            right_knee_y = int(13 - right_lift)
            left_boot_y = int(15 - left_lift)
            right_boot_y = int(15 - right_lift)

            nodes.update(
                {
                    "head": (int(head[0]), int(head[1])),
                    "chest": (6, 8),
                    "hip": (6, int(leg_top)),
                    "l_hip": (int(left_hip), int(leg_top)),
                    "r_hip": (int(right_hip), int(leg_top)),
                    "l_knee": (int(left_x), int(left_knee_y)),
                    "r_knee": (int(right_x), int(right_knee_y)),
                    "l_foot": (int(left_x), int(left_boot_y)),
                    "r_foot": (int(right_x), int(right_boot_y)),
                    "l_hand": (int(l_hand[0]), int(l_hand[1])),
                    "r_hand": (int(r_hand[0]), int(r_hand[1])),
                }
            )
            return nodes

        return {}

    def _make_player_sprite(
        direction: str,
        step: int,
        *,
        idle: bool,
        run: bool = False,
        pal=_PLAYER_PAL,
    ) -> pygame.Surface:
        w, h = 12, 16
        surf = pygame.Surface((w, h), pygame.SRCALPHA)

        hair = pal["H"]
        skin = pal["S"]
        coat = pal["C"]
        pants = pal["P"]
        boots = pal["B"]
        eye = pal["E"]
        coat_dark = (56, 72, 140)
        pants_dark = (40, 40, 50)

        step = int(step) % 6
        if idle:
            step = 2

        def draw_line(
            col: tuple[int, int, int],
            x0: int,
            y0: int,
            x1: int,
            y1: int,
        ) -> None:
            x0 = int(clamp(int(x0), 0, w - 1))
            x1 = int(clamp(int(x1), 0, w - 1))
            y0 = int(clamp(int(y0), 0, h - 1))
            y1 = int(clamp(int(y1), 0, h - 1))

            dx = abs(x1 - x0)
            dy = -abs(y1 - y0)
            sx = 1 if x0 < x1 else -1
            sy = 1 if y0 < y1 else -1
            err = dx + dy
            x, y = x0, y0
            while True:
                surf.fill(col, pygame.Rect(int(x), int(y), 1, 1))
                if x == x1 and y == y1:
                    break
                e2 = 2 * err
                if e2 >= dy:
                    err += dy
                    x += sx
                if e2 <= dx:
                    err += dx
                    y += sy

        def draw_leg(
            hip_x: int,
            knee_x: int,
            boot_x: int,
            boot_y: int,
            *,
            leg_top: int,
            knee_y: int,
            leg_col: tuple[int, int, int],
        ) -> None:
            hip_x = int(clamp(int(hip_x), 0, w - 1))
            knee_x = int(clamp(int(knee_x), 0, w - 1))
            boot_x = int(clamp(int(boot_x), 0, w - 1))
            leg_top = int(clamp(int(leg_top), 0, h - 1))
            knee_y = int(clamp(int(knee_y), 0, h - 1))
            boot_y = int(clamp(int(boot_y), 0, h - 1))

            if knee_y < leg_top:
                knee_y = leg_top
            if boot_y < knee_y:
                boot_y = knee_y

            draw_line(leg_col, int(hip_x), int(leg_top), int(knee_x), int(knee_y))
            draw_line(leg_col, int(knee_x), int(knee_y), int(boot_x), int(boot_y))
            surf.fill(boots, pygame.Rect(boot_x, boot_y, 1, 1))

        def draw_straight_leg(
            hip_x: int,
            foot_x: int,
            foot_y: int,
            *,
            leg_top: int,
            leg_col: tuple[int, int, int],
        ) -> None:
            hip_x = int(clamp(int(hip_x), 0, w - 1))
            foot_x = int(clamp(int(foot_x), 0, w - 1))
            leg_top = int(clamp(int(leg_top), 0, h - 1))
            foot_y = int(clamp(int(foot_y), 0, h - 1))

            draw_line(leg_col, int(hip_x), int(leg_top), int(foot_x), int(foot_y))
            surf.fill(boots, pygame.Rect(int(foot_x), int(foot_y), 1, 1))

        if direction in ("down", "up"):
            leg_top = 11 if direction == "up" else 10
            if direction == "down":
                left_hip = 4
                right_hip = 7
            else:
                left_hip = 5
                right_hip = 6

            # 6-step walk: left swings early, right swings late.
            left_lift = 2 if step == 1 else 1 if step == 0 else 0
            right_lift = 2 if step == 4 else 1 if step == 3 else 0

            left_x = left_hip - (1 if left_lift else 0)
            right_x = right_hip + (1 if right_lift else 0)
            left_knee_y = 13 - left_lift
            right_knee_y = 13 - right_lift
            left_boot_y = 15 - left_lift
            right_boot_y = 15 - right_lift

            # Legs first (behind torso) so the player doesn't look "spidery".
            draw_leg(
                int(right_hip),
                int(right_x),
                int(right_x),
                int(right_boot_y),
                leg_top=int(leg_top),
                knee_y=int(right_knee_y),
                leg_col=pants_dark,
            )
            draw_leg(
                int(left_hip),
                int(left_x),
                int(left_x),
                int(left_boot_y),
                leg_top=int(leg_top),
                knee_y=int(left_knee_y),
                leg_col=pants,
            )

            if direction == "down":
                # Torso + arms.
                surf.fill(coat, pygame.Rect(3, 5, 6, 6))
                surf.fill(coat_dark, pygame.Rect(3, 10, 6, 1))
                surf.fill(coat, pygame.Rect(2, 6, 1, 3))
                surf.fill(coat, pygame.Rect(9, 6, 1, 3))
                surf.fill(skin, pygame.Rect(2, 9, 1, 1))
                surf.fill(skin, pygame.Rect(9, 9, 1, 1))

                # Head.
                surf.fill(hair, pygame.Rect(4, 0, 4, 2))
                surf.fill(skin, pygame.Rect(4, 2, 4, 3))
                surf.set_at((5, 3), eye)
                surf.set_at((7, 3), eye)
            else:
                # Torso + arms.
                surf.fill(coat, pygame.Rect(3, 4, 6, 7))
                surf.fill(coat_dark, pygame.Rect(4, 6, 4, 4))
                surf.fill(coat, pygame.Rect(2, 5, 1, 4))
                surf.fill(coat, pygame.Rect(9, 5, 1, 4))

                # Back head.
                surf.fill(hair, pygame.Rect(4, 0, 4, 3))
                surf.fill(skin, pygame.Rect(5, 3, 2, 1))

            return surf

        if direction == "right":
            leg_top = 10
            far_hip = 5
            near_hip = 6

            # Side-walk: alternating stride (one leg swings while the other supports).
            # 4-frame side gait ():
            # - Swing leg bends (knee) on the first frame of the step.
            # - Then it extends straight while still forward.
            # - Swap draw order when legs cross so it doesn't look like only one
            #   leg is moving.
            if idle:
                step = 0
                near_offsets = (0, 0, 0, 0, 0, 0)
                far_offsets = (0, 0, 0, 0, 0, 0)
                near_lifts = (0, 0, 0, 0, 0, 0)
                far_lifts = (0, 0, 0, 0, 0, 0)
            else:
                step = int(step) % 6
                if bool(run):
                    near_offsets = (2, 1, -1, -1, 1, 3)
                    far_offsets = (-2, 1, 3, 2, 1, -1)
                    near_lifts = (0, 0, 0, 1, 3, 4)
                    far_lifts = (1, 3, 4, 0, 0, 0)
                else:
                    near_offsets = (1, 1, 0, -1, 0, 2)
                    far_offsets = (-1, 0, 2, 1, 1, 0)
                    near_lifts = (0, 0, 0, 0, 1, 2)
                    far_lifts = (0, 1, 2, 0, 0, 0)

            near_foot_x = int(near_hip + int(near_offsets[int(step)]))
            far_foot_x = int(far_hip + int(far_offsets[int(step)]))
            near_lift = int(near_lifts[int(step)])
            far_lift = int(far_lifts[int(step)])

            def solve_knee_ik(
                hip_x: float,
                hip_y: float,
                foot_x: float,
                foot_y: float,
                upper_len: float,
                lower_len: float,
            ) -> tuple[int, int]:
                dx = float(foot_x) - float(hip_x)
                dy = float(foot_y) - float(hip_y)
                d = float(math.hypot(dx, dy))
                if d <= 1e-4:
                    return int(round(float(hip_x))), int(round(float(hip_y) + float(upper_len)))

                max_d = float(upper_len + lower_len) - 1e-3
                min_d = float(abs(float(upper_len) - float(lower_len))) + 1e-3
                d = float(clamp(float(d), float(min_d), float(max_d)))

                ux = dx / d
                uy = dy / d

                a = (float(upper_len) * float(upper_len) - float(lower_len) * float(lower_len) + d * d) / (2.0 * d)
                h2 = float(upper_len) * float(upper_len) - a * a
                h = math.sqrt(max(0.0, float(h2)))

                px = float(hip_x) + a * ux
                py = float(hip_y) + a * uy

                # Prefer the knee to face forward (right) for the unflipped sprite.
                vx = -uy
                vy = ux
                k1x = px + h * vx
                k1y = py + h * vy
                k2x = px - h * vx
                k2y = py - h * vy
                if k1x >= k2x:
                    kx, ky = k1x, k1y
                else:
                    kx, ky = k2x, k2y
                return int(round(float(kx))), int(round(float(ky)))

            def draw_pose(hip_x: int, foot_x: int, lift: int, *, col: tuple[int, int, int]) -> None:
                hip_x = int(hip_x)
                foot_x = int(clamp(int(foot_x), 0, w - 1))
                lift_px = int(clamp(int(min(int(lift), 4)), 0, 4))

                hip_y = int(leg_top)
                raise_px = 1 if int(lift_px) > 0 else 0
                foot_y = int(max(int(leg_top) + 1, 15 - int(raise_px)))
                foot_y = int(clamp(int(foot_y), 0, 15))

                if lift_px <= 0:
                    draw_straight_leg(int(hip_x), int(foot_x), int(foot_y), leg_top=int(hip_y), leg_col=col)
                    return

                else:
                    dist = float(15 - int(hip_y))
                    total = float(max(4.0, float(dist) + 1.0))
                    upper = float(total * 0.5)
                    lower = float(total * 0.5)
                    knee_x, knee_y = solve_knee_ik(float(hip_x), float(hip_y), float(foot_x), float(foot_y), float(upper), float(lower))

                    mid_x = float(hip_x + foot_x) * 0.5
                    mid_y = float(hip_y + foot_y) * 0.5
                    t = float(clamp((float(lift_px) / 4.0) ** 0.85, 0.0, 1.0))
                    knee_x = int(round(mid_x + (float(knee_x) - mid_x) * t))
                    knee_y = int(round(mid_y + (float(knee_y) - mid_y) * t))
                    kmin = min(int(hip_x), int(foot_x)) - 1
                    kmax = max(int(hip_x), int(foot_x)) + 2
                    knee_x = int(clamp(int(knee_x), int(kmin), int(kmax)))

                knee_x = int(clamp(int(knee_x), 0, w - 1))
                knee_y = int(clamp(int(knee_y), int(hip_y), int(foot_y)))

                draw_leg(
                    int(hip_x),
                    int(knee_x),
                    int(foot_x),
                    int(foot_y),
                    leg_top=int(hip_y),
                    knee_y=int(knee_y),
                    leg_col=col,
                )

            # Depth + shading: the front leg uses the lighter pants color so
            # the crossing reads clearly (otherwise it can look like only the
            # near leg is moving).
            if int(near_foot_x) >= int(far_foot_x):
                # Near leg is in front.
                draw_pose(int(far_hip), int(far_foot_x), int(far_lift), col=pants_dark)
                draw_pose(int(near_hip), int(near_foot_x), int(near_lift), col=pants)
            else:
                # Far leg crosses in front.
                draw_pose(int(near_hip), int(near_foot_x), int(near_lift), col=pants_dark)
                draw_pose(int(far_hip), int(far_foot_x), int(far_lift), col=pants)

            # Torso + near arm.
            surf.fill(coat, pygame.Rect(4, 5, 5, 6))
            surf.fill(coat_dark, pygame.Rect(4, 10, 5, 1))
            surf.fill(coat, pygame.Rect(8, 6, 1, 3))
            surf.fill(skin, pygame.Rect(8, 9, 1, 1))

            # Head.
            surf.fill(hair, pygame.Rect(4, 0, 4, 2))
            surf.fill(skin, pygame.Rect(6, 2, 3, 3))
            surf.set_at((8, 3), eye)

            return surf

        return surf

    _P_DOWN_FRAMES: list[pygame.Surface] = []
    _P_DOWN_FRAMES.append(_make_player_sprite("down", 0, idle=True))
    for _i in range(6):
        _P_DOWN_FRAMES.append(_make_player_sprite("down", _i, idle=False))

    _P_UP_FRAMES: list[pygame.Surface] = []
    _P_UP_FRAMES.append(_make_player_sprite("up", 0, idle=True))
    for _i in range(6):
        _P_UP_FRAMES.append(_make_player_sprite("up", _i, idle=False))

    _P_RIGHT_FRAMES: list[pygame.Surface] = []
    _P_RIGHT_FRAMES.append(_make_player_sprite("right", 0, idle=True))
    for _i in range(6):
        _P_RIGHT_FRAMES.append(_make_player_sprite("right", _i, idle=False))    

    _PLAYER_FRAMES: dict[str, list[pygame.Surface]] = {
        "down": _P_DOWN_FRAMES,
        "up": _P_UP_FRAMES,
        "right": _P_RIGHT_FRAMES,
        "left": [],
    }
    for _s in _P_RIGHT_FRAMES:
        _PLAYER_FRAMES["left"].append(pygame.transform.flip(_s, True, False))

    @classmethod
    def _avatar_colors(cls, avatar: SurvivalAvatar) -> dict[str, tuple[int, int, int]]:
        avatar.clamp_all()
        gender = int(avatar.gender)
        makeup = int(getattr(avatar, "makeup", 0))
        outfit = int(avatar.outfit)

        skin_pals = [
            (236, 210, 180),  # 
            (220, 190, 160),  # 
            (202, 172, 142),  # 
            (170, 140, 110),  # 
        ]
        hair_pals = [
            (26, 26, 30),  # 
            (60, 44, 34),  # 
            (170, 140, 84),  # 
            (200, 200, 210),  # 
            (180, 60, 60),  # 
            (60, 120, 200),  # 
        ]
        eye_pals = [
            (6, 6, 8),  # 
            (46, 28, 16),  # 
            (36, 90, 170),  # 
            (40, 140, 90),  # 
            (160, 40, 40),  # 
        ]

        skin = skin_pals[int(getattr(avatar, "skin", 0)) % len(skin_pals)]
        hair = hair_pals[int(getattr(avatar, "hair_color", 0)) % len(hair_pals)]
        eye = eye_pals[int(getattr(avatar, "eye_color", 0)) % len(eye_pals)]

        # A tiny gender tint so "" doesn't look identical at a glance.
        if gender != 0:
            hair = (min(255, hair[0] + 8), min(255, hair[1] + 4), min(255, hair[2] + 6))
            skin = (min(255, skin[0] + 6), min(255, skin[1] + 4), min(255, skin[2] + 2))

        blush = (240, 140, 160)
        lipstick = (210, 70, 80)
        lip = lipstick if int(makeup) >= 2 else (max(0, skin[0] - 70), max(0, skin[1] - 70), max(0, skin[2] - 70))
        boots = (22, 22, 26)

        pals: list[tuple[tuple[int, int, int], tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]]] = [
            ((72, 92, 160), (56, 72, 140), (52, 52, 62), (40, 40, 50)),  # 
            ((70, 120, 90), (48, 86, 64), (66, 54, 40), (46, 38, 28)),  # 
            ((92, 92, 104), (70, 70, 82), (44, 44, 56), (32, 32, 40)),  # 
            ((210, 130, 60), (170, 90, 44), (70, 46, 34), (50, 32, 24)),  # 
            ((220, 220, 230), (180, 180, 190), (92, 92, 104), (70, 70, 82)),  # 
            ((224, 210, 112), (190, 176, 84), (70, 70, 82), (52, 52, 62)),  # 
            ((210, 120, 160), (168, 92, 130), (44, 44, 56), (32, 32, 40)),  # 
            ((90, 140, 210), (70, 110, 170), (60, 52, 46), (44, 38, 34)),  # 
            ((240, 240, 245), (200, 200, 210), (92, 92, 104), (70, 70, 82)),  # 
            ((210, 70, 80), (160, 50, 60), (22, 22, 26), (12, 12, 16)),  # 
            ((120, 190, 140), (92, 150, 110), (70, 46, 34), (50, 32, 24)),  # 
            ((28, 28, 34), (18, 18, 22), (28, 28, 34), (18, 18, 22)),  # 
            ((160, 140, 90), (120, 110, 70), (90, 80, 60), (70, 62, 44)),  # 
            ((80, 160, 210), (60, 120, 170), (40, 40, 50), (28, 28, 34)),  # 
            ((200, 190, 230), (160, 150, 190), (92, 92, 104), (70, 70, 82)),  # 
            ((220, 220, 240), (180, 180, 200), (200, 140, 170), (160, 100, 130)),  # 
        ]
        coat, coat_dark, pants, pants_dark = pals[int(outfit) % len(pals)]

        return {
            "hair": hair,
            "skin": skin,
            "eye": eye,
            "coat": coat,
            "coat_dark": coat_dark,
            "pants": pants,
            "pants_dark": pants_dark,
            "boots": boots,
            "lip": lip,
            "blush": blush,
        }

    @classmethod
    def _make_avatar_player_sprite(
        cls,
        direction: str,
        step: int,
        *,
        idle: bool,
        avatar: SurvivalAvatar,
        run: bool = False,
    ) -> pygame.Surface:
        avatar.clamp_all()
        w, h = 12, 16
        surf = pygame.Surface((w, h), pygame.SRCALPHA)

        cols = cls._avatar_colors(avatar)
        hair = cols["hair"]
        skin = cols["skin"]
        coat = cols["coat"]
        coat_dark = cols["coat_dark"]
        pants = cols["pants"]
        pants_dark = cols["pants_dark"]
        boots = cols["boots"]
        eye = cols["eye"]
        outline = (10, 10, 12)
        skin_shade = (max(0, skin[0] - 45), max(0, skin[1] - 45), max(0, skin[2] - 45))
        beard_col = (max(0, hair[0] - 32), max(0, hair[1] - 32), max(0, hair[2] - 32))

        step = int(step) % 6
        if idle:
            step = 2

        height_delta = 1 if int(avatar.height) == 0 else -1 if int(avatar.height) == 2 else 0
        gender = int(getattr(avatar, "gender", 0))
        face_kind = int(avatar.face)
        eye_kind = int(avatar.eyes)
        hair_kind = int(avatar.hair)
        nose_kind = int(avatar.nose)
        mouth_kind = int(getattr(avatar, "mouth", 0))
        beard_kind = int(getattr(avatar, "beard", 0))
        makeup_kind = int(getattr(avatar, "makeup", 0))
        accessory_kind = int(getattr(avatar, "accessory", 0))
        outfit_kind = int(avatar.outfit)
        lip = cols.get("lip", skin_shade)
        blush = cols.get("blush", (240, 140, 160))
        glass = (90, 90, 110)
        mask = (180, 180, 190)
        ear = (255, 220, 140)

        def draw_hair_down() -> None:
            if hair_kind == 3:  # hat
                hat = coat_dark
                pygame.draw.rect(surf, hat, pygame.Rect(3, 0, 6, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 0, 6, 2), 1, border_radius=1)
                pygame.draw.rect(surf, hat, pygame.Rect(3, 2, 5, 1), border_radius=1)
                return

            surf.fill(hair, pygame.Rect(4, 0, 4, 2))
            if hair_kind == 1:  # bangs
                surf.set_at((5, 2), hair)
                surf.set_at((6, 2), hair)
            elif hair_kind == 2:  # long
                for (x, y) in ((3, 2), (8, 2), (3, 3), (8, 3), (3, 4), (8, 4)):
                    surf.set_at((x, y), hair)
            elif hair_kind == 4:  # ponytail
                for (x, y) in ((3, 2), (8, 2), (6, 3), (6, 4)):
                    surf.set_at((x, y), hair)
            elif hair_kind == 5:  # twin tails
                for (x, y) in ((2, 2), (9, 2), (2, 3), (9, 3), (3, 4), (8, 4)):
                    surf.set_at((x, y), hair)
            elif hair_kind == 6:  # bob
                surf.fill(hair, pygame.Rect(4, 0, 4, 3))
                for (x, y) in ((3, 2), (8, 2), (3, 3), (8, 3)):
                    surf.set_at((x, y), hair)
            elif hair_kind == 7:  # bun
                surf.set_at((6, 0), hair)
                surf.set_at((6, 1), hair)

        def draw_face_down() -> None:
            if face_kind == 0:  # round
                surf.fill(skin, pygame.Rect(4, 2, 4, 3))
            elif face_kind == 1:  # square
                surf.fill(skin, pygame.Rect(4, 2, 4, 3))
                surf.fill(skin, pygame.Rect(3, 3, 1, 2))
                surf.fill(skin, pygame.Rect(8, 3, 1, 2))
            else:  # sharp
                surf.fill(skin, pygame.Rect(4, 2, 4, 2))
                surf.fill(skin, pygame.Rect(5, 4, 2, 1))

            if eye_kind == 0:  # normal
                surf.set_at((5, 3), eye)
                surf.set_at((7, 3), eye)
            elif eye_kind == 1:  # big
                for px in (5, 7):
                    surf.set_at((px, 3), eye)
                    surf.set_at((px, 4), eye)
            elif eye_kind == 2:  # angry
                surf.set_at((5, 3), eye)
                surf.set_at((7, 3), eye)
                surf.set_at((5, 2), outline)
                surf.set_at((7, 2), outline)
            else:  # sleepy
                surf.set_at((5, 3), outline)
                surf.set_at((7, 3), outline)

            # Masculine cue: simple eyebrows (unless already "angry").
            if int(gender) == 0 and int(eye_kind) != 2:
                surf.set_at((5, 2), outline)
                surf.set_at((7, 2), outline)

            if nose_kind == 1:  # dot
                surf.set_at((5, 4), skin_shade)
            elif nose_kind == 2:  # line
                surf.set_at((5, 4), skin_shade)
                surf.set_at((6, 4), skin_shade)

            # Feminine cue: subtle eyeliner/eyelashes.
            if int(gender) != 0:
                surf.set_at((4, 3), outline)
                surf.set_at((8, 3), outline)

            # Beard/stubble (male only). Keep it subtle so it doesn't fight the mouth pixels.
            if int(gender) == 0 and int(beard_kind) > 0:
                jaw = skin_shade if int(beard_kind) == 1 else beard_col
                surf.set_at((4, 4), jaw)
                surf.set_at((8, 4), jaw)

            # Mouth.
            if mouth_kind == 1:  # smile
                surf.set_at((6, 4), lip)
                surf.set_at((5, 4), lip)
            elif mouth_kind == 2:  # pout
                surf.set_at((6, 4), lip)
                surf.set_at((7, 4), lip)
            elif mouth_kind == 3:  # cold
                surf.set_at((6, 4), outline)

            # Makeup.
            if int(makeup_kind) >= 1:
                surf.set_at((4, 4), blush)
                surf.set_at((8, 4), blush)

            # Accessories.
            if accessory_kind == 1:  # glasses
                for x in range(4, 9):
                    surf.set_at((x, 3), glass)
                surf.set_at((4, 2), glass)
                surf.set_at((8, 2), glass)
            elif accessory_kind == 2:  # mask
                surf.fill(mask, pygame.Rect(4, 4, 4, 1))
            elif accessory_kind == 3:  # earrings
                surf.set_at((3, 4), ear)
                surf.set_at((9, 4), ear)

        def draw_hair_right() -> None:
            if hair_kind == 3:  # hat
                hat = coat_dark
                pygame.draw.rect(surf, hat, pygame.Rect(3, 0, 7, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 0, 7, 2), 1, border_radius=1)
                pygame.draw.rect(surf, hat, pygame.Rect(4, 2, 5, 1), border_radius=1)
                return

            surf.fill(hair, pygame.Rect(4, 0, 4, 2))
            if hair_kind == 1:  # bangs
                surf.set_at((7, 2), hair)
            elif hair_kind == 2:  # long
                for (x, y) in ((4, 2), (4, 3), (4, 4), (3, 3)):
                    surf.set_at((x, y), hair)
            elif hair_kind == 4:  # ponytail
                for (x, y) in ((4, 2), (4, 3), (3, 4), (4, 4)):
                    surf.set_at((x, y), hair)
            elif hair_kind == 5:  # twin tails
                for (x, y) in ((4, 2), (3, 2), (4, 3), (3, 3), (4, 4)):
                    surf.set_at((x, y), hair)
            elif hair_kind == 6:  # bob
                surf.fill(hair, pygame.Rect(4, 0, 4, 3))
                for (x, y) in ((4, 3), (4, 4), (3, 3)):
                    surf.set_at((x, y), hair)
            elif hair_kind == 7:  # bun
                surf.set_at((3, 1), hair)

        def draw_face_right() -> None:
            if face_kind == 0:
                surf.fill(skin, pygame.Rect(6, 2, 3, 3))
            elif face_kind == 1:
                surf.fill(skin, pygame.Rect(6, 2, 3, 3))
                surf.fill(skin, pygame.Rect(5, 3, 1, 2))
            else:
                surf.fill(skin, pygame.Rect(6, 2, 3, 2))
                surf.fill(skin, pygame.Rect(7, 4, 1, 1))

            if eye_kind == 1:  # big
                surf.set_at((8, 3), eye)
                surf.set_at((8, 4), eye)
            elif eye_kind == 2:  # angry
                surf.set_at((8, 3), eye)
                surf.set_at((8, 2), outline)
            elif eye_kind == 3:  # sleepy
                surf.set_at((8, 3), outline)
            else:
                surf.set_at((8, 3), eye)

            if int(gender) == 0 and int(eye_kind) != 2:
                surf.set_at((8, 2), outline)

            if nose_kind == 1:
                surf.set_at((7, 4), skin_shade)
            elif nose_kind == 2:
                surf.set_at((7, 4), skin_shade)
                surf.set_at((8, 4), skin_shade)

            if int(gender) != 0:
                surf.set_at((9, 2), outline)

            if mouth_kind == 1:
                surf.set_at((9, 4), lip)
            elif mouth_kind == 2:
                surf.set_at((9, 4), lip)
                surf.set_at((9, 5), lip)
            elif mouth_kind == 3:
                surf.set_at((9, 4), outline)

            if int(gender) == 0 and int(beard_kind) > 0:
                jaw = skin_shade if int(beard_kind) == 1 else beard_col
                if int(beard_kind) == 2:
                    surf.set_at((8, 4), jaw)  # tiny moustache hint
                else:
                    surf.set_at((8, 5), jaw)
                    if int(mouth_kind) != 2:
                        surf.set_at((9, 5), jaw)
                    if int(beard_kind) >= 3:
                        surf.set_at((7, 4), jaw)
                        surf.set_at((8, 4), jaw)

            if int(makeup_kind) >= 1:
                surf.set_at((6, 4), blush)

            if accessory_kind == 1:  # glasses
                surf.set_at((7, 3), glass)
                surf.set_at((8, 3), glass)
                surf.set_at((9, 3), glass)
            elif accessory_kind == 2:  # mask
                surf.fill(mask, pygame.Rect(7, 4, 3, 1))
            elif accessory_kind == 3:  # earrings
                surf.set_at((5, 4), ear)

        def draw_line(
            col: tuple[int, int, int],
            x0: int,
            y0: int,
            x1: int,
            y1: int,
        ) -> None:
            x0 = int(clamp(int(x0), 0, w - 1))
            x1 = int(clamp(int(x1), 0, w - 1))
            y0 = int(clamp(int(y0), 0, h - 1))
            y1 = int(clamp(int(y1), 0, h - 1))

            dx = abs(x1 - x0)
            dy = -abs(y1 - y0)
            sx = 1 if x0 < x1 else -1
            sy = 1 if y0 < y1 else -1
            err = dx + dy
            x, y = x0, y0
            while True:
                surf.fill(col, pygame.Rect(int(x), int(y), 1, 1))
                if x == x1 and y == y1:
                    break
                e2 = 2 * err
                if e2 >= dy:
                    err += dy
                    x += sx
                if e2 <= dx:
                    err += dx
                    y += sy

        def draw_leg(
            hip_x: int,
            knee_x: int,
            boot_x: int,
            boot_y: int,
            *,
            leg_top: int,
            knee_y: int,
            leg_col: tuple[int, int, int],
        ) -> None:
            hip_x = int(clamp(int(hip_x), 0, w - 1))
            knee_x = int(clamp(int(knee_x), 0, w - 1))
            boot_x = int(clamp(int(boot_x), 0, w - 1))
            leg_top = int(clamp(int(leg_top), 0, h - 1))
            knee_y = int(clamp(int(knee_y), 0, h - 1))
            boot_y = int(clamp(int(boot_y), 0, h - 1))

            if knee_y < leg_top:
                knee_y = leg_top
            if boot_y < knee_y:
                boot_y = knee_y

            draw_line(leg_col, int(hip_x), int(leg_top), int(knee_x), int(knee_y))
            draw_line(leg_col, int(knee_x), int(knee_y), int(boot_x), int(boot_y))
            surf.fill(boots, pygame.Rect(boot_x, boot_y, 1, 1))

        def draw_straight_leg(
            hip_x: int,
            foot_x: int,
            foot_y: int,
            *,
            leg_top: int,
            leg_col: tuple[int, int, int],
        ) -> None:
            hip_x = int(clamp(int(hip_x), 0, w - 1))
            foot_x = int(clamp(int(foot_x), 0, w - 1))
            leg_top = int(clamp(int(leg_top), 0, h - 1))
            foot_y = int(clamp(int(foot_y), 0, h - 1))

            draw_line(leg_col, int(hip_x), int(leg_top), int(foot_x), int(foot_y))
            surf.fill(boots, pygame.Rect(int(foot_x), int(foot_y), 1, 1))

        if direction in ("down", "up"):
            leg_top = (11 if direction == "up" else 10) + height_delta
            leg_top = int(clamp(int(leg_top), 8, 12))

            if direction == "down":
                left_hip = 4
                right_hip = 7
            else:
                left_hip = 5
                right_hip = 6

            # 6-step walk: left swings early, right swings late.
            left_lift = 2 if step == 1 else 1 if step == 0 else 0
            right_lift = 2 if step == 4 else 1 if step == 3 else 0

            left_x = left_hip - (1 if left_lift else 0)
            right_x = right_hip + (1 if right_lift else 0)
            left_knee_y = 13 - left_lift
            right_knee_y = 13 - right_lift
            left_boot_y = 15 - left_lift
            right_boot_y = 15 - right_lift

            draw_leg(
                int(right_hip),
                int(right_x),
                int(right_x),
                int(right_boot_y),
                leg_top=int(leg_top),
                knee_y=int(right_knee_y),
                leg_col=pants_dark,
            )
            draw_leg(
                int(left_hip),
                int(left_x),
                int(left_x),
                int(left_boot_y),
                leg_top=int(leg_top),
                knee_y=int(left_knee_y),
                leg_col=pants,
            )

            if direction == "down":
                surf.fill(coat, pygame.Rect(3, 5, 6, 6))
                surf.fill(coat_dark, pygame.Rect(3, 10, 6, 1))
                surf.fill(coat, pygame.Rect(2, 6, 1, 3))
                surf.fill(coat, pygame.Rect(9, 6, 1, 3))
                surf.fill(skin, pygame.Rect(2, 9, 1, 1))
                surf.fill(skin, pygame.Rect(9, 9, 1, 1))

                if outfit_kind == 2:  # tactical pouches
                    surf.fill(coat_dark, pygame.Rect(4, 7, 2, 2))
                    surf.fill(coat_dark, pygame.Rect(6, 7, 2, 2))
                elif outfit_kind == 3:  # stripes
                    for y in (6, 8, 10):
                        surf.fill(pants_dark, pygame.Rect(3, y, 6, 1))
                elif outfit_kind == 4:  # medic cross
                    surf.fill((210, 70, 80), pygame.Rect(5, 7, 1, 3))
                    surf.fill((210, 70, 80), pygame.Rect(4, 8, 3, 1))
                elif outfit_kind == 1:  # belt
                    surf.fill(pants_dark, pygame.Rect(3, 9, 6, 1))

                # A tiny skirt hint for the maid outfit so "" reads quickly.
                if int(gender) != 0 and int(outfit_kind) == 15:
                    surf.fill(coat_dark, pygame.Rect(3, 11, 6, 1))

                draw_hair_down()
                draw_face_down()
            else:
                surf.fill(coat, pygame.Rect(3, 4, 6, 7))
                surf.fill(coat_dark, pygame.Rect(4, 6, 4, 4))
                surf.fill(coat, pygame.Rect(2, 5, 1, 4))
                surf.fill(coat, pygame.Rect(9, 5, 1, 4))
                surf.fill(hair, pygame.Rect(4, 0, 4, 3))
                surf.fill(skin, pygame.Rect(5, 3, 2, 1))
                if hair_kind in (2, 4, 5):  # longer styles
                    surf.set_at((3, 3), hair)
                    surf.set_at((8, 3), hair)
                if hair_kind == 4:  # ponytail
                    surf.set_at((6, 4), hair)
                if hair_kind == 6:  # bob
                    surf.set_at((4, 3), hair)
                    surf.set_at((7, 3), hair)
                if hair_kind == 7:  # bun
                    surf.set_at((6, 1), hair)

            return surf

        # right (left built by flipping)
        leg_top = 10 + height_delta
        leg_top = int(clamp(int(leg_top), 8, 12))
        sk = cls._survivor_skeleton_nodes(
            "right",
            int(step),
            idle=bool(idle),
            height_delta=int(height_delta),
            run=bool(run),
        )
        l_hip = sk.get("l_hip", (5, int(leg_top)))
        l_knee = sk.get("l_knee", (5, 13))
        l_foot = sk.get("l_foot", (5, 15))
        r_hip = sk.get("r_hip", (6, int(leg_top)))
        r_knee = sk.get("r_knee", (6, 13))
        r_foot = sk.get("r_foot", (6, 15))

        if idle:
            step_idx = 0
            near_lift = 0
            far_lift = 0
        else:
            step_idx = int(step) % 6
            _, _, near_lifts, far_lifts = cls._side_walk_tables(run=bool(run))
            near_lift = int(near_lifts[step_idx])
            far_lift = int(far_lifts[step_idx])

        def draw_pose(
            hip: tuple[int, int],
            knee: tuple[int, int],
            foot: tuple[int, int],
            lift: int,
            *,
            col: tuple[int, int, int],
        ) -> None:
            if int(lift) <= 0:
                draw_straight_leg(int(hip[0]), int(foot[0]), int(foot[1]), leg_top=int(hip[1]), leg_col=col)
                return
            draw_leg(
                int(hip[0]),
                int(knee[0]),
                int(foot[0]),
                int(foot[1]),
                leg_top=int(hip[1]),
                knee_y=int(knee[1]),
                leg_col=col,
            )

        # Depth + shading: whichever leg is in front gets the lighter pants
        # color so the "cross" reads clearly.
        if int(r_foot[0]) >= int(l_foot[0]):
            # Near (right) leg in front.
            draw_pose(l_hip, l_knee, l_foot, int(far_lift), col=pants_dark)
            draw_pose(r_hip, r_knee, r_foot, int(near_lift), col=pants)
        else:
            # Far (left) leg crosses in front.
            draw_pose(r_hip, r_knee, r_foot, int(near_lift), col=pants_dark)
            draw_pose(l_hip, l_knee, l_foot, int(far_lift), col=pants)

        surf.fill(coat, pygame.Rect(4, 5, 5, 6))
        surf.fill(coat_dark, pygame.Rect(4, 10, 5, 1))
        surf.fill(coat, pygame.Rect(8, 6, 1, 3))
        surf.fill(skin, pygame.Rect(8, 9, 1, 1))

        if outfit_kind == 2:
            surf.fill(coat_dark, pygame.Rect(5, 7, 2, 2))
        elif outfit_kind == 3:
            for y in (6, 8, 10):
                surf.fill(pants_dark, pygame.Rect(4, y, 5, 1))
        elif outfit_kind == 4:
            surf.fill((210, 70, 80), pygame.Rect(6, 7, 1, 3))
            surf.fill((210, 70, 80), pygame.Rect(5, 8, 3, 1))

        draw_hair_right()
        draw_face_right()
        return surf

    @classmethod
    def build_avatar_player_frames(cls, avatar: SurvivalAvatar, *, run: bool = False) -> dict[str, list[pygame.Surface]]:
        avatar = avatar or SurvivalAvatar()
        avatar.clamp_all()

        down = [cls._make_avatar_player_sprite("down", 0, idle=True, avatar=avatar, run=bool(run))]
        for i in range(6):
            down.append(cls._make_avatar_player_sprite("down", i, idle=False, avatar=avatar, run=bool(run)))

        up = [cls._make_avatar_player_sprite("up", 0, idle=True, avatar=avatar, run=bool(run))]
        for i in range(6):
            up.append(cls._make_avatar_player_sprite("up", i, idle=False, avatar=avatar, run=bool(run)))

        right = [cls._make_avatar_player_sprite("right", 0, idle=True, avatar=avatar, run=bool(run))]
        for i in range(6):
            right.append(cls._make_avatar_player_sprite("right", i, idle=False, avatar=avatar, run=bool(run)))

        left: list[pygame.Surface] = []
        for s in right:
            left.append(pygame.transform.flip(s, True, False))

        return {"down": down, "up": up, "right": right, "left": left}

    @classmethod
    def _make_avatar_pose_sit_sprite(cls, direction: str, *, avatar: SurvivalAvatar) -> pygame.Surface:
        avatar = avatar or SurvivalAvatar()
        avatar.clamp_all()
        direction = str(direction)
        if direction == "left":
            return pygame.transform.flip(cls._make_avatar_pose_sit_sprite("right", avatar=avatar), True, False)

        w, h = 12, 16
        surf = pygame.Surface((w, h), pygame.SRCALPHA)
        cols = cls._avatar_colors(avatar)
        hair = cols["hair"]
        skin = cols["skin"]
        coat = cols["coat"]
        coat_dark = cols["coat_dark"]
        pants = cols["pants"]
        pants_dark = cols["pants_dark"]
        boots = cols["boots"]
        eye = cols["eye"]
        outline = (10, 10, 12)

        def px(x: int, y: int, c: tuple[int, int, int]) -> None:
            if 0 <= x < w and 0 <= y < h:
                surf.set_at((int(x), int(y)), c)

        def rect(x: int, y: int, rw: int, rh: int, c: tuple[int, int, int]) -> None:
            if rw <= 0 or rh <= 0:
                return
            surf.fill(c, pygame.Rect(int(x), int(y), int(rw), int(rh)))

        if direction in ("down", "up"):
            # Head + hair.
            rect(4, 0, 4, 2, hair)
            rect(4, 2, 4, 3, skin)
            if direction == "down":
                px(5, 3, eye)
                px(6, 3, eye)
            else:
                px(5, 2, hair)
                px(6, 2, hair)

            # Torso.
            rect(4, 5, 4, 4, coat)
            rect(4, 9, 4, 1, coat_dark)
            rect(3, 6, 1, 3, coat_dark)
            rect(8, 6, 1, 3, coat_dark)

            # Sitting legs (bent).
            rect(4, 10, 4, 1, pants)
            rect(4, 11, 4, 1, pants_dark)
            rect(5, 12, 2, 1, pants)
            rect(4, 13, 2, 1, boots)
            rect(6, 13, 2, 1, boots)

            pygame.draw.rect(surf, outline, pygame.Rect(3, 0, 6, 14), 1)
        else:
            # Right-facing sit pose.
            rect(4, 0, 4, 2, hair)
            rect(6, 2, 3, 3, skin)
            px(8, 3, eye)
            rect(4, 5, 5, 4, coat)
            rect(4, 9, 5, 1, coat_dark)
            rect(4, 6, 1, 3, coat_dark)
            rect(8, 6, 1, 3, coat_dark)

            rect(5, 10, 4, 1, pants)
            rect(6, 11, 3, 1, pants_dark)
            rect(7, 12, 2, 1, pants)
            rect(8, 13, 2, 1, boots)
            pygame.draw.rect(surf, outline, pygame.Rect(3, 0, 7, 14), 1)

        return surf

    @classmethod
    def _make_avatar_pose_sleep_sprite(cls, frame: int, *, avatar: SurvivalAvatar) -> pygame.Surface:
        avatar = avatar or SurvivalAvatar()
        avatar.clamp_all()
        w, h = 16, 12
        surf = pygame.Surface((w, h), pygame.SRCALPHA)
        cols = cls._avatar_colors(avatar)
        hair = cols["hair"]
        skin = cols["skin"]
        coat = cols["coat"]
        coat_dark = cols["coat_dark"]
        pants = cols["pants"]
        boots = cols["boots"]
        eye = cols["eye"]
        outline = (10, 10, 12)

        def rect(x: int, y: int, rw: int, rh: int, c: tuple[int, int, int]) -> None:
            if rw <= 0 or rh <= 0:
                return
            surf.fill(c, pygame.Rect(int(x), int(y), int(rw), int(rh)))

        # Head on the left.
        rect(1, 1, 4, 2, hair)
        rect(1, 3, 4, 2, skin)
        surf.set_at((3, 4), eye)

        # Body.
        rect(5, 2, 6, 4, coat)
        rect(5, 6, 6, 1, coat_dark)
        rect(11, 3, 3, 3, pants)
        rect(14, 4, 1, 2, boots)

        # Tiny "breath" highlight.
        if int(frame) % 2 == 0:
            surf.set_at((7, 3), (min(255, coat[0] + 20), min(255, coat[1] + 20), min(255, coat[2] + 20)))
        else:
            surf.set_at((7, 4), (min(255, coat[0] + 20), min(255, coat[1] + 20), min(255, coat[2] + 20)))

        pygame.draw.rect(surf, outline, pygame.Rect(0, 1, 15, 7), 1)
        return surf

    @classmethod
    def _make_avatar_cyclist_sprite(cls, direction: str, frame: int, *, avatar: SurvivalAvatar) -> pygame.Surface:
        avatar.clamp_all()
        w, h = 12, 16
        surf = pygame.Surface((w, h), pygame.SRCALPHA)

        cols = cls._avatar_colors(avatar)
        hair = cols["hair"]
        skin = cols["skin"]
        coat = cols["coat"]
        coat_dark = cols["coat_dark"]
        pants = cols["pants"]
        pants_dark = cols["pants_dark"]
        boots = cols["boots"]
        eye = cols["eye"]
        outline = (10, 10, 12)
        skin_shade = (max(0, skin[0] - 45), max(0, skin[1] - 45), max(0, skin[2] - 45))

        phase = int(frame) % 2
        face_kind = int(avatar.face)
        eye_kind = int(avatar.eyes)
        hair_kind = int(avatar.hair)
        nose_kind = int(avatar.nose)

        def draw_hair_down() -> None:
            if hair_kind == 3:
                hat = coat_dark
                pygame.draw.rect(surf, hat, pygame.Rect(3, 0, 6, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 0, 6, 2), 1, border_radius=1)
                pygame.draw.rect(surf, hat, pygame.Rect(3, 2, 5, 1), border_radius=1)
                return
            surf.fill(hair, pygame.Rect(4, 0, 4, 2))
            if hair_kind == 1:
                surf.set_at((5, 2), hair)
                surf.set_at((6, 2), hair)
            elif hair_kind == 2:
                for (x, y) in ((3, 2), (8, 2), (3, 3), (8, 3), (3, 4), (8, 4)):
                    surf.set_at((x, y), hair)

        def draw_face_down() -> None:
            if face_kind == 0:
                surf.fill(skin, pygame.Rect(4, 2, 4, 3))
            elif face_kind == 1:
                surf.fill(skin, pygame.Rect(4, 2, 4, 3))
                surf.fill(skin, pygame.Rect(3, 3, 1, 2))
                surf.fill(skin, pygame.Rect(8, 3, 1, 2))
            else:
                surf.fill(skin, pygame.Rect(4, 2, 4, 2))
                surf.fill(skin, pygame.Rect(5, 4, 2, 1))

            if eye_kind == 1:
                surf.set_at((5, 3), eye)
                surf.set_at((5, 4), eye)
                surf.set_at((6, 3), eye)
                surf.set_at((6, 4), eye)
            elif eye_kind == 2:
                surf.set_at((5, 3), eye)
                surf.set_at((6, 3), eye)
                surf.set_at((5, 2), outline)
                surf.set_at((6, 2), outline)
            elif eye_kind == 3:
                surf.set_at((5, 3), outline)
                surf.set_at((6, 3), outline)
            else:
                surf.set_at((5, 3), eye)
                surf.set_at((6, 3), eye)

            if nose_kind == 1:
                surf.set_at((5, 4), skin_shade)
            elif nose_kind == 2:
                surf.set_at((5, 4), skin_shade)
                surf.set_at((6, 4), skin_shade)

        def draw_hair_right() -> None:
            if hair_kind == 3:
                hat = coat_dark
                pygame.draw.rect(surf, hat, pygame.Rect(3, 0, 7, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 0, 7, 2), 1, border_radius=1)
                pygame.draw.rect(surf, hat, pygame.Rect(4, 2, 5, 1), border_radius=1)
                return
            surf.fill(hair, pygame.Rect(4, 0, 4, 2))
            if hair_kind == 1:
                surf.set_at((7, 2), hair)
            elif hair_kind == 2:
                for (x, y) in ((4, 2), (4, 3), (4, 4)):
                    surf.set_at((x, y), hair)

        def draw_face_right() -> None:
            if face_kind == 0:
                surf.fill(skin, pygame.Rect(6, 2, 3, 3))
            elif face_kind == 1:
                surf.fill(skin, pygame.Rect(6, 2, 3, 3))
                surf.fill(skin, pygame.Rect(5, 3, 1, 2))
            else:
                surf.fill(skin, pygame.Rect(6, 2, 3, 2))
                surf.fill(skin, pygame.Rect(7, 4, 1, 1))

            if eye_kind == 1:
                surf.set_at((8, 3), eye)
                surf.set_at((8, 4), eye)
            elif eye_kind == 2:
                surf.set_at((8, 3), eye)
                surf.set_at((8, 2), outline)
            elif eye_kind == 3:
                surf.set_at((8, 3), outline)
            else:
                surf.set_at((8, 3), eye)

            if nose_kind == 1:
                surf.set_at((7, 4), skin_shade)
            elif nose_kind == 2:
                surf.set_at((7, 4), skin_shade)
                surf.set_at((8, 4), skin_shade)

        def draw_leg(x: int, y0: int, y1: int, *, col: tuple[int, int, int]) -> None:
            x = int(clamp(int(x), 0, w - 1))
            y0 = int(clamp(int(y0), 0, h - 1))
            y1 = int(clamp(int(y1), 0, h - 1))
            if y1 < y0:
                y0, y1 = y1, y0
            for y in range(y0, y1):
                surf.fill(col, pygame.Rect(x, y, 1, 1))
            surf.fill(boots, pygame.Rect(x, y1, 1, 1))

        if direction in ("down", "up"):
            if direction == "down":
                draw_hair_down()
                draw_face_down()
            else:
                surf.fill(hair, pygame.Rect(4, 0, 4, 3))
                surf.fill(skin, pygame.Rect(5, 3, 2, 1))
                if hair_kind == 2:
                    surf.set_at((3, 3), hair)
                    surf.set_at((8, 3), hair)

            surf.fill(coat, pygame.Rect(3, 5, 6, 5))
            surf.fill(coat_dark, pygame.Rect(4, 7, 4, 3))
            surf.fill(coat, pygame.Rect(2, 6, 1, 2))
            surf.fill(coat, pygame.Rect(9, 6, 1, 2))
            surf.fill(skin, pygame.Rect(2, 8, 1, 1))
            surf.fill(skin, pygame.Rect(9, 8, 1, 1))

            lx = 5
            rx = 6
            if direction == "down":
                l_y = 13 + (0 if phase == 0 else 1)
                r_y = 13 + (1 if phase == 0 else 0)
            else:
                l_y = 14 - (0 if phase == 0 else 1)
                r_y = 14 - (1 if phase == 0 else 0)
            draw_leg(lx, 11, l_y, col=pants)
            draw_leg(rx, 11, r_y, col=pants_dark)
            surf.fill((30, 30, 34), pygame.Rect(4, 10, 4, 1))  # seat hint
            return surf

        # right
        draw_hair_right()
        draw_face_right()
        surf.fill(coat, pygame.Rect(4, 5, 5, 5))
        surf.fill(coat_dark, pygame.Rect(4, 9, 5, 1))
        surf.fill(coat, pygame.Rect(8, 6, 2, 1))
        surf.fill(skin, pygame.Rect(9, 7, 1, 1))
        near_shift = 1 if phase == 0 else 0
        far_shift = 0 if phase == 0 else 1
        draw_leg(5 + far_shift, 10, 14, col=pants_dark)
        draw_leg(6 + near_shift, 10, 13, col=pants)
        return surf

    @classmethod
    def build_avatar_cyclist_frames(cls, avatar: SurvivalAvatar) -> dict[str, list[pygame.Surface]]:
        avatar = avatar or SurvivalAvatar()
        avatar.clamp_all()
        down = [cls._make_avatar_cyclist_sprite("down", 0, avatar=avatar), cls._make_avatar_cyclist_sprite("down", 1, avatar=avatar)]
        up = [cls._make_avatar_cyclist_sprite("up", 0, avatar=avatar), cls._make_avatar_cyclist_sprite("up", 1, avatar=avatar)]
        right = [cls._make_avatar_cyclist_sprite("right", 0, avatar=avatar), cls._make_avatar_cyclist_sprite("right", 1, avatar=avatar)]
        left: list[pygame.Surface] = []
        for s in right:
            left.append(pygame.transform.flip(s, True, False))
        return {"down": down, "up": up, "right": right, "left": left}

    _MONSTER_PALS: dict[str, dict[str, tuple[int, int, int]]] = {
        "walker": {
            "skin": (92, 140, 96),
            "cloth": (76, 82, 74),
            "cloth2": (56, 60, 54),
            "pants": (44, 44, 56),
            "boots": (18, 18, 22),
            "eye": (18, 18, 22),
            "blood": (150, 70, 70),
        },
        "runner": {
            "skin": (100, 150, 104),
            "cloth": (140, 70, 70),
            "cloth2": (108, 52, 54),
            "pants": (40, 40, 50),
            "boots": (18, 18, 22),
            "eye": (18, 18, 22),
            "blood": (160, 76, 76),
        },
        "screamer": {
            "skin": (170, 170, 182),
            "cloth": (110, 80, 140),
            "cloth2": (78, 56, 104),
            "pants": (40, 40, 50),
            "boots": (18, 18, 22),
            "eye": (18, 18, 22),
            "blood": (170, 80, 90),
        },
    }

    def _make_monster_sprite(
        kind: str,
        direction: str,
        step: int,
        *,
        idle: bool,
        pals: dict[str, dict[str, tuple[int, int, int]]] = _MONSTER_PALS,
    ) -> pygame.Surface:
        w, h = 12, 16
        surf = pygame.Surface((w, h), pygame.SRCALPHA)

        pal = pals.get(str(kind), pals["walker"])
        skin = pal["skin"]
        cloth = pal["cloth"]
        cloth2 = pal["cloth2"]
        pants = pal["pants"]
        boots = pal["boots"]
        eye = pal["eye"]
        blood = pal["blood"]
        outline = (10, 10, 12)

        def shade(col: tuple[int, int, int], k: float) -> tuple[int, int, int]:
            return (
                int(clamp(float(col[0]) * float(k), 0.0, 255.0)),
                int(clamp(float(col[1]) * float(k), 0.0, 255.0)),
                int(clamp(float(col[2]) * float(k), 0.0, 255.0)),
            )

        pants_far = shade(pants, 0.72)
        boots_far = shade(boots, 0.72)

        step = int(step) % 2
        if idle:
            step = 0

        stride = 1 if step == 0 else -1

        def draw_leg(
            hip_x: int,
            knee_x: int,
            boot_x: int,
            boot_y: int,
            *,
            col: tuple[int, int, int],
            boot_col: tuple[int, int, int] | None = None,
        ) -> None:
            hip_x = int(clamp(int(hip_x), 0, w - 1))
            knee_x = int(clamp(int(knee_x), 0, w - 1))
            boot_x = int(clamp(int(boot_x), 0, w - 1))
            boot_y = int(clamp(int(boot_y), 0, h - 1))
            leg_top = 10
            knee_y = 13
            for y in range(leg_top, knee_y):
                surf.fill(col, pygame.Rect(hip_x, y, 1, 1))
            x0 = min(hip_x, knee_x)
            x1 = max(hip_x, knee_x)
            for x in range(x0, x1 + 1):
                surf.fill(col, pygame.Rect(x, knee_y, 1, 1))
            for y in range(knee_y, boot_y):
                surf.fill(col, pygame.Rect(knee_x, y, 1, 1))
            surf.fill((boots if boot_col is None else boot_col), pygame.Rect(boot_x, boot_y, 1, 1))

        if direction in ("down", "up"):
            left_hip = 4
            right_hip = 7
            left_boot_x = left_hip
            right_boot_x = right_hip
            if kind in ("walker", "screamer"):
                # Zombie shuffle: one leg "scuffs" forward with a bent knee, the other drags.
                lift = (1 if kind == "walker" else 2) if not idle else 0
                bend = (1 if kind == "walker" else 2) if not idle else 0
                if step == 0:
                    left_boot_y = 15 - lift
                    right_boot_y = 15
                    left_knee_x = left_hip + bend
                    right_knee_x = right_hip
                else:
                    left_boot_y = 15
                    right_boot_y = 15 - lift
                    left_knee_x = left_hip
                    right_knee_x = right_hip - bend
                left_boot_x = left_knee_x
                right_boot_x = right_knee_x
            else:
                left_boot_y = 15 - (1 if stride > 0 else 0)
                right_boot_y = 15 - (1 if stride < 0 else 0)
                left_knee_x = left_hip + stride
                right_knee_x = right_hip - stride
                left_boot_x = left_knee_x
                right_boot_x = right_knee_x

            # Legs behind torso.
            draw_leg(
                right_hip,
                right_knee_x,
                right_boot_x,
                right_boot_y,
                col=pants_far,
                boot_col=boots_far,
            )
            draw_leg(left_hip, left_knee_x, left_boot_x, left_boot_y, col=pants, boot_col=boots)

            # Torso + arms.
            torso_y = 6 if kind in ("walker", "screamer") else 5
            surf.fill(cloth, pygame.Rect(3, torso_y, 6, 6))
            surf.fill(cloth2, pygame.Rect(3, torso_y + 5, 6, 1))
            if kind == "walker":
                arm_y = torso_y
                reach = 4 if not idle else 3
                if direction == "down":
                    y0 = arm_y + (0 if stride > 0 else 1)
                else:
                    y0 = max(0, arm_y - reach - (0 if stride > 0 else 1))
                for ax in (3, 8):
                    surf.fill(skin, pygame.Rect(ax, y0, 1, reach))
                    surf.fill(skin, pygame.Rect(ax, y0 + reach, 1, 1))
                # Sleeves.
                surf.fill(cloth, pygame.Rect(3, arm_y, 1, 1))
                surf.fill(cloth, pygame.Rect(8, arm_y, 1, 1))
            else:
                arm_y = 6 if kind != "runner" else 5
                surf.fill(cloth, pygame.Rect(2, arm_y, 1, 3))
                surf.fill(cloth, pygame.Rect(9, arm_y, 1, 3))
                if kind == "screamer":
                    surf.fill(cloth, pygame.Rect(1, arm_y - 1, 1, 3))
                    surf.fill(cloth, pygame.Rect(10, arm_y - 1, 1, 3))

            # Head / face.
            head_y = 2 if kind in ("walker", "screamer") else 1
            if direction == "down":
                surf.fill(skin, pygame.Rect(4, head_y, 4, 4))
                surf.fill(outline, pygame.Rect(4, head_y, 4, 4), 1)
                surf.set_at((5, head_y + 2), eye)
                surf.set_at((6, head_y + 2), eye)
                if kind == "screamer":
                    surf.fill(blood, pygame.Rect(5, head_y + 3, 2, 1))
                else:
                    surf.set_at((6, head_y + 3), blood if kind == "runner" else outline)
            else:
                surf.fill(skin, pygame.Rect(4, head_y, 4, 4))
                surf.fill(outline, pygame.Rect(4, head_y, 4, 4), 1)
                surf.fill(cloth2, pygame.Rect(4, head_y, 4, 2))

            return surf

        # right / left (build right, flip elsewhere)
        # Legs.
        far_hip = 4
        near_hip = 7
        if kind in ("walker", "screamer"):
            lift = (1 if kind == "walker" else 2) if not idle else 0
            bend = (1 if kind == "walker" else 2) if not idle else 0
            far_knee_x = far_hip + (bend if step == 1 else 0)
            near_knee_x = near_hip - (bend if step == 0 else 0)
            near_boot_y = 15 - (lift if step == 0 else 0)
            far_boot_y = 15 - (lift if step == 1 else 0)
            draw_leg(far_hip, far_knee_x, far_knee_x, far_boot_y, col=pants_far, boot_col=boots_far)
            draw_leg(near_hip, near_knee_x, near_knee_x, near_boot_y, col=pants, boot_col=boots)
        else:
            near_dx = 1 if stride > 0 else -1
            far_dx = -near_dx
            near_boot_y = 15 - (1 if stride > 0 else 0)
            far_boot_y = 15 - (1 if stride < 0 else 0)
            draw_leg(far_hip, far_hip + far_dx, far_hip + far_dx, far_boot_y, col=pants_far, boot_col=boots_far)
            draw_leg(near_hip, near_hip + near_dx, near_hip + near_dx, near_boot_y, col=pants, boot_col=boots)

        # Body.
        body_y = 4 if kind == "runner" else 6 if kind in ("walker", "screamer") else 5
        surf.fill(cloth, pygame.Rect(4, body_y, 5, 7))
        surf.fill(cloth2, pygame.Rect(4, body_y + 5, 5, 1))
        # Arm / reach.
        if kind == "runner":
            surf.fill(cloth, pygame.Rect(8, body_y + 1, 3, 2))
            surf.fill(blood, pygame.Rect(10, body_y + 2, 1, 1))
        elif kind == "screamer":
            surf.fill(cloth, pygame.Rect(8, body_y, 3, 3))
            surf.fill(cloth, pygame.Rect(8, body_y + 3, 2, 2))
        else:
            # Walker: two forward-reaching arms (zombie style).
            arm_y0 = body_y + 2 + (0 if stride > 0 else 1)
            arm_y1 = body_y + 4 + (1 if stride > 0 else 0)
            ext0 = 4 if not idle else 3
            ext1 = 3 if not idle else 2
            surf.fill(skin, pygame.Rect(8, arm_y0, ext0, 1))
            surf.fill(skin, pygame.Rect(9, arm_y0 + 1, max(1, ext0 - 1), 1))
            surf.fill(skin, pygame.Rect(8, arm_y1, ext1, 1))
            surf.fill(skin, pygame.Rect(9, arm_y1 + 1, max(1, ext1 - 1), 1))
            # Sleeve pixel near torso.
            surf.fill(cloth, pygame.Rect(8, body_y + 2, 1, 1))

        # Head.
        head_y = 2 if kind in ("walker", "screamer") else 1
        surf.fill(skin, pygame.Rect(6, head_y, 4, 4))
        surf.fill(outline, pygame.Rect(6, head_y, 4, 4), 1)
        surf.set_at((9, head_y + 2), eye)
        if kind == "screamer":
            surf.fill(blood, pygame.Rect(8, head_y + 3, 2, 1))
        else:
            surf.set_at((9, head_y + 3), blood if kind == "runner" else outline)
        return surf

    _MONSTER_FRAMES: dict[str, dict[str, list[pygame.Surface]]] = {}
    for _kind in ("walker", "runner", "screamer"):
        _down = [
            _make_monster_sprite(_kind, "down", 0, idle=True),
            _make_monster_sprite(_kind, "down", 0, idle=False),
            _make_monster_sprite(_kind, "down", 1, idle=False),
        ]
        _up = [
            _make_monster_sprite(_kind, "up", 0, idle=True),
            _make_monster_sprite(_kind, "up", 0, idle=False),
            _make_monster_sprite(_kind, "up", 1, idle=False),
        ]
        _right = [
            _make_monster_sprite(_kind, "right", 0, idle=True),
            _make_monster_sprite(_kind, "right", 0, idle=False),
            _make_monster_sprite(_kind, "right", 1, idle=False),
        ]
        _left: list[pygame.Surface] = []
        for _spr in _right:
            _left.append(pygame.transform.flip(_spr, True, False))
        _MONSTER_FRAMES[_kind] = {"down": _down, "up": _up, "right": _right, "left": _left}

    @dataclass(frozen=True)
    class _CarModel:
        id: str
        name: str
        sprite_size: tuple[int, int]
        collider: tuple[int, int]
        wheelbase: float
        max_fwd: float
        max_rev: float
        accel: float
        brake: float
        fuel_per_px: float
        steer_max: float = 0.62
        # Optional tighter collision box while driving (px).
        # Use this when the visual/footprint collider is intentionally large (e.g. RV interior stamping),
        # but driving would feel "stuck" in dense city streets/building facades.
        drive_collider: tuple[int, int] | None = None

    _CAR_MODELS: dict[str, _CarModel] = {
        "rv": _CarModel(
            id="rv",
            name="",
            # Larger RV so it can contain a small walkable interior space (world camera mode).
            sprite_size=(90, 40),
            collider=(90, 40),
            # City roads are 5 tiles wide (+1 tile sidewalk each side). A 9-tile-wide RV footprint
            # tends to constantly collide with adjacent building facades, making it feel immobile.
            # Keep the big footprint for RV interior stamping, but drive with a tighter box.
            # NOTE: Must be <= 5 tiles wide (<= 50px) to reliably move on the main road grid.
            drive_collider=(46, 24),
            wheelbase=30.0,
            max_fwd=105.0,
            max_rev=38.0,
            accel=165.0,
            brake=320.0,
            fuel_per_px=0.022,
            steer_max=0.52,
        ),
        "beetle": _CarModel(
            id="beetle",
            name="()",
            sprite_size=(32, 22),
            collider=(22, 14),
            wheelbase=18.0,
            max_fwd=115.0,
            max_rev=48.0,
            accel=190.0,
            brake=320.0,
            fuel_per_px=0.012,
        ),
        "porsche": _CarModel(
            id="porsche",
            name="()",
            sprite_size=(36, 18),
            collider=(26, 12),
            wheelbase=20.0,
            max_fwd=150.0,
            max_rev=55.0,
            accel=240.0,
            brake=380.0,
            fuel_per_px=0.014,
        ),
        "truck": _CarModel(
            id="truck",
            name="",
            sprite_size=(44, 20),
            collider=(30, 14),
            wheelbase=26.0,
            max_fwd=110.0,
            max_rev=44.0,
            accel=175.0,
            brake=320.0,
            fuel_per_px=0.018,
        ),
        "schoolbus": _CarModel(
            id="schoolbus",
            name="",
            sprite_size=(50, 20),
            collider=(34, 14),
            wheelbase=30.0,
            max_fwd=105.0,
            max_rev=40.0,
            accel=165.0,
            brake=310.0,
            fuel_per_px=0.020,
        ),
        "lamborghini": _CarModel(
            id="lamborghini",
            name="()",
            sprite_size=(36, 18),
            collider=(26, 12),
            wheelbase=20.0,
            max_fwd=165.0,
            max_rev=58.0,
            accel=260.0,
            brake=400.0,
            fuel_per_px=0.016,
        ),
        "mercedes": _CarModel(
            id="mercedes",
            name="()",
            sprite_size=(38, 18),
            collider=(28, 12),
            wheelbase=22.0,
            max_fwd=135.0,
            max_rev=52.0,
            accel=220.0,
            brake=360.0,
            fuel_per_px=0.015,
        ),
        "police": _CarModel(
            id="police",
            name="",
            sprite_size=(38, 18),
            collider=(28, 12),
            wheelbase=22.0,
            max_fwd=145.0,
            max_rev=52.0,
            accel=235.0,
            brake=380.0,
            fuel_per_px=0.015,
        ),
    }

    def _draw_wheel(
        surf: pygame.Surface,
        cx: int,
        cy: int,
        *,
        r: int,
        frame: int,
        outline: tuple[int, int, int],
        steer_state: int = 0,
        is_front: bool = False,
    ) -> None:
        # Top-down wheel: compact contact patch with a steer hint (MiniDayZ-like feel,
        # but original art).
        r = max(1, int(r))
        cx = int(cx)
        cy = int(cy)
        steer_state = int(clamp(int(steer_state), -1, 1))

        tire = (14, 14, 18)
        rim = (64, 64, 76)
        hi = (44, 44, 54)

        length = max(5, int(r * 3))
        thickness = max(2, int(r))
        half_l = int(length // 2)
        half_t = int(thickness // 2)
        br = max(1, int(min(length, thickness) // 2))

        def draw_patch(rect: pygame.Rect) -> None:
            pygame.draw.rect(surf, tire, rect, border_radius=br)
            inner = rect.inflate(-2, -2)
            if inner.w > 0 and inner.h > 0:
                pygame.draw.rect(surf, rim, inner, border_radius=max(1, int(min(inner.w, inner.h) // 2)))
            # Spinning hint.
            if int(frame) % 2 == 0:
                pygame.draw.line(surf, hi, (rect.left + 1, rect.centery), (rect.right - 2, rect.centery), 1)
            else:
                pygame.draw.line(surf, hi, (rect.centerx, rect.top + 1), (rect.centerx, rect.bottom - 2), 1)
            pygame.draw.rect(surf, outline, rect, 1, border_radius=br)

        if is_front and steer_state != 0:
            # A simple slanted patch to imply steering.
            sl = 2 if r >= 3 else 1
            sl *= 1 if steer_state > 0 else -1
            pts = [
                (cx - half_l + sl, cy - half_t),
                (cx + half_l + sl, cy - half_t),
                (cx + half_l - sl, cy + half_t),
                (cx - half_l - sl, cy + half_t),
            ]
            pygame.draw.polygon(surf, tire, pts)
            ipts = [
                (cx - max(1, half_l - 2) + sl, cy - max(0, half_t - 1)),
                (cx + max(1, half_l - 2) + sl, cy - max(0, half_t - 1)),
                (cx + max(1, half_l - 2) - sl, cy + max(0, half_t - 1)),
                (cx - max(1, half_l - 2) - sl, cy + max(0, half_t - 1)),
            ]
            pygame.draw.polygon(surf, rim, ipts)
            pygame.draw.polygon(surf, outline, pts, 1)
            # Steer direction accent.
            if steer_state > 0:
                pygame.draw.line(surf, hi, (cx + half_l - 1, cy - half_t), (cx + half_l - 3, cy + half_t), 1)
            else:
                pygame.draw.line(surf, hi, (cx - half_l + 1, cy - half_t), (cx - half_l + 3, cy + half_t), 1)
            return

        rect = pygame.Rect(int(cx - half_l), int(cy - half_t), int(length), int(thickness))
        draw_patch(rect)

    def _make_car_base(
        model_id: str,
        frame: int,
        steer_state: int,
        _car_models: dict[str, "HardcoreSurvivalState._CarModel"] = _CAR_MODELS,
        _draw_wheel_fn: Callable[..., None] = _draw_wheel,
    ) -> pygame.Surface:
        model = _car_models.get(str(model_id))
        if model is None:
            model = _car_models["beetle"]
        w, h = int(model.sprite_size[0]), int(model.sprite_size[1])
        surf = pygame.Surface((w, h), pygame.SRCALPHA)

        outline = (12, 12, 16)
        glass = (120, 140, 160)
        glass2 = (160, 180, 200)
        light = (255, 230, 150)
        tail = (255, 110, 110)

        steer_state = int(clamp(int(steer_state), -1, 1))

        def tint(c: tuple[int, int, int], add: tuple[int, int, int]) -> tuple[int, int, int]:
            return (
                int(clamp(int(c[0]) + int(add[0]), 0, 255)),
                int(clamp(int(c[1]) + int(add[1]), 0, 255)),
                int(clamp(int(c[2]) + int(add[2]), 0, 255)),
            )

        wheel_centers: list[tuple[int, int]] = []
        wheel_r = 3

        if model.id == "rv":
            body = (236, 236, 242)
            body2 = tint(body, (-30, -30, -32))
            body3 = tint(body, (10, 10, 12))
            stripe = (210, 120, 80)

            shell = pygame.Rect(2, 3, w - 4, h - 6)
            coach = pygame.Rect(shell.x, shell.y, shell.w - 18, shell.h)
            cab_left = int(coach.right - 2)
            cab_top = int(shell.y + 2)
            cab_bottom = int(shell.bottom - 3)
            front = int(shell.right - 1)
            midy = int((cab_top + cab_bottom) // 2)

            pygame.draw.rect(surf, body, coach, border_radius=4)
            pygame.draw.rect(surf, outline, coach, 2, border_radius=4)
            # Rear bumper + ladder hint.
            pygame.draw.rect(surf, body2, pygame.Rect(coach.x + 1, coach.y + 1, 3, coach.h - 2), border_radius=2)
            pygame.draw.line(surf, outline, (coach.x + 3, coach.y + 3), (coach.x + 3, coach.bottom - 4), 1)
            pygame.draw.line(surf, outline, (coach.x + 2, coach.y + 5), (coach.x + 4, coach.y + 5), 1)
            pygame.draw.line(surf, outline, (coach.x + 2, coach.y + 8), (coach.x + 4, coach.y + 8), 1)

            # Roof on the coach.
            roof = pygame.Rect(coach.x + 6, coach.y + 2, coach.w - 14, coach.h - 4)
            pygame.draw.rect(surf, body3, roof, border_radius=3)
            pygame.draw.rect(surf, outline, roof, 1, border_radius=3)
            pygame.draw.rect(surf, tint(body, (-10, -10, -10)), pygame.Rect(roof.x + 8, roof.y + 2, 6, 3), border_radius=1)  # vent
            pygame.draw.rect(surf, tint(body, (-10, -10, -10)), pygame.Rect(roof.right - 12, roof.y + 2, 8, 3), border_radius=1)  # AC

            # Side windows (coach).
            wx0 = coach.x + 10
            for i in range(4):
                rwin = pygame.Rect(wx0 + i * 8, coach.y + 3, 6, 4)
                pygame.draw.rect(surf, glass, rwin, border_radius=2)
                pygame.draw.rect(surf, outline, rwin, 1, border_radius=2)

            # Cab (tapered nose).
            cab_poly = [
                (cab_left, cab_top),
                (front - 3, cab_top + 1),
                (front, midy),
                (front - 3, cab_bottom - 1),
                (cab_left, cab_bottom),
            ]
            pygame.draw.polygon(surf, body2, cab_poly)
            pygame.draw.polygon(surf, outline, cab_poly, 1)
            # Windshield.
            wind = [
                (front - 8, cab_top + 2),
                (front - 2, cab_top + 3),
                (front - 2, cab_bottom - 3),
                (front - 8, cab_bottom - 2),
            ]
            pygame.draw.polygon(surf, glass, wind)
            pygame.draw.polygon(surf, outline, wind, 1)
            pygame.draw.line(surf, glass2, (front - 7, cab_top + 3), (front - 3, cab_top + 3), 1)

            # Side stripe + door hint.
            pygame.draw.rect(surf, stripe, pygame.Rect(coach.x + 6, coach.bottom - 5, coach.w + 6, 2), border_radius=1)
            door_x = int(coach.right - 10)
            pygame.draw.line(surf, outline, (door_x, coach.y + 4), (door_x, coach.bottom - 5), 1)
            pygame.draw.circle(surf, outline, (door_x + 2, midy + 2), 1)

            # Lights.
            pygame.draw.circle(surf, light, (front, cab_top + 2), 1)
            pygame.draw.circle(surf, light, (front, cab_bottom - 2), 1)
            pygame.draw.circle(surf, tail, (coach.x + 1, coach.y + 2), 1)
            pygame.draw.circle(surf, tail, (coach.x + 1, coach.bottom - 3), 1)

            y_top = int(shell.y + 1)
            y_bottom = int(shell.bottom - 2)
            wheel_centers = [(12, y_top), (12, y_bottom), (w - 10, y_top), (w - 10, y_bottom)]
            wheel_r = 3
        elif model.id == "beetle":
            body = (84, 170, 190)
            body2 = tint(body, (-22, -22, -18))
            shell = pygame.Rect(3, 4, w - 6, h - 8)
            pygame.draw.rect(surf, body, shell, border_radius=10)
            pygame.draw.rect(surf, outline, shell, 2, border_radius=10)
            roof = pygame.Rect(shell.x + 9, shell.y + 2, shell.w - 18, shell.h - 4)
            pygame.draw.rect(surf, body2, roof, border_radius=8)
            win = roof.inflate(-2, -2)
            pygame.draw.rect(surf, glass, win, border_radius=7)
            pygame.draw.rect(surf, outline, win, 1, border_radius=7)
            pygame.draw.line(surf, outline, (shell.x + 7, shell.y + 2), (shell.x + 7, shell.bottom - 3), 1)
            pygame.draw.line(surf, outline, (shell.right - 8, shell.y + 2), (shell.right - 8, shell.bottom - 3), 1)
            pygame.draw.circle(surf, light, (w - 4, h // 2 - 3), 1)
            pygame.draw.circle(surf, light, (w - 4, h // 2 + 3), 1)
            pygame.draw.circle(surf, tail, (3, h // 2 - 3), 1)
            pygame.draw.circle(surf, tail, (3, h // 2 + 3), 1)
            y_top = 4
            y_bottom = h - 5
            wheel_centers = [(7, y_top), (7, y_bottom), (w - 7, y_top), (w - 7, y_bottom)]
            wheel_r = 3
        elif model.id == "porsche":
            body = (220, 80, 80)
            body2 = tint(body, (-40, -32, -32))
            shell = pygame.Rect(3, 4, w - 6, h - 8)
            pygame.draw.rect(surf, body, shell, border_radius=6)
            pygame.draw.rect(surf, outline, shell, 2, border_radius=6)
            hood = pygame.Rect(shell.right - 14, shell.y + 1, 10, shell.h - 2)
            pygame.draw.rect(surf, body2, hood, border_radius=5)
            roof = pygame.Rect(shell.x + 12, shell.y + 2, shell.w - 26, shell.h - 4)
            pygame.draw.rect(surf, tint(body, (-12, -12, -12)), roof, border_radius=4)
            win = roof.inflate(-2, -2)
            pygame.draw.rect(surf, glass, win, border_radius=3)
            pygame.draw.rect(surf, outline, win, 1, border_radius=3)
            pygame.draw.line(surf, glass2, (win.x + 2, win.y + 2), (win.right - 3, win.y + 2), 1)
            pygame.draw.circle(surf, light, (w - 4, 6), 1)
            pygame.draw.circle(surf, light, (w - 4, h - 7), 1)
            pygame.draw.circle(surf, tail, (3, 6), 1)
            pygame.draw.circle(surf, tail, (3, h - 7), 1)
            y_top = 4
            y_bottom = h - 5
            wheel_centers = [(9, y_top), (9, y_bottom), (w - 7, y_top), (w - 7, y_bottom)]
            wheel_r = 2
        elif model.id == "lamborghini":
            body = (86, 190, 96)
            body2 = tint(body, (-28, -38, -28))
            shell = pygame.Rect(3, 4, w - 6, h - 8)
            pygame.draw.rect(surf, body, shell, border_radius=4)
            pygame.draw.rect(surf, outline, shell, 2, border_radius=4)
            # Wedge nose.
            pygame.draw.polygon(surf, body2, [(w - 4, h // 2), (w - 14, shell.y + 1), (w - 14, shell.bottom - 2)])
            # Engine cover vents.
            eng = pygame.Rect(shell.x + 4, shell.y + 2, 10, shell.h - 4)
            pygame.draw.rect(surf, body2, eng, border_radius=2)
            for y in range(eng.y + 1, eng.bottom - 1, 2):
                pygame.draw.line(surf, outline, (eng.x + 1, y), (eng.right - 2, y), 1)
            roof = pygame.Rect(shell.x + 14, shell.y + 2, shell.w - 28, shell.h - 4)
            pygame.draw.polygon(
                surf,
                glass,
                [(roof.x, roof.y + 1), (roof.right, roof.y + 2), (roof.right - 2, roof.bottom - 2), (roof.x + 2, roof.bottom - 1)],
            )
            pygame.draw.polygon(
                surf,
                outline,
                [(roof.x, roof.y + 1), (roof.right, roof.y + 2), (roof.right - 2, roof.bottom - 2), (roof.x + 2, roof.bottom - 1)],
                1,
            )
            pygame.draw.circle(surf, light, (w - 4, 6), 1)
            pygame.draw.circle(surf, light, (w - 4, h - 7), 1)
            pygame.draw.circle(surf, tail, (3, 6), 1)
            pygame.draw.circle(surf, tail, (3, h - 7), 1)
            y_top = 4
            y_bottom = h - 5
            wheel_centers = [(9, y_top), (9, y_bottom), (w - 7, y_top), (w - 7, y_bottom)]
            wheel_r = 2
        elif model.id == "mercedes":
            body = (150, 150, 160)
            body2 = tint(body, (-34, -34, -34))
            shell = pygame.Rect(3, 4, w - 6, h - 8)
            pygame.draw.rect(surf, body, shell, border_radius=5)
            pygame.draw.rect(surf, outline, shell, 2, border_radius=5)
            hood = pygame.Rect(shell.right - 15, shell.y + 1, 10, shell.h - 2)
            pygame.draw.rect(surf, body2, hood, border_radius=4)
            roof = pygame.Rect(shell.x + 11, shell.y + 2, shell.w - 24, shell.h - 4)
            pygame.draw.rect(surf, tint(body, (8, 8, 10)), roof, border_radius=4)
            win = roof.inflate(-2, -2)
            pygame.draw.rect(surf, glass, win, border_radius=3)
            pygame.draw.rect(surf, outline, win, 1, border_radius=3)
            pygame.draw.circle(surf, light, (w - 4, 6), 1)
            pygame.draw.circle(surf, light, (w - 4, h - 7), 1)
            pygame.draw.circle(surf, tail, (3, 6), 1)
            pygame.draw.circle(surf, tail, (3, h - 7), 1)
            y_top = 4
            y_bottom = h - 5
            wheel_centers = [(10, y_top), (10, y_bottom), (w - 6, y_top), (w - 6, y_bottom)]
            wheel_r = 2
        elif model.id == "police":
            body = (236, 236, 242)
            body2 = (44, 44, 54)
            shell = pygame.Rect(3, 4, w - 6, h - 8)
            pygame.draw.rect(surf, body, shell, border_radius=5)
            pygame.draw.rect(surf, outline, shell, 2, border_radius=5)
            # Side dark stripe (doors).
            stripe = pygame.Rect(shell.x + 4, shell.y + 5, shell.w - 18, 3)
            pygame.draw.rect(surf, body2, stripe, border_radius=2)
            pygame.draw.rect(surf, outline, stripe, 1, border_radius=2)
            # Hood + roof.
            hood = pygame.Rect(shell.right - 15, shell.y + 1, 10, shell.h - 2)
            pygame.draw.rect(surf, tint(body2, (16, 16, 16)), hood, border_radius=4)
            roof = pygame.Rect(shell.x + 11, shell.y + 2, shell.w - 24, shell.h - 4)
            pygame.draw.rect(surf, tint(body, (6, 6, 8)), roof, border_radius=4)
            win = roof.inflate(-2, -2)
            pygame.draw.rect(surf, glass, win, border_radius=3)
            pygame.draw.rect(surf, outline, win, 1, border_radius=3)
            # Siren lights.
            sir = pygame.Rect(roof.centerx - 3, roof.y - 1, 6, 2)
            pygame.draw.rect(surf, (190, 190, 200), sir, border_radius=1)
            pygame.draw.rect(surf, outline, sir, 1, border_radius=1)
            surf.set_at((sir.x + 1, sir.y), (255, 90, 90))
            surf.set_at((sir.right - 2, sir.y), (90, 160, 255))
            # Lights.
            pygame.draw.circle(surf, light, (w - 4, 6), 1)
            pygame.draw.circle(surf, light, (w - 4, h - 7), 1)
            pygame.draw.circle(surf, tail, (3, 6), 1)
            pygame.draw.circle(surf, tail, (3, h - 7), 1)
            y_top = 4
            y_bottom = h - 5
            wheel_centers = [(10, y_top), (10, y_bottom), (w - 6, y_top), (w - 6, y_bottom)]
            wheel_r = 2
        elif model.id == "truck":
            cab = (220, 220, 230)
            cab2 = tint(cab, (-26, -26, -26))
            bed = (92, 92, 104)
            bed2 = tint(bed, (-22, -22, -22))
            cab_w = 16
            bed_r = pygame.Rect(3, 4, w - cab_w - 5, h - 8)
            pygame.draw.rect(surf, bed, bed_r, border_radius=4)
            pygame.draw.rect(surf, outline, bed_r, 2, border_radius=4)
            pygame.draw.rect(surf, bed2, pygame.Rect(bed_r.x + 1, bed_r.y + bed_r.h - 4, bed_r.w - 2, 2), border_radius=2)
            for x in range(bed_r.x + 3, bed_r.right - 2, 4):
                pygame.draw.line(surf, outline, (x, bed_r.y + 2), (x, bed_r.bottom - 3), 1)
            cab_r = pygame.Rect(w - cab_w - 2, 3, cab_w, h - 6)
            pygame.draw.rect(surf, cab, cab_r, border_radius=4)
            pygame.draw.rect(surf, outline, cab_r, 2, border_radius=4)
            wind = pygame.Rect(cab_r.x + 3, cab_r.y + 3, cab_r.w - 6, 6)
            pygame.draw.rect(surf, glass, wind, border_radius=2)
            pygame.draw.rect(surf, outline, wind, 1, border_radius=2)
            pygame.draw.rect(surf, cab2, pygame.Rect(cab_r.x + 2, cab_r.bottom - 6, cab_r.w - 4, 3), border_radius=2)
            pygame.draw.circle(surf, light, (w - 3, 6), 1)
            pygame.draw.circle(surf, light, (w - 3, h - 7), 1)
            pygame.draw.circle(surf, tail, (3, 6), 1)
            pygame.draw.circle(surf, tail, (3, h - 7), 1)
            y_top = 4
            y_bottom = h - 5
            wheel_centers = [(11, y_top), (11, y_bottom), (w - 7, y_top), (w - 7, y_bottom)]
            wheel_r = 3
        else:
            # schoolbus
            body = (230, 200, 90)
            body2 = tint(body, (-28, -28, -18))
            stripe = (80, 80, 86)
            shell = pygame.Rect(2, 4, w - 4, h - 8)
            pygame.draw.rect(surf, body, shell, border_radius=3)
            pygame.draw.rect(surf, outline, shell, 2, border_radius=3)
            pygame.draw.rect(surf, body2, pygame.Rect(shell.x + 1, shell.y + shell.h - 4, shell.w - 2, 2), border_radius=2)
            pygame.draw.rect(surf, stripe, pygame.Rect(shell.x + 6, shell.bottom - 6, shell.w - 12, 2), border_radius=1)
            wx0 = shell.x + 10
            for i in range(6):
                r = pygame.Rect(wx0 + i * 6, shell.y + 2, 4, 4)
                pygame.draw.rect(surf, glass, r, border_radius=1)
                pygame.draw.rect(surf, outline, r, 1, border_radius=1)
            pygame.draw.line(surf, outline, (w - 16, shell.y + 2), (w - 16, shell.bottom - 3), 1)  # door hint
            pygame.draw.circle(surf, light, (w - 3, shell.y + 2), 1)
            pygame.draw.circle(surf, light, (w - 3, shell.bottom - 3), 1)       
            pygame.draw.circle(surf, tail, (shell.x + 1, shell.y + 2), 1)       
            pygame.draw.circle(surf, tail, (shell.x + 1, shell.bottom - 3), 1)  
            y_top = 4
            y_bottom = h - 5
            wheel_centers = [(12, y_top), (12, y_bottom), (w - 8, y_top), (w - 8, y_bottom)]
            wheel_r = 3

        front_x = max(int(cx) for cx, _ in wheel_centers) - 1 if wheel_centers else (w - 6)
        for cx, cy in wheel_centers:
            is_front = int(cx) >= int(front_x)
            _draw_wheel_fn(
                surf,
                int(cx),
                int(cy),
                r=int(wheel_r),
                frame=int(frame),
                outline=outline,
                steer_state=int(steer_state),
                is_front=is_front,
            )

        return surf

    def _make_shadow(sprite: pygame.Surface, *, alpha: int = 110) -> pygame.Surface:
        w, h = sprite.get_size()
        shadow = pygame.Surface((w, h), pygame.SRCALPHA)
        alpha = int(clamp(int(alpha), 0, 255))
        for y in range(int(h)):
            for x in range(int(w)):
                r, g, b, a = sprite.get_at((x, y))
                if a == 0:
                    continue
                shadow.set_at((x, y), (0, 0, 0, alpha))
        return shadow

    _CAR_BASE: dict[tuple[str, int, int], pygame.Surface] = {}
    _CAR_SHADOW: dict[tuple[str, int, int], pygame.Surface] = {}
    for _mid in _CAR_MODELS:
        for _steer in (-1, 0, 1):
            for _frm in (0, 1):
                _base = _make_car_base(_mid, _frm, _steer)
                _CAR_BASE[(_mid, _steer, _frm)] = _base
                _CAR_SHADOW[(_mid, _steer, _frm)] = _make_shadow(_base, alpha=110)

    def _make_bike_sprite(direction: str, frame: int) -> pygame.Surface:        
        w, h = 18, 18
        surf = pygame.Surface((w, h), pygame.SRCALPHA)

        outline = (10, 10, 12)
        tire = (16, 16, 20)
        rim = (62, 62, 72)
        spoke = (130, 130, 142)
        frame_col = (96, 96, 110)
        frame_dark = (72, 72, 86)
        seat = (44, 44, 54)
        light = (255, 230, 150)
        moving = int(frame) % 2 == 1

        def draw_wheel(cx: int, cy: int, *, orient: str) -> None:
            cx = int(cx)
            cy = int(cy)
            # Round wheels (top-down look).
            outer = 3
            inner = 2
            pygame.draw.circle(surf, tire, (cx, cy), int(outer))
            pygame.draw.circle(surf, rim, (cx, cy), int(inner))
            pygame.draw.circle(surf, outline, (cx, cy), int(outer), 1)
            pygame.draw.circle(surf, (90, 90, 104), (cx, cy), 1)  # hub

            if moving:
                pygame.draw.line(surf, spoke, (cx - 2, cy), (cx + 2, cy), 1)
                pygame.draw.line(surf, spoke, (cx, cy - 2), (cx, cy + 2), 1)
            else:
                pygame.draw.line(surf, spoke, (cx - 2, cy - 2), (cx + 2, cy + 2), 1)
                pygame.draw.line(surf, spoke, (cx - 2, cy + 2), (cx + 2, cy - 2), 1)

        if direction in ("left", "right"):
            y = 10
            front_x = 14 if direction == "right" else 4
            rear_x = 4 if direction == "right" else 14

            draw_wheel(rear_x, y, orient="h")
            draw_wheel(front_x, y, orient="h")

            crank_x, crank_y = 9, 10
            seat_x, seat_y = 8, 6
            handle_y = 6

            pygame.draw.line(surf, frame_col, (rear_x, y), (crank_x, crank_y), 1)
            pygame.draw.line(surf, frame_col, (crank_x, crank_y), (front_x, y), 1)
            pygame.draw.line(surf, frame_col, (crank_x, crank_y), (seat_x, seat_y), 1)
            pygame.draw.line(surf, frame_col, (seat_x, seat_y), (rear_x + (2 if direction == "right" else -2), y - 1), 1)

            pygame.draw.rect(surf, seat, pygame.Rect(seat_x - 2, seat_y - 1, 5, 2), border_radius=1)
            pygame.draw.line(surf, outline, (seat_x - 2, seat_y), (seat_x + 2, seat_y), 1)

            # Fork + handlebar.
            pygame.draw.line(surf, frame_dark, (front_x, y), (front_x + (0 if direction == "right" else 0), handle_y + 2), 1)
            pygame.draw.line(surf, frame_dark, (front_x - 2, handle_y), (front_x + 2, handle_y), 1)
            pygame.draw.line(surf, frame_dark, (front_x, handle_y), (front_x, handle_y + 2), 1)

            # Pedal hint.
            if moving:
                surf.set_at((crank_x + (1 if direction == "right" else -1), crank_y), spoke)
                surf.set_at((crank_x, crank_y + 1), spoke)
            else:
                surf.set_at((crank_x, crank_y + 1), spoke)
                surf.set_at((crank_x + (1 if direction == "right" else -1), crank_y + 1), spoke)

            pygame.draw.circle(surf, light, (front_x + (2 if direction == "right" else -2), y - 2), 1)
        else:
            x = 9
            front_y = 4 if direction == "up" else 14
            rear_y = 14 if direction == "up" else 4

            draw_wheel(x, rear_y, orient="v")
            draw_wheel(x, front_y, orient="v")

            crank_x, crank_y = 8, 9
            seat_x, seat_y = 6, 8
            handle_x = x

            pygame.draw.line(surf, frame_col, (x, rear_y), (crank_x, crank_y), 1)
            pygame.draw.line(surf, frame_col, (crank_x, crank_y), (x, front_y), 1)
            pygame.draw.line(surf, frame_col, (crank_x, crank_y), (seat_x, seat_y), 1)
            pygame.draw.line(surf, frame_col, (seat_x, seat_y), (x - 1, rear_y + (-2 if direction == "up" else 2)), 1)

            pygame.draw.rect(surf, seat, pygame.Rect(seat_x - 2, seat_y - 1, 5, 2), border_radius=1)
            pygame.draw.line(surf, outline, (seat_x - 2, seat_y), (seat_x + 2, seat_y), 1)

            pygame.draw.line(surf, frame_dark, (x, front_y), (x + 2, front_y + (2 if direction == "down" else -2)), 1)
            pygame.draw.line(surf, frame_dark, (handle_x - 2, front_y), (handle_x + 2, front_y), 1)
            pygame.draw.line(surf, frame_dark, (handle_x, front_y - 1), (handle_x, front_y + 1), 1)

            if moving:
                surf.set_at((crank_x + 1, crank_y), spoke)
                surf.set_at((crank_x, crank_y + (1 if direction == "down" else -1)), spoke)
            else:
                surf.set_at((crank_x, crank_y + 1), spoke)
                surf.set_at((crank_x + 1, crank_y + 1), spoke)

            pygame.draw.circle(surf, light, (x + 3, front_y + (3 if direction == "down" else -3)), 1)

        return surf

    _BIKE_FRAMES: dict[str, list[pygame.Surface]] = {
        "up": [_make_bike_sprite("up", 0), _make_bike_sprite("up", 1)],
        "down": [_make_bike_sprite("down", 0), _make_bike_sprite("down", 1)],   
        "left": [_make_bike_sprite("left", 0), _make_bike_sprite("left", 1)],   
        "right": [_make_bike_sprite("right", 0), _make_bike_sprite("right", 1)],
    }

    def _recolor_sprite(
        src: pygame.Surface,
        mapping: dict[tuple[int, int, int, int], tuple[int, int, int, int]],
    ) -> pygame.Surface:
        out = src.copy()
        w, h = out.get_size()
        for y in range(int(h)):
            for x in range(int(w)):
                rgba = out.get_at((x, y))
                repl = mapping.get((int(rgba.r), int(rgba.g), int(rgba.b), int(rgba.a)))
                if repl is not None:
                    out.set_at((x, y), repl)
        return out

    def _bike_variant_from_base(
        base: dict[str, list[pygame.Surface]],
        mapping: dict[tuple[int, int, int, int], tuple[int, int, int, int]],
        *,
        basket: bool = False,
        battery: bool = False,
    ) -> dict[str, list[pygame.Surface]]:
        out: dict[str, list[pygame.Surface]] = {}
        basket_col = (130, 92, 62, 255)
        basket_line = (10, 10, 12, 255)
        battery_col = (70, 90, 140, 255)
        for d, frames in base.items():
            nf: list[pygame.Surface] = []
            for s in frames:
                ns = s.copy()
                w, h = ns.get_size()
                for yy in range(int(h)):
                    for xx in range(int(w)):
                        rgba = ns.get_at((xx, yy))
                        repl = mapping.get((int(rgba.r), int(rgba.g), int(rgba.b), int(rgba.a)))
                        if repl is not None:
                            ns.set_at((xx, yy), repl)
                if basket:
                    if d == "right":
                        pygame.draw.rect(ns, basket_col, pygame.Rect(14, 6, 3, 3), border_radius=1)
                        pygame.draw.rect(ns, basket_line, pygame.Rect(14, 6, 3, 3), 1, border_radius=1)
                    elif d == "left":
                        pygame.draw.rect(ns, basket_col, pygame.Rect(1, 6, 3, 3), border_radius=1)
                        pygame.draw.rect(ns, basket_line, pygame.Rect(1, 6, 3, 3), 1, border_radius=1)
                    elif d == "up":
                        pygame.draw.rect(ns, basket_col, pygame.Rect(12, 1, 3, 3), border_radius=1)
                        pygame.draw.rect(ns, basket_line, pygame.Rect(12, 1, 3, 3), 1, border_radius=1)
                    else:
                        pygame.draw.rect(ns, basket_col, pygame.Rect(12, 14, 3, 3), border_radius=1)
                        pygame.draw.rect(ns, basket_line, pygame.Rect(12, 14, 3, 3), 1, border_radius=1)
                if battery:
                    pygame.draw.rect(ns, battery_col, pygame.Rect(8, 9, 4, 3), border_radius=1)
                    pygame.draw.rect(ns, basket_line, pygame.Rect(8, 9, 4, 3), 1, border_radius=1)
                nf.append(ns)
            out[str(d)] = nf
        return out

    def _make_moto_sprite(
        direction: str,
        frame: int,
        *,
        body: tuple[int, int, int] = (110, 80, 80),
        body2: tuple[int, int, int] = (72, 50, 50),
        accent: tuple[int, int, int] = (240, 210, 140),
        long: bool = False,
    ) -> pygame.Surface:
        w, h = 22, 22
        surf = pygame.Surface((w, h), pygame.SRCALPHA)
        outline = (10, 10, 12)
        tire = (16, 16, 20)
        rim = (62, 62, 72)
        spoke = (130, 130, 142)
        moving = int(frame) % 2 == 1

        def draw_wheel(cx: int, cy: int) -> None:
            pygame.draw.circle(surf, tire, (int(cx), int(cy)), 4)
            pygame.draw.circle(surf, rim, (int(cx), int(cy)), 3)
            pygame.draw.circle(surf, outline, (int(cx), int(cy)), 4, 1)
            if moving:
                pygame.draw.line(surf, spoke, (cx - 2, cy), (cx + 2, cy), 1)
                pygame.draw.line(surf, spoke, (cx, cy - 2), (cx, cy + 2), 1)
            else:
                pygame.draw.line(surf, spoke, (cx - 2, cy - 2), (cx + 2, cy + 2), 1)
                pygame.draw.line(surf, spoke, (cx - 2, cy + 2), (cx + 2, cy - 2), 1)

        if direction in ("left", "right"):
            y = 12
            front_x = 17 if direction == "right" else 4
            rear_x = 5 if direction == "right" else 18
            draw_wheel(rear_x, y)
            draw_wheel(front_x, y)
            body_r = pygame.Rect(min(front_x, rear_x) + 2, y - 4, abs(front_x - rear_x) - 3, 7)
            if long:
                body_r.w += 2
                body_r.x -= 1
            pygame.draw.rect(surf, body, body_r, border_radius=3)
            pygame.draw.rect(surf, outline, body_r, 1, border_radius=3)
            pygame.draw.rect(surf, body2, pygame.Rect(body_r.x + 2, body_r.y + 1, max(1, body_r.w - 4), 2), border_radius=2)
            pygame.draw.rect(surf, accent, pygame.Rect(body_r.centerx - 2, body_r.y + 3, 4, 2), border_radius=1)
        else:
            x = 11
            front_y = 4 if direction == "up" else 17
            rear_y = 18 if direction == "up" else 5
            draw_wheel(x, rear_y)
            draw_wheel(x, front_y)
            body_r = pygame.Rect(x - 4, min(front_y, rear_y) + 2, 7, abs(front_y - rear_y) - 3)
            if long:
                body_r.h += 2
                body_r.y -= 1
            pygame.draw.rect(surf, body, body_r, border_radius=3)
            pygame.draw.rect(surf, outline, body_r, 1, border_radius=3)
            pygame.draw.rect(surf, body2, pygame.Rect(body_r.x + 1, body_r.y + 2, 2, max(1, body_r.h - 4)), border_radius=2)
            pygame.draw.rect(surf, accent, pygame.Rect(body_r.x + 3, body_r.centery - 2, 2, 4), border_radius=1)
        return surf

    _TWO_WHEEL_FRAMES: dict[str, dict[str, list[pygame.Surface]]] = {
        "bike": _BIKE_FRAMES,
        "bike_lady": _bike_variant_from_base(
            _BIKE_FRAMES,
            {
                (96, 96, 110, 255): (220, 110, 180, 255),
                (72, 72, 86, 255): (170, 70, 140, 255),
                (44, 44, 54, 255): (60, 40, 50, 255),
            },
            basket=True,
        ),
        "bike_mountain": _bike_variant_from_base(
            _BIKE_FRAMES,
            {
                (96, 96, 110, 255): (90, 170, 110, 255),
                (72, 72, 86, 255): (60, 130, 80, 255),
                (44, 44, 54, 255): (30, 40, 34, 255),
            },
        ),
        "bike_auto": _bike_variant_from_base(
            _BIKE_FRAMES,
            {
                (96, 96, 110, 255): (90, 140, 210, 255),
                (72, 72, 86, 255): (60, 100, 170, 255),
                (44, 44, 54, 255): (30, 40, 60, 255),
            },
            battery=True,
        ),
        "moto": {
            "up": [_make_moto_sprite("up", 0), _make_moto_sprite("up", 1)],
            "down": [_make_moto_sprite("down", 0), _make_moto_sprite("down", 1)],
            "right": [_make_moto_sprite("right", 0), _make_moto_sprite("right", 1)],
            "left": [pygame.transform.flip(_make_moto_sprite("right", 0), True, False), pygame.transform.flip(_make_moto_sprite("right", 1), True, False)],
        },
        "moto_lux": {
            "up": [_make_moto_sprite("up", 0, body=(40, 40, 46), body2=(26, 26, 32), accent=(220, 180, 90)), _make_moto_sprite("up", 1, body=(40, 40, 46), body2=(26, 26, 32), accent=(220, 180, 90))],
            "down": [_make_moto_sprite("down", 0, body=(40, 40, 46), body2=(26, 26, 32), accent=(220, 180, 90)), _make_moto_sprite("down", 1, body=(40, 40, 46), body2=(26, 26, 32), accent=(220, 180, 90))],
            "right": [_make_moto_sprite("right", 0, body=(40, 40, 46), body2=(26, 26, 32), accent=(220, 180, 90)), _make_moto_sprite("right", 1, body=(40, 40, 46), body2=(26, 26, 32), accent=(220, 180, 90))],
            "left": [pygame.transform.flip(_make_moto_sprite("right", 0, body=(40, 40, 46), body2=(26, 26, 32), accent=(220, 180, 90)), True, False), pygame.transform.flip(_make_moto_sprite("right", 1, body=(40, 40, 46), body2=(26, 26, 32), accent=(220, 180, 90)), True, False)],
        },
        "moto_long": {
            "up": [_make_moto_sprite("up", 0, body=(110, 90, 70), body2=(70, 60, 46), accent=(240, 210, 140), long=True), _make_moto_sprite("up", 1, body=(110, 90, 70), body2=(70, 60, 46), accent=(240, 210, 140), long=True)],
            "down": [_make_moto_sprite("down", 0, body=(110, 90, 70), body2=(70, 60, 46), accent=(240, 210, 140), long=True), _make_moto_sprite("down", 1, body=(110, 90, 70), body2=(70, 60, 46), accent=(240, 210, 140), long=True)],
            "right": [_make_moto_sprite("right", 0, body=(110, 90, 70), body2=(70, 60, 46), accent=(240, 210, 140), long=True), _make_moto_sprite("right", 1, body=(110, 90, 70), body2=(70, 60, 46), accent=(240, 210, 140), long=True)],
            "left": [pygame.transform.flip(_make_moto_sprite("right", 0, body=(110, 90, 70), body2=(70, 60, 46), accent=(240, 210, 140), long=True), True, False), pygame.transform.flip(_make_moto_sprite("right", 1, body=(110, 90, 70), body2=(70, 60, 46), accent=(240, 210, 140), long=True), True, False)],
        },
    }

    def _make_cyclist_sprite(
        direction: str,
        frame: int,
        *,
        pal=_PLAYER_PAL,
    ) -> pygame.Surface:
        # A seated variant of the player used when riding the bike (2 pedal frames).
        w, h = 12, 16
        surf = pygame.Surface((w, h), pygame.SRCALPHA)

        hair = pal["H"]
        skin = pal["S"]
        coat = pal["C"]
        pants = pal["P"]
        boots = pal["B"]
        eye = pal["E"]
        coat_dark = (56, 72, 140)
        pants_dark = (40, 40, 50)

        phase = int(frame) % 2

        def draw_leg(x: int, y0: int, y1: int, *, col: tuple[int, int, int]) -> None:
            x = int(clamp(int(x), 0, w - 1))
            y0 = int(clamp(int(y0), 0, h - 1))
            y1 = int(clamp(int(y1), 0, h - 1))
            if y1 < y0:
                y0, y1 = y1, y0
            for y in range(y0, y1):
                surf.fill(col, pygame.Rect(x, y, 1, 1))
            surf.fill(boots, pygame.Rect(x, y1, 1, 1))

        if direction in ("down", "up"):
            # Head.
            if direction == "down":
                surf.fill(hair, pygame.Rect(4, 0, 4, 2))
                surf.fill(skin, pygame.Rect(4, 2, 4, 3))
                surf.set_at((5, 3), eye)
                surf.set_at((6, 3), eye)
            else:
                surf.fill(hair, pygame.Rect(4, 0, 4, 3))
                surf.fill(skin, pygame.Rect(5, 3, 2, 1))

            # Torso (lower + leaning).
            surf.fill(coat, pygame.Rect(3, 5, 6, 5))
            surf.fill(coat_dark, pygame.Rect(4, 7, 4, 3))
            # Arms forward to a "handlebar" hint.
            surf.fill(coat, pygame.Rect(2, 6, 1, 2))
            surf.fill(coat, pygame.Rect(9, 6, 1, 2))
            surf.fill(skin, pygame.Rect(2, 8, 1, 1))
            surf.fill(skin, pygame.Rect(9, 8, 1, 1))

            # Legs pedal around the crank: alternate boot height.
            lx = 5
            rx = 6
            if direction == "down":
                l_y = 13 + (0 if phase == 0 else 1)
                r_y = 13 + (1 if phase == 0 else 0)
            else:
                l_y = 14 - (0 if phase == 0 else 1)
                r_y = 14 - (1 if phase == 0 else 0)
            draw_leg(lx, 11, l_y, col=pants)
            draw_leg(rx, 11, r_y, col=pants_dark)
            surf.fill((30, 30, 34), pygame.Rect(4, 10, 4, 1))  # seat hint
            return surf

        # right
        # Head.
        surf.fill(hair, pygame.Rect(4, 0, 4, 2))
        surf.fill(skin, pygame.Rect(6, 2, 3, 3))
        surf.set_at((8, 3), eye)
        # Torso + near arm.
        surf.fill(coat, pygame.Rect(4, 5, 5, 5))
        surf.fill(coat_dark, pygame.Rect(4, 9, 5, 1))
        surf.fill(coat, pygame.Rect(8, 6, 2, 1))
        surf.fill(skin, pygame.Rect(9, 7, 1, 1))

        # Legs (2-frame pedal hint).
        near_shift = 1 if phase == 0 else 0
        far_shift = 0 if phase == 0 else 1
        draw_leg(5 + far_shift, 10, 14, col=pants_dark)
        draw_leg(6 + near_shift, 10, 13, col=pants)
        return surf

    _CYC_DOWN_FRAMES = [_make_cyclist_sprite("down", 0), _make_cyclist_sprite("down", 1)]
    _CYC_UP_FRAMES = [_make_cyclist_sprite("up", 0), _make_cyclist_sprite("up", 1)]
    _CYC_RIGHT_FRAMES = [_make_cyclist_sprite("right", 0), _make_cyclist_sprite("right", 1)]
    _CYC_LEFT_FRAMES: list[pygame.Surface] = []
    for _s in _CYC_RIGHT_FRAMES:
        _CYC_LEFT_FRAMES.append(pygame.transform.flip(_s, True, False))

    _CYCLIST_FRAMES: dict[str, list[pygame.Surface]] = {
        "down": _CYC_DOWN_FRAMES,
        "up": _CYC_UP_FRAMES,
        "right": _CYC_RIGHT_FRAMES,
        "left": _CYC_LEFT_FRAMES,
    }

    # High-rise apartment (multi-floor) interior.
    _HR_INT_LOBBY_LAYOUT: list[str] = [
        "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
        "W.............................W",
        "W....CC.................CC....W",
        "W....CC.................CC....W",
        "W.............................W",
        "W.......^^....EE..............W",
        "W.......vv....EE..............W",
        "W.............................D",
        "W.............................W",
        "W....CC.................CC....W",
        "W....CC.................CC....W",
        "W.............................W",
        "W.............................W",
        "W.............................W",
        "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
    ]
    _HR_INT_HALL_BASE: list[str] = [
        "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
        "W..............A..............W",
        "W.............................W",
        "W.......A.............A.......W",
        "W.............................W",
        "W.......^^....EE..............W",
        "W.......vv....EE..............W",
        "W.............................W",
        "W.............................W",
        "W.............................W",
        "W.............................W",
        "W.............................W",
        "W.............................W",
        "W.............................W",
        "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
    ]
    _HR_INT_HOME_LAYOUT: list[str] = [
        "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
        "WVVV....VVV....VVV....VVV.....W",
        "W....SSS.....W...W.....SSS....W",
        "W..BBBB......W...W..BBBB......W",
        "W..BBBB......W...W..BBBB......W",
        "W....SSS.....W...W....SSS.....W",
        "W.............................W",
        "WWWWWWWWWWWWWW...WWWWWWWWWWWWWW",
        "W.............................W",
        "W..PPP.....CCC..L..XXX........D",
        "W...C.................WWWWWWWWW",
        "WKKKKK.FF.............W,,,,,,,W",
        "WKKKKK..TTT............,,,,,,,W",
        "WKKKKK................W,,,O,,,W",
        "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
    ]
    _HR_INT_HOME_LAYOUT_VERSION = 5
    _HR_INT_W = 31
    _HR_INT_H = 15
    _HR_INT_TILE_SIZE = 20
    _HR_INT_SPRITE_SCALE = 2
    HIGHRISE_MAX_FLOORS = 10
    # Minimum playable interior height (in world tiles, excluding border walls)
    # for high-rises so the lobby + apartments don't collapse into "only elevator".
    HIGHRISE_MIN_FLOOR_TILES = 9
    _HR_INT_MAX_FLOORS_DEFAULT = HIGHRISE_MAX_FLOORS
    _HR_INT_APT_DOORS: list[tuple[int, int]] = [(8, 3), (22, 3), (15, 1)]

    GAS_CAN_REFUEL = 45.0

    # School (multi-floor) interior.
    _SCH_INT_LOBBY_LAYOUT: list[str] = [
        "WWWWWWWWWWWWWWWWWWWWWWW",
        "WVV.................VVW",
        "WLL...TTTT..TTTT....LLW",
        "WLL...TTTT..TTTT....LLW",
        "W.....................W",
        "W....^^.....EE.....vv.D",
        "W....^^.....EE.....vv.W",
        "W.....................W",
        "WLL...TTTT..TTTT....LLW",
        "WLL...TTTT..TTTT....LLW",
        "WWWWWWWWWWWWWWWWWWWWWWW",
    ]
    _SCH_INT_FLOOR_LAYOUT: list[str] = [
        "WWWWWWWWWWWWWWWWWWWWWWW",
        "WVV.................VVW",
        "WLL...TTTT..TTTT....LLW",
        "WLL...TTTT..TTTT....LLW",
        "W.....................W",
        "W....^^.....EE.....vv.W",
        "W....^^.....EE.....vv.W",
        "W.....................W",
        "WLL...TTTT..TTTT....LLW",
        "WLL...TTTT..TTTT....LLW",
        "WWWWWWWWWWWWWWWWWWWWWWW",
    ]
    _SCH_INT_W = 23
    _SCH_INT_H = 11
    _SCH_INT_TILE_SIZE = 20
    _SCH_INT_SPRITE_SCALE = 2
    _SCH_INT_MAX_FLOORS_DEFAULT = 4

    # Multi-floor house (23 floors) interior.
    _HOUSE_INT_F1_LAYOUT: list[str] = [
        "WWWWWWWWWWWWWWWWWWWWWWW",
        "WVV...........W,,,,,VVW",
        "W..BBBBB..SSSSW,,,O,,,W",
        "W..BBBBB..SSSSd,,,,,,,W",
        "W..............,,,R,,,W",
        "W....^^........vv.....D",
        "W....^^........vv.....W",
        "W.....................W",
        "W..KKKKK..TTTT..FFFF..W",
        "W..KKKKK..TTTT..FFFF..W",
        "WWWWWWWWWWWWWWWWWWWWWWW",
    ]
    _HOUSE_INT_FLOOR_LAYOUT: list[str] = [
        "WWWWWWWWWWWWWWWWWWWWWWW",
        "WVV...........W,,,,,VVW",
        "W......SSSS...W,,,O,,,W",
        "W..TT..SSSS...d,,,,,,,W",
        "W..TT..........,,,R,,,W",
        "W....^^........vvWWWWWW",
        "W....^^........vv.....W",
        "W.........BBBBB.......W",
        "W..KKKKK..BBBBB.SSSS..W",
        "W..KKKKK........SSSS..W",
        "WWWWWWWWWWWWWWWWWWWWWWW",
    ]
    _HOUSE_INT_W = 23
    _HOUSE_INT_H = 11
    _HOUSE_INT_TILE_SIZE = 20
    _HOUSE_INT_SPRITE_SCALE = 2
    _HOUSE_INT_MAX_FLOORS_DEFAULT = 3

    @dataclass(frozen=True)
    class _ItemDef:
        id: str
        name: str
        stack: int
        color: tuple[int, int, int]
        kind: str
        desc: str = ""

    _ITEMS: dict[str, _ItemDef] = {
        "cola": _ItemDef("cola", "", stack=3, color=(220, 70, 80), kind="drink"),
        "food_can": _ItemDef("food_can", "", stack=6, color=(210, 170, 90), kind="food"),
        "water": _ItemDef("water", "", stack=3, color=(120, 170, 230), kind="drink"),
        "bandage": _ItemDef("bandage", "", stack=12, color=(230, 230, 240), kind="med"),
        "medkit": _ItemDef("medkit", "", stack=2, color=(240, 120, 120), kind="med"),
        "pistol": _ItemDef("pistol", "9mm", stack=1, color=(190, 190, 200), kind="gun"),
        "ammo_9mm": _ItemDef("ammo_9mm", "9mm", stack=60, color=(230, 220, 140), kind="ammo"),
        "scrap": _ItemDef("scrap", "", stack=20, color=(150, 150, 160), kind="mat"),
        "wood": _ItemDef("wood", "", stack=20, color=(150, 110, 70), kind="mat"),
        "cup": _ItemDef("cup", "", stack=1, color=(230, 230, 236), kind="tool"),
        "cup_water": _ItemDef("cup_water", "", stack=1, color=(120, 170, 230), kind="drink"),
    }

    # Procedurally-generated bulk item library (300+). Keep it compact by composing
    # base types + variants, but still deterministic and readable.
    def _bulk_item_seed(s: str) -> int:
        n = 0
        for ch in str(s):
            n = (n * 131 + ord(ch)) & 0xFFFFFFFF
        return int(n)

    def _bulk_item_color(base: tuple[int, int, int], seed: int, *, spread: int = 22) -> tuple[int, int, int]:
        seed = int(seed) & 0xFFFFFFFF
        dv = int((seed >> 8) % 11) - 5  # -5..+5
        dv2 = int((seed >> 16) % 9) - 4
        s = int(max(6, int(spread)))
        r = int(clamp(int(base[0]) + dv * (s // 6), 0, 255))
        g = int(clamp(int(base[1]) + dv2 * (s // 7), 0, 255))
        b = int(clamp(int(base[2]) + dv * (s // 8), 0, 255))
        return (r, g, b)

    _BULK_ITEMS: dict[str, _ItemDef] = {}

    _FOOD_BASES: list[tuple[str, str]] = [
        ("bread", ""),
        ("biscuit", ""),
        ("chips", ""),
        ("jerky", ""),
        ("noodle", ""),
        ("riceball", ""),
        ("candy", ""),
        ("chocolate", ""),
        ("nuts", ""),
        ("sausage", ""),
        ("cereal", ""),
        ("crackers", ""),
        ("tuna", ""),
        ("beans", ""),
        ("corn", ""),
        ("fruitcan", ""),
        ("soup", ""),
        ("mre", ""),
        ("driedfruit", ""),
        ("pickles", ""),
        ("seaweed", ""),
        ("cheese", ""),
        ("energybar", ""),
        ("mealbox", ""),
    ]
    _FOOD_FLAVORS: list[tuple[str, str]] = [
        ("plain", ""),
        ("spicy", ""),
        ("tomato", ""),
        ("curry", ""),
        ("garlic", ""),
        ("bbq", ""),
        ("pepper", ""),
        ("sweet", ""),
    ]
    for _bid, _bname in _FOOD_BASES:
        for _fid, _fname in _FOOD_FLAVORS:
            _iid = f"food_{_bid}_{_fid}"
            if _iid in _ITEMS or _iid in _BULK_ITEMS:
                continue
            _seed = _bulk_item_seed(_iid)
            _BULK_ITEMS[_iid] = _ItemDef(
                _iid,
                f"{_fname}{_bname}",
                stack=6,
                color=_bulk_item_color((210, 170, 90), _seed),
                kind="food",
            )

    _DRINK_BASES: list[tuple[str, str]] = [
        ("soda", ""),
        ("energy", ""),
        ("juice", ""),
        ("tea", ""),
        ("coffee", ""),
        ("milk", ""),
        ("soymilk", ""),
        ("beer", ""),
        ("wine", ""),
        ("sports", ""),
        ("sparkling", ""),
        ("cocoa", ""),
        ("lemonade", ""),
        ("water_mineral", ""),
        ("milk_choco", ""),
    ]
    _DRINK_FLAVORS: list[tuple[str, str]] = [
        ("plain", ""),
        ("lemon", ""),
        ("orange", ""),
        ("grape", ""),
        ("peach", ""),
        ("sugarfree", ""),
    ]
    for _bid, _bname in _DRINK_BASES:
        for _fid, _fname in _DRINK_FLAVORS:
            _iid = f"drink_{_bid}_{_fid}"
            if _iid in _ITEMS or _iid in _BULK_ITEMS:
                continue
            _seed = _bulk_item_seed(_iid)
            _BULK_ITEMS[_iid] = _ItemDef(
                _iid,
                f"{_fname}{_bname}",
                stack=3,
                color=_bulk_item_color((120, 170, 230), _seed),
                kind="drink",
            )

    _MEDS: list[tuple[str, str]] = [
        ("med_painkillers", ""),
        ("med_antibiotic", ""),
        ("med_vitamin", ""),
        ("med_alcoholwipe", ""),
        ("med_iodine", ""),
        ("med_saline", ""),
        ("med_glucose", ""),
        ("med_cough", ""),
        ("med_allergy", ""),
        ("med_burncream", ""),
        ("med_antiseptic", ""),
        ("med_sleep", ""),
        ("med_bandage_roll", ""),
        ("med_splint", ""),
        ("med_ointment", ""),
        ("med_eye", ""),
        ("med_mask", ""),
        ("med_gloves", ""),
        ("med_syringe", ""),
        ("med_adrenaline", ""),
        ("med_charcoal", ""),
        ("med_disinfect_wipes", ""),
        ("med_thermometer", ""),
        ("med_pain_patch", ""),
        ("med_antifungal", ""),
        ("med_antidiarrheal", ""),
        ("med_antacid", ""),
        ("med_suture", ""),
        ("med_salt", ""),
        ("med_medicinal_tea", ""),
    ]
    for _iid, _name in _MEDS:
        if _iid in _ITEMS or _iid in _BULK_ITEMS:
            continue
        _seed = _bulk_item_seed(_iid)
        _BULK_ITEMS[_iid] = _ItemDef(_iid, _name, stack=6, color=_bulk_item_color((230, 230, 240), _seed), kind="med")

    _MATS: list[tuple[str, str]] = [
        ("nails", ""),
        ("screws", ""),
        ("duct_tape", ""),
        ("rope", ""),
        ("cloth", ""),
        ("plastic", ""),
        ("glass", ""),
        ("wire", ""),
        ("battery", ""),
        ("charcoal", ""),
        ("matches", ""),
        ("lighter", ""),
        ("soap", ""),
        ("salt", ""),
        ("sugar", ""),
        ("spices", ""),
        ("paper", ""),
        ("book", ""),
        ("map", ""),
        ("flashlight", ""),
        ("knife", ""),
        ("hammer", ""),
        ("saw", ""),
        ("wrench", ""),
        ("screwdriver", ""),
        ("crowbar", ""),
        ("backpack", ""),
        ("phone", ""),
        ("radio", ""),
        ("binoculars", ""),
        ("can_opener", ""),
        ("cigarettes", ""),
        ("lighter_fluid", ""),
        ("bottle_empty", ""),
        ("plank", ""),
        ("sheet_metal", ""),
        ("oil_filter", ""),
        ("spark_plug", ""),
        ("repair_kit", ""),
    ]
    for _iid, _name in _MATS:
        if _iid in _ITEMS or _iid in _BULK_ITEMS:
            continue
        _seed = _bulk_item_seed(_iid)
        stack = (
            1
            if _iid
            in (
                "flashlight",
                "knife",
                "hammer",
                "saw",
                "wrench",
                "screwdriver",
                "crowbar",
                "backpack",
                "phone",
                "radio",
                "binoculars",
                "can_opener",
                "repair_kit",
            )
            else 20
        )
        kind = "tool" if stack == 1 else "mat"
        _BULK_ITEMS[_iid] = _ItemDef(_iid, _name, stack=int(stack), color=_bulk_item_color((150, 150, 160), _seed), kind=kind)

    _FURN_BASES: list[tuple[str, str]] = [
        ("chair", ""),
        ("stool", ""),
        ("table", ""),
        ("sofa", ""),
        ("bed", ""),
        ("cabinet", ""),
        ("wardrobe", ""),
        ("shelf", ""),
        ("tv", ""),
        ("lamp", ""),
        ("fan", ""),
        ("microwave", ""),
        ("fridge", ""),
        ("washer", ""),
        ("heater", ""),
    ]
    _FURN_VARIANTS: list[tuple[str, str]] = [
        ("old", ""),
        ("new", ""),
        ("broken", ""),
        ("heavy", ""),
    ]
    for _bid, _bname in _FURN_BASES:
        for _vid, _vname in _FURN_VARIANTS:
            _iid = f"furn_{_bid}_{_vid}"
            if _iid in _ITEMS or _iid in _BULK_ITEMS:
                continue
            _seed = _bulk_item_seed(_iid)
            _BULK_ITEMS[_iid] = _ItemDef(
                _iid,
                f"{_vname}{_bname}",
                stack=1,
                color=_bulk_item_color((120, 110, 100), _seed),
                kind="furniture",
            )

    # Keys / fuel (used by vehicle systems).
    _EXTRA_CORE: list[tuple[str, str, str, tuple[int, int, int], int]] = [
        ("key_rv", "", "key", (220, 220, 240), 1),
        ("key_moto", "", "key", (220, 220, 240), 1),
        ("key_house", "", "key", (220, 220, 240), 1),
        ("gas_can", "", "fuel", (210, 170, 90), 1),
    ]
    for _iid, _name, _kind, _base_col, _stack in _EXTRA_CORE:
        if _iid in _ITEMS or _iid in _BULK_ITEMS:
            continue
        _seed = _bulk_item_seed(_iid)
        _BULK_ITEMS[_iid] = _ItemDef(_iid, _name, stack=int(_stack), color=_bulk_item_color(_base_col, _seed), kind=str(_kind))

    # Guns / ammo / attachments (core gameplay loop).
    _EXTRA_WEAPONS: list[tuple[str, str, str, tuple[int, int, int], int, str]] = [
        ("uzi", "UZI", "gun", (190, 190, 200), 1, ""),
        ("ak47", "AK-47", "gun", (190, 190, 200), 1, ""),
        ("scar_l", "SCAR-L", "gun", (190, 190, 200), 1, ""),
        ("rpg", "", "gun", (200, 190, 170), 1, ""),
        ("ammo_556", "5.56mm", "ammo", (210, 220, 170), 90, "5.5645mm"),
        ("ammo_762", "7.62mm", "ammo", (230, 200, 120), 75, "7.6239mm"),
        ("ammo_rocket", "", "ammo", (240, 140, 100), 6, ""),
        # Attachments
        ("mod_optic_reddot", "", "gun_mod", (170, 170, 190), 1, ""),
        ("mod_optic_4x", "4", "gun_mod", (170, 170, 190), 1, ""),
        ("mod_muzzle_suppressor_9mm", "9mm", "gun_mod", (120, 120, 132), 1, ""),
        ("mod_muzzle_suppressor_rifle", "", "gun_mod", (120, 120, 132), 1, ""),
        ("mod_muzzle_comp_rifle", "", "gun_mod", (140, 140, 154), 1, ""),
        ("mod_undergrip_stab", "", "gun_mod", (120, 140, 150), 1, ""),
        ("mod_mag_ext_pistol", "", "gun_mod", (170, 150, 120), 1, ""),
        ("mod_mag_ext_9mm", "9mm", "gun_mod", (170, 150, 120), 1, ""),
        ("mod_mag_ext_rifle", "", "gun_mod", (170, 150, 120), 1, ""),
    ]
    for _iid, _name, _kind, _base_col, _stack, _desc in _EXTRA_WEAPONS:
        if _iid in _ITEMS or _iid in _BULK_ITEMS:
            continue
        _seed = _bulk_item_seed(_iid)
        _BULK_ITEMS[_iid] = _ItemDef(
            _iid,
            _name,
            stack=int(_stack),
            color=_bulk_item_color(_base_col, _seed),
            kind=str(_kind),
            desc=str(_desc),
        )

    _EXTRA_MELEE: list[tuple[str, str, str, tuple[int, int, int], int, str]] = [
        ("melee_club", "", "melee", (150, 110, 70), 1, ""),
        ("melee_bat", "", "melee", (160, 120, 80), 1, ""),
        ("melee_pipe", "", "melee", (150, 150, 160), 1, ""),
        ("melee_machete", "", "melee", (200, 200, 210), 1, ""),
    ]
    for _iid, _name, _kind, _base_col, _stack, _desc in _EXTRA_MELEE:
        if _iid in _ITEMS or _iid in _BULK_ITEMS:
            continue
        _seed = _bulk_item_seed(_iid)
        _BULK_ITEMS[_iid] = _ItemDef(
            _iid,
            _name,
            stack=int(_stack),
            color=_bulk_item_color(_base_col, _seed),
            kind=str(_kind),
            desc=str(_desc),
        )

    _EXTRA_CLOTHES: list[tuple[str, str, str, tuple[int, int, int], int, str]] = [
        ("clothes_jacket_blue", "", "clothes", (72, 92, 160), 1, ""),
        ("clothes_work_green", "", "clothes", (70, 120, 90), 1, ""),
        ("clothes_tactical_gray", "", "clothes", (92, 92, 104), 1, ""),
        ("clothes_prisoner_orange", "", "clothes", (210, 130, 60), 1, ""),
        ("clothes_medic_white", "", "clothes", (220, 220, 230), 1, "Buff"),
        ("clothes_raincoat_yellow", "", "clothes", (224, 210, 112), 1, ""),
        ("clothes_hoodie_pink", "", "clothes", (210, 120, 160), 1, ""),
        ("clothes_denim_blue", "", "clothes", (90, 140, 210), 1, ""),
        ("clothes_chef_white", "", "clothes", (240, 240, 245), 1, ""),
        ("clothes_racing_red", "", "clothes", (210, 70, 80), 1, ""),
        ("clothes_xmas_green", "", "clothes", (120, 190, 140), 1, ""),
        ("clothes_black_suit", "", "clothes", (28, 28, 34), 1, ""),
        ("clothes_desert_camo", "", "clothes", (160, 140, 90), 1, ""),
        ("clothes_sport_cyan", "", "clothes", (80, 160, 210), 1, ""),
        ("clothes_pajama_bear", "", "clothes", (200, 190, 230), 1, ""),
        ("clothes_maid", "", "clothes", (220, 220, 240), 1, ""),
    ]
    for _iid, _name, _kind, _base_col, _stack, _desc in _EXTRA_CLOTHES:
        if _iid in _ITEMS or _iid in _BULK_ITEMS:
            continue
        _seed = _bulk_item_seed(_iid)
        _BULK_ITEMS[_iid] = _ItemDef(
            _iid,
            _name,
            stack=int(_stack),
            color=_bulk_item_color(_base_col, _seed),
            kind=str(_kind),
            desc=str(_desc),
        )

    _EXTRA_GUN_MODS_MORE: list[tuple[str, str, str, tuple[int, int, int], int, str]] = [
        ("mod_optic_holo", "", "gun_mod", (170, 170, 190), 1, ""),
        ("mod_undergrip_bipod", "", "gun_mod", (120, 140, 150), 1, ""),
        ("mod_stock_tactical", "", "gun_mod", (140, 140, 154), 1, ""),
        ("mod_muzzle_flash_hider_rifle", "", "gun_mod", (120, 120, 132), 1, ""),
        ("mod_trigger_light", "", "gun_mod", (170, 170, 190), 1, ""),
        ("mod_mag_drum_9mm", "9mm", "gun_mod", (170, 150, 120), 1, ""),
        ("mod_mag_drum_rifle", "", "gun_mod", (170, 150, 120), 1, ""),
    ]
    for _iid, _name, _kind, _base_col, _stack, _desc in _EXTRA_GUN_MODS_MORE:
        if _iid in _ITEMS or _iid in _BULK_ITEMS:
            continue
        _seed = _bulk_item_seed(_iid)
        _BULK_ITEMS[_iid] = _ItemDef(
            _iid,
            _name,
            stack=int(_stack),
            color=_bulk_item_color(_base_col, _seed),
            kind=str(_kind),
            desc=str(_desc),
        )

    for _iid, _idef in _BULK_ITEMS.items():
        if _iid not in _ITEMS:
            _ITEMS[_iid] = _idef

    _ICON_PAL = {
        "K": (18, 18, 22),
        "G": (190, 190, 200),
        "W": (240, 240, 240),
        "R": (240, 120, 120),
        "C": (220, 70, 80),
        "c": (170, 50, 60),
        "B": (120, 170, 230),
        "Y": (230, 220, 140),
        "O": (210, 170, 90),
        "S": (150, 150, 160),
        "T": (150, 110, 70),
    }

    _ICON_PISTOL = sprite_from_pixels(
        [
            "        ",
            "   GGG  ",
            "  GKKG  ",
            "  GGGG  ",
            "    KG  ",
            "   GKG  ",
            "    G   ",
            "        ",
        ],
        _ICON_PAL,
    )
    _ICON_AMMO = sprite_from_pixels(
        [
            "        ",
            "  YYYY  ",
            "  YYYY  ",
            "  YYYY  ",
            "   YY   ",
            "   YY   ",
            "        ",
            "        ",
        ],
        _ICON_PAL,
    )
    _ICON_FOOD = sprite_from_pixels(
        [
            "        ",
            "  OOOO  ",
            " OOOOOO ",
            " OOKKOO ",
            " OOOOOO ",
            "  OOOO  ",
            "        ",
            "        ",
        ],
        _ICON_PAL,
    )
    _ICON_WATER = sprite_from_pixels(
        [
            "        ",
            "   BB   ",
            "   BB   ",
            "  BBBB  ",
            "  BBBB  ",
            "  BBBB  ",
            "   BB   ",
            "        ",
        ],
        _ICON_PAL,
    )
    _ICON_COLA = sprite_from_pixels(
        [
            "        ",
            "  CCCC  ",
            " CCCCC  ",
            " CWWWC  ",
            " CCCCC  ",
            "  CCCC  ",
            "   CC   ",
            "        ",
        ],
        _ICON_PAL,
    )
    _ICON_BANDAGE = sprite_from_pixels(
        [
            "        ",
            "  WWWW  ",
            "  WKKW  ",
            "  WWWW  ",
            "  WKKW  ",
            "  WWWW  ",
            "        ",
            "        ",
        ],
        _ICON_PAL,
    )
    _ICON_MEDKIT = sprite_from_pixels(
        [
            "        ",
            "  RRRR  ",
            "  RWWR  ",
            "  RWWR  ",
            "  RRRR  ",
            "   RR   ",
            "        ",
            "        ",
        ],
        _ICON_PAL,
    )
    _ICON_SCRAP = sprite_from_pixels(
        [
            "        ",
            "  SSSS  ",
            " SSKKSS ",
            " SSSSSS ",
            "  SSSS  ",
            "   SS   ",
            "        ",
            "        ",
        ],
        _ICON_PAL,
    )
    _ICON_WOOD = sprite_from_pixels(
        [
            "        ",
            "  TTTT  ",
            " TTKKTT ",
            " TTTTTT ",
            "  TTTT  ",
            "   TT   ",
            "        ",
            "        ",
        ],
        _ICON_PAL,
    )

    _ITEM_ICONS: dict[str, pygame.Surface] = {
        "pistol": _ICON_PISTOL,
        "ammo_9mm": _ICON_AMMO,
        "food_can": _ICON_FOOD,
        "water": _ICON_WATER,
        "cola": _ICON_COLA,
        "bandage": _ICON_BANDAGE,
        "medkit": _ICON_MEDKIT,
        "scrap": _ICON_SCRAP,
        "wood": _ICON_WOOD,
    }

    def _make_item_sprite_pistol() -> pygame.Surface:
        surf = pygame.Surface((20, 12), pygame.SRCALPHA)
        outline = (10, 10, 12)
        dark = (62, 62, 72)
        mid = (92, 92, 104)
        hi = (150, 150, 162)

        # Slide + barrel.
        pygame.draw.rect(surf, dark, pygame.Rect(2, 3, 14, 3))
        pygame.draw.rect(surf, hi, pygame.Rect(3, 4, 12, 1))
        pygame.draw.rect(surf, outline, pygame.Rect(2, 3, 14, 3), 1)
        pygame.draw.rect(surf, dark, pygame.Rect(16, 4, 2, 2))
        pygame.draw.rect(surf, outline, pygame.Rect(16, 4, 2, 2), 1)
        surf.set_at((18, 5), outline)  # muzzle
        pygame.draw.rect(surf, mid, pygame.Rect(9, 3, 3, 1))  # ejection port hint

        # Grip + trigger guard.
        pygame.draw.rect(surf, mid, pygame.Rect(8, 6, 5, 5))
        pygame.draw.rect(surf, outline, pygame.Rect(8, 6, 5, 5), 1)
        pygame.draw.rect(surf, dark, pygame.Rect(9, 6, 3, 2))
        pygame.draw.rect(surf, outline, pygame.Rect(9, 6, 3, 2), 1)
        pygame.draw.line(surf, outline, (7, 7), (8, 7), 1)
        # Trigger + grip texture.
        surf.set_at((9, 8), outline)
        for y in range(7, 11):
            if y % 2 == 0:
                surf.set_at((11, y), dark)

        return surf

    def _make_item_sprite_ammo() -> pygame.Surface:
        surf = pygame.Surface((16, 12), pygame.SRCALPHA)
        outline = (10, 10, 12)
        box = (120, 120, 132)
        box2 = (92, 92, 104)
        brass = (230, 220, 140)
        brass2 = (200, 180, 90)

        pygame.draw.rect(surf, box, pygame.Rect(2, 4, 12, 6), border_radius=2)
        pygame.draw.rect(surf, outline, pygame.Rect(2, 4, 12, 6), 1, border_radius=2)
        pygame.draw.rect(surf, box2, pygame.Rect(2, 8, 12, 2), border_radius=1)
        for i in range(3):
            x = 4 + i * 3
            pygame.draw.rect(surf, brass, pygame.Rect(x, 2, 2, 4))
            pygame.draw.rect(surf, brass2, pygame.Rect(x, 4, 2, 1))
            pygame.draw.rect(surf, outline, pygame.Rect(x, 2, 2, 4), 1)
        return surf

    def _make_item_sprite_food_can() -> pygame.Surface:
        surf = pygame.Surface((14, 12), pygame.SRCALPHA)
        outline = (10, 10, 12)
        can = (210, 170, 90)
        can2 = (170, 130, 70)
        label = (230, 220, 140)
        label2 = (200, 180, 90)

        pygame.draw.rect(surf, can, pygame.Rect(3, 2, 8, 9), border_radius=2)
        pygame.draw.rect(surf, outline, pygame.Rect(3, 2, 8, 9), 1, border_radius=2)
        pygame.draw.line(surf, label, (4, 5), (9, 5), 2)
        pygame.draw.line(surf, label2, (4, 7), (9, 7), 1)
        pygame.draw.line(surf, can2, (4, 3), (9, 3), 1)
        return surf

    def _make_item_sprite_water() -> pygame.Surface:
        surf = pygame.Surface((12, 14), pygame.SRCALPHA)
        outline = (10, 10, 12)
        water = (120, 170, 230)
        water2 = (90, 130, 190)
        cap = (220, 220, 230)

        # Cap.
        pygame.draw.rect(surf, cap, pygame.Rect(5, 1, 2, 2), border_radius=1)
        pygame.draw.rect(surf, outline, pygame.Rect(5, 1, 2, 2), 1, border_radius=1)

        # Neck.
        pygame.draw.rect(surf, water, pygame.Rect(5, 3, 2, 2), border_radius=1)
        pygame.draw.rect(surf, outline, pygame.Rect(5, 3, 2, 2), 1, border_radius=1)

        # Body.
        body = pygame.Rect(3, 5, 6, 8)
        pygame.draw.rect(surf, water, body, border_radius=3)
        pygame.draw.rect(surf, outline, body, 1, border_radius=3)

        # Label band.
        label = pygame.Rect(3, 8, 6, 2)
        pygame.draw.rect(surf, cap, label, border_radius=1)
        pygame.draw.rect(surf, outline, label, 1, border_radius=1)
        surf.set_at((5, 9), (255, 255, 255))

        # Highlights.
        pygame.draw.line(surf, water2, (4, 6), (4, 12), 1)
        pygame.draw.line(surf, cap, (8, 6), (8, 12), 1)
        return surf

    def _make_item_sprite_cola() -> pygame.Surface:
        surf = pygame.Surface((12, 14), pygame.SRCALPHA)
        outline = (10, 10, 12)
        red = (220, 70, 80)
        red2 = (170, 50, 60)
        white = (240, 240, 240)
        steel = (220, 220, 230)

        # Top.
        pygame.draw.rect(surf, steel, pygame.Rect(4, 1, 4, 2), border_radius=1)
        pygame.draw.rect(surf, outline, pygame.Rect(4, 1, 4, 2), 1, border_radius=1)

        # Can body.
        body = pygame.Rect(3, 3, 6, 10)
        pygame.draw.rect(surf, red, body, border_radius=2)
        pygame.draw.rect(surf, outline, body, 1, border_radius=2)
        pygame.draw.rect(surf, red2, pygame.Rect(3, 4, 2, 8), border_radius=1)
        pygame.draw.line(surf, steel, (8, 4), (8, 11), 1)  # right highlight

        # Logo wave (simple, readable at 2x in world).
        pygame.draw.line(surf, white, (4, 7), (7, 6), 2)
        pygame.draw.line(surf, white, (4, 9), (7, 8), 1)
        pygame.draw.line(surf, white, (4, 11), (7, 10), 1)
        pygame.draw.circle(surf, white, (6, 8), 1)  # badge

        # Bottom rim.
        pygame.draw.line(surf, steel, (4, 12), (7, 12), 1)
        surf.set_at((6, 2), outline)  # pull-tab hint
        return surf

    def _make_item_sprite_bandage() -> pygame.Surface:
        surf = pygame.Surface((14, 10), pygame.SRCALPHA)
        outline = (10, 10, 12)
        cloth = (240, 240, 240)
        cloth2 = (200, 200, 210)

        # Rolled bandage + loose tail.
        roll = pygame.Rect(2, 2, 7, 6)
        pygame.draw.ellipse(surf, cloth, roll)
        pygame.draw.ellipse(surf, outline, roll, 1)
        pygame.draw.ellipse(surf, cloth2, roll.inflate(-3, -3))
        pygame.draw.line(surf, outline, (roll.centerx, roll.top + 1), (roll.centerx, roll.bottom - 2), 1)

        tail = pygame.Rect(8, 4, 4, 3)
        pygame.draw.rect(surf, cloth, tail, border_radius=1)
        pygame.draw.rect(surf, outline, tail, 1, border_radius=1)
        pygame.draw.line(surf, cloth2, (tail.left + 1, tail.top + 1), (tail.right - 2, tail.top + 1), 1)
        return surf

    def _make_item_sprite_medkit() -> pygame.Surface:
        surf = pygame.Surface((16, 12), pygame.SRCALPHA)
        outline = (10, 10, 12)
        red = (240, 120, 120)
        red2 = (190, 90, 90)
        white = (240, 240, 240)

        pygame.draw.rect(surf, red, pygame.Rect(3, 3, 10, 7), border_radius=2)
        pygame.draw.rect(surf, outline, pygame.Rect(3, 3, 10, 7), 1, border_radius=2)
        pygame.draw.rect(surf, red2, pygame.Rect(3, 8, 10, 2), border_radius=1)
        pygame.draw.rect(surf, outline, pygame.Rect(6, 1, 4, 2), 1)  # handle
        pygame.draw.rect(surf, white, pygame.Rect(7, 5, 2, 4))
        pygame.draw.rect(surf, white, pygame.Rect(6, 6, 4, 2))
        return surf

    def _make_item_sprite_scrap() -> pygame.Surface:
        surf = pygame.Surface((14, 12), pygame.SRCALPHA)
        outline = (10, 10, 12)
        metal = (150, 150, 160)
        metal2 = (110, 110, 122)

        pygame.draw.polygon(surf, metal, [(2, 7), (5, 2), (12, 3), (10, 10), (4, 11)])
        pygame.draw.polygon(surf, outline, [(2, 7), (5, 2), (12, 3), (10, 10), (4, 11)], 1)
        pygame.draw.polygon(surf, metal2, [(6, 5), (11, 4), (9, 9), (5, 9)])
        pygame.draw.line(surf, metal2, (3, 8), (9, 6), 1)

        # Bolt plate.
        plate = pygame.Rect(1, 2, 5, 3)
        pygame.draw.rect(surf, metal2, plate, border_radius=1)
        pygame.draw.rect(surf, outline, plate, 1, border_radius=1)
        pygame.draw.circle(surf, metal, (plate.left + 2, plate.centery), 1)
        pygame.draw.circle(surf, outline, (plate.left + 2, plate.centery), 1, 1)
        return surf

    def _make_item_sprite_wood() -> pygame.Surface:
        surf = pygame.Surface((16, 10), pygame.SRCALPHA)
        outline = (10, 10, 12)
        wood = (150, 110, 70)
        wood2 = (120, 86, 56)
        wood3 = (176, 132, 86)

        # Back plank.
        back = pygame.Rect(4, 1, 10, 4)
        pygame.draw.rect(surf, wood2, back, border_radius=2)
        pygame.draw.rect(surf, outline, back, 1, border_radius=2)
        pygame.draw.line(surf, wood3, (back.left + 2, back.top + 1), (back.right - 3, back.top + 1), 1)

        # Front plank.
        front = pygame.Rect(2, 4, 12, 4)
        pygame.draw.rect(surf, wood, front, border_radius=2)
        pygame.draw.rect(surf, outline, front, 1, border_radius=2)
        for x in (4, 7, 10):
            pygame.draw.line(surf, wood2, (x, 5), (x, 7), 1)
        pygame.draw.circle(surf, wood2, (9, 6), 1)  # knot
        return surf

    _ITEM_SPRITES: dict[str, pygame.Surface] = {
        "pistol": _make_item_sprite_pistol(),
        "ammo_9mm": _make_item_sprite_ammo(),
        "food_can": _make_item_sprite_food_can(),
        "water": _make_item_sprite_water(),
        "cola": _make_item_sprite_cola(),
        "bandage": _make_item_sprite_bandage(),
        "medkit": _make_item_sprite_medkit(),
        "scrap": _make_item_sprite_scrap(),
        "wood": _make_item_sprite_wood(),
    }

    _ITEM_SPRITES_WORLD: dict[str, pygame.Surface] = {}
    for _iid, _spr in _ITEM_SPRITES.items():
        try:
            # World loot should be smaller than the player sprite (12x16).
            # We keep the detailed sprite, but scale it down to a small icon-like
            # footprint so ground drops don't look oversized.
            max_px = 11
            sw, sh = int(_spr.get_width()), int(_spr.get_height())
            biggest = max(1, max(int(sw), int(sh)))
            scale = min(1.0, float(max_px) / float(biggest))
            if scale < 1.0:
                nw = max(1, int(round(float(sw) * scale)))
                nh = max(1, int(round(float(sh) * scale)))
                _ITEM_SPRITES_WORLD[_iid] = pygame.transform.scale(_spr, (int(nw), int(nh)))
            else:
                _ITEM_SPRITES_WORLD[_iid] = _spr
        except Exception:
            _ITEM_SPRITES_WORLD[_iid] = _spr

    for _iid, _spr in _ITEM_SPRITES.items():
        try:
            if _iid not in _ITEM_ICONS:
                _ITEM_ICONS[_iid] = pygame.transform.scale(_spr, (8, 8))
        except Exception:
            pass

    # Keep pistol visuals consistent across world + inventory + in-hand.
    try:
        _ps = _ITEM_SPRITES_WORLD.get("pistol")
        if _ps is not None:
            bw, bh = int(_ps.get_width()), int(_ps.get_height())
            scale = min(8.0 / max(1.0, float(bw)), 8.0 / max(1.0, float(bh)))
            tw = int(max(1, round(float(bw) * scale)))
            th = int(max(1, round(float(bh) * scale)))
            thumb = pygame.transform.scale(_ps, (tw, th))
            icon = pygame.Surface((8, 8), pygame.SRCALPHA)
            icon.blit(thumb, (int((8 - tw) // 2), int((8 - th) // 2)))
            _ITEM_ICONS["pistol"] = icon
    except Exception:
        pass

    def _make_hand_pistol_sprite(_src: pygame.Surface = _ITEM_SPRITES_WORLD["pistol"]) -> pygame.Surface:
        # Keep the held pistol consistent with the pickup sprite.
        return _src

    def _make_hand_gun_sprite(
        iid: str,
        fallback: pygame.Surface,
        _sprites_world: dict[str, pygame.Surface] = _ITEM_SPRITES_WORLD,
        _sprites_inv: dict[str, pygame.Surface] = _ITEM_SPRITES,
    ) -> pygame.Surface:
        # NOTE: Class-body helper functions don't close over class locals, so we
        # capture the dicts via default args to avoid NameError at import time.
        spr = _sprites_world.get(str(iid)) or _sprites_inv.get(str(iid))
        return spr if spr is not None else fallback

    _GUN_HAND_SPRITES: dict[str, pygame.Surface] = {
        "pistol": _make_hand_pistol_sprite(),
        "uzi": _make_hand_gun_sprite("uzi", _make_hand_pistol_sprite()),
        "ak47": _make_hand_gun_sprite("ak47", _make_hand_pistol_sprite()),
        "scar_l": _make_hand_gun_sprite("scar_l", _make_hand_pistol_sprite()),
        "rpg": _make_hand_gun_sprite("rpg", _make_hand_pistol_sprite()),
    }

    # Auto item sprites for the bulk item library.

    @staticmethod
    def _rgb_shift(col: tuple[int, int, int], dr: int = 0, dg: int = 0, db: int = 0) -> tuple[int, int, int]:
        r, g, b = int(col[0]) + int(dr), int(col[1]) + int(dg), int(col[2]) + int(db)
        return (int(clamp(r, 0, 255)), int(clamp(g, 0, 255)), int(clamp(b, 0, 255)))

    @staticmethod
    def _rgb_lerp(a: tuple[int, int, int], b: tuple[int, int, int], t: float) -> tuple[int, int, int]:
        t = float(clamp(float(t), 0.0, 1.0))
        return (
            int(clamp(int(round(float(a[0]) + (float(b[0]) - float(a[0])) * t)), 0, 255)),
            int(clamp(int(round(float(a[1]) + (float(b[1]) - float(a[1])) * t)), 0, 255)),
            int(clamp(int(round(float(a[2]) + (float(b[2]) - float(a[2])) * t)), 0, 255)),
        )

    @staticmethod
    def _make_item_icon_from_sprite(spr: pygame.Surface) -> pygame.Surface:
        bw, bh = int(spr.get_width()), int(spr.get_height())
        scale = min(8.0 / max(1.0, float(bw)), 8.0 / max(1.0, float(bh)))
        scale = float(min(1.0, float(scale)))
        tw = int(max(1, round(float(bw) * float(scale))))
        th = int(max(1, round(float(bh) * float(scale))))
        thumb = pygame.transform.scale(spr, (int(tw), int(th))) if (tw != bw or th != bh) else spr
        icon = pygame.Surface((8, 8), pygame.SRCALPHA)
        icon.blit(thumb, (int((8 - tw) // 2), int((8 - th) // 2)))
        return icon

    @staticmethod
    def _make_item_world_sprite(spr: pygame.Surface, *, max_px: int = 11) -> pygame.Surface:
        max_px = int(max(2, int(max_px)))
        sw, sh = int(spr.get_width()), int(spr.get_height())
        biggest = max(1, max(int(sw), int(sh)))
        scale = min(1.0, float(max_px) / float(biggest))
        if scale >= 1.0:
            return spr
        nw = max(1, int(round(float(sw) * float(scale))))
        nh = max(1, int(round(float(sh) * float(scale))))
        return pygame.transform.scale(spr, (int(nw), int(nh)))

    @staticmethod
    def _make_item_sprite_auto(item_id: str, idef) -> pygame.Surface:
        item_id = str(item_id or "")
        seed = 0
        for ch in item_id:
            seed = (seed * 131 + ord(ch)) & 0xFFFFFFFF

        base_col = (180, 180, 192)
        kind = ""
        if idef is not None:
            try:
                base_col = (int(idef.color[0]), int(idef.color[1]), int(idef.color[2]))
                kind = str(getattr(idef, "kind", ""))
            except Exception:
                pass

        outline = (10, 10, 12)

        if item_id in ("cup", "cup_water"):
            surf = pygame.Surface((12, 12), pygame.SRCALPHA)
            cup_col = (232, 232, 238)
            cup_sh = (200, 200, 210)
            water_col = (120, 170, 230)
            body = pygame.Rect(3, 4, 6, 6)
            pygame.draw.rect(surf, cup_col, body, border_radius=2)
            pygame.draw.rect(surf, outline, body, 1, border_radius=2)
            # Rim highlight + base shadow.
            surf.fill((245, 245, 250), pygame.Rect(body.x + 1, body.y + 1, body.w - 2, 1))
            surf.fill(cup_sh, pygame.Rect(body.x + 1, body.bottom - 2, body.w - 2, 1))
            # Handle.
            handle = pygame.Rect(body.right - 1, body.y + 2, 2, 3)
            pygame.draw.rect(surf, cup_col, handle, border_radius=1)
            pygame.draw.rect(surf, outline, handle, 1, border_radius=1)
            if item_id == "cup_water":
                fill = pygame.Rect(body.x + 1, body.y + 2, body.w - 2, body.h - 3)
                pygame.draw.rect(surf, water_col, fill, border_radius=1)
                pygame.draw.rect(surf, outline, fill, 1, border_radius=1)
            return surf

        def seed_sign(shift: int) -> int:
            return -1 if (((int(seed) >> int(shift)) & 1) == 1) else 1

        accent = HardcoreSurvivalState._rgb_shift(
            base_col,
            45 * seed_sign(3),
            30 * seed_sign(7),
            35 * seed_sign(11),
        )
        accent2 = HardcoreSurvivalState._rgb_shift(accent, -35, -35, -35)

        def make_can(*, label: tuple[int, int, int]) -> pygame.Surface:
            surf = pygame.Surface((14, 12), pygame.SRCALPHA)
            can_body = HardcoreSurvivalState._rgb_lerp((210, 170, 90), base_col, 0.35)
            can_shadow = HardcoreSurvivalState._rgb_shift(can_body, -35, -35, -35)
            pygame.draw.rect(surf, can_body, pygame.Rect(3, 2, 8, 9), border_radius=2)
            pygame.draw.rect(surf, outline, pygame.Rect(3, 2, 8, 9), 1, border_radius=2)
            pygame.draw.line(surf, can_shadow, (4, 3), (9, 3), 1)
            pygame.draw.rect(surf, label, pygame.Rect(4, 5, 6, 3), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(4, 5, 6, 3), 1, border_radius=1)
            ink = HardcoreSurvivalState._rgb_shift(label, 55, 55, 55)
            for xx in range(5, 9, 2):
                surf.set_at((xx, 6), ink)
            return surf

        def make_bottle(*, cap: tuple[int, int, int], liquid: tuple[int, int, int], label: tuple[int, int, int]) -> pygame.Surface:
            surf = pygame.Surface((12, 14), pygame.SRCALPHA)
            liq2 = HardcoreSurvivalState._rgb_shift(liquid, -30, -30, -30)
            cap2 = HardcoreSurvivalState._rgb_shift(cap, -25, -25, -25)
            pygame.draw.rect(surf, cap, pygame.Rect(4, 1, 4, 2), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(4, 1, 4, 2), 1, border_radius=1)
            pygame.draw.rect(surf, cap2, pygame.Rect(5, 3, 2, 2), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(5, 3, 2, 2), 1, border_radius=1)
            body = pygame.Rect(3, 5, 6, 8)
            pygame.draw.rect(surf, liquid, body, border_radius=3)
            pygame.draw.rect(surf, outline, body, 1, border_radius=3)
            band = pygame.Rect(3, 8, 6, 2)
            pygame.draw.rect(surf, label, band, border_radius=1)
            pygame.draw.rect(surf, outline, band, 1, border_radius=1)
            pygame.draw.line(surf, liq2, (4, 6), (4, 12), 1)
            pygame.draw.line(surf, cap, (8, 6), (8, 12), 1)
            return surf

        def make_carton(*, body: tuple[int, int, int], band: tuple[int, int, int]) -> pygame.Surface:
            surf = pygame.Surface((12, 14), pygame.SRCALPHA)
            b2 = HardcoreSurvivalState._rgb_shift(body, -30, -30, -30)
            hi = HardcoreSurvivalState._rgb_shift(body, 25, 25, 25)
            box = pygame.Rect(3, 2, 6, 11)
            pygame.draw.rect(surf, body, box, border_radius=2)
            pygame.draw.rect(surf, outline, box, 1, border_radius=2)
            pygame.draw.polygon(surf, hi, [(3, 3), (6, 1), (9, 3)])
            pygame.draw.polygon(surf, outline, [(3, 3), (6, 1), (9, 3)], 1)
            pygame.draw.rect(surf, band, pygame.Rect(3, 8, 6, 2), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(3, 8, 6, 2), 1, border_radius=1)
            surf.set_at((6, 9), (240, 240, 240))
            pygame.draw.line(surf, b2, (8, 4), (8, 12), 1)
            pygame.draw.line(surf, outline, (8, 6), (10, 4), 1)
            return surf

        def make_bag(*, body: tuple[int, int, int], band: tuple[int, int, int]) -> pygame.Surface:
            surf = pygame.Surface((14, 14), pygame.SRCALPHA)
            b2 = HardcoreSurvivalState._rgb_shift(body, -35, -35, -35)
            hi = HardcoreSurvivalState._rgb_shift(body, 30, 30, 30)
            pts = [(3, 2), (11, 2), (10, 12), (4, 12)]
            pygame.draw.polygon(surf, body, pts)
            pygame.draw.polygon(surf, outline, pts, 1)
            pygame.draw.line(surf, hi, (4, 3), (10, 3), 1)
            pygame.draw.rect(surf, band, pygame.Rect(4, 6, 6, 3), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(4, 6, 6, 3), 1, border_radius=1)
            pygame.draw.line(surf, b2, (5, 11), (9, 11), 1)
            return surf

        def make_box(*, body: tuple[int, int, int], band: tuple[int, int, int]) -> pygame.Surface:
            surf = pygame.Surface((14, 12), pygame.SRCALPHA)
            b2 = HardcoreSurvivalState._rgb_shift(body, -35, -35, -35)
            hi = HardcoreSurvivalState._rgb_shift(body, 35, 35, 35)
            box = pygame.Rect(2, 3, 10, 7)
            pygame.draw.rect(surf, body, box, border_radius=2)
            pygame.draw.rect(surf, outline, box, 1, border_radius=2)
            pygame.draw.rect(surf, hi, pygame.Rect(3, 4, 8, 1))
            pygame.draw.rect(surf, b2, pygame.Rect(3, 9, 8, 1))
            pygame.draw.rect(surf, band, pygame.Rect(4, 6, 6, 2), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(4, 6, 6, 2), 1, border_radius=1)
            return surf

        def make_pills(
            *,
            body: tuple[int, int, int],
            label: tuple[int, int, int] | None = None,
            symbol: str = "cross",
        ) -> pygame.Surface:
            surf = pygame.Surface((14, 12), pygame.SRCALPHA)
            cap = (230, 230, 240)
            b2 = HardcoreSurvivalState._rgb_shift(body, -25, -25, -25)
            bottle = pygame.Rect(4, 2, 6, 9)
            pygame.draw.rect(surf, body, bottle, border_radius=3)
            pygame.draw.rect(surf, outline, bottle, 1, border_radius=3)
            pygame.draw.rect(surf, cap, pygame.Rect(5, 1, 4, 2), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(5, 1, 4, 2), 1, border_radius=1)
            pygame.draw.line(surf, b2, (5, 8), (8, 8), 1)
            if label is not None:
                band = pygame.Rect(bottle.x + 1, bottle.y + 4, bottle.w - 2, 2)
                pygame.draw.rect(surf, label, band, border_radius=1)
                pygame.draw.rect(surf, outline, band, 1, border_radius=1)

            sym = str(symbol or "cross")
            sym_col = (220, 80, 90) if sym != "blue" else (90, 160, 230)
            sym_col = sym_col if sym != "green" else (90, 200, 140)
            sym_col = sym_col if sym != "yellow" else (232, 190, 90)
            if sym == "dot":
                pygame.draw.circle(surf, sym_col, (7, 7), 2)
            else:
                pygame.draw.rect(surf, sym_col, pygame.Rect(6, 5, 2, 4))
                pygame.draw.rect(surf, sym_col, pygame.Rect(5, 6, 4, 2))
            return surf

        def make_key(*, metal: tuple[int, int, int]) -> pygame.Surface:
            surf = pygame.Surface((14, 10), pygame.SRCALPHA)
            m2 = HardcoreSurvivalState._rgb_shift(metal, -30, -30, -30)
            pygame.draw.circle(surf, metal, (4, 5), 3)
            pygame.draw.circle(surf, outline, (4, 5), 3, 1)
            pygame.draw.circle(surf, (0, 0, 0, 0), (4, 5), 1)
            pygame.draw.rect(surf, metal, pygame.Rect(6, 4, 7, 2))
            pygame.draw.rect(surf, outline, pygame.Rect(6, 4, 7, 2), 1)
            pygame.draw.rect(surf, metal, pygame.Rect(11, 6, 2, 2))
            pygame.draw.rect(surf, metal, pygame.Rect(9, 6, 1, 2))
            pygame.draw.line(surf, m2, (6, 5), (12, 5), 1)
            return surf

        def make_gas_can(*, body: tuple[int, int, int]) -> pygame.Surface:
            surf = pygame.Surface((14, 14), pygame.SRCALPHA)
            b2 = HardcoreSurvivalState._rgb_shift(body, -35, -35, -35)
            hi = HardcoreSurvivalState._rgb_shift(body, 30, 30, 30)
            can = pygame.Rect(3, 3, 8, 9)
            pygame.draw.rect(surf, body, can, border_radius=2)
            pygame.draw.rect(surf, outline, can, 1, border_radius=2)
            pygame.draw.rect(surf, hi, pygame.Rect(5, 2, 4, 2), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(5, 2, 4, 2), 1, border_radius=1)
            pygame.draw.rect(surf, b2, pygame.Rect(9, 4, 3, 2), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(9, 4, 3, 2), 1, border_radius=1)
            mark = (240, 240, 240)
            pygame.draw.line(surf, mark, (5, 6), (9, 10), 1)
            pygame.draw.line(surf, mark, (9, 6), (5, 10), 1)
            return surf

        def make_simple_tool(*, tool: str, body: tuple[int, int, int]) -> pygame.Surface:
            surf = pygame.Surface((16, 12), pygame.SRCALPHA)
            steel = (220, 220, 230)
            handle = body
            handle2 = HardcoreSurvivalState._rgb_shift(handle, -30, -30, -30)
            if tool == "flashlight":
                pygame.draw.rect(surf, handle, pygame.Rect(3, 5, 9, 4), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 5, 9, 4), 1, border_radius=2)
                pygame.draw.rect(surf, steel, pygame.Rect(12, 5, 2, 4), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(12, 5, 2, 4), 1, border_radius=1)
                pygame.draw.line(surf, handle2, (4, 8), (10, 8), 1)
                return surf
            if tool == "knife":
                pygame.draw.rect(surf, steel, pygame.Rect(3, 6, 9, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 6, 9, 2), 1, border_radius=1)
                pygame.draw.rect(surf, handle, pygame.Rect(12, 5, 2, 4), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(12, 5, 2, 4), 1, border_radius=1)
                return surf
            if tool == "hammer":
                pygame.draw.rect(surf, handle, pygame.Rect(7, 3, 2, 8), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(7, 3, 2, 8), 1, border_radius=1)
                pygame.draw.rect(surf, steel, pygame.Rect(4, 3, 8, 3), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(4, 3, 8, 3), 1, border_radius=1)
                pygame.draw.line(surf, handle2, (8, 5), (8, 10), 1)
                return surf
            if tool == "wrench":
                pygame.draw.polygon(surf, steel, [(4, 4), (7, 4), (12, 9), (9, 9)])
                pygame.draw.polygon(surf, outline, [(4, 4), (7, 4), (12, 9), (9, 9)], 1)
                pygame.draw.circle(surf, steel, (4, 4), 2)
                pygame.draw.circle(surf, outline, (4, 4), 2, 1)
                return surf
            if tool == "screwdriver":
                pygame.draw.rect(surf, handle, pygame.Rect(3, 6, 6, 3), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 6, 6, 3), 1, border_radius=2)
                pygame.draw.rect(surf, steel, pygame.Rect(9, 7, 5, 1))
                pygame.draw.rect(surf, outline, pygame.Rect(9, 7, 5, 1), 1)
                pygame.draw.line(surf, handle2, (4, 8), (7, 8), 1)
                return surf
            if tool == "crowbar":
                pygame.draw.line(surf, steel, (4, 9), (12, 3), 2)
                pygame.draw.line(surf, outline, (4, 9), (12, 3), 1)
                pygame.draw.line(surf, steel, (12, 3), (13, 4), 1)
                pygame.draw.line(surf, outline, (12, 3), (13, 4), 1)
                return surf
            if tool == "saw":
                pygame.draw.rect(surf, handle, pygame.Rect(3, 7, 4, 4), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 7, 4, 4), 1, border_radius=2)
                pygame.draw.rect(surf, steel, pygame.Rect(6, 4, 8, 4), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(6, 4, 8, 4), 1, border_radius=1)
                for xx in range(7, 14, 2):
                    surf.set_at((xx, 8), outline)
                return surf
            return make_box(body=body, band=HardcoreSurvivalState._rgb_shift(body, 45, 45, 45))

        def make_furniture(*, fkind: str, variant: str) -> pygame.Surface:
            surf = pygame.Surface((16, 16), pygame.SRCALPHA)
            col = base_col
            if variant == "old":
                col = HardcoreSurvivalState._rgb_shift(col, -25, -25, -25)
            elif variant == "new":
                col = HardcoreSurvivalState._rgb_shift(col, 20, 20, 20)
            elif variant == "broken":
                col = HardcoreSurvivalState._rgb_shift(col, -10, -10, -10)
            col2 = HardcoreSurvivalState._rgb_shift(col, -30, -30, -30)
            hi = HardcoreSurvivalState._rgb_shift(col, 25, 25, 25)
            steel = (220, 220, 230)
            if fkind == "chair":
                pygame.draw.rect(surf, col, pygame.Rect(5, 6, 6, 6), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(5, 6, 6, 6), 1, border_radius=2)
                pygame.draw.rect(surf, col2, pygame.Rect(5, 4, 6, 3), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(5, 4, 6, 3), 1, border_radius=1)
            elif fkind == "table":
                pygame.draw.rect(surf, col, pygame.Rect(3, 5, 10, 4), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 5, 10, 4), 1, border_radius=2)
                for xx in (5, 11):
                    pygame.draw.line(surf, col2, (xx, 9), (xx, 14), 1)
            elif fkind == "sofa":
                pygame.draw.rect(surf, col, pygame.Rect(3, 7, 10, 6), border_radius=3)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 7, 10, 6), 1, border_radius=3)
                pygame.draw.rect(surf, hi, pygame.Rect(4, 8, 8, 2), border_radius=1)
            elif fkind == "bed":
                pygame.draw.rect(surf, col, pygame.Rect(3, 6, 10, 7), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 6, 10, 7), 1, border_radius=2)
                pygame.draw.rect(surf, (240, 240, 240), pygame.Rect(4, 7, 4, 2), border_radius=1)
                pygame.draw.line(surf, col2, (4, 12), (12, 12), 1)
            elif fkind in ("cabinet", "wardrobe", "fridge"):
                pygame.draw.rect(surf, col, pygame.Rect(4, 3, 8, 11), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(4, 3, 8, 11), 1, border_radius=2)
                pygame.draw.line(surf, col2, (8, 4), (8, 13), 1)
                surf.set_at((7, 8), steel)
                surf.set_at((9, 8), steel)
            else:
                pygame.draw.rect(surf, col, pygame.Rect(4, 4, 8, 10), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(4, 4, 8, 10), 1, border_radius=2)
            pygame.draw.line(surf, hi, (5, 5), (10, 5), 1)
            if variant == "broken":
                pygame.draw.line(surf, outline, (5, 11), (11, 7), 1)
            return surf

        # choose by kind/id
        if kind == "key":
            return make_key(metal=HardcoreSurvivalState._rgb_lerp((220, 220, 240), base_col, 0.4))
        if kind == "fuel":
            return make_gas_can(body=HardcoreSurvivalState._rgb_lerp((220, 80, 70), base_col, 0.35))
        if kind == "ammo":
            if item_id == "ammo_rocket":
                surf = pygame.Surface((18, 12), pygame.SRCALPHA)
                tube = HardcoreSurvivalState._rgb_lerp((120, 120, 132), base_col, 0.55)
                tube2 = HardcoreSurvivalState._rgb_shift(tube, -28, -28, -28)
                nose = HardcoreSurvivalState._rgb_lerp((240, 140, 100), base_col, 0.25)
                nose2 = HardcoreSurvivalState._rgb_shift(nose, -28, -18, -18)
                pygame.draw.rect(surf, tube, pygame.Rect(3, 5, 12, 4), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 5, 12, 4), 1, border_radius=2)
                pygame.draw.rect(surf, tube2, pygame.Rect(3, 8, 12, 1), border_radius=1)
                pygame.draw.polygon(surf, nose, [(15, 5), (17, 7), (15, 9)])
                pygame.draw.polygon(surf, outline, [(15, 5), (17, 7), (15, 9)], 1)
                pygame.draw.line(surf, nose2, (15, 6), (16, 7), 1)
                # fins
                pygame.draw.line(surf, outline, (4, 4), (6, 5), 1)
                pygame.draw.line(surf, outline, (4, 10), (6, 9), 1)
                return surf
            box = HardcoreSurvivalState._rgb_lerp((120, 120, 132), base_col, 0.55)
            brass = (230, 220, 140)
            surf = pygame.Surface((16, 12), pygame.SRCALPHA)
            pygame.draw.rect(surf, box, pygame.Rect(2, 4, 12, 6), border_radius=2)
            pygame.draw.rect(surf, outline, pygame.Rect(2, 4, 12, 6), 1, border_radius=2)
            pygame.draw.rect(surf, HardcoreSurvivalState._rgb_shift(box, -28, -28, -28), pygame.Rect(2, 8, 12, 2), border_radius=1)
            for i in range(3):
                xx = 4 + i * 3
                pygame.draw.rect(surf, brass, pygame.Rect(xx, 2, 2, 4))
                pygame.draw.rect(surf, outline, pygame.Rect(xx, 2, 2, 4), 1)
            return surf
        if kind == "melee":
            surf = pygame.Surface((16, 12), pygame.SRCALPHA)
            col = HardcoreSurvivalState._rgb_lerp((200, 200, 210), base_col, 0.35)
            col2 = HardcoreSurvivalState._rgb_shift(col, -30, -30, -30)
            hi = HardcoreSurvivalState._rgb_shift(col, 30, 30, 30)
            wood = HardcoreSurvivalState._rgb_lerp((150, 110, 70), base_col, 0.20)
            if item_id == "melee_machete":
                pygame.draw.line(surf, col, (3, 9), (13, 3), 3)
                pygame.draw.line(surf, outline, (3, 9), (13, 3), 1)
                pygame.draw.line(surf, hi, (4, 8), (12, 4), 1)
                pygame.draw.rect(surf, wood, pygame.Rect(2, 8, 3, 3), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(2, 8, 3, 3), 1, border_radius=1)
                return surf
            if item_id == "melee_pipe":
                pygame.draw.line(surf, col, (3, 9), (13, 3), 3)
                pygame.draw.line(surf, outline, (3, 9), (13, 3), 1)
                pygame.draw.line(surf, col2, (4, 9), (12, 4), 1)
                return surf
            # club / bat (default)
            pygame.draw.line(surf, wood, (3, 9), (13, 3), 3)
            pygame.draw.line(surf, outline, (3, 9), (13, 3), 1)
            pygame.draw.line(surf, HardcoreSurvivalState._rgb_shift(wood, 22, 18, 12), (4, 8), (12, 4), 1)
            return surf
        if kind == "clothes":
            surf = pygame.Surface((14, 12), pygame.SRCALPHA)
            body = HardcoreSurvivalState._rgb_lerp((200, 200, 210), base_col, 0.35)
            body2 = HardcoreSurvivalState._rgb_shift(body, -30, -30, -30)
            hi = HardcoreSurvivalState._rgb_shift(body, 30, 30, 30)
            # sleeves
            pygame.draw.rect(surf, body2, pygame.Rect(1, 4, 4, 3), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(1, 4, 4, 3), 1, border_radius=1)
            pygame.draw.rect(surf, body2, pygame.Rect(9, 4, 4, 3), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(9, 4, 4, 3), 1, border_radius=1)
            # torso
            pygame.draw.rect(surf, body, pygame.Rect(4, 3, 6, 8), border_radius=2)
            pygame.draw.rect(surf, outline, pygame.Rect(4, 3, 6, 8), 1, border_radius=2)
            pygame.draw.line(surf, hi, (5, 4), (8, 4), 1)
            return surf
        if kind == "gun":
            # keep guns consistent with the pistol sprite style, but differentiate silhouettes
            dark = (62, 62, 72)
            mid = (92, 92, 104)
            hi = (150, 150, 162)
            if item_id in ("ak47", "scar_l"):
                surf = pygame.Surface((22, 12), pygame.SRCALPHA)
                pygame.draw.rect(surf, dark, pygame.Rect(2, 4, 16, 3))
                pygame.draw.rect(surf, hi, pygame.Rect(3, 5, 14, 1))
                pygame.draw.rect(surf, outline, pygame.Rect(2, 4, 16, 3), 1)
                # stock
                pygame.draw.rect(surf, mid, pygame.Rect(1, 5, 3, 4), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(1, 5, 3, 4), 1, border_radius=1)
                # mag
                pygame.draw.rect(surf, mid, pygame.Rect(9, 7, 3, 4), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(9, 7, 3, 4), 1, border_radius=1)
                surf.set_at((18, 6), outline)
                return surf
            if item_id == "uzi":
                surf = pygame.Surface((20, 12), pygame.SRCALPHA)
                pygame.draw.rect(surf, dark, pygame.Rect(3, 4, 12, 3))
                pygame.draw.rect(surf, outline, pygame.Rect(3, 4, 12, 3), 1)
                pygame.draw.rect(surf, mid, pygame.Rect(6, 7, 3, 4), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(6, 7, 3, 4), 1, border_radius=1)
                pygame.draw.rect(surf, hi, pygame.Rect(4, 5, 10, 1))
                surf.set_at((15, 6), outline)
                return surf
            if item_id == "rpg":
                surf = pygame.Surface((22, 12), pygame.SRCALPHA)
                tube = HardcoreSurvivalState._rgb_lerp((120, 120, 132), base_col, 0.45)
                tube2 = HardcoreSurvivalState._rgb_shift(tube, -28, -28, -28)
                pygame.draw.rect(surf, tube, pygame.Rect(2, 5, 18, 4), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(2, 5, 18, 4), 1, border_radius=2)
                pygame.draw.rect(surf, tube2, pygame.Rect(2, 8, 18, 1), border_radius=1)
                pygame.draw.rect(surf, mid, pygame.Rect(7, 8, 4, 3), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(7, 8, 4, 3), 1, border_radius=1)
                return surf
            return HardcoreSurvivalState._make_item_sprite_pistol()
        if kind == "gun_mod":
            surf = pygame.Surface((16, 12), pygame.SRCALPHA)
            body = HardcoreSurvivalState._rgb_lerp((92, 92, 104), base_col, 0.35)
            hi2 = HardcoreSurvivalState._rgb_shift(body, 25, 25, 25)
            pygame.draw.rect(surf, body, pygame.Rect(3, 5, 10, 4), border_radius=2)
            pygame.draw.rect(surf, outline, pygame.Rect(3, 5, 10, 4), 1, border_radius=2)
            pygame.draw.rect(surf, hi2, pygame.Rect(4, 6, 8, 1), border_radius=1)
            # tiny rail notch
            pygame.draw.line(surf, outline, (5, 4), (11, 4), 1)
            return surf
        if kind == "med":
            iid = item_id
            # Use stronger label colors so meds don't all look identical.
            lab_pal = [
                (90, 160, 230),  # blue
                (232, 190, 90),  # yellow
                (90, 200, 140),  # green
                (180, 120, 220),  # purple
                (220, 80, 90),  # red
                (200, 200, 210),  # gray
            ]
            lab = lab_pal[int(seed % len(lab_pal))]
            lab = HardcoreSurvivalState._rgb_lerp(lab, accent, 0.25)

            if iid == "medkit":
                surf = make_box(body=HardcoreSurvivalState._rgb_lerp((240, 120, 120), base_col, 0.35), band=lab)
                white = (240, 240, 240)
                cx, cy = 7, 7
                pygame.draw.rect(surf, white, pygame.Rect(cx - 1, cy - 3, 2, 7))
                pygame.draw.rect(surf, white, pygame.Rect(cx - 3, cy - 1, 7, 2))
                pygame.draw.rect(surf, outline, pygame.Rect(cx - 3, cy - 3, 7, 7), 1)
                return surf

            if iid == "bandage" or ("bandage" in iid and "wipe" not in iid):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                cloth = (235, 235, 242)
                cloth2 = (200, 200, 210)
                roll = pygame.Rect(3, 4, 8, 5)
                pygame.draw.rect(surf, cloth, roll, border_radius=3)
                pygame.draw.rect(surf, outline, roll, 1, border_radius=3)
                pygame.draw.line(surf, cloth2, (4, 6), (10, 6), 1)
                pygame.draw.line(surf, cloth2, (4, 8), (10, 8), 1)
                pad = pygame.Rect(5, 5, 4, 3)
                pygame.draw.rect(surf, lab, pad, border_radius=1)
                pygame.draw.rect(surf, outline, pad, 1, border_radius=1)
                return surf

            if "splint" in iid:
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                wood = HardcoreSurvivalState._rgb_lerp((150, 110, 70), base_col, 0.35)
                wood2 = HardcoreSurvivalState._rgb_shift(wood, -30, -30, -30)
                pygame.draw.rect(surf, wood, pygame.Rect(3, 3, 3, 8), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 3, 3, 8), 1, border_radius=1)
                pygame.draw.rect(surf, wood, pygame.Rect(8, 3, 3, 8), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(8, 3, 3, 8), 1, border_radius=1)
                wrap = (235, 235, 242)
                pygame.draw.rect(surf, wrap, pygame.Rect(2, 6, 10, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(2, 6, 10, 2), 1, border_radius=1)
                pygame.draw.line(surf, wood2, (4, 10), (10, 10), 1)
                return surf

            if "antacid" in iid or "antidiarrheal" in iid or "charcoal" in iid:
                # Blister pack.
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                pack = (210, 210, 220)
                pack2 = (180, 180, 192)
                r = pygame.Rect(2, 3, 10, 7)
                pygame.draw.rect(surf, pack, r, border_radius=2)
                pygame.draw.rect(surf, outline, r, 1, border_radius=2)
                surf.fill(pack2, pygame.Rect(r.x + 1, r.bottom - 2, r.w - 2, 1))
                pill = (90, 200, 140) if "antacid" in iid else ((232, 190, 90) if "antidiarrheal" in iid else (90, 160, 230))
                for cx in (5, 8, 11):
                    pygame.draw.circle(surf, pill, (int(cx), 6), 2, 1)
                return surf

            if "ointment" in iid or "burncream" in iid:
                surf = pygame.Surface((16, 10), pygame.SRCALPHA)
                body = HardcoreSurvivalState._rgb_lerp((230, 230, 240), base_col, 0.35)
                tube = pygame.Rect(3, 3, 10, 4)
                pygame.draw.rect(surf, body, tube, border_radius=2)
                pygame.draw.rect(surf, outline, tube, 1, border_radius=2)
                cap = pygame.Rect(13, 4, 2, 2)
                pygame.draw.rect(surf, (90, 90, 104), cap, border_radius=1)
                pygame.draw.rect(surf, outline, cap, 1, border_radius=1)
                band = pygame.Rect(4, 4, 5, 2)
                pygame.draw.rect(surf, lab, band, border_radius=1)
                pygame.draw.rect(surf, outline, band, 1, border_radius=1)
                return surf

            if "wipe" in iid or "alcohol" in iid:
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                pack = HardcoreSurvivalState._rgb_lerp((180, 180, 192), base_col, 0.35)
                r = pygame.Rect(2, 4, 10, 6)
                pygame.draw.rect(surf, pack, r, border_radius=2)
                pygame.draw.rect(surf, outline, r, 1, border_radius=2)
                flap = pygame.Rect(4, 5, 6, 2)
                pygame.draw.rect(surf, lab, flap, border_radius=1)
                pygame.draw.rect(surf, outline, flap, 1, border_radius=1)
                surf.set_at((10, 8), (240, 240, 240))
                return surf

            if "saline" in iid or "glucose" in iid:
                # Simple IV bag.
                surf = pygame.Surface((12, 14), pygame.SRCALPHA)
                bag = (235, 235, 242)
                bag2 = (200, 200, 210)
                r = pygame.Rect(3, 2, 6, 10)
                pygame.draw.rect(surf, bag, r, border_radius=2)
                pygame.draw.rect(surf, outline, r, 1, border_radius=2)
                liquid = (90, 160, 230) if "saline" in iid else (232, 190, 90)
                pygame.draw.rect(surf, liquid, pygame.Rect(r.x + 1, r.y + 4, r.w - 2, 6), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(r.x + 1, r.y + 4, r.w - 2, 6), 1, border_radius=1)
                pygame.draw.line(surf, bag2, (6, 1), (6, 2), 1)
                pygame.draw.line(surf, outline, (6, 1), (6, 2), 1)
                pygame.draw.line(surf, outline, (6, 12), (6, 14), 1)
                return surf

            if "iodine" in iid or "antiseptic" in iid:
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                bottle = pygame.Rect(5, 2, 4, 9)
                liquid = (150, 90, 60) if "iodine" in iid else (90, 120, 150)
                pygame.draw.rect(surf, liquid, bottle, border_radius=2)
                pygame.draw.rect(surf, outline, bottle, 1, border_radius=2)
                pygame.draw.rect(surf, (230, 230, 236), pygame.Rect(5, 1, 4, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(5, 1, 4, 2), 1, border_radius=1)
                pygame.draw.rect(surf, lab, pygame.Rect(5, 6, 4, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(5, 6, 4, 2), 1, border_radius=1)
                return surf

            if "eye" in iid:
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                bottle = pygame.Rect(5, 2, 4, 9)
                body = (230, 230, 236)
                pygame.draw.rect(surf, body, bottle, border_radius=2)
                pygame.draw.rect(surf, outline, bottle, 1, border_radius=2)
                pygame.draw.rect(surf, (90, 160, 230), pygame.Rect(5, 6, 4, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(5, 6, 4, 2), 1, border_radius=1)
                drop = (90, 160, 230)
                pygame.draw.circle(surf, drop, (10, 9), 1)
                return surf

            if "thermometer" in iid:
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                pygame.draw.line(surf, (230, 230, 236), (7, 3), (7, 9), 1)
                pygame.draw.line(surf, outline, (7, 3), (7, 9), 1)
                pygame.draw.circle(surf, (220, 80, 90), (7, 10), 2)
                pygame.draw.circle(surf, outline, (7, 10), 2, 1)
                return surf

            if "mask" in iid:
                surf = pygame.Surface((14, 10), pygame.SRCALPHA)
                cloth = (235, 235, 242)
                cloth2 = (200, 200, 210)
                pygame.draw.rect(surf, cloth, pygame.Rect(4, 3, 6, 4), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(4, 3, 6, 4), 1, border_radius=2)
                pygame.draw.line(surf, cloth2, (2, 4), (4, 4), 1)
                pygame.draw.line(surf, cloth2, (10, 4), (12, 4), 1)
                pygame.draw.line(surf, cloth2, (2, 6), (4, 6), 1)
                pygame.draw.line(surf, cloth2, (10, 6), (12, 6), 1)
                return surf
            if "gloves" in iid:
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                glove = (235, 235, 242)
                glove2 = (200, 200, 210)
                pygame.draw.rect(surf, glove, pygame.Rect(3, 4, 4, 6), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 4, 4, 6), 1, border_radius=2)
                pygame.draw.rect(surf, glove, pygame.Rect(7, 3, 4, 7), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(7, 3, 4, 7), 1, border_radius=2)
                pygame.draw.line(surf, glove2, (4, 9), (6, 9), 1)
                pygame.draw.line(surf, glove2, (8, 9), (10, 9), 1)
                return surf
            if "syringe" in iid:
                surf = pygame.Surface((16, 10), pygame.SRCALPHA)
                steel = (230, 230, 236)
                pygame.draw.rect(surf, steel, pygame.Rect(3, 4, 9, 2))
                pygame.draw.rect(surf, outline, pygame.Rect(3, 4, 9, 2), 1)
                pygame.draw.line(surf, outline, (12, 5), (15, 5), 1)
                pygame.draw.line(surf, steel, (2, 3), (2, 7), 1)
                pygame.draw.line(surf, outline, (2, 3), (2, 7), 1)
                return surf
            # Default pill bottle with item-specific label/symbol so medicines differ.
            sym = "cross"
            if "antibiotic" in iid:
                sym = "blue"
            elif "vitamin" in iid:
                sym = "yellow"
            elif "sleep" in iid:
                sym = "dot"
            elif "pain" in iid:
                sym = "cross"
            elif "allergy" in iid:
                sym = "green"
            return make_pills(body=HardcoreSurvivalState._rgb_lerp((230, 230, 240), base_col, 0.35), label=lab, symbol=sym)
        if kind == "drink":
            parts = item_id.split("_")
            base = parts[1] if len(parts) >= 3 and parts[0] == "drink" else item_id
            flavor = parts[2] if len(parts) >= 3 and parts[0] == "drink" else ""

            # Flavor-coded label so drinks read differently at a glance.
            flavor_col = {
                "plain": accent,
                "lemon": (232, 190, 90),
                "orange": (230, 140, 70),
                "grape": (160, 110, 220),
                "peach": (232, 160, 190),
                "sugarfree": (170, 190, 190),
            }.get(str(flavor), accent)
            label = HardcoreSurvivalState._rgb_lerp(accent, flavor_col, 0.8)

            cap = (230, 230, 236)
            if base in ("water", "water_mineral", "sparkling"):
                cap = (120, 170, 230)
            elif base in ("tea",):
                cap = (90, 200, 140)
            elif base in ("coffee",):
                cap = (200, 170, 120)
            elif base in ("energy",):
                cap = (232, 190, 90)

            # Container silhouettes by type.
            if base in ("milk", "soymilk", "cocoa", "milk_choco"):
                body = HardcoreSurvivalState._rgb_lerp((240, 240, 240), base_col, 0.35)
                return make_carton(body=body, band=label)
            if base in ("beer", "wine"):
                liquid = HardcoreSurvivalState._rgb_lerp(base_col, (110, 80, 60) if base == "beer" else (150, 70, 90), 0.35)
                return make_bottle(cap=cap, liquid=liquid, label=label)
            if base in ("soda", "energy", "cola"):
                return make_can(label=label)
            return make_bottle(cap=cap, liquid=base_col, label=label)
        if kind == "food":
            parts = item_id.split("_")
            base = parts[1] if len(parts) >= 3 and parts[0] == "food" else item_id
            flavor = parts[2] if len(parts) >= 3 and parts[0] == "food" else ""

            # Flavor-coded label so variants read differently at a glance.
            flavor_col = {
                "plain": accent,
                "spicy": (230, 92, 72),
                "tomato": (230, 78, 86),
                "curry": (232, 190, 90),
                "garlic": (230, 230, 214),
                "bbq": (184, 124, 78),
                "pepper": (130, 130, 142),
                "sweet": (232, 160, 190),
            }.get(str(flavor), accent)
            label = HardcoreSurvivalState._rgb_lerp(accent, flavor_col, 0.75)
            ink = HardcoreSurvivalState._rgb_shift(label, 70, 70, 70)

            def blit_pat_centered(surf: pygame.Surface, rect: pygame.Rect, pat: list[str], col: tuple[int, int, int]) -> None:
                if not pat:
                    return
                pw = max(len(r) for r in pat)
                ph = len(pat)
                ox = int(rect.x + max(0, (int(rect.w) - int(pw)) // 2))
                oy = int(rect.y + max(0, (int(rect.h) - int(ph)) // 2))
                sw, sh = int(surf.get_width()), int(surf.get_height())
                for yy, row in enumerate(pat):
                    for xx, ch in enumerate(row):
                        if ch != "#":
                            continue
                        px = int(ox + xx)
                        py = int(oy + yy)
                        if 0 <= px < sw and 0 <= py < sh:
                            surf.set_at((px, py), col)

            # More distinct silhouettes for common foods.
            if base in ("bread",):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                crust = HardcoreSurvivalState._rgb_lerp((190, 132, 78), base_col, 0.45)
                crumb = HardcoreSurvivalState._rgb_shift(crust, 28, 28, 28)
                loaf = pygame.Rect(2, 4, 10, 6)
                pygame.draw.rect(surf, crust, loaf, border_radius=3)
                pygame.draw.rect(surf, outline, loaf, 1, border_radius=3)
                pygame.draw.rect(surf, crumb, pygame.Rect(loaf.x + 1, loaf.y + 1, loaf.w - 2, 1))
                for xx in (5, 8):
                    pygame.draw.line(surf, HardcoreSurvivalState._rgb_shift(crust, -22, -22, -22), (xx, loaf.y + 2), (xx, loaf.bottom - 2), 1)
                tag = pygame.Rect(5, 6, 4, 2)
                pygame.draw.rect(surf, label, tag, border_radius=1)
                pygame.draw.rect(surf, outline, tag, 1, border_radius=1)
                return surf
            if base in ("cheese",):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                cheese = HardcoreSurvivalState._rgb_lerp((232, 210, 110), base_col, 0.35)
                cheese2 = HardcoreSurvivalState._rgb_shift(cheese, -35, -35, -35)
                pts = [(3, 10), (11, 7), (11, 11)]
                pygame.draw.polygon(surf, cheese, pts)
                pygame.draw.polygon(surf, outline, pts, 1)
                pygame.draw.line(surf, cheese2, (6, 10), (11, 7), 1)
                for px, py in ((7, 9), (9, 10), (8, 11)):
                    surf.set_at((px, py), HardcoreSurvivalState._rgb_shift(cheese, -55, -55, -55))
                return surf
            if base in ("pickles", "nuts"):
                # Small jar (pickles / nuts).
                surf = pygame.Surface((12, 14), pygame.SRCALPHA)
                cap = (220, 220, 230)
                jar = (110, 170, 110) if base == "pickles" else HardcoreSurvivalState._rgb_lerp((160, 120, 80), base_col, 0.35)
                jar2 = HardcoreSurvivalState._rgb_shift(jar, -30, -30, -30)
                pygame.draw.rect(surf, cap, pygame.Rect(4, 1, 4, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(4, 1, 4, 2), 1, border_radius=1)
                body = pygame.Rect(3, 3, 6, 10)
                pygame.draw.rect(surf, jar, body, border_radius=3)
                pygame.draw.rect(surf, outline, body, 1, border_radius=3)
                band = pygame.Rect(3, 8, 6, 2)
                pygame.draw.rect(surf, label, band, border_radius=1)
                pygame.draw.rect(surf, outline, band, 1, border_radius=1)
                pygame.draw.line(surf, jar2, (4, 5), (4, 12), 1)
                return surf
            if base in ("energybar", "chocolate"):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                wrap = HardcoreSurvivalState._rgb_lerp((210, 170, 90), base_col, 0.35)
                wrap2 = HardcoreSurvivalState._rgb_shift(wrap, -35, -35, -35)
                bar = pygame.Rect(2, 5, 10, 4)
                pygame.draw.rect(surf, wrap, bar, border_radius=2)
                pygame.draw.rect(surf, outline, bar, 1, border_radius=2)
                pygame.draw.line(surf, wrap2, (3, 8), (10, 8), 1)
                band = pygame.Rect(4, 6, 6, 2)
                pygame.draw.rect(surf, label, band, border_radius=1)
                pygame.draw.rect(surf, outline, band, 1, border_radius=1)
                if base == "chocolate":
                    cocoa = HardcoreSurvivalState._rgb_lerp((110, 70, 60), base_col, 0.35)
                    pygame.draw.rect(surf, cocoa, pygame.Rect(3, 4, 8, 4), border_radius=1)
                    pygame.draw.rect(surf, outline, pygame.Rect(3, 4, 8, 4), 1, border_radius=1)
                    for xx in (6, 8):
                        pygame.draw.line(surf, HardcoreSurvivalState._rgb_shift(cocoa, -30, -30, -30), (xx, 5), (xx, 7), 1)
                return surf
            if base in ("candy",):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                wrap = HardcoreSurvivalState._rgb_lerp((232, 160, 190), base_col, 0.35)
                wrap2 = HardcoreSurvivalState._rgb_shift(wrap, -35, -35, -35)
                core = pygame.Rect(4, 5, 6, 4)
                pygame.draw.rect(surf, wrap, core, border_radius=2)
                pygame.draw.rect(surf, outline, core, 1, border_radius=2)
                pygame.draw.polygon(surf, wrap2, [(3, 6), (4, 5), (4, 9)])
                pygame.draw.polygon(surf, wrap2, [(10, 5), (10, 9), (11, 6)])
                pygame.draw.polygon(surf, outline, [(3, 6), (4, 5), (4, 9)], 1)
                pygame.draw.polygon(surf, outline, [(10, 5), (10, 9), (11, 6)], 1)
                band = pygame.Rect(5, 6, 4, 2)
                pygame.draw.rect(surf, label, band, border_radius=1)
                pygame.draw.rect(surf, outline, band, 1, border_radius=1)
                return surf
            if base in ("mealbox",):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                box = HardcoreSurvivalState._rgb_lerp((220, 220, 230), base_col, 0.35)
                box2 = HardcoreSurvivalState._rgb_shift(box, -35, -35, -35)
                br = pygame.Rect(2, 4, 10, 7)
                pygame.draw.rect(surf, box, br, border_radius=2)
                pygame.draw.rect(surf, outline, br, 1, border_radius=2)
                pygame.draw.rect(surf, box2, pygame.Rect(br.x + 1, br.y + 4, br.w - 2, 2), border_radius=1)
                pygame.draw.line(surf, outline, (br.x + 5, br.y + 1), (br.x + 5, br.bottom - 2), 1)
                band = pygame.Rect(4, 6, 6, 2)
                pygame.draw.rect(surf, label, band, border_radius=1)
                pygame.draw.rect(surf, outline, band, 1, border_radius=1)
                return surf
            if base in ("mre",):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                pouch = HardcoreSurvivalState._rgb_lerp((120, 140, 110), base_col, 0.35)
                pouch2 = HardcoreSurvivalState._rgb_shift(pouch, -30, -30, -30)
                pr = pygame.Rect(3, 3, 8, 8)
                pygame.draw.rect(surf, pouch, pr, border_radius=2)
                pygame.draw.rect(surf, outline, pr, 1, border_radius=2)
                pygame.draw.line(surf, outline, (pr.x + 1, pr.y + 2), (pr.right - 2, pr.y + 2), 1)
                pygame.draw.line(surf, pouch2, (pr.x + 1, pr.bottom - 2), (pr.right - 2, pr.bottom - 2), 1)
                band = pygame.Rect(4, 6, 6, 2)
                pygame.draw.rect(surf, label, band, border_radius=1)
                pygame.draw.rect(surf, outline, band, 1, border_radius=1)
                return surf
            if base in ("seaweed",):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                pack = HardcoreSurvivalState._rgb_lerp((70, 110, 80), base_col, 0.35)
                pack2 = HardcoreSurvivalState._rgb_shift(pack, -35, -35, -35)
                pr = pygame.Rect(3, 4, 8, 7)
                pygame.draw.rect(surf, pack, pr, border_radius=2)
                pygame.draw.rect(surf, outline, pr, 1, border_radius=2)
                pygame.draw.line(surf, pack2, (4, 9), (10, 9), 1)
                band = pygame.Rect(4, 6, 6, 2)
                pygame.draw.rect(surf, label, band, border_radius=1)
                pygame.draw.rect(surf, outline, band, 1, border_radius=1)
                return surf

            if base in ("riceball",):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                rice = (240, 240, 240)
                wrap = accent2
                pygame.draw.polygon(surf, rice, [(7, 2), (12, 11), (2, 11)])
                pygame.draw.polygon(surf, outline, [(7, 2), (12, 11), (2, 11)], 1)
                pygame.draw.rect(surf, wrap, pygame.Rect(6, 7, 3, 3), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(6, 7, 3, 3), 1, border_radius=1)
                return surf
            if base in ("sausage",):
                surf = pygame.Surface((14, 10), pygame.SRCALPHA)
                meat = HardcoreSurvivalState._rgb_lerp((200, 120, 120), base_col, 0.45)
                meat2 = HardcoreSurvivalState._rgb_shift(meat, -30, -30, -30)
                pygame.draw.rect(surf, meat, pygame.Rect(2, 4, 10, 3), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(2, 4, 10, 3), 1, border_radius=2)
                pygame.draw.line(surf, meat2, (3, 6), (10, 6), 1)
                return surf
            if base in ("noodle",):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                cup = HardcoreSurvivalState._rgb_lerp((240, 240, 240), base_col, 0.35)
                cup2 = HardcoreSurvivalState._rgb_shift(cup, -30, -30, -30)
                pygame.draw.polygon(surf, cup, [(4, 3), (10, 3), (11, 11), (3, 11)])
                pygame.draw.polygon(surf, outline, [(4, 3), (10, 3), (11, 11), (3, 11)], 1)
                pygame.draw.line(surf, cup2, (4, 10), (10, 10), 1)
                pygame.draw.rect(surf, accent, pygame.Rect(5, 6, 5, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(5, 6, 5, 2), 1, border_radius=1)
                return surf
            if base in ("tuna", "beans", "corn", "fruitcan", "soup") or "can" in base:
                surf = make_can(label=label)
                pat = {
                    "tuna": ["###", ".#.", ".#."],  # T
                    "beans": ["##.", "###", "##."],  # B
                    "corn": ["###", "#..", "###"],  # C
                    "fruitcan": ["###", "##.", "#.."],  # F
                    "soup": ["###", ".##", "##."],  # S
                }.get(str(base))
                if pat:
                    blit_pat_centered(surf, pygame.Rect(4, 5, 6, 3), pat, ink)
                return surf
            if base in ("chips", "jerky", "driedfruit"):
                surf = make_bag(body=base_col, band=label)
                pat = {
                    "chips": ["#.#.#", ".#.#.", "#.#.#"],
                    "jerky": ["#####", ".....", "#####"],
                    "driedfruit": ["#...#", ".#.#.", "#...#"],
                }.get(str(base))
                if pat:
                    blit_pat_centered(surf, pygame.Rect(4, 6, 6, 3), pat, ink)
                return surf
            if base in ("cereal", "crackers", "biscuit"):
                surf = make_box(body=base_col, band=label)
                pat = {
                    "cereal": [".###.", "#...#"],
                    "crackers": ["#.#.#", ".#.#."],
                    "biscuit": [".###.", "#.#.#"],
                }.get(str(base))
                if pat:
                    blit_pat_centered(surf, pygame.Rect(4, 6, 6, 2), pat, ink)
                return surf
            return make_box(body=base_col, band=label)
        if kind == "furniture":
            parts = item_id.split("_")
            fkind = parts[1] if len(parts) >= 3 and parts[0] == "furn" else "cabinet"
            variant = parts[2] if len(parts) >= 3 and parts[0] == "furn" else "old"
            return make_furniture(fkind=fkind, variant=variant)
        if kind in ("mat", "tool"):
            iid = item_id
            if iid in ("plank",):
                return HardcoreSurvivalState._make_item_sprite_wood()
            if iid in ("sheet_metal", "scrap"):
                return HardcoreSurvivalState._make_item_sprite_scrap()
            if iid in ("flashlight", "knife", "hammer", "saw", "wrench", "screwdriver", "crowbar"):
                return make_simple_tool(tool=iid if iid != "knife" else "knife", body=base_col)
            if iid in ("rope", "wire"):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                coil = HardcoreSurvivalState._rgb_lerp((150, 110, 70), base_col, 0.35) if iid == "rope" else (180, 180, 192)
                coil2 = HardcoreSurvivalState._rgb_shift(coil, -30, -30, -30)
                for r in (4, 3, 2):
                    pygame.draw.circle(surf, coil, (7, 6), r, 1)
                pygame.draw.circle(surf, coil2, (7, 6), 4, 1)
                return surf
            if iid == "duct_tape":
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                tape = HardcoreSurvivalState._rgb_lerp((180, 180, 192), base_col, 0.35)
                tape2 = HardcoreSurvivalState._rgb_shift(tape, -35, -35, -35)
                pygame.draw.circle(surf, tape, (7, 6), 4)
                pygame.draw.circle(surf, outline, (7, 6), 4, 1)
                pygame.draw.circle(surf, tape2, (7, 6), 2)
                pygame.draw.circle(surf, outline, (7, 6), 2, 1)
                return surf
            if iid in ("key_rv", "key_moto"):
                return make_key(metal=(220, 220, 240))
            if iid == "gas_can":
                return make_gas_can(body=HardcoreSurvivalState._rgb_lerp((220, 80, 70), base_col, 0.35))
            if iid == "battery":
                surf = pygame.Surface((12, 12), pygame.SRCALPHA)
                body = (90, 90, 104)
                top = (230, 230, 236)
                pygame.draw.rect(surf, body, pygame.Rect(3, 3, 6, 7), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 3, 6, 7), 1, border_radius=2)
                pygame.draw.rect(surf, top, pygame.Rect(5, 2, 2, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(5, 2, 2, 2), 1, border_radius=1)
                return surf
            if iid in ("paper", "book", "map"):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                page = (235, 235, 242)
                page2 = (200, 200, 210)
                pygame.draw.rect(surf, page, pygame.Rect(3, 3, 8, 7), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 3, 8, 7), 1, border_radius=1)
                if iid == "book":
                    cover = HardcoreSurvivalState._rgb_lerp((120, 110, 100), base_col, 0.45)
                    pygame.draw.rect(surf, cover, pygame.Rect(2, 3, 4, 7), border_radius=1)
                    pygame.draw.rect(surf, outline, pygame.Rect(2, 3, 4, 7), 1, border_radius=1)
                elif iid == "map":
                    pygame.draw.line(surf, page2, (4, 4), (10, 5), 1)
                    pygame.draw.line(surf, page2, (4, 6), (10, 7), 1)
                else:
                    for yy in (5, 7, 9):
                        pygame.draw.line(surf, page2, (4, yy), (10, yy), 1)
                return surf
            # fallback
            return make_box(body=base_col, band=accent)
        return make_box(body=base_col, band=accent)

    def _ensure_item_visuals(self, item_id: str) -> None:
        item_id = str(item_id or "")
        if not item_id:
            return
        if item_id in self._ITEM_SPRITES and item_id in self._ITEM_SPRITES_WORLD and item_id in self._ITEM_ICONS:
            return

        spr = self._ITEM_SPRITES.get(item_id)
        if spr is None:
            idef = self._ITEMS.get(item_id)
            try:
                spr = self._make_item_sprite_auto(item_id, idef)
            except Exception:
                spr = pygame.Surface((12, 12), pygame.SRCALPHA)
                pygame.draw.rect(spr, (60, 60, 72), pygame.Rect(2, 2, 8, 8), border_radius=2)
                pygame.draw.rect(spr, (10, 10, 12), pygame.Rect(2, 2, 8, 8), 1, border_radius=2)
            self._ITEM_SPRITES[item_id] = spr

        if item_id not in self._ITEM_SPRITES_WORLD:
            try:
                self._ITEM_SPRITES_WORLD[item_id] = self._make_item_world_sprite(spr, max_px=11)
            except Exception:
                self._ITEM_SPRITES_WORLD[item_id] = spr

        if item_id not in self._ITEM_ICONS:
            try:
                self._ITEM_ICONS[item_id] = self._make_item_icon_from_sprite(spr)
            except Exception:
                pass

    @dataclass
    class _ItemStack:
        item_id: str
        qty: int
        meta: dict[str, object] = field(default_factory=dict)

    @dataclass
    class _WorldItem:
        pos: pygame.Vector2
        item_id: str
        qty: int

    @dataclass
    class _MapMarker:
        tx: int
        ty: int
        label: str
        color: tuple[int, int, int] = (255, 220, 140)

    @dataclass
    class _HitFX:
        pos: pygame.Vector2
        vel: pygame.Vector2
        ttl: float
        color: tuple[int, int, int] = (170, 80, 90)  # blood-ish

    @dataclass
    class _ParkedCar:
        pos: pygame.Vector2
        model_id: str
        heading: float = 0.0
        steer_state: int = 0
        frame: int = 0
        fuel: float = 0.0

    @dataclass
    class _ParkedBike:
        pos: pygame.Vector2
        model_id: str
        dir: str = "right"
        frame: int = 0
        fuel: float = 0.0

    @dataclass
    class _WorldProp:
        pos: pygame.Vector2
        prop_id: str
        variant: int = 0
        dir: str = "down"

    @dataclass(frozen=True)
    class _PropDef:
        id: str
        name: str
        category: str
        solid: bool = False
        collider: tuple[int, int] = (10, 10)  # px, for collisions (centered on pos)
        sprites: tuple[pygame.Surface, ...] = ()

    def _make_prop_sprite_sign(*, bg: tuple[int, int, int], accent: tuple[int, int, int], icon: str) -> pygame.Surface:
        surf = pygame.Surface((14, 10), pygame.SRCALPHA)
        outline = (10, 10, 12)
        border = pygame.Rect(1, 1, 12, 8)
        pygame.draw.rect(surf, bg, border, border_radius=2)
        pygame.draw.rect(surf, outline, border, 1, border_radius=2)
        pygame.draw.rect(surf, accent, pygame.Rect(1, 7, 12, 2), border_radius=1)
        # Small icon in the middle (readable at 1x).
        cx, cy = 7, 4
        if icon == "cross":
            red = (240, 80, 90)
            pygame.draw.rect(surf, red, pygame.Rect(cx - 1, cy - 2, 2, 5))
            pygame.draw.rect(surf, red, pygame.Rect(cx - 2, cy - 1, 5, 2))
        elif icon == "cart":
            white = (240, 240, 240)
            pygame.draw.rect(surf, white, pygame.Rect(cx - 3, cy - 1, 6, 3), 1)
            pygame.draw.line(surf, white, (cx - 4, cy - 2), (cx - 1, cy - 2), 1)
            pygame.draw.line(surf, white, (cx - 1, cy - 2), (cx + 1, cy + 1), 1)
            surf.set_at((cx - 2, cy + 2), white)
            surf.set_at((cx + 2, cy + 2), white)
        elif icon == "gun":
            # Tiny pistol silhouette (readable at 1x).
            steel = (230, 230, 236)
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 3, cy - 1, 6, 2))
            pygame.draw.rect(surf, outline, pygame.Rect(cx - 3, cy - 1, 6, 2), 1)
            pygame.draw.rect(surf, steel, pygame.Rect(cx + 3, cy - 1, 2, 1))
            pygame.draw.rect(surf, outline, pygame.Rect(cx + 3, cy - 1, 2, 1), 1)
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 1, cy + 1, 2, 3))
            pygame.draw.rect(surf, outline, pygame.Rect(cx - 1, cy + 1, 2, 3), 1)
            surf.set_at((cx + 5, cy - 1), outline)
        elif icon == "school":
            blue = (130, 190, 240)
            pygame.draw.rect(surf, blue, pygame.Rect(cx - 3, cy - 2, 6, 5), 1)
            pygame.draw.line(surf, blue, (cx - 3, cy - 1), (cx + 2, cy - 2), 1)
            pygame.draw.line(surf, blue, (cx - 3, cy + 1), (cx + 2, cy), 1)
        elif icon == "bars":
            steel = (220, 220, 230)
            for dx in (-2, 0, 2):
                pygame.draw.line(surf, steel, (cx + dx, cy - 2), (cx + dx, cy + 2), 1)
            pygame.draw.line(surf, steel, (cx - 3, cy - 2), (cx + 3, cy - 2), 1)
            pygame.draw.line(surf, steel, (cx - 3, cy + 2), (cx + 3, cy + 2), 1)
        elif icon == "tower":
            steel = (220, 220, 230)
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 2, cy - 3, 5, 7), 1)
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 1, cy - 2, 1, 1))
            pygame.draw.rect(surf, steel, pygame.Rect(cx + 1, cy - 1, 1, 1))
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 1, cy + 1, 1, 1))
        elif icon == "book":
            ink = (240, 240, 240)
            pygame.draw.rect(surf, ink, pygame.Rect(cx - 4, cy - 2, 4, 5), 1)
            pygame.draw.rect(surf, ink, pygame.Rect(cx, cy - 2, 4, 5), 1)
            pygame.draw.line(surf, ink, (cx, cy - 2), (cx, cy + 2), 1)
            surf.set_at((cx - 3, cy - 1), ink)
            surf.set_at((cx + 2, cy), ink)
        elif icon == "pagoda":
            gold = (240, 210, 130)
            red = (220, 90, 80)
            pygame.draw.line(surf, gold, (cx - 4, cy - 2), (cx + 4, cy - 2), 1)
            pygame.draw.line(surf, gold, (cx - 3, cy - 1), (cx + 3, cy - 1), 1)
            pygame.draw.line(surf, red, (cx - 4, cy), (cx + 4, cy), 1)
            pygame.draw.rect(surf, red, pygame.Rect(cx - 2, cy, 5, 3), 1)
            surf.set_at((cx, cy - 3), gold)
        elif icon == "fuel":
            white = (240, 240, 240)
            # Droplet silhouette.
            for dx, dy in (
                (0, -3),
                (-1, -2),
                (1, -2),
                (-2, -1),
                (2, -1),
                (-2, 0),
                (2, 0),
                (-1, 1),
                (1, 1),
                (0, 2),
            ):
                x = int(cx + dx)
                y = int(cy + dy)
                if 0 <= x < surf.get_width() and 0 <= y < surf.get_height():
                    surf.set_at((x, y), white)
        elif icon == "gym":
            steel = (240, 240, 240)
            # Dumbbell silhouette.
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 4, cy - 1, 2, 3))
            pygame.draw.rect(surf, outline, pygame.Rect(cx - 4, cy - 1, 2, 3), 1)
            pygame.draw.rect(surf, steel, pygame.Rect(cx + 3, cy - 1, 2, 3))
            pygame.draw.rect(surf, outline, pygame.Rect(cx + 3, cy - 1, 2, 3), 1)
            pygame.draw.line(surf, steel, (cx - 2, cy), (cx + 2, cy), 1)
        elif icon == "home":
            # Tiny house.
            steel = (240, 240, 240)
            pygame.draw.polygon(surf, steel, [(cx - 3, cy), (cx, cy - 3), (cx + 3, cy)], 1)
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 2, cy, 5, 4), 1)
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 1, cy + 2, 2, 2), 1)
        elif icon == "work":
            # Briefcase.
            steel = (240, 240, 240)
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 4, cy - 1, 8, 5), 1)
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 1, cy - 3, 3, 2), 1)
            pygame.draw.line(surf, steel, (cx - 3, cy + 1), (cx + 2, cy + 1), 1)
        else:
            steel = (220, 220, 230)
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 2, cy - 2, 4, 4), 1)
        return surf

    def _make_prop_sprite_billboard(*, variant: int = 0) -> pygame.Surface:
        surf = pygame.Surface((18, 10), pygame.SRCALPHA)
        outline = (10, 10, 12)
        paper = (200, 200, 210)
        grime = (130, 130, 140)
        frame = (70, 70, 86)
        board = pygame.Rect(1, 1, 16, 7)
        pygame.draw.rect(surf, frame, board, border_radius=2)
        pygame.draw.rect(surf, outline, board, 1, border_radius=2)
        pygame.draw.rect(surf, paper, pygame.Rect(2, 2, 14, 5), border_radius=1)
        # Torn / dirty lines.
        for i in range(3):
            y = 2 + i * 2
            pygame.draw.line(surf, grime, (3, y), (15, y), 1)
        if int(variant) % 2 == 1:
            pygame.draw.rect(surf, (240, 200, 120), pygame.Rect(2, 2, 4, 5))
        # Poles.
        pygame.draw.rect(surf, outline, pygame.Rect(5, 8, 2, 2))
        pygame.draw.rect(surf, outline, pygame.Rect(11, 8, 2, 2))
        return surf

    def _make_prop_sprite_seesaw(*, variant: int = 0) -> pygame.Surface:
        surf = pygame.Surface((16, 10), pygame.SRCALPHA)
        outline = (10, 10, 12)
        wood = (170, 130, 70)
        rust = (150, 90, 60)
        plank = pygame.Rect(1, 4, 14, 2)
        pygame.draw.rect(surf, wood, plank, border_radius=1)
        pygame.draw.rect(surf, outline, plank, 1, border_radius=1)
        pivot = pygame.Rect(7, 5, 2, 3)
        pygame.draw.rect(surf, rust, pivot, border_radius=1)
        pygame.draw.rect(surf, outline, pivot, 1, border_radius=1)
        # One broken seat.
        if int(variant) % 2 == 0:
            surf.set_at((2, 3), outline)
            surf.set_at((13, 6), outline)
        return surf

    def _make_prop_sprite_carousel(*, variant: int = 0) -> pygame.Surface:
        surf = pygame.Surface((16, 16), pygame.SRCALPHA)
        outline = (10, 10, 12)
        rust = (150, 90, 60)
        metal = (140, 140, 150)
        ring = pygame.Rect(2, 2, 12, 12)
        pygame.draw.ellipse(surf, metal, ring)
        pygame.draw.ellipse(surf, outline, ring, 1)
        pygame.draw.ellipse(surf, (110, 110, 122), ring.inflate(-6, -6))
        # Spokes + seats (some missing).
        cx, cy = 8, 8
        for i, (dx, dy) in enumerate(((0, -5), (4, -3), (5, 0), (4, 3), (0, 5), (-4, 3), (-5, 0), (-4, -3))):
            pygame.draw.line(surf, rust, (cx, cy), (cx + dx, cy + dy), 1)
            if int(variant) % 3 == 0 and i in (2, 6):
                continue
            surf.set_at((cx + dx, cy + dy), outline)
        return surf

    def _make_prop_sprite_swing(*, variant: int = 0) -> pygame.Surface:
        surf = pygame.Surface((16, 12), pygame.SRCALPHA)
        outline = (10, 10, 12)
        metal = (160, 160, 170)
        rust = (150, 90, 60)
        # Frame.
        pygame.draw.line(surf, metal, (3, 10), (6, 2), 1)
        pygame.draw.line(surf, metal, (13, 10), (10, 2), 1)
        pygame.draw.line(surf, metal, (6, 2), (10, 2), 1)
        pygame.draw.line(surf, outline, (3, 10), (6, 2), 1)
        pygame.draw.line(surf, outline, (13, 10), (10, 2), 1)
        pygame.draw.line(surf, outline, (6, 2), (10, 2), 1)
        # Chains + seat (one chain broken sometimes).
        pygame.draw.line(surf, rust, (7, 3), (7, 8), 1)
        if int(variant) % 2 == 0:
            pygame.draw.line(surf, rust, (9, 3), (9, 8), 1)
        pygame.draw.rect(surf, (90, 90, 110), pygame.Rect(6, 8, 4, 2), border_radius=1)
        pygame.draw.rect(surf, outline, pygame.Rect(6, 8, 4, 2), 1, border_radius=1)
        return surf

    def _make_prop_sprite_streetlamp(*, variant: int = 0) -> pygame.Surface:
        # Simple road-side lamp post (tall sprite; light itself is handled by the lighting system).
        w, h = 14, 30
        surf = pygame.Surface((w, h), pygame.SRCALPHA)
        outline = (10, 10, 12)
        pole = (130, 130, 140)
        pole2 = (96, 96, 106)
        glow = (255, 230, 150)

        # Pole.
        pygame.draw.rect(surf, pole, pygame.Rect(w // 2 - 1, 8, 2, 18))
        pygame.draw.rect(surf, pole2, pygame.Rect(w // 2, 8, 1, 18))
        pygame.draw.rect(surf, outline, pygame.Rect(w // 2 - 1, 8, 2, 18), 1)

        # Arm + head.
        arm_y = 8
        arm_w = 6
        if int(variant) % 2 == 0:
            pygame.draw.line(surf, pole, (w // 2, arm_y), (w // 2 + arm_w, arm_y + 2), 2)
            pygame.draw.line(surf, outline, (w // 2, arm_y), (w // 2 + arm_w, arm_y + 2), 1)
            head = pygame.Rect(w // 2 + arm_w - 2, arm_y + 1, 4, 4)
        else:
            pygame.draw.line(surf, pole, (w // 2, arm_y), (w // 2 - arm_w, arm_y + 2), 2)
            pygame.draw.line(surf, outline, (w // 2, arm_y), (w // 2 - arm_w, arm_y + 2), 1)
            head = pygame.Rect(w // 2 - arm_w - 2, arm_y + 1, 4, 4)
        pygame.draw.rect(surf, (34, 34, 42), head, border_radius=1)
        pygame.draw.rect(surf, outline, head, 1, border_radius=1)
        surf.fill(glow, head.inflate(-2, -2))

        # Base.
        base = pygame.Rect(w // 2 - 3, 25, 6, 3)
        pygame.draw.rect(surf, pole2, base, border_radius=1)
        pygame.draw.rect(surf, outline, base, 1, border_radius=1)
        return surf

    _PROP_DEFS: dict[str, _PropDef] = {
        # Building signs / markers.
        "sign_hospital": _PropDef(
            id="sign_hospital",
            name="",
            category="",
            solid=False,
            collider=(10, 8),
            sprites=(_make_prop_sprite_sign(bg=(220, 220, 230), accent=(200, 80, 90), icon="cross"),),
        ),
        "sign_shop": _PropDef(
            id="sign_shop",
            name="",
            category="",
            solid=False,
            collider=(10, 8),
            sprites=(_make_prop_sprite_sign(bg=(60, 60, 72), accent=(230, 200, 120), icon="cart"),),
        ),
        "sign_gym": _PropDef(
            id="sign_gym",
            name="",
            category="",
            solid=False,
            collider=(12, 8),
            sprites=(_make_prop_sprite_sign(bg=(44, 40, 56), accent=(190, 140, 240), icon="gym"),),
        ),
        "sign_gas": _PropDef(
            id="sign_gas",
            name="",
            category="",
            solid=False,
            collider=(12, 8),
            sprites=(_make_prop_sprite_sign(bg=(46, 46, 56), accent=(240, 200, 120), icon="fuel"),),
        ),
        "sign_shop_big": _PropDef(
            id="sign_shop_big",
            name="",
            category="",
            solid=False,
            collider=(12, 8),
            sprites=(_make_prop_sprite_sign(bg=(70, 70, 86), accent=(240, 200, 120), icon="cart"),),
        ),
        "sign_gunshop": _PropDef(
            id="sign_gunshop",
            name="",
            category="",
            solid=False,
            collider=(12, 8),
            sprites=(_make_prop_sprite_sign(bg=(36, 36, 44), accent=(220, 140, 90), icon="gun"),),
        ),
        "sign_school": _PropDef(
            id="sign_school",
            name="",
            category="",
            solid=False,
            collider=(10, 8),
            sprites=(_make_prop_sprite_sign(bg=(36, 44, 60), accent=(120, 180, 240), icon="school"),),
        ),
        "sign_prison": _PropDef(
            id="sign_prison",
            name="",
            category="",
            solid=False,
            collider=(12, 8),
            sprites=(_make_prop_sprite_sign(bg=(40, 40, 48), accent=(160, 160, 170), icon="bars"),),
        ),
        "sign_highrise": _PropDef(
            id="sign_highrise",
            name="",
            category="",
            solid=False,
            collider=(10, 8),
            sprites=(_make_prop_sprite_sign(bg=(50, 50, 60), accent=(120, 120, 132), icon="tower"),),
        ),
        "sign_bookstore": _PropDef(
            id="sign_bookstore",
            name="",
            category="",
            solid=False,
            collider=(12, 8),
            sprites=(_make_prop_sprite_sign(bg=(38, 52, 88), accent=(240, 210, 130), icon="book"),),
        ),
        "sign_chinese": _PropDef(
            id="sign_chinese",
            name="",
            category="",
            solid=False,
            collider=(12, 8),
            sprites=(_make_prop_sprite_sign(bg=(70, 36, 36), accent=(240, 210, 130), icon="pagoda"),),
        ),
        "sign_office": _PropDef(
            id="sign_office",
            name="",
            category="",
            solid=False,
            collider=(12, 8),
            sprites=(_make_prop_sprite_sign(bg=(34, 40, 62), accent=(160, 220, 255), icon="work"),),
        ),
        "sign_home": _PropDef(
            id="sign_home",
            name="",
            category="",
            solid=False,
            collider=(10, 8),
            sprites=(_make_prop_sprite_sign(bg=(58, 52, 46), accent=(170, 130, 70), icon="home"),),
        ),
        # City dressing.
        "billboard": _PropDef(
            id="billboard",
            name="",
            category="",
            solid=False,
            collider=(16, 8),
            sprites=(
                _make_prop_sprite_billboard(variant=0),
                _make_prop_sprite_billboard(variant=1),
                _make_prop_sprite_billboard(variant=2),
            ),
        ),
        "streetlamp": _PropDef(
            id="streetlamp",
            name="",
            category="",
            solid=False,
            collider=(10, 10),
            sprites=(
                _make_prop_sprite_streetlamp(variant=0),
                _make_prop_sprite_streetlamp(variant=1),
            ),
        ),
        # Park toys (abandoned).
        "toy_seesaw": _PropDef(
            id="toy_seesaw",
            name="",
            category="",
            solid=True,
            collider=(16, 10),
            sprites=(_make_prop_sprite_seesaw(variant=0), _make_prop_sprite_seesaw(variant=1)),
        ),
        "toy_carousel": _PropDef(
            id="toy_carousel",
            name="",
            category="",
            solid=True,
            collider=(16, 16),
            sprites=(_make_prop_sprite_carousel(variant=0), _make_prop_sprite_carousel(variant=1), _make_prop_sprite_carousel(variant=2)),
        ),
        "toy_swing": _PropDef(
            id="toy_swing",
            name="",
            category="",
            solid=True,
            collider=(16, 12),
            sprites=(_make_prop_sprite_swing(variant=0), _make_prop_sprite_swing(variant=1)),
        ),
    }
    # Streetlamps must be solid so vehicles can't drive through them.
    try:
        _sl = _PROP_DEFS.get("streetlamp")
        if _sl is not None and not bool(getattr(_sl, "solid", False)):
            _PROP_DEFS["streetlamp"] = _PropDef(
                id=str(getattr(_sl, "id", "streetlamp")),
                name=str(getattr(_sl, "name", "streetlamp")),
                category=str(getattr(_sl, "category", "streetlamp")),
                solid=True,
                collider=tuple(getattr(_sl, "collider", (10, 10))),
                sprites=tuple(getattr(_sl, "sprites", ())),
            )
    except Exception:
        pass

    @dataclass
    class _Inventory:
        slots: list["HardcoreSurvivalState._ItemStack | None"]
        cols: int = 4

        def add(
            self,
            item_id: str,
            qty: int,
            item_defs: dict[str, "HardcoreSurvivalState._ItemDef"],
            *,
            meta: dict[str, object] | None = None,
        ) -> int:
            if qty <= 0:
                return 0
            idef = item_defs.get(item_id)
            if idef is None:
                return qty
            stack_max = max(1, int(idef.stack))
            meta = dict(meta) if isinstance(meta, dict) else None

            # Per-item metadata is only supported for non-stackable items for now.
            # (Guns/clothes/attachments are stack=1, so this is enough.)
            if meta is not None and stack_max > 1:
                meta = None

            left = int(qty)
            for slot in self.slots:
                if slot is None or slot.item_id != item_id:
                    continue
                if slot.qty >= stack_max:
                    continue
                take = min(stack_max - slot.qty, left)
                slot.qty += int(take)
                left -= int(take)
                if left <= 0:
                    return 0

            for i, slot in enumerate(self.slots):
                if slot is not None:
                    continue
                take = min(stack_max, left)
                st = HardcoreSurvivalState._ItemStack(item_id=item_id, qty=int(take))
                if meta is not None:
                    st.meta = dict(meta)
                self.slots[i] = st
                left -= int(take)
                if left <= 0:
                    return 0
            return left

        def drop_slot(self, index: int) -> "HardcoreSurvivalState._ItemStack | None":
            if not (0 <= index < len(self.slots)):
                return None
            stack = self.slots[index]
            self.slots[index] = None
            return stack

        def count(self, item_id: str) -> int:
            total = 0
            for slot in self.slots:
                if slot is not None and slot.item_id == item_id:
                    total += int(slot.qty)
            return int(total)

        def remove(self, item_id: str, qty: int) -> int:
            need = int(qty)
            if need <= 0:
                return 0
            removed = 0
            for i, slot in enumerate(self.slots):
                if need <= 0:
                    break
                if slot is None or slot.item_id != item_id:
                    continue
                take = min(int(slot.qty), need)
                slot.qty -= int(take)
                need -= int(take)
                removed += int(take)
                if slot.qty <= 0:
                    self.slots[i] = None
            return int(removed)

    @dataclass(frozen=True)
    class _GunDef:
        id: str
        name: str
        ammo_item: str
        mag_size: int
        fire_rate: float
        reload_s: float
        damage: int
        bullet_speed: float
        spread_deg: float
        noise_radius: float = 220.0
        muzzle_flash_s: float = 0.06
        bullet_ttl: float = 1.35
        bullet_kind: str = "bullet"  # "bullet" | "rocket"
        aoe_radius: float = 0.0  # px (rocket)
        aoe_damage: int = 0  # rocket splash base damage

    _GUNS: dict[str, _GunDef] = {
        "pistol": _GunDef(
            id="pistol",
            name="9mm",
            ammo_item="ammo_9mm",
            mag_size=12,
            fire_rate=4.0,
            reload_s=1.15,
            damage=12,
            bullet_speed=260.0,
            spread_deg=4.0,
            noise_radius=210.0,
        ),
        "uzi": _GunDef(
            id="uzi",
            name="UZI ",
            ammo_item="ammo_9mm",
            mag_size=32,
            fire_rate=10.5,
            reload_s=1.75,
            damage=8,
            bullet_speed=270.0,
            spread_deg=7.0,
            noise_radius=240.0,
        ),
        "ak47": _GunDef(
            id="ak47",
            name="AK-47",
            ammo_item="ammo_762",
            mag_size=30,
            fire_rate=8.5,
            reload_s=2.25,
            damage=18,
            bullet_speed=310.0,
            spread_deg=6.0,
            noise_radius=300.0,
        ),
        "scar_l": _GunDef(
            id="scar_l",
            name="SCAR-L",
            ammo_item="ammo_556",
            mag_size=30,
            fire_rate=9.0,
            reload_s=2.10,
            damage=16,
            bullet_speed=330.0,
            spread_deg=5.0,
            noise_radius=290.0,
        ),
        "rpg": _GunDef(
            id="rpg",
            name="",
            ammo_item="ammo_rocket",
            mag_size=1,
            fire_rate=0.65,
            reload_s=2.85,
            damage=80,
            bullet_speed=190.0,
            spread_deg=2.2,
            noise_radius=460.0,
            muzzle_flash_s=0.10,
            bullet_ttl=1.85,
            bullet_kind="rocket",
            aoe_radius=72.0,
            aoe_damage=55,
        ),
    }

    @dataclass(frozen=True)
    class _GunModDef:
        id: str
        name: str
        slot: str
        desc: str
        compat: tuple[str, ...]  # compatible gun ids
        mag_add: int = 0
        fire_rate_mult: float = 1.0
        reload_mult: float = 1.0
        damage_mult: float = 1.0
        damage_add: int = 0
        bullet_speed_mult: float = 1.0
        spread_mult: float = 1.0
        noise_mult: float = 1.0

    _GUN_MODS: dict[str, _GunModDef] = {
        # Optics
        "mod_optic_reddot": _GunModDef(
            id="mod_optic_reddot",
            name="",
            slot="optic",
            desc="",
            compat=("pistol", "uzi", "ak47", "scar_l"),
            spread_mult=0.78,
        ),
        "mod_optic_4x": _GunModDef(
            id="mod_optic_4x",
            name="4",
            slot="optic",
            desc="",
            compat=("ak47", "scar_l"),
            spread_mult=0.60,
        ),
        # Muzzle
        "mod_muzzle_suppressor_9mm": _GunModDef(
            id="mod_muzzle_suppressor_9mm",
            name="9mm ",
            slot="muzzle",
            desc="",
            compat=("pistol", "uzi"),
            damage_mult=0.95,
            bullet_speed_mult=0.93,
            spread_mult=0.95,
            noise_mult=0.55,
        ),
        "mod_muzzle_suppressor_rifle": _GunModDef(
            id="mod_muzzle_suppressor_rifle",
            name="",
            slot="muzzle",
            desc="",
            compat=("ak47", "scar_l"),
            damage_mult=0.96,
            bullet_speed_mult=0.94,
            spread_mult=0.95,
            noise_mult=0.60,
        ),
        "mod_muzzle_comp_rifle": _GunModDef(
            id="mod_muzzle_comp_rifle",
            name="",
            slot="muzzle",
            desc="",
            compat=("ak47", "scar_l"),
            spread_mult=0.86,
            noise_mult=1.10,
        ),
        # Stabilizers / grips
        "mod_undergrip_stab": _GunModDef(
            id="mod_undergrip_stab",
            name="",
            slot="under",
            desc="",
            compat=("uzi", "ak47", "scar_l"),
            spread_mult=0.82,
        ),
        # Magazines
        "mod_mag_ext_pistol": _GunModDef(
            id="mod_mag_ext_pistol",
            name="",
            slot="mag",
            desc="",
            compat=("pistol",),
            mag_add=5,
            reload_mult=1.08,
        ),
        "mod_mag_ext_9mm": _GunModDef(
            id="mod_mag_ext_9mm",
            name="9mm ",
            slot="mag",
            desc="",
            compat=("uzi",),
            mag_add=12,
            reload_mult=1.12,
        ),
        "mod_mag_ext_rifle": _GunModDef(
            id="mod_mag_ext_rifle",
            name="",
            slot="mag",
            desc="",
            compat=("ak47", "scar_l"),
            mag_add=15,
            reload_mult=1.15,
        ),
        "mod_optic_holo": _GunModDef(
            id="mod_optic_holo",
            name="",
            slot="optic",
            desc="",
            compat=("pistol", "uzi", "ak47", "scar_l"),
            spread_mult=0.72,
        ),
        "mod_undergrip_bipod": _GunModDef(
            id="mod_undergrip_bipod",
            name="",
            slot="under",
            desc="",
            compat=("ak47", "scar_l"),
            spread_mult=0.72,
            reload_mult=1.08,
        ),
        "mod_stock_tactical": _GunModDef(
            id="mod_stock_tactical",
            name="",
            slot="stock",
            desc="",
            compat=("uzi", "ak47", "scar_l"),
            spread_mult=0.90,
        ),
        "mod_muzzle_flash_hider_rifle": _GunModDef(
            id="mod_muzzle_flash_hider_rifle",
            name="",
            slot="muzzle",
            desc="",
            compat=("ak47", "scar_l"),
            spread_mult=0.94,
            noise_mult=0.85,
        ),
        "mod_trigger_light": _GunModDef(
            id="mod_trigger_light",
            name="",
            slot="trigger",
            desc="",
            compat=("pistol", "uzi"),
            fire_rate_mult=1.15,
            spread_mult=1.05,
        ),
        "mod_mag_drum_9mm": _GunModDef(
            id="mod_mag_drum_9mm",
            name="9mm ",
            slot="mag",
            desc="",
            compat=("uzi",),
            mag_add=38,
            reload_mult=1.25,
        ),
        "mod_mag_drum_rifle": _GunModDef(
            id="mod_mag_drum_rifle",
            name=" ",
            slot="mag",
            desc="",
            compat=("ak47", "scar_l"),
            mag_add=35,
            reload_mult=1.30,
        ),
    }

    @dataclass
    class _Gun:
        gun_id: str
        mag: int
        mods: dict[str, str] = field(default_factory=dict)
        cooldown_left: float = 0.0
        reload_left: float = 0.0
        reload_total: float = 0.0

    @dataclass
    class _Bullet:
        pos: pygame.Vector2
        vel: pygame.Vector2
        ttl: float
        dmg: int
        kind: str = "bullet"
        aoe_radius: float = 0.0
        aoe_damage: int = 0

    @dataclass
    class _ThrownFurniture:
        pos: pygame.Vector2
        vel: pygame.Vector2
        ttl: float
        tid: int
        offsets: list[tuple[int, int]]
        space: str = "world"  # home | rv | world
        hp: int | None = None

    @dataclass(frozen=True)
    class _MonsterDef:
        id: str
        name: str
        hp: int
        speed: float
        dmg: int
        sense: float
        attack_range: float
        attack_cd: float
        roam_speed: float
        scream_cd: float = 0.0
        scream_radius: float = 0.0
        scream_spawn: int = 0

    _MONSTER_DEFS: dict[str, _MonsterDef] = {
        "walker": _MonsterDef(
            id="walker",
            name="",
            hp=26,
            speed=16.0,
            dmg=8,
            sense=120.0,
            attack_range=10.0,
            attack_cd=0.65,
            roam_speed=7.0,
        ),
        "runner": _MonsterDef(
            id="runner",
            name="",
            hp=16,
            speed=24.0,
            dmg=12,
            sense=140.0,
            attack_range=12.0,
            attack_cd=0.90,
            roam_speed=11.0,
        ),
        "screamer": _MonsterDef(
            id="screamer",
            name="",
            hp=18,
            speed=20.0,
            dmg=7,
            sense=150.0,
            attack_range=10.0,
            attack_cd=0.80,
            roam_speed=9.0,
            scream_cd=10.0,
            scream_radius=110.0,
            scream_spawn=4,
        ),
    }

    # Player melee (unarmed punch).
    _PUNCH_TOTAL_S = 0.26
    _PUNCH_WINDUP_S = 0.06
    _PUNCH_COOLDOWN_S = 0.28
    _PUNCH_HIT_T = 0.50  # 0..1 progress (hit near full extension)
    _PUNCH_RANGE_PX = 18.0
    _PUNCH_ARC_DOT = 0.28  # smaller => wider arc
    _PUNCH_DAMAGE = 7
    _PUNCH_STAGGER_S = 0.18
    _PUNCH_STAGGER_SPEED = 95.0

    @dataclass(frozen=True)
    class _MeleeDef:
        id: str
        name: str
        total_s: float
        windup_s: float
        cooldown_s: float
        hit_t: float
        range_px: float
        arc_dot: float
        damage: int
        stagger_s: float
        stagger_speed: float
        stamina_cost: float = 5.0
        noise_radius: float = 120.0
        visual_len: float = 0.0
        visual_thick: int = 2

    _MELEE_DEFS: dict[str, _MeleeDef] = {
        "fist": _MeleeDef(
            id="fist",
            name="",
            total_s=_PUNCH_TOTAL_S,
            windup_s=_PUNCH_WINDUP_S,
            cooldown_s=_PUNCH_COOLDOWN_S,
            hit_t=_PUNCH_HIT_T,
            range_px=_PUNCH_RANGE_PX,
            arc_dot=_PUNCH_ARC_DOT,
            damage=_PUNCH_DAMAGE,
            stagger_s=_PUNCH_STAGGER_S,
            stagger_speed=_PUNCH_STAGGER_SPEED,
            stamina_cost=5.0,
            noise_radius=120.0,
            visual_len=0.0,
            visual_thick=2,
        ),
        "melee_club": _MeleeDef(
            id="melee_club",
            name="\u6728\u68cd",
            total_s=0.36,
            windup_s=0.10,
            cooldown_s=0.42,
            hit_t=0.52,
            range_px=26.0,
            arc_dot=0.18,
            damage=11,
            stagger_s=0.20,
            stagger_speed=115.0,
            stamina_cost=7.0,
            noise_radius=150.0,
            visual_len=11.0,
            visual_thick=2,
        ),
        "melee_bat": _MeleeDef(
            id="melee_bat",
            name="\u68d2\u7403\u68cd",
            total_s=0.42,
            windup_s=0.12,
            cooldown_s=0.50,
            hit_t=0.54,
            range_px=30.0,
            arc_dot=0.16,
            damage=14,
            stagger_s=0.24,
            stagger_speed=135.0,
            stamina_cost=9.0,
            noise_radius=180.0,
            visual_len=13.0,
            visual_thick=3,
        ),
        "melee_pipe": _MeleeDef(
            id="melee_pipe",
            name="\u94c1\u7ba1",
            total_s=0.46,
            windup_s=0.13,
            cooldown_s=0.56,
            hit_t=0.55,
            range_px=28.0,
            arc_dot=0.20,
            damage=16,
            stagger_s=0.26,
            stagger_speed=150.0,
            stamina_cost=10.0,
            noise_radius=190.0,
            visual_len=12.0,
            visual_thick=3,
        ),
        "melee_machete": _MeleeDef(
            id="melee_machete",
            name="\u780d\u5200",
            total_s=0.34,
            windup_s=0.10,
            cooldown_s=0.40,
            hit_t=0.50,
            range_px=24.0,
            arc_dot=0.30,
            damage=18,
            stagger_s=0.16,
            stagger_speed=110.0,
            stamina_cost=8.0,
            noise_radius=140.0,
            visual_len=10.0,
            visual_thick=2,
        ),
    }

    _CLOTHES_OUTFIT_INDEX: dict[str, int] = {
        "clothes_jacket_blue": 0,
        "clothes_work_green": 1,
        "clothes_tactical_gray": 2,
        "clothes_prisoner_orange": 3,
        "clothes_medic_white": 4,
        "clothes_raincoat_yellow": 5,
        "clothes_hoodie_pink": 6,
        "clothes_denim_blue": 7,
        "clothes_chef_white": 8,
        "clothes_racing_red": 9,
        "clothes_xmas_green": 10,
        "clothes_black_suit": 11,
        "clothes_desert_camo": 12,
        "clothes_sport_cyan": 13,
        "clothes_pajama_bear": 14,
        "clothes_maid": 15,
    }

    _OUTFIT_TO_CLOTHES: dict[int, str] = {
        0: "clothes_jacket_blue",
        1: "clothes_work_green",
        2: "clothes_tactical_gray",
        3: "clothes_prisoner_orange",
        4: "clothes_medic_white",
        5: "clothes_raincoat_yellow",
        6: "clothes_hoodie_pink",
        7: "clothes_denim_blue",
        8: "clothes_chef_white",
        9: "clothes_racing_red",
        10: "clothes_xmas_green",
        11: "clothes_black_suit",
        12: "clothes_desert_camo",
        13: "clothes_sport_cyan",
        14: "clothes_pajama_bear",
        15: "clothes_maid",
    }
    # Zombie corpse/decay (keep bodies for a while instead of despawning instantly).
    _ZOMBIE_CORPSE_TOTAL_S = 14.0
    _ZOMBIE_FALL_S = 0.22
    _ZOMBIE_VEHICLE_HIT_CD_S = 0.18

    _BODY_PART_NAMES: dict[str, str] = {
        "head": "",
        "torso": "",
        "left_arm": "",
        "right_arm": "",
        "left_leg": "",
        "right_leg": "",
    }

    @dataclass
    class _Zombie:
        pos: pygame.Vector2
        vel: pygame.Vector2
        hp: int
        speed: float
        kind: str = "walker"
        w: int = 10
        h: int = 10
        dir: str = "down"
        anim: float = 0.0
        attack_left: float = 0.0
        scream_left: float = 0.0
        wander_dir: pygame.Vector2 = field(default_factory=lambda: pygame.Vector2(0, 0))
        wander_left: float = 0.0
        stagger_left: float = 0.0
        stagger_vel: pygame.Vector2 = field(default_factory=lambda: pygame.Vector2(0, 0))
        # Death/decay (corpse stays for a while; used for vehicle kills too).
        corpse_total: float = 0.0
        corpse_left: float = 0.0
        death_t: float = 0.0
        # Cooldown so vehicles don't multi-hit the same zombie every tick while overlapping.
        vehicle_hit_left: float = 0.0

        def rect(self) -> pygame.Rect:
            return pygame.Rect(
                iround(float(self.pos.x) - float(self.w) / 2.0),
                iround(float(self.pos.y) - float(self.h) / 2.0),
                int(self.w),
                int(self.h),
            )

    @dataclass
    class _RV:
        pos: pygame.Vector2
        vel: pygame.Vector2
        model_id: str = "rv"
        fuel: float = 100.0
        heading: float = 0.0  # radians; 0 points right
        speed: float = 0.0  # px/s (signed)
        steer: float = 0.0  # radians (signed)
        w: int = 26
        h: int = 16

        def rect(self) -> pygame.Rect:
            return pygame.Rect(
                iround(float(self.pos.x) - float(self.w) / 2.0),
                iround(float(self.pos.y) - float(self.h) / 2.0),
                int(self.w),
                int(self.h),
            )

    @dataclass
    class _Bike:
        pos: pygame.Vector2
        vel: pygame.Vector2
        model_id: str = "bike"
        fuel: float = 0.0
        w: int = 14
        h: int = 10

        def rect(self) -> pygame.Rect:
            return pygame.Rect(
                iround(float(self.pos.x) - float(self.w) / 2.0),
                iround(float(self.pos.y) - float(self.h) / 2.0),
                int(self.w),
                int(self.h),
            )

    def _hash_u32(self, n: int) -> int:
        n &= 0xFFFFFFFF
        n ^= (n >> 16) & 0xFFFFFFFF
        n = (n * 0x7FEB352D) & 0xFFFFFFFF
        n ^= (n >> 15) & 0xFFFFFFFF
        n = (n * 0x846CA68B) & 0xFFFFFFFF
        n ^= (n >> 16) & 0xFFFFFFFF
        return n & 0xFFFFFFFF

    def _hash2_u32(self, x: int, y: int, seed: int) -> int:
        n = (x * 0x1F123BB5 + y * 0x05491333 + seed * 0x9E3779B9) & 0xFFFFFFFF
        return self._hash_u32(n)

    def _rand01(self, x: int, y: int, seed: int) -> float:
        return self._hash2_u32(x, y, seed) / 4294967296.0

    def _fade(self, t: float) -> float:
        return t * t * t * (t * (t * 6.0 - 15.0) + 10.0)

    def _lerp(self, a: float, b: float, t: float) -> float:
        return a + (b - a) * t

    def _noise2(self, x: float, y: float, seed: int) -> float:
        xi = math.floor(x)
        yi = math.floor(y)
        xf = x - xi
        yf = y - yi
        v00 = self._rand01(int(xi), int(yi), seed)
        v10 = self._rand01(int(xi) + 1, int(yi), seed)
        v01 = self._rand01(int(xi), int(yi) + 1, seed)
        v11 = self._rand01(int(xi) + 1, int(yi) + 1, seed)
        u = self._fade(float(xf))
        v = self._fade(float(yf))
        return self._lerp(self._lerp(v00, v10, u), self._lerp(v01, v11, u), v)

    def _fractal(self, x: float, y: float, seed: int) -> float:
        value = 0.0
        amp = 1.0
        total = 0.0
        freq = 1.0 / 64.0
        for octave in range(4):
            value += self._noise2(x * freq, y * freq, seed + octave * 101) * amp
            total += amp
            amp *= 0.5
            freq *= 2.0
        if total <= 0.0:
            return 0.0
        return value / total

    @dataclass(frozen=True)
    class _SpecialBuilding:
        kind: str  # e.g. "highrise"
        name: str
        tx0: int
        ty0: int
        w: int
        h: int
        door_tiles: tuple[tuple[int, int], ...]
        floors: int = 0

    @dataclass
    class _MultiHouse:
        tx0: int
        ty0: int
        w: int
        h: int
        floors: int
        cur_floor: int = 1
        floor_tiles: dict[int, list[int]] = field(default_factory=dict)  # floor -> w*h snapshot

    @dataclass
    class _Chunk:
        cx: int
        cy: int
        tiles: list[int]
        items: list["HardcoreSurvivalState._WorldItem"] = field(default_factory=list)
        buildings: list[tuple[int, int, int, int, int, int]] = field(default_factory=list)  # (tx0, ty0, w, h, roof_kind, floors) in world tiles
        special_buildings: list["HardcoreSurvivalState._SpecialBuilding"] = field(default_factory=list)
        multi_houses: list["HardcoreSurvivalState._MultiHouse"] = field(default_factory=list)
        cars: list["HardcoreSurvivalState._ParkedCar"] = field(default_factory=list)
        bikes: list["HardcoreSurvivalState._ParkedBike"] = field(default_factory=list)
        props: list["HardcoreSurvivalState._WorldProp"] = field(default_factory=list)
        town_kind: str | None = None

    class _World:
        def __init__(self, state: "HardcoreSurvivalState", seed: int) -> None:
            self.state = state
            self.seed = int(seed) & 0xFFFFFFFF
            self.chunks: dict[tuple[int, int], HardcoreSurvivalState._Chunk] = {}
            # Chunk streaming: we avoid generating new chunks during render (draw)
            # to prevent big hitches when the camera crosses chunk corners.
            self._gen_queue: list[tuple[int, int]] = []
            self._gen_queue_i = 0
            self._gen_queue_set: set[tuple[int, int]] = set()
            self.road_off_x = state._hash2_u32(7, 11, self.seed) % state.ROAD_PERIOD
            self.road_off_y = state._hash2_u32(13, 17, self.seed) % state.ROAD_PERIOD

            # Spawn-city: a dense urban region centered on the spawn road intersection.
            stx, sty = self.spawn_tile()
            self.city_cx = int(stx) // state.CHUNK_SIZE
            self.city_cy = int(sty) // state.CHUNK_SIZE
            self.city_radius = 5  # chunks
            self.city_period = 24  # minor street grid (tiles)
            self.city_w = 1  # half-width of minor streets (tiles)
            self.city_off_x = state._hash2_u32(29, 37, self.seed) % max(1, int(self.city_period))
            self.city_off_y = state._hash2_u32(41, 53, self.seed) % max(1, int(self.city_period))

            # Coastline (sea) near the city (for beach / boardwalk / wetlands).
            self.coast_dir = int(state._hash2_u32(61, 67, self.seed) % 4)  # 0=N,1=E,2=S,3=W
            coast_offset_chunks = int(self.city_radius) + 4
            if self.coast_dir == 0:  # north
                self.coast_line = (int(self.city_cy) - coast_offset_chunks) * int(state.CHUNK_SIZE)
            elif self.coast_dir == 1:  # east
                self.coast_line = (int(self.city_cx) + coast_offset_chunks) * int(state.CHUNK_SIZE)
            elif self.coast_dir == 2:  # south
                self.coast_line = (int(self.city_cy) + coast_offset_chunks) * int(state.CHUNK_SIZE)
            else:  # west
                self.coast_line = (int(self.city_cx) - coast_offset_chunks) * int(state.CHUNK_SIZE)

            # Abandoned highways: two wide bands around the city outskirts.
            self.highway_w = 4  # half-width (tiles)
            hw_off_y = int(state._hash2_u32(97, 101, self.seed) % (state.CHUNK_SIZE * 2)) - int(state.CHUNK_SIZE)
            hw_off_x = int(state._hash2_u32(103, 107, self.seed) % (state.CHUNK_SIZE * 2)) - int(state.CHUNK_SIZE)
            self.highway_y = (int(self.city_cy) + int(self.city_radius) + 2) * int(state.CHUNK_SIZE) + int(hw_off_y)
            self.highway_x = (int(self.city_cx) - int(self.city_radius) - 2) * int(state.CHUNK_SIZE) + int(hw_off_x)

            # Chinese residential compound () near spawn: one enclosed community
            # with ~7-8 tall towers and a low-rise podium ("") around them.
            self.compound_w_chunks = 5
            self.compound_h_chunks = 5
            self.compound_cx0 = int(self.city_cx) - int(self.compound_w_chunks // 2)
            # Place the compound just north of spawn so you can approach the gate.
            self.compound_cy1 = int(self.city_cy) - 1
            self.compound_cy0 = int(self.compound_cy1) - int(self.compound_h_chunks - 1)
            self.compound_cx1 = int(self.compound_cx0) + int(self.compound_w_chunks) - 1
            self.compound_cy1 = int(self.compound_cy0) + int(self.compound_h_chunks) - 1
            self.compound_tx0 = int(self.compound_cx0) * int(state.CHUNK_SIZE)
            self.compound_ty0 = int(self.compound_cy0) * int(state.CHUNK_SIZE)
            self.compound_tx1 = (int(self.compound_cx1) + 1) * int(state.CHUNK_SIZE) - 1
            self.compound_ty1 = (int(self.compound_cy1) + 1) * int(state.CHUNK_SIZE) - 1

            # Internal road stripes (local coords within each chunk).
            # Keep roads a bit narrower so towers can be wider (bigger apartments).
            self.compound_road_v_x0 = 15
            self.compound_road_v_x1 = 16
            # Put the horizontal road at the very bottom so towers can be taller
            # (bigger apartments) without eating into the internal road.
            self.compound_road_h_y0 = 31
            self.compound_road_h_y1 = 31

            # Gate opening (south wall) aligned with the central chunk column.
            gate_cx = int(self.compound_cx0) + int(self.compound_w_chunks // 2)
            self.compound_gate_x0 = int(gate_cx) * int(state.CHUNK_SIZE) + int(self.compound_road_v_x0)
            self.compound_gate_x1 = int(gate_cx) * int(state.CHUNK_SIZE) + int(self.compound_road_v_x1)

            # Reserve entrance/parking chunks near the gate.
            self.compound_gate_chunks: set[tuple[int, int]] = {
                (int(gate_cx), int(self.compound_cy1)),
                (int(gate_cx) - 1, int(self.compound_cy1)),
                (int(gate_cx) + 1, int(self.compound_cy1)),
            }
            self.compound_parking_chunks: set[tuple[int, int]] = {
                (int(gate_cx) - 1, int(self.compound_cy1)),
                (int(gate_cx) + 1, int(self.compound_cy1)),
            }
            self.compound_towers_by_chunk: dict[
                tuple[int, int], list[tuple[int, int, int, int, int, int]]
            ] = self._plan_compound_towers(target=8)

            # Gas station (world-map POI): place one on the south highway near the main road,
            # so the player can drive there to refuel.
            try:
                stx, _sty = self.spawn_tile()
                self.gas_station_cx = int(stx) // int(state.CHUNK_SIZE)
                self.gas_station_cy = int(getattr(self, "highway_y", 0)) // int(state.CHUNK_SIZE)
                if self._is_city_chunk(int(self.gas_station_cx), int(self.gas_station_cy)):
                    self.gas_station_cy = int(self.city_cy) + int(self.city_radius) + 1
                if self._is_compound_chunk(int(self.gas_station_cx), int(self.gas_station_cy)):
                    self.gas_station_cy = int(self.compound_cy1) + 2
            except Exception:
                self.gas_station_cx = int(self.city_cx)
                self.gas_station_cy = int(self.city_cy) + int(self.city_radius) + 1

        def spawn_tile(self) -> tuple[int, int]:
            tx = self.state.ROAD_HALF - int(self.road_off_x)
            ty = self.state.ROAD_HALF - int(self.road_off_y)
            return tx, ty

        def _is_road_x(self, tx: int) -> bool:
            d = ((tx + int(self.road_off_x)) % self.state.ROAD_PERIOD) - self.state.ROAD_HALF
            return abs(int(d)) <= self.state.ROAD_W

        def _is_road_y(self, ty: int) -> bool:
            d = ((ty + int(self.road_off_y)) % self.state.ROAD_PERIOD) - self.state.ROAD_HALF
            return abs(int(d)) <= self.state.ROAD_W

        def is_road(self, tx: int, ty: int) -> bool:
            return self._is_road_x(tx) or self._is_road_y(ty)

        def is_highway(self, tx: int, ty: int) -> bool:
            tx = int(tx)
            ty = int(ty)
            w = int(getattr(self, "highway_w", 0))
            if w <= 0:
                return False
            hx = int(getattr(self, "highway_x", 0))
            hy = int(getattr(self, "highway_y", 0))
            return abs(tx - hx) <= w or abs(ty - hy) <= w

        def _coast_distance(self, tx: int, ty: int) -> int:
            # Signed distance from coastline (>=0 is sea side).
            tx = int(tx)
            ty = int(ty)
            cd = int(getattr(self, "coast_dir", 0)) & 3
            line = int(getattr(self, "coast_line", 0))
            if cd == 0:  # north
                return int(line - ty)
            if cd == 2:  # south
                return int(ty - line)
            if cd == 1:  # east
                return int(tx - line)
            return int(line - tx)  # west

        def _is_city_chunk(self, cx: int, cy: int) -> bool:
            dx = abs(int(cx) - int(getattr(self, "city_cx", 0)))
            dy = abs(int(cy) - int(getattr(self, "city_cy", 0)))
            r = max(0, int(getattr(self, "city_radius", 0)))
            return max(dx, dy) <= r

        def _is_compound_chunk(self, cx: int, cy: int) -> bool:
            cx0 = int(getattr(self, "compound_cx0", 0))
            cy0 = int(getattr(self, "compound_cy0", 0))
            cx1 = int(getattr(self, "compound_cx1", -1))
            cy1 = int(getattr(self, "compound_cy1", -1))
            return int(cx0) <= int(cx) <= int(cx1) and int(cy0) <= int(cy) <= int(cy1)

        def _plan_compound_towers(
            self,
            *,
            target: int,
        ) -> dict[tuple[int, int], list[tuple[int, int, int, int, int, int]]]:
            target = int(target)
            if target <= 0:
                return {}

            cx0 = int(getattr(self, "compound_cx0", 0))
            cy0 = int(getattr(self, "compound_cy0", 0))
            cx1 = int(getattr(self, "compound_cx1", -1))
            cy1 = int(getattr(self, "compound_cy1", -1))
            if cx1 < cx0 or cy1 < cy0:
                return {}

            # One tower per inner chunk (7-8 total); keep the perimeter for the podium/skirt building.
            # Slightly larger towers so each apartment feels like a real home.
            tower_w = 15
            tower_h = 31
            inner_cx0 = int(cx0) + 1
            inner_cx1 = int(cx1) - 1
            inner_cy0 = int(cy0) + 1
            inner_cy1 = int(cy1) - 1
            if inner_cx1 < inner_cx0 or inner_cy1 < inner_cy0:
                return {}

            inner_chunks: list[tuple[int, int]] = []
            for cy in range(int(inner_cy0), int(inner_cy1) + 1):
                for cx in range(int(inner_cx0), int(inner_cx1) + 1):
                    inner_chunks.append((int(cx), int(cy)))
            if not inner_chunks:
                return {}

            # Keep the very center chunk empty as a courtyard/green space when possible.
            center = ((int(inner_cx0) + int(inner_cx1)) // 2, (int(inner_cy0) + int(inner_cy1)) // 2)
            inner_chunks_usable = [c for c in inner_chunks if c != center]
            if not inner_chunks_usable:
                inner_chunks_usable = inner_chunks

            rng = random.Random(self.state._hash2_u32(211, 223, self.seed ^ 0x51C17011))
            rng.shuffle(inner_chunks_usable)
            picked = inner_chunks_usable[: int(clamp(int(target), 1, len(inner_chunks_usable)))]

            plan: dict[tuple[int, int], list[tuple[int, int, int, int, int, int]]] = {}
            for cx, cy in picked:
                # Alternate left/right so we don't overwrite the internal road stripe at x=15..16.
                x0 = 0 if ((int(cx) + int(cy)) % 2 == 0) else 17
                y0 = 0
                base_tx = int(cx) * int(self.state.CHUNK_SIZE)
                base_ty = int(cy) * int(self.state.CHUNK_SIZE)
                tx0w = int(base_tx + int(x0))
                ty0w = int(base_ty + int(y0))
                rr = random.Random(self.state._hash2_u32(int(tx0w), int(ty0w), self.seed ^ 0xA17F1A2B))
                roof_var = int(rr.randrange(0, 256))
                # Keep compound towers at 6F so the roof-cut doesn't shrink the
                # walkable apartment area too much (home must be >= 100 tiles).
                floors = 6
                plan.setdefault((int(cx), int(cy)), []).append(
                    (int(x0), int(y0), int(tower_w), int(tower_h), int(roof_var), int(floors))
                )
            return plan

        def _is_city_street_x(self, tx: int) -> bool:
            period = max(8, int(getattr(self, "city_period", 24)))
            half = int(period // 2)
            w = max(1, int(getattr(self, "city_w", 1)))
            off = int(getattr(self, "city_off_x", 0)) % period
            d = ((int(tx) + off) % period) - half
            return abs(int(d)) <= w

        def _is_city_street_y(self, ty: int) -> bool:
            period = max(8, int(getattr(self, "city_period", 24)))
            half = int(period // 2)
            w = max(1, int(getattr(self, "city_w", 1)))
            off = int(getattr(self, "city_off_y", 0)) % period
            d = ((int(ty) + off) % period) - half
            return abs(int(d)) <= w

        def is_city_street(self, tx: int, ty: int) -> bool:
            return self._is_city_street_x(tx) or self._is_city_street_y(ty)

        def get_tile(self, tx: int, ty: int) -> int:
            cx = tx // self.state.CHUNK_SIZE
            cy = ty // self.state.CHUNK_SIZE
            lx = tx - cx * self.state.CHUNK_SIZE
            ly = ty - cy * self.state.CHUNK_SIZE
            chunk = self.get_chunk(cx, cy)
            return chunk.tiles[ly * self.state.CHUNK_SIZE + lx]

        def peek_chunk(self, cx: int, cy: int) -> "HardcoreSurvivalState._Chunk | None":
            return self.chunks.get((int(cx), int(cy)))

        def peek_tile(self, tx: int, ty: int, *, default: int | None = None) -> int:
            cx = tx // self.state.CHUNK_SIZE
            cy = ty // self.state.CHUNK_SIZE
            lx = tx - cx * self.state.CHUNK_SIZE
            ly = ty - cy * self.state.CHUNK_SIZE
            chunk = self.peek_chunk(cx, cy)
            if chunk is None:
                return int(self.state.T_GRASS if default is None else default)
            return int(chunk.tiles[int(ly) * int(self.state.CHUNK_SIZE) + int(lx)])

        def request_chunk(self, cx: int, cy: int) -> None:
            key = (int(cx), int(cy))
            if key in self.chunks or key in self._gen_queue_set:
                return
            self._gen_queue.append(key)
            self._gen_queue_set.add(key)

        def pump_generation(self, *, max_chunks: int = 1) -> int:
            made = 0
            max_chunks = max(0, int(max_chunks))
            while made < max_chunks and self._gen_queue_i < len(self._gen_queue):
                key = self._gen_queue[self._gen_queue_i]
                self._gen_queue_i += 1
                self._gen_queue_set.discard(key)
                if key not in self.chunks:
                    self.chunks[key] = self._gen_chunk(int(key[0]), int(key[1]))
                made += 1

            # Compact occasionally to avoid unbounded growth.
            if self._gen_queue_i > 256 and self._gen_queue_i > (len(self._gen_queue) // 2):
                self._gen_queue = self._gen_queue[self._gen_queue_i :]
                self._gen_queue_i = 0
            return int(made)

        def get_chunk(self, cx: int, cy: int) -> "HardcoreSurvivalState._Chunk":
            key = (int(cx), int(cy))
            chunk = self.chunks.get(key)
            if chunk is None:
                chunk = self._gen_chunk(int(cx), int(cy))
                self.chunks[key] = chunk
            return chunk

        def _chunk_has_intersection(self, cx: int, cy: int) -> bool:
            base_tx = cx * self.state.CHUNK_SIZE
            base_ty = cy * self.state.CHUNK_SIZE
            has_x = any(self._is_road_x(base_tx + i) for i in range(self.state.CHUNK_SIZE))
            has_y = any(self._is_road_y(base_ty + i) for i in range(self.state.CHUNK_SIZE))
            return has_x and has_y

        def _is_town_chunk(self, cx: int, cy: int) -> bool:
            if self._chunk_has_intersection(cx, cy):
                return True
            r = self.state._rand01(cx, cy, self.seed ^ 0xA17F1A2B)
            return r >= 0.92

        def _gen_chunk(self, cx: int, cy: int) -> "HardcoreSurvivalState._Chunk":
            tiles = [self.state.T_GRASS] * (self.state.CHUNK_SIZE * self.state.CHUNK_SIZE)
            base_tx = cx * self.state.CHUNK_SIZE
            base_ty = cy * self.state.CHUNK_SIZE
            items: list[HardcoreSurvivalState._WorldItem] = []
            buildings: list[tuple[int, int, int, int, int, int]] = []
            special_buildings: list[HardcoreSurvivalState._SpecialBuilding] = []
            multi_houses: list[HardcoreSurvivalState._MultiHouse] = []
            cars: list[HardcoreSurvivalState._ParkedCar] = []
            bikes: list[HardcoreSurvivalState._ParkedBike] = []
            props: list[HardcoreSurvivalState._WorldProp] = []
            door_reserved: set[tuple[int, int]] = set()

            # Allow stamping helpers to register 2F house floor snapshots without
            # threading an extra parameter through every call site.
            self._multi_houses_out = multi_houses

            is_city = self._is_city_chunk(int(cx), int(cy))

            for ly in range(self.state.CHUNK_SIZE):
                ty = base_ty + ly
                for lx in range(self.state.CHUNK_SIZE):
                    tx = base_tx + lx
                    if is_city:
                        # City ground zoning: highways -> roads -> sidewalks -> district floors.
                        if self.is_highway(tx, ty):
                            tile = int(self.state.T_HIGHWAY)
                        elif self.is_road(tx, ty) or self.is_city_street(tx, ty):
                            tile = int(self.state.T_ROAD)
                        else:
                            near_road = bool(
                                self.is_highway(tx - 1, ty)
                                or self.is_highway(tx + 1, ty)
                                or self.is_highway(tx, ty - 1)
                                or self.is_highway(tx, ty + 1)
                                or self.is_road(tx - 1, ty)
                                or self.is_road(tx + 1, ty)
                                or self.is_road(tx, ty - 1)
                                or self.is_road(tx, ty + 1)
                                or self.is_city_street(tx - 1, ty)
                                or self.is_city_street(tx + 1, ty)
                                or self.is_city_street(tx, ty - 1)
                                or self.is_city_street(tx, ty + 1)
                            )
                            if near_road:
                                tile = int(self.state.T_SIDEWALK)
                            else:
                                district = float(
                                    self.state._noise2(float(tx) / 96.0, float(ty) / 96.0, self.seed ^ 0x7A11C1D3)
                                )
                                grit = float(
                                    self.state._noise2(float(tx) / 24.0, float(ty) / 24.0, self.seed ^ 0x1B7D3D39)
                                )
                                if district > 0.70:
                                    tile = int(self.state.T_BRICK)
                                elif district > 0.42:
                                    tile = int(self.state.T_CONCRETE)
                                else:
                                    tile = int(self.state.T_PAVEMENT)

                                # Occasional brick courtyards / plazas inside blocks.
                                if tile != int(self.state.T_BRICK) and grit > 0.885:
                                    tile = int(self.state.T_BRICK)
                                elif tile == int(self.state.T_PAVEMENT) and grit < 0.14:
                                    tile = int(self.state.T_CONCRETE)

                                # Small parks inside the city (keep roads/sidewalks clean).
                                park = float(
                                    self.state._noise2(float(tx) / 48.0, float(ty) / 48.0, self.seed ^ 0x51C17011)
                                )
                                if park > 0.905:
                                    tile = int(self.state.T_FOREST)
                                elif park > 0.84:
                                    tile = int(self.state.T_GRASS)
                    else:
                        n = self.state._fractal(float(tx), float(ty), self.seed)
                        coast_d = int(self._coast_distance(tx, ty))
                        if coast_d >= 10:
                            tile = self.state.T_WATER
                        elif coast_d >= 3:
                            # Shallows with occasional sand bars.
                            tile = self.state.T_WATER
                            shoal = float(self.state._noise2(float(tx) / 18.0, float(ty) / 18.0, self.seed ^ 0x0CEAD511))
                            if shoal > 0.88:
                                tile = self.state.T_SAND
                        elif coast_d >= 0:
                            tile = self.state.T_WATER
                        elif coast_d >= -4:
                            tile = self.state.T_SAND
                        elif coast_d >= -7:
                            # Boardwalk band just inland from the beach.
                            bw = float(self.state._noise2(float(tx) / 12.0, float(ty) / 12.0, self.seed ^ 0xB04A7A1C))
                            tile = self.state.T_BOARDWALK if bw > 0.55 else self.state.T_SAND
                        elif coast_d >= -18:
                            # Coastal wetlands behind the beach.
                            wet = float(self.state._noise2(float(tx) / 24.0, float(ty) / 24.0, self.seed ^ 0x717E17D5))
                            if wet > 0.92:
                                tile = self.state.T_WATER
                            elif wet > 0.78:
                                tile = self.state.T_MARSH
                            else:
                                if n < 0.30:
                                    tile = self.state.T_FOREST
                                else:
                                    tile = self.state.T_GRASS
                        else:
                            if n < 0.24:
                                tile = self.state.T_WATER
                            elif n < 0.36:
                                tile = self.state.T_FOREST
                            else:
                                tile = self.state.T_GRASS

                        # Inland biomes: forests / wheat fields / mountains.
                        # Keep shoreline/wetland bands intact by only applying far inland.
                        if tile != self.state.T_WATER and int(coast_d) < -18:
                            biome = float(
                                self.state._noise2(float(tx) / 360.0, float(ty) / 360.0, self.seed ^ 0x6F1C0B37)
                            )
                            elev = float(
                                self.state._noise2(float(tx) / 180.0, float(ty) / 180.0, self.seed ^ 0x1D3B7A11)
                            )
                            detail = float(
                                self.state._noise2(float(tx) / 32.0, float(ty) / 32.0, self.seed ^ 0xA511C0DE)
                            )

                            # Mountain ranges: high "elevation" with a regional bias.
                            if elev > 0.76 and biome > 0.52:
                                tile = self.state.T_MOUNTAIN
                                # Small pockets of forest on mountain slopes.
                                if detail > 0.92:
                                    tile = self.state.T_FOREST
                            # Wheat fields: flatter regions (avoid high elevation).
                            elif biome < 0.22 and elev < 0.68:
                                tile = self.state.T_WHEAT
                                # Small breaks so it doesn't look like a perfect carpet.
                                if detail < 0.10:
                                    tile = self.state.T_GRASS
                            # Dense forests as a third region type.
                            elif biome > 0.74:
                                tile = self.state.T_FOREST

                        # Roads/highways override terrain (but keep deep sea water intact).
                        if tile != self.state.T_WATER and self.is_highway(tx, ty):
                            tile = self.state.T_HIGHWAY
                        elif self.is_road(tx, ty):
                            tile = self.state.T_ROAD
                    tiles[ly * self.state.CHUNK_SIZE + lx] = tile

            gas_station_cx = int(getattr(self, "gas_station_cx", 10**9))
            gas_station_cy = int(getattr(self, "gas_station_cy", 10**9))
            is_gas_station = bool(int(cx) == int(gas_station_cx) and int(cy) == int(gas_station_cy))

            town_kind: str | None = None
            if is_gas_station:
                rng = random.Random(self.state._hash2_u32(cx, cy, self.seed ^ 0xA511F00D))
                self._stamp_gas_station_chunk(tiles, items, buildings, props, cx, cy, rng=rng, reserved=door_reserved)
                town_kind = ""
            elif is_city:
                rng = random.Random(self.state._hash2_u32(cx, cy, self.seed ^ 0xC17C1701))
                self._stamp_city_chunk(
                    tiles,
                    items,
                    buildings,
                    special_buildings,
                    cars,
                    bikes,
                    props,
                    cx,
                    cy,
                    rng,
                    reserved=door_reserved,
                )
                town_kind = ""
            elif self._is_town_chunk(cx, cy):
                rng = random.Random(self.state._hash2_u32(cx, cy, self.seed))
                kinds = ["", "", "", "", "", "", ""]
                stx, sty = self.spawn_tile()
                is_spawn_chunk = (int(stx) // self.state.CHUNK_SIZE == int(cx)) and (int(sty) // self.state.CHUNK_SIZE == int(cy))
                if is_spawn_chunk:
                    plan = ["", ""]
                else:
                    plan = [rng.choice(kinds)]
                    if plan[0] != "" and rng.random() < 0.35:
                        pool = [k for k in kinds if k not in plan and k != ""]
                        if pool:
                            plan.append(rng.choice(pool))

                town_kind = "+".join(plan)
                for kind in plan:
                    self._stamp_buildings(
                        tiles,
                        items,
                        buildings,
                        special_buildings,
                        props,
                        cx,
                        cy,
                        rng,
                        kind,
                        reserved=door_reserved,
                    )

                if not is_city and not is_gas_station:
                    # Beach / wetlands / highway decoration on non-city chunks.
                    rng2 = random.Random(self.state._hash2_u32(cx, cy, self.seed ^ 0x0D00BDEC))
                    self._stamp_outdoor_decor(tiles, props, cx, cy, rng=rng2)

            # Safety net: ensure every stamped building that has a walkable interior
            # is actually enterable from outside (some rare stamp interactions can
            # overwrite door tiles).
            if buildings or special_buildings:
                self._ensure_building_doors(tiles, buildings, special_buildings, cx, cy, reserved=door_reserved)

            # Safety: prevent parked vehicles from ending up inside building footprints.
            # This can happen if later stamps overwrite previously spawned vehicles.
            if buildings and (cars or bikes):
                tile_size = float(self.state.TILE_SIZE)
                chunk_size = int(self.state.CHUNK_SIZE)
                t_floor = int(self.state.T_FLOOR)
                t_door = int(self.state.T_DOOR)

                def inside_any_building(tx: int, ty: int) -> bool:
                    for bx0, by0, bw, bh, _roof_kind, _floors in buildings:
                        if int(bx0) <= int(tx) < int(bx0) + int(bw) and int(by0) <= int(ty) < int(by0) + int(bh):
                            return True
                    return False

                def tile_blocks_vehicle(t: int) -> bool:
                    t = int(t)
                    if t in (t_floor, t_door):
                        return True
                    tdef = self.state._TILES.get(int(t))
                    if tdef is None:
                        return False
                    return bool(getattr(tdef, "solid", False))

                def keep_vehicle_at(px: float, py: float) -> bool:
                    tx = int(math.floor(float(px) / tile_size))
                    ty = int(math.floor(float(py) / tile_size))
                    if inside_any_building(int(tx), int(ty)):
                        return False
                    lx = int(tx - base_tx)
                    ly = int(ty - base_ty)
                    if not (0 <= lx < chunk_size and 0 <= ly < chunk_size):
                        return False
                    t = int(tiles[int(ly) * chunk_size + int(lx)])
                    return not tile_blocks_vehicle(int(t))

                cars[:] = [c for c in cars if keep_vehicle_at(float(c.pos.x), float(c.pos.y))]
                bikes[:] = [b for b in bikes if keep_vehicle_at(float(b.pos.x), float(b.pos.y))]

            # Safety: avoid parked vehicles blocking building entrances (door tiles).
            # (Parked vehicles are centered on a tile; if that tile is next to a door, the
            # collider can overlap the doorway and make the building feel "sealed".)
            if cars or bikes:
                try:
                    chunk_size = int(self.state.CHUNK_SIZE)
                    t_doors = {
                        int(self.state.T_DOOR),
                        int(self.state.T_DOOR_BROKEN),
                        int(self.state.T_DOOR_HOME),
                    }
                    door_clear: set[tuple[int, int]] = set()
                    for ly in range(chunk_size):
                        row = int(ly) * int(chunk_size)
                        for lx in range(chunk_size):
                            if int(tiles[int(row + int(lx))]) not in t_doors:
                                continue
                            for oy in (-1, 0, 1):
                                for ox in (-1, 0, 1):
                                    door_clear.add((int(lx) + int(ox), int(ly) + int(oy)))
                    if door_clear:
                        tile_size = float(self.state.TILE_SIZE)

                        def keep_near_door(px: float, py: float) -> bool:
                            tx = int(math.floor(float(px) / tile_size))
                            ty = int(math.floor(float(py) / tile_size))
                            lx = int(tx - base_tx)
                            ly = int(ty - base_ty)
                            return (int(lx), int(ly)) not in door_clear

                        cars[:] = [c for c in cars if keep_near_door(float(c.pos.x), float(c.pos.y))]
                        bikes[:] = [b for b in bikes if keep_near_door(float(b.pos.x), float(b.pos.y))]
                except Exception:
                    pass

            # Safety: avoid world items spawning on solid tiles (walls/water/facades).
            if items:
                ts = float(self.state.TILE_SIZE)
                chunk_size = int(self.state.CHUNK_SIZE)

                def tile_at_world(tx: int, ty: int) -> int:
                    lx = int(tx - base_tx)
                    ly = int(ty - base_ty)
                    if not (0 <= lx < chunk_size and 0 <= ly < chunk_size):
                        return int(self.state.T_GRASS)
                    return int(tiles[int(ly) * chunk_size + int(lx)])

                max_r = 4  # tiles
                for it in items:
                    try:
                        p = pygame.Vector2(getattr(it, "pos", pygame.Vector2(0, 0)))
                        tx0 = int(math.floor(float(p.x) / ts))
                        ty0 = int(math.floor(float(p.y) / ts))
                        t0 = int(tile_at_world(int(tx0), int(ty0)))
                        if not bool(self.state._tile_solid(int(t0))):
                            continue
                        best: tuple[float, int, int] | None = None
                        for r in range(1, int(max_r) + 1):
                            for oy in range(-r, r + 1):
                                for ox in range(-r, r + 1):
                                    if abs(int(ox)) != int(r) and abs(int(oy)) != int(r):
                                        continue
                                    tx = int(tx0 + ox)
                                    ty = int(ty0 + oy)
                                    t = int(tile_at_world(int(tx), int(ty)))
                                    if bool(self.state._tile_solid(int(t))):
                                        continue
                                    cx = (float(tx) + 0.5) * ts
                                    cy = (float(ty) + 0.5) * ts
                                    d2 = (float(cx) - float(p.x)) ** 2 + (float(cy) - float(p.y)) ** 2
                                    if best is None or float(d2) < float(best[0]):
                                        best = (float(d2), int(tx), int(ty))
                            if best is not None:
                                break
                        if best is not None:
                            _d2, txb, tyb = best
                            getattr(it, "pos").update((float(txb) + 0.5) * ts, (float(tyb) + 0.5) * ts)
                    except Exception:
                        continue

            # Clear the transient registration hook for stamping helpers.
            try:
                self._multi_houses_out = None
            except Exception:
                pass

            return HardcoreSurvivalState._Chunk(
                cx=cx,
                cy=cy,
                tiles=tiles,
                items=items,
                buildings=buildings,
                special_buildings=special_buildings,
                multi_houses=multi_houses,
                cars=cars,
                bikes=bikes,
                props=props,
                town_kind=town_kind,
            )

        def _stamp_compound_highrise_tower(
            self,
            tiles: list[int],
            buildings: list[tuple[int, int, int, int, int, int]],
            special_buildings: list["HardcoreSurvivalState._SpecialBuilding"],
            cx: int,
            cy: int,
            *,
            x0: int,
            y0: int,
            w: int,
            h: int,
            roof_var: int,
            floors: int,
        ) -> None:
            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            x0 = int(x0)
            y0 = int(y0)
            w = int(w)
            h = int(h)
            roof_var = int(roof_var) & 0xFF
            max_f = int(max(2, int(getattr(self.state, "HIGHRISE_MAX_FLOORS", 10))))
            floors = int(max(2, min(int(floors), int(max_f))))

            cut_px = int(self.state._roof_cut_px(style=6, w=int(w), h=int(h), var=int(roof_var), floors=int(floors)))
            ts = int(max(1, int(self.state.TILE_SIZE)))
            cut_tiles = int(cut_px) // ts
            core_h = int(max(2, int(h) - 2 - int(cut_tiles)))
            min_core_h = int(max(6, int(getattr(self.state, "HIGHRISE_MIN_FLOOR_TILES", 9))))
            core_h = int(min(int(max(int(core_h), int(min_core_h))), int(max(2, int(h) - 2))))
            top_cut = int(max(0, (int(h) - 2) - int(core_h)))
            floor_y0 = int(y0 + 1 + int(top_cut))

            # Border walls + walkable interior (same mode as regular houses).
            for y in range(int(y0), int(y0 + h)):
                for x in range(int(x0), int(x0 + w)):
                    if 0 <= x < int(self.state.CHUNK_SIZE) and 0 <= y < int(self.state.CHUNK_SIZE):
                        is_border = (
                            int(x) == int(x0)
                            or int(x) == int(x0 + w - 1)
                            or int(y) == int(y0)
                            or int(y) == int(y0 + h - 1)
                        )
                        if is_border:
                            tiles[idx(int(x), int(y))] = int(self.state.T_WALL)
                        else:
                            inside_floor = bool(int(y) >= int(floor_y0))
                            tiles[idx(int(x), int(y))] = int(self.state.T_FLOOR if inside_floor else self.state.T_WALL)

            # South-facing entrance (2 tiles wide).
            door_y = int(y0 + h - 1)
            door_x0 = int(clamp(int(x0 + w // 2 - 1), int(x0 + 1), int(x0 + w - 3)))
            door_tiles_local = [(int(door_x0), int(door_y)), (int(door_x0 + 1), int(door_y))]
            for dx, dy in door_tiles_local:
                if 0 <= dx < int(self.state.CHUNK_SIZE) and 0 <= dy < int(self.state.CHUNK_SIZE):
                    tiles[idx(int(dx), int(dy))] = int(self.state.T_DOOR)

            # Elevator tile inside the lobby (world-map multi-floor switching).
            try:
                elev_x = int(clamp(int(door_x0), int(x0 + 1), int(x0 + w - 2)))
                elev_y = int(clamp(int(door_y - 3), int(floor_y0), int(y0 + h - 2)))
                if 0 <= elev_x < int(self.state.CHUNK_SIZE) and 0 <= elev_y < int(self.state.CHUNK_SIZE):
                    if int(tiles[idx(int(elev_x), int(elev_y))]) != int(self.state.T_WALL):
                        tiles[idx(int(elev_x), int(elev_y))] = int(self.state.T_ELEVATOR)
            except Exception:
                pass

            # 1F interior: elevator lobby + 2/3 apartments (never single-unit).
            apt_doors: list[tuple[int, int, bool]] = []
            try:
                in_left = int(x0 + 1)
                in_right = int(x0 + w - 2)
                in_top = int(floor_y0)
                in_bottom = int(y0 + h - 2)
                usable_h = int(in_bottom - in_top + 1)
                usable_w = int(in_right - in_left + 1)

                if int(usable_h) >= 6 and int(usable_w) >= 7:
                    # Find (or force) elevator position in the bottom lobby.
                    ex = None
                    ey = None
                    for yy in range(int(in_top), int(in_bottom) + 1):
                        for xx in range(int(in_left), int(in_right) + 1):
                            if int(tiles[idx(int(xx), int(yy))]) == int(self.state.T_ELEVATOR):
                                ex = int(xx)
                                ey = int(yy)
                                break
                        if ex is not None:
                            break

                    # Keep the lobby compact so apartments feel like real homes.
                    lobby_h = int(clamp(int(round(float(usable_h) * 0.18)), 2, 3))
                    min_apt_h = 4
                    lobby_h = int(clamp(int(lobby_h), 2, max(2, int(usable_h) - int(min_apt_h))))
                    sep_y = int(in_bottom - int(lobby_h))
                    sep_y = int(clamp(int(sep_y), int(in_top + min_apt_h - 1), int(in_bottom - 2)))

                    if ex is None or ey is None or int(ey) <= int(sep_y):
                        # Clear any old elevator tiles and place one in the lobby.
                        for yy in range(int(in_top), int(in_bottom) + 1):
                            for xx in range(int(in_left), int(in_right) + 1):
                                if int(tiles[idx(int(xx), int(yy))]) == int(self.state.T_ELEVATOR):
                                    tiles[idx(int(xx), int(yy))] = int(self.state.T_FLOOR)
                        ex = int(clamp(int(door_x0), int(in_left + 1), int(in_right - 1)))
                        ey = int(clamp(int(sep_y + 1), int(sep_y + 1), int(in_bottom - 1)))
                        if int(tiles[idx(int(ex), int(ey))]) != int(self.state.T_WALL):
                            tiles[idx(int(ex), int(ey))] = int(self.state.T_ELEVATOR)

                    lobby_area: set[tuple[int, int]] = set()
                    for dy in (-1, 0, 1):
                        for dx in (-1, 0, 1):
                            lobby_area.add((int(ex + dx), int(ey + dy)))

                    # Horizontal separator: lobby (south) vs apartments (north).
                    for xx in range(int(in_left), int(in_right) + 1):
                        if int(tiles[idx(int(xx), int(sep_y))]) == int(self.state.T_ELEVATOR):
                            continue
                        tiles[idx(int(xx), int(sep_y))] = int(self.state.T_WALL)

                    # Always 2 units ().
                    units = 2
                    min_unit_w = 5 if int(usable_w) >= 11 else 3
                    if int(units) == 3:
                        min_unit_w = 5
                    unit_ranges: list[tuple[int, int]] = []
                    split_xs: list[int] = []
                    if int(units) == 2:
                        split_x = int(clamp(int(ex), int(in_left + min_unit_w), int(in_right - min_unit_w)))
                        split_xs = [int(split_x)]
                        unit_ranges = [(int(in_left), int(split_x - 1)), (int(split_x + 1), int(in_right))]
                    else:
                        x1 = int(in_left + (int(usable_w) // 3))
                        x2 = int(in_left + (int(usable_w) * 2) // 3)
                        x1 = int(clamp(int(x1), int(in_left + min_unit_w), int(in_right - 2 * min_unit_w - 1)))
                        x2 = int(clamp(int(x2), int(x1 + min_unit_w + 1), int(in_right - min_unit_w)))
                        split_xs = [int(x1), int(x2)]
                        unit_ranges = [
                            (int(in_left), int(x1 - 1)),
                            (int(x1 + 1), int(x2 - 1)),
                            (int(x2 + 1), int(in_right)),
                        ]

                    # Vertical separators between units (only above the lobby line).
                    for sx in split_xs:
                        for yy in range(int(in_top), int(sep_y)):
                            tiles[idx(int(sx), int(yy))] = int(self.state.T_WALL)

                    reserved: set[tuple[int, int]] = set(lobby_area)
                    seed_base = int(self.seed) ^ 0x6B8B4567
                    for ux0, ux1 in unit_ranges:
                        if int(ux1 - ux0 + 1) < 3:
                            continue
                        dx = int(clamp(int((ux0 + ux1) // 2), int(ux0 + 1), int(ux1 - 1)))
                        # Unit-entry doors:
                        # - 1F: always locked (prevents breaking into neighbors from the lobby).
                        # - Upper floors: some are broken (enterable).
                        wx = int(cx) * int(self.state.CHUNK_SIZE) + int(dx)
                        wy = int(cy) * int(self.state.CHUNK_SIZE) + int(sep_y)
                        hh = int(self.state._hash2_u32(int(wx), int(wy), int(seed_base)))
                        broken_up = int(hh % 100) < 18
                        tiles[idx(int(dx), int(sep_y))] = int(self.state.T_DOOR_LOCKED)
                        apt_doors.append((int(dx), int(sep_y), bool(broken_up)))
                        for dy in (-1, 0, 1):
                            for dx2 in (-1, 0, 1):
                                reserved.add((int(dx + dx2), int(sep_y + dy)))
            except Exception:
                pass

            # Register as a high-rise (for markers/home selection).     
            tx0w = int(cx) * int(self.state.CHUNK_SIZE) + int(x0)       
            ty0w = int(cy) * int(self.state.CHUNK_SIZE) + int(y0)       
            doors_w = tuple(
                (int(cx) * int(self.state.CHUNK_SIZE) + int(dx), int(cy) * int(self.state.CHUNK_SIZE) + int(dy))
                for dx, dy in door_tiles_local
            )
            special_buildings.append(
                HardcoreSurvivalState._SpecialBuilding(
                    kind="highrise",
                    name="",
                    tx0=int(tx0w),
                    ty0=int(ty0w),
                    w=int(w),
                    h=int(h),
                    door_tiles=doors_w,
                    floors=int(floors),
                )
            )
            roof_kind = (6 << 8) | int(roof_var)
            buildings.append((int(tx0w), int(ty0w), int(w), int(h), int(roof_kind), int(floors)))

            # Register as a multi-floor building so facade slicing + floor switching works.
            mh_out: list[HardcoreSurvivalState._MultiHouse] | None = getattr(self, "_multi_houses_out", None)
            if mh_out is not None and int(floors) > 1:
                f1: list[int] = []
                for yy in range(int(h)):
                    for xx in range(int(w)):
                        f1.append(int(tiles[idx(int(x0 + xx), int(y0 + yy))]))

                f_up = list(f1)
                for dx, dy in door_tiles_local:
                    i2 = int(dy - y0) * int(w) + int(dx - x0)
                    if 0 <= i2 < len(f_up):
                        f_up[int(i2)] = int(self.state.T_WALL)
                # Upper floors: apply the precomputed broken/locked state for unit-entry doors.
                try:
                    for dx, dy, broken_up in list(apt_doors):
                        i2 = int(dy - y0) * int(w) + int(dx - x0)
                        if 0 <= i2 < len(f_up):
                            f_up[int(i2)] = int(self.state.T_DOOR_BROKEN) if bool(broken_up) else int(self.state.T_DOOR_LOCKED)
                except Exception:
                    pass

                floor_tiles: dict[int, list[int]] = {1: f1}
                for fl in range(2, int(floors) + 1):
                    floor_tiles[int(fl)] = f_up

                mh_out.append(
                    HardcoreSurvivalState._MultiHouse(
                        tx0=int(tx0w),
                        ty0=int(ty0w),
                        w=int(w),
                        h=int(h),
                        floors=int(floors),
                        cur_floor=1,
                        floor_tiles=floor_tiles,
                    )
                )

        def _stamp_compound_podium_block(
            self,
            tiles: list[int],
            buildings: list[tuple[int, int, int, int, int, int]],
            cx: int,
            cy: int,
            *,
            x0: int,
            y0: int,
            w: int,
            h: int,
            roof_style: int = 2,
            roof_var: int | None = None,
        ) -> None:
            # Simple low-rise skirt building chunk: solid mass with a roof (visual ring).
            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            x0 = int(x0)
            y0 = int(y0)
            w = int(w)
            h = int(h)
            if w <= 0 or h <= 0:
                return

            for y in range(int(y0), int(y0 + h)):
                if not (0 <= int(y) < int(self.state.CHUNK_SIZE)):
                    continue
                for x in range(int(x0), int(x0 + w)):
                    if not (0 <= int(x) < int(self.state.CHUNK_SIZE)):
                        continue
                    tiles[idx(int(x), int(y))] = int(self.state.T_WALL)

            tx0w = int(cx) * int(self.state.CHUNK_SIZE) + int(x0)
            ty0w = int(cy) * int(self.state.CHUNK_SIZE) + int(y0)
            if roof_var is None:
                roof_var = int(self.state._hash2_u32(int(tx0w), int(ty0w), self.seed ^ 0x7A11C1D3) & 0xFF)
            roof_kind = (int(roof_style) << 8) | (int(roof_var) & 0xFF)
            buildings.append((int(tx0w), int(ty0w), int(w), int(h), int(roof_kind), 0))

        def _stamp_compound_chunk(
            self,
            tiles: list[int],
            buildings: list[tuple[int, int, int, int, int, int]],
            special_buildings: list["HardcoreSurvivalState._SpecialBuilding"],
            cars: list["HardcoreSurvivalState._ParkedCar"],
            bikes: list["HardcoreSurvivalState._ParkedBike"],
            props: list["HardcoreSurvivalState._WorldProp"],
            cx: int,
            cy: int,
            rng: random.Random,
        ) -> None:
            # Walled "": ~7-8 tall towers (20+ floors) with a low-rise podium ring.
            cx = int(cx)
            cy = int(cy)

            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            base_tx = int(cx) * int(self.state.CHUNK_SIZE)
            base_ty = int(cy) * int(self.state.CHUNK_SIZE)

            tx0 = int(getattr(self, "compound_tx0", 0))
            ty0 = int(getattr(self, "compound_ty0", 0))
            tx1 = int(getattr(self, "compound_tx1", 0))
            ty1 = int(getattr(self, "compound_ty1", 0))
            gate_x0 = int(getattr(self, "compound_gate_x0", 0))
            gate_x1 = int(getattr(self, "compound_gate_x1", -1))
            rvx0 = int(getattr(self, "compound_road_v_x0", 15))
            rvx1 = int(getattr(self, "compound_road_v_x1", 16))
            rhy0 = int(getattr(self, "compound_road_h_y0", 31))
            rhy1 = int(getattr(self, "compound_road_h_y1", 31))

            ccx0 = int(getattr(self, "compound_cx0", cx))
            ccy0 = int(getattr(self, "compound_cy0", cy))
            ccx1 = int(getattr(self, "compound_cx1", cx))
            ccy1 = int(getattr(self, "compound_cy1", cy))
            gate_cx = int(ccx0) + int(int(getattr(self, "compound_w_chunks", 0)) // 2)
            near_gate = bool(int(cy) == int(ccy1) and abs(int(cx) - int(gate_cx)) <= 1)
            is_gate_chunk = bool(int(cy) == int(ccy1) and int(cx) == int(gate_cx))

            parking_chunks = set(getattr(self, "compound_parking_chunks", set()))
            is_parking_chunk = (int(cx), int(cy)) in parking_chunks

            # Base ground (overwrite the city district pattern in the compound area).
            for y in range(int(self.state.CHUNK_SIZE)):
                wy = int(base_ty + y)
                for x in range(int(self.state.CHUNK_SIZE)):
                    wx = int(base_tx + x)

                    tile = int(self.state.T_CONCRETE)
                    # Sparse greenery between blocks.
                    g = float(self.state._noise2(float(wx) / 18.0, float(wy) / 18.0, self.seed ^ 0x7A11C1D3))
                    if g > 0.94:
                        tile = int(self.state.T_GRASS)

                    if not is_parking_chunk:
                        if int(rvx0) <= int(x) <= int(rvx1) or int(rhy0) <= int(y) <= int(rhy1):
                            tile = int(self.state.T_ROAD)

                    # Outer compound wall (leave a driveable opening at the gate).
                    if int(wx) == int(tx0) or int(wx) == int(tx1) or int(wy) == int(ty0) or int(wy) == int(ty1):
                        if int(wy) == int(ty1) and int(gate_x0) <= int(wx) <= int(gate_x1):
                            tile = int(self.state.T_ROAD)  # gate opening (walk/drive through)
                        else:
                            tile = int(self.state.T_WALL)

                    tiles[idx(int(x), int(y))] = int(tile)

            # Podium ("") ring along the compound perimeter (keep the gate approach open).
            on_edge = bool(int(cx) == int(ccx0) or int(cx) == int(ccx1) or int(cy) == int(ccy0) or int(cy) == int(ccy1))
            if on_edge and (not is_parking_chunk):
                pod_t = 10
                if int(cy) == int(ccy0):
                    self._stamp_compound_podium_block(tiles, buildings, cx, cy, x0=2, y0=2, w=28, h=pod_t, roof_style=2)
                if int(cy) == int(ccy1) and (not near_gate):
                    # Keep a few tiles open near the south wall so the player can reach the gate.
                    self._stamp_compound_podium_block(tiles, buildings, cx, cy, x0=2, y0=18, w=28, h=pod_t, roof_style=2)
                if int(cx) == int(ccx0):
                    self._stamp_compound_podium_block(tiles, buildings, cx, cy, x0=2, y0=2, w=pod_t, h=28, roof_style=2)
                if int(cx) == int(ccx1):
                    self._stamp_compound_podium_block(tiles, buildings, cx, cy, x0=20, y0=2, w=pod_t, h=28, roof_style=2)

            # Gatehouse blocks (1F) framing the opening.
            if is_gate_chunk:
                # Two small wings near the south wall, leave the center corridor clear.
                self._stamp_compound_podium_block(tiles, buildings, cx, cy, x0=2, y0=22, w=10, h=8, roof_style=2, roof_var=64)
                self._stamp_compound_podium_block(tiles, buildings, cx, cy, x0=20, y0=22, w=10, h=8, roof_style=2, roof_var=96)
                # A sign prop near the gate so it reads as an entrance.
                gx = int(clamp(int((gate_x0 + gate_x1) // 2), int(base_tx), int(base_tx + self.state.CHUNK_SIZE - 1)))
                gy = int(ty1 - 1)
                props.append(
                    HardcoreSurvivalState._WorldProp(
                        pos=pygame.Vector2((float(gx) + 0.5) * float(self.state.TILE_SIZE), (float(gy) + 0.5) * float(self.state.TILE_SIZE)),
                        prop_id="sign_chinese",
                        variant=int(rng.randint(0, 3)),
                        dir="down",
                    )
                )

            # Parking lots near the gate (visual interest).
            if is_parking_chunk:
                self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings)
                self._spawn_two_wheelers(
                    tiles,
                    bikes,
                    cx,
                    cy,
                    rng=rng,
                    count=int(rng.randint(0, 2)),
                    models=["bike_lady", "bike_mountain", "bike_auto", "moto"],
                    buildings=buildings,
                )

            # Stamp planned towers for this chunk.
            towers = (getattr(self, "compound_towers_by_chunk", {}) or {}).get((int(cx), int(cy)), [])
            for x0, y0, w, h, roof_var, floors in towers:
                self._stamp_compound_highrise_tower(
                    tiles,
                    buildings,
                    special_buildings,
                    cx,
                    cy,
                    x0=int(x0),
                    y0=int(y0),
                    w=int(w),
                    h=int(h),
                    roof_var=int(roof_var),
                    floors=int(floors),
                )

        def _stamp_city_chunk(
            self,
            tiles: list[int],
            items: list["HardcoreSurvivalState._WorldItem"],
            buildings: list[tuple[int, int, int, int, int, int]],
            special_buildings: list["HardcoreSurvivalState._SpecialBuilding"],
            cars: list["HardcoreSurvivalState._ParkedCar"],
            bikes: list["HardcoreSurvivalState._ParkedBike"],
            props: list["HardcoreSurvivalState._WorldProp"],
            cx: int,
            cy: int,
            rng: random.Random,
            reserved: set[tuple[int, int]] | None = None,
        ) -> None:
            # Dense city composition: mix facilities + residential blocks.
            roll = float(rng.random())
            dist = max(abs(int(cx) - int(getattr(self, "city_cx", 0))), abs(int(cy) - int(getattr(self, "city_cy", 0))))
            radius = max(1, int(getattr(self, "city_radius", 1)))
            density = 1.0 - float(dist) / float(radius)
            buildings_n = int(clamp(3 + int(round(5.0 * density)), 3, 8))

            # Chunk-level districts so city blocks feel different.
            district = float(self.state._noise2(float(cx) / 3.4, float(cy) / 3.4, self.seed ^ 0x4C17C0DE))
            chinese_district = bool(district > 0.78)
            commercial_district = bool(district < 0.22)

            core = bool(density >= 0.72)
            stx, sty = self.spawn_tile()
            spawn_cx = int(stx) // self.state.CHUNK_SIZE
            spawn_cy = int(sty) // self.state.CHUNK_SIZE
            if self._is_compound_chunk(int(cx), int(cy)):
                self._stamp_compound_chunk(
                    tiles,
                    buildings,
                    special_buildings,
                    cars,
                    bikes,
                    props,
                    cx,
                    cy,
                    rng,
                )
                return
            is_spawn_chunk = (int(spawn_cx) == int(cx)) and (int(spawn_cy) == int(cy))
            # Starter "Chinese community": a small cluster of high-rises near spawn.
            in_community = (int(spawn_cx) <= int(cx) <= int(spawn_cx) + 1) and (int(spawn_cy) <= int(cy) <= int(spawn_cy) + 1)
            school_chunk = (int(cx) == int(spawn_cx) + 1) and (int(cy) == int(spawn_cy))
            # Dedicated compound exists now; disable the old starter-community cluster here.
            use_starter_community = False
            if use_starter_community and is_spawn_chunk:
                # Spawn block: guarantee a home high-rise; the school is in an adjacent
                # community chunk to keep this block more residential.
                self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "", reserved=reserved)
                # Add a few extra towers so it reads like a "".
                for _ in range(int(rng.randint(1, 3))):
                    if rng.random() < 0.85:
                        self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "", reserved=reserved)
                if rng.random() < 0.35:
                    self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "", reserved=reserved)
                self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, school=True, buildings=buildings, reserved=reserved)
                self._spawn_two_wheelers(
                    tiles,
                    bikes,
                    cx,
                    cy,
                    rng=rng,
                    count=rng.randint(6, 12),
                    models=["bike_lady", "bike_mountain", "bike_auto", "moto", "moto_lux", "moto_long"],
                    buildings=buildings,
                    reserved=reserved,
                )
                buildings_n = max(3, buildings_n - 2)
            elif use_starter_community and in_community:
                # Community chunks: mostly residential towers; one chunk hosts the school.
                if school_chunk:
                    self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "", reserved=reserved)
                    self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, school=True, buildings=buildings, reserved=reserved)
                else:
                    self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "", reserved=reserved)
                    if rng.random() < 0.55:
                        self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "", reserved=reserved)
                    if core and rng.random() < 0.22:
                        self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "", reserved=reserved)
                    if rng.random() < 0.55:
                        self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)
                buildings_n = max(3, buildings_n - 1)
            elif core:
                big_roll = float(rng.random())
                if big_roll < 0.07:
                    self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "", reserved=reserved)
                    self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)
                    buildings_n = max(3, buildings_n - 1)
                elif big_roll < 0.12:
                    self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "", reserved=reserved)
                    if rng.random() < 0.35:
                        self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "", reserved=reserved)
                    buildings_n = max(3, buildings_n - 1)
                elif big_roll < 0.18:
                    self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "", reserved=reserved)
                    buildings_n = max(3, buildings_n - 1)
                elif big_roll < 0.24:
                    # Core districts should always have a few recognizable shops.
                    kind = "" if rng.random() < 0.52 else ""
                    self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, kind, reserved=reserved)
                    self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)
                    buildings_n = max(3, buildings_n - 1)

            if chinese_district and (not is_spawn_chunk) and rng.random() < (0.55 + 0.25 * density):
                # A small cluster of Chinese-style buildings.
                n = 2 if (density > 0.55 and rng.random() < 0.55) else 1
                for _ in range(int(n)):
                    self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "", reserved=reserved)
                buildings_n = max(3, int(buildings_n) - int(n))

            if roll < 0.16:
                self._stamp_basketball_court(tiles, rng=rng)
                self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)
            elif roll < 0.32:
                self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "", reserved=reserved)
                self._stamp_basketball_court(tiles, rng=rng)
                self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, school=True, buildings=buildings, reserved=reserved)
                self._spawn_two_wheelers(tiles, bikes, cx, cy, rng=rng, count=rng.randint(2, 6), models=["bike_lady", "bike_mountain", "bike_auto", "moto", "moto_lux", "moto_long"], buildings=buildings, reserved=reserved)
                buildings_n = max(3, buildings_n - 1)
            elif roll < 0.46:
                self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "", reserved=reserved)
                self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)
            elif roll < 0.60:
                self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "", reserved=reserved)
                self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)
            elif roll < 0.68 and commercial_district:
                kind = "" if rng.random() < 0.55 else ""
                self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, kind, reserved=reserved)
                self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)
            elif roll < 0.74:
                self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "", reserved=reserved)

            for _ in range(int(buildings_n)):
                if chinese_district and rng.random() < 0.55:
                    kind = ""
                else:
                    if commercial_district:
                        pool = ["", "", "", "", "", "", "", "", "", "", ""]
                    else:
                        # Non-commercial blocks still occasionally get a bookstore/gun shop,
                        # so the whole city doesn't end up as pure residential.
                        pool = ["", "", "", "", "", "", "", "", "", "", "", "", ""]
                    kind = str(rng.choice(pool))
                if core:
                    if kind == "" and rng.random() < 0.45:
                        kind = ""
                    elif kind == "" and rng.random() < 0.45:
                        kind = ""
                    elif kind == "" and rng.random() < 0.35:
                        kind = ""
                if not commercial_district:
                    if kind in ("", "", "") and rng.random() < 0.35:
                        kind = ""
                    elif kind in ("", "") and rng.random() < 0.15:
                        kind = ""
                self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, kind, reserved=reserved)

            # Make parking lots common/visible in city blocks (esp. near core).
            # (Parking stamping is safe: it avoids overwriting buildings/roads.)
            if not is_spawn_chunk:
                lot_chance = float(clamp(0.12 + 0.18 * density, 0.10, 0.35))
                if rng.random() < lot_chance:
                    self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)
                if core and rng.random() < 0.10:
                    self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)

            # Street lighting: road-side lamp posts so nights aren't pure black.
            self._stamp_city_streetlamps(tiles, props, buildings, cx, cy, rng=rng, reserved=reserved)
            self._stamp_city_decor(tiles, props, cx, cy, rng=rng)

        def _stamp_city_streetlamps(
            self,
            tiles: list[int],
            props: list["HardcoreSurvivalState._WorldProp"],
            buildings: list[tuple[int, int, int, int, int, int]],
            cx: int,
            cy: int,
            *,
            rng: random.Random,
            reserved: set[tuple[int, int]] | None = None,
        ) -> None:
            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            base_tx = int(cx) * int(self.state.CHUNK_SIZE)
            base_ty = int(cy) * int(self.state.CHUNK_SIZE)
            tile_size = int(self.state.TILE_SIZE)

            t_road = int(self.state.T_ROAD)
            t_highway = int(self.state.T_HIGHWAY)
            walk_tiles = {
                int(self.state.T_SIDEWALK),
                int(self.state.T_PAVEMENT),
                int(self.state.T_BRICK),
                int(self.state.T_CONCRETE),
            }

            def inside_any_building(tx: int, ty: int) -> bool:
                for bx0, by0, bw, bh, _roof_kind, _floors in buildings:
                    if int(bx0) <= int(tx) < int(bx0) + int(bw) and int(by0) <= int(ty) < int(by0) + int(bh):
                        return True
                return False

            # Deterministic spacing along streets.
            spacing = 10
            off_x = int(rng.randrange(spacing))
            off_y = int(rng.randrange(spacing))

            cand: list[tuple[int, int]] = []
            for y in range(2, int(self.state.CHUNK_SIZE) - 2):
                for x in range(2, int(self.state.CHUNK_SIZE) - 2):
                    if reserved is not None and (int(x), int(y)) in reserved:
                        continue
                    t = int(tiles[idx(int(x), int(y))])
                    if t not in walk_tiles:
                        continue
                    # Must be next to a road/highway edge.
                    left = int(tiles[idx(int(x - 1), int(y))])
                    right = int(tiles[idx(int(x + 1), int(y))])
                    up = int(tiles[idx(int(x), int(y - 1))])
                    down = int(tiles[idx(int(x), int(y + 1))])
                    near_lr = (left in (t_road, t_highway)) or (right in (t_road, t_highway))
                    near_ud = (up in (t_road, t_highway)) or (down in (t_road, t_highway))
                    if not (near_lr or near_ud):
                        continue

                    # Avoid placing right against building walls/doors to reduce visual overlap.
                    near_wall = False
                    for ny in range(int(y) - 1, int(y) + 2):
                        for nx in range(int(x) - 1, int(x) + 2):
                            tt = int(tiles[idx(int(nx), int(ny))])
                            if tt in (int(self.state.T_WALL), int(self.state.T_DOOR)):
                                near_wall = True
                                break
                        if near_wall:
                            break
                    if near_wall:
                        continue

                    tx = int(base_tx + int(x))
                    ty = int(base_ty + int(y))
                    if inside_any_building(int(tx), int(ty)):
                        continue

                    if near_lr and (int(ty) % spacing) != int(off_y):
                        continue
                    if near_ud and (int(tx) % spacing) != int(off_x):
                        continue
                    cand.append((int(x), int(y)))

            if not cand:
                return
            rng.shuffle(cand)

            # Cap per chunk to keep lighting cost predictable.
            want = int(clamp(int(len(cand) // 18), 4, 14))
            min_d2 = float((tile_size * 6) ** 2)

            placed = 0
            for x, y in cand:
                if placed >= want:
                    break
                tx = int(base_tx + int(x))
                ty = int(base_ty + int(y))
                px = (float(tx) + 0.5) * float(tile_size)
                py = (float(ty) + 0.5) * float(tile_size)
                ok = True
                for pr in props:
                    if str(getattr(pr, "prop_id", "")) != "streetlamp":
                        continue
                    dx = float(pr.pos.x) - float(px)
                    dy = float(pr.pos.y) - float(py)
                    if dx * dx + dy * dy < min_d2:
                        ok = False
                        break
                if not ok:
                    continue
                props.append(
                    HardcoreSurvivalState._WorldProp(
                        pos=pygame.Vector2(px, py),
                        prop_id="streetlamp",
                        variant=int(rng.randint(0, 1)),
                        dir=str(rng.choice(["left", "right"])),
                    )
                )
                placed += 1

        def _ensure_building_doors(
            self,
            tiles: list[int],
            buildings: list[tuple[int, int, int, int, int, int]],
            special_buildings: list["HardcoreSurvivalState._SpecialBuilding"],
            cx: int,
            cy: int,
            *,
            reserved: set[tuple[int, int]] | None = None,
        ) -> None:
            # Ensure that:
            # - portal buildings' door tiles are actually doors on the tilemap
            # - "walkable interior" buildings have at least 1 exterior door
            # This prevents un-enterable buildings (solid wall loops).
            chunk_size = int(self.state.CHUNK_SIZE)
            base_tx = int(cx) * chunk_size
            base_ty = int(cy) * chunk_size

            def idx(x: int, y: int) -> int:
                return int(y) * chunk_size + int(x)

            door_tids = {
                int(self.state.T_DOOR),
                int(self.state.T_DOOR_HOME),
                int(self.state.T_DOOR_LOCKED),
                int(self.state.T_DOOR_HOME_LOCKED),
                int(self.state.T_DOOR_BROKEN),
            }

            # 1) Special building portals: force the listed door tiles to be doors.
            try:
                for sb in list(special_buildings or []):
                    for tx, ty in getattr(sb, "door_tiles", ()) or ():
                        lx = int(tx) - int(base_tx)
                        ly = int(ty) - int(base_ty)
                        if 0 <= lx < chunk_size and 0 <= ly < chunk_size:
                            tiles[idx(lx, ly)] = int(self.state.T_DOOR)
            except Exception:
                pass

            def has_walkable_interior(x0: int, y0: int, w: int, h: int) -> bool:
                # Decorative blocks (e.g., podium ring) are all-wall; skip them.
                # Treat any non-solid interior tile as "walkable interior" so
                # we don't miss buildings that use alternate floor materials.
                for yy in range(int(y0) + 1, int(y0 + h) - 1):
                    for xx in range(int(x0) + 1, int(x0 + w) - 1):
                        t = int(tiles[idx(int(xx), int(yy))])
                        if t == int(self.state.T_WALL):
                            continue
                        tdef = self.state._TILES.get(int(t))
                        if tdef is None:
                            continue
                        if not bool(getattr(tdef, "solid", False)):
                            return True
                return False

            def clear_if_solid(x: int, y: int) -> None: 
                if not (0 <= int(x) < chunk_size and 0 <= int(y) < chunk_size): 
                    return 
                tid = int(tiles[idx(int(x), int(y))]) 
                tdef = self.state._TILES.get(int(tid)) 
                if tdef is None: 
                    return 
                if bool(getattr(tdef, "solid", False)): 
                    tiles[idx(int(x), int(y))] = int(self.state.T_FLOOR) 

            def border_has_door(x0: int, y0: int, w: int, h: int) -> bool:
                for xx in range(int(x0), int(x0 + w)):
                    if int(tiles[idx(int(xx), int(y0))]) in door_tids:
                        return True
                    if int(tiles[idx(int(xx), int(y0 + h - 1))]) in door_tids:
                        return True
                for yy in range(int(y0), int(y0 + h)):
                    if int(tiles[idx(int(x0), int(yy))]) in door_tids:
                        return True
                    if int(tiles[idx(int(x0 + w - 1), int(yy))]) in door_tids:
                        return True
                return False

            def approach_clear(x: int, y: int, *, ox: int, oy: int) -> bool:
                # Ensure a few tiles outside the door aren't blocked by other buildings.
                for step in range(1, 9):
                    px = int(x) + int(ox) * int(step)
                    py = int(y) + int(oy) * int(step)
                    if not (0 <= px < chunk_size and 0 <= py < chunk_size):
                        break
                    tcur = int(tiles[idx(int(px), int(py))])
                    if tcur in (
                        int(self.state.T_WALL),
                        int(self.state.T_FLOOR),
                        int(self.state.T_DOOR),
                        int(self.state.T_DOOR_HOME),
                        int(self.state.T_DOOR_LOCKED),
                        int(self.state.T_DOOR_HOME_LOCKED),
                        int(self.state.T_DOOR_BROKEN),
                    ):
                        return False
                return True

            def carve_path_from(x: int, y: int, *, ox: int, oy: int) -> None:
                path_tile = (
                    int(self.state.T_SIDEWALK) if bool(self._is_city_chunk(int(cx), int(cy))) else int(self.state.T_ROAD)
                )
                for step in range(1, 9):
                    px = int(x) + int(ox) * int(step)
                    py = int(y) + int(oy) * int(step)
                    if not (0 <= px < chunk_size and 0 <= py < chunk_size):
                        break
                    tcur = int(tiles[idx(int(px), int(py))])
                    if tcur in (
                        int(self.state.T_WALL),
                        int(self.state.T_FLOOR),
                        int(self.state.T_DOOR),
                        int(self.state.T_DOOR_HOME),
                        int(self.state.T_DOOR_LOCKED),
                        int(self.state.T_DOOR_HOME_LOCKED),
                        int(self.state.T_DOOR_BROKEN),
                    ):
                        break
                    tiles[idx(int(px), int(py))] = int(path_tile)
                    if reserved is not None:
                        reserved.add((int(px), int(py)))

            # 2) Regular buildings: if interior is walkable, guarantee at least one exterior door.
            for bx0, by0, bw, bh, _roof_kind, _floors in list(buildings or []):
                bx0 = int(bx0)
                by0 = int(by0)
                bw = int(bw)
                bh = int(bh)
                lx0 = int(bx0) - int(base_tx)
                ly0 = int(by0) - int(base_ty)
                if bw <= 0 or bh <= 0:
                    continue
                if not (0 <= lx0 < chunk_size and 0 <= ly0 < chunk_size):
                    continue
                if lx0 + bw > chunk_size or ly0 + bh > chunk_size: 
                    continue 
                if not has_walkable_interior(lx0, ly0, bw, bh): 
                    continue 
 
                if not border_has_door(lx0, ly0, bw, bh): 
                    # Default to a south-facing 2-tile entrance (matches our facade draw). 
                    door_y = int(ly0 + bh - 1) 
                    if door_y <= 0 or door_y >= chunk_size: 
                        continue 
                    ox, oy = 0, 1 
 
                    # Prefer positions with a clear approach; fall back to centered. 
                    x_candidates = [int(x) for x in range(int(lx0 + 1), int(lx0 + bw - 2))] 
                    if x_candidates: 
                        # Center bias: check closer-to-center candidates first. 
                        cx0 = int(lx0 + bw // 2) 
                        x_candidates.sort(key=lambda v: abs(int(v) - int(cx0))) 
 
                    door_x0: int | None = None 
                    for cand in x_candidates: 
                        if cand + 1 >= int(lx0 + bw - 1): 
                            continue 
                        # Ensure the tiles just inside the doorway are not walls. 
                        in_ok = True 
                        for dx in (cand, cand + 1): 
                            if int(tiles[idx(int(dx), int(door_y - 1))]) == int(self.state.T_WALL): 
                                in_ok = False 
                                break 
                        if not in_ok: 
                            continue 
                        if approach_clear(int(cand), int(door_y), ox=ox, oy=oy): 
                            door_x0 = int(cand) 
                            break 
 
                    if door_x0 is None: 
                        # As a last resort, carve the interior landing too. 
                        door_x0 = int(clamp(int(lx0 + bw // 2 - 1), int(lx0 + 1), int(lx0 + bw - 3))) 
 
                    for dx in (int(door_x0), int(door_x0 + 1)): 
                        tiles[idx(int(dx), int(door_y))] = int(self.state.T_DOOR) 
                        clear_if_solid(int(dx), int(door_y - 1)) 
 
                    carve_path_from(int(door_x0), int(door_y), ox=ox, oy=oy) 
                    carve_path_from(int(door_x0 + 1), int(door_y), ox=ox, oy=oy) 
 
                # Ensure existing/new doorway landings aren't blocked by solid furniture. 
                try: 
                    for xx in range(int(lx0), int(lx0 + bw)): 
                        if int(tiles[idx(int(xx), int(ly0))]) in door_tids: 
                            clear_if_solid(int(xx), int(ly0 + 1)) 
                        if int(tiles[idx(int(xx), int(ly0 + bh - 1))]) in door_tids: 
                            clear_if_solid(int(xx), int(ly0 + bh - 2)) 
                    for yy in range(int(ly0), int(ly0 + bh)): 
                        if int(tiles[idx(int(lx0), int(yy))]) in door_tids: 
                            clear_if_solid(int(lx0 + 1), int(yy)) 
                        if int(tiles[idx(int(lx0 + bw - 1), int(yy))]) in door_tids: 
                            clear_if_solid(int(lx0 + bw - 2), int(yy)) 
                except Exception: 
                    pass 
 
        def _stamp_basketball_court(self, tiles: list[int], *, rng: random.Random) -> None: 
            # Simple outdoor court: a rectangle of court tiles. 
            w = rng.randint(10, 14) 
            h = rng.randint(8, 10)
            x0 = rng.randint(2, self.state.CHUNK_SIZE - w - 2)
            y0 = rng.randint(2, self.state.CHUNK_SIZE - h - 2)

            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            for y in range(int(y0), int(y0 + h)):
                for x in range(int(x0), int(x0 + w)):
                    if int(tiles[idx(x, y)]) == int(self.state.T_ROAD):
                        return
            for y in range(int(y0), int(y0 + h)):
                for x in range(int(x0), int(x0 + w)):
                    tiles[idx(x, y)] = int(self.state.T_COURT)

        def _stamp_gas_station_chunk(
            self,
            tiles: list[int],
            items: list["HardcoreSurvivalState._WorldItem"],
            buildings: list[tuple[int, int, int, int, int, int]],
            props: list["HardcoreSurvivalState._WorldProp"],
            cx: int,
            cy: int,
            *,
            rng: random.Random,
            reserved: set[tuple[int, int]] | None = None,
        ) -> None:
            # Simple roadside gas station: a small shop + a couple of pumps.
            chunk_size = int(self.state.CHUNK_SIZE)

            def idx(x: int, y: int) -> int:
                return y * chunk_size + x

            base_tx = int(cx) * chunk_size
            base_ty = int(cy) * chunk_size

            # Forecourt aligned near the highway band (if present).
            hy = int(getattr(self, "highway_y", base_ty + chunk_size // 2))
            y_center = int(clamp(int(hy - base_ty), 8, 24))
            x0 = 4
            w = 24
            h = 14
            y0 = int(clamp(int(y_center) - 10, 2, chunk_size - h - 2))

            for y in range(int(y0), int(y0 + h)):
                for x in range(int(x0), int(x0 + w)):
                    tiles[idx(int(x), int(y))] = int(self.state.T_PAVEMENT)

            # Shop building (1F).
            shop_x0 = int(x0 + 2)
            shop_y0 = int(y0 + 2)
            shop_w = 9
            shop_h = 7
            door_x = int(shop_x0 + shop_w // 2)
            door_y = int(shop_y0 + shop_h - 1)
            for y in range(int(shop_y0), int(shop_y0 + shop_h)):
                for x in range(int(shop_x0), int(shop_x0 + shop_w)):
                    border = bool(
                        int(x) == int(shop_x0)
                        or int(x) == int(shop_x0 + shop_w - 1)
                        or int(y) == int(shop_y0)
                        or int(y) == int(shop_y0 + shop_h - 1)
                    )
                    tiles[idx(int(x), int(y))] = int(self.state.T_WALL if border else self.state.T_FLOOR)
            tiles[idx(int(door_x), int(door_y))] = int(self.state.T_DOOR)
            if reserved is not None:
                for dy in (-1, 0, 1):
                    for dx in (-1, 0, 1):
                        reserved.add((int(door_x + dx), int(door_y + dy)))

            roof_var = int(rng.randrange(0, 256))
            roof_kind = (2 << 8) | int(roof_var)
            buildings.append((int(base_tx + shop_x0), int(base_ty + shop_y0), int(shop_w), int(shop_h), int(roof_kind), 1))

            # Front sign.
            props.append(
                HardcoreSurvivalState._WorldProp(
                    pos=pygame.Vector2((float(base_tx + door_x) + 0.5) * float(self.state.TILE_SIZE), (float(base_ty + door_y) + 0.5) * float(self.state.TILE_SIZE)),
                    prop_id="sign_gas",
                    variant=0,
                    dir="down",
                )
            )

            # Pumps (solid tiles).
            pump_y = int(y0 + h - 5)
            for pump_x in (int(x0 + w - 8), int(x0 + w - 5)):
                if int(x0) <= int(pump_x) < int(x0 + w) and int(y0) <= int(pump_y) < int(y0 + h):
                    tiles[idx(int(pump_x), int(pump_y))] = int(self.state.T_GAS_PUMP)

            # Small parking stripe to the side.
            for y in range(int(y0 + 1), int(y0 + h - 1)):
                x = int(x0 + w - 2)
                if 0 <= x < chunk_size:
                    tiles[idx(int(x), int(y))] = int(self.state.T_PARKING)

        def _stamp_parking_lot(
            self,
            tiles: list[int],
            cars: list["HardcoreSurvivalState._ParkedCar"],
            bikes: list["HardcoreSurvivalState._ParkedBike"],
            cx: int,
            cy: int,
            *,
            rng: random.Random,
            school: bool = False,
            buildings: list[tuple[int, int, int, int, int, int]] | None = None,
            reserved: set[tuple[int, int]] | None = None,
        ) -> None:
            # Parking lot: stamp tiles + spawn parked vehicles (visual props).
            allowed_base = {
                int(self.state.T_GRASS),
                int(self.state.T_FOREST),
                int(self.state.T_PAVEMENT),
                int(self.state.T_PARKING),
                int(self.state.T_SIDEWALK),
                int(self.state.T_BRICK),
                int(self.state.T_CONCRETE),
            }

            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            placed: tuple[int, int, int, int] | None = None
            for _ in range(18):
                w = rng.randint(12, 20)
                h = rng.randint(9, 14)
                x0 = rng.randint(2, self.state.CHUNK_SIZE - w - 2)
                y0 = rng.randint(2, self.state.CHUNK_SIZE - h - 2)

                blocked = False
                for y in range(int(y0), int(y0 + h)):
                    for x in range(int(x0), int(x0 + w)):
                        t = int(tiles[idx(x, y)])
                        if t not in allowed_base:
                            blocked = True
                            break
                    if blocked:
                        break
                if blocked:
                    continue
                placed = (int(x0), int(y0), int(w), int(h))
                break
            if placed is None:
                return

            x0, y0, w, h = placed
            for y in range(int(y0), int(y0 + h)):
                for x in range(int(x0), int(x0 + w)):
                    tiles[idx(x, y)] = int(self.state.T_PARKING)
                    if reserved is not None:
                        reserved.add((int(x), int(y)))

            # Spawn cars in a loose grid.
            car_pool = [mid for mid in self.state._CAR_MODELS.keys() if str(mid) not in ("rv", "police")]
            if not car_pool:
                return
            base_tx = int(cx) * int(self.state.CHUNK_SIZE)
            base_ty = int(cy) * int(self.state.CHUNK_SIZE)
            spots: list[tuple[int, int]] = []
            for yy in range(int(y0) + 1, int(y0 + h) - 1, 3):
                for xx in range(int(x0) + 1, int(x0 + w) - 1, 4):
                    if int(tiles[idx(xx, yy)]) != int(self.state.T_PARKING):
                        continue
                    spots.append((int(xx), int(yy)))
            if not spots:
                return
            rng.shuffle(spots)
            n_cars = int(clamp(int(rng.randint(1, 4)), 0, len(spots)))
            for i in range(n_cars):
                sx, sy = spots[i]
                tx = base_tx + int(sx)
                ty = base_ty + int(sy)
                px = (float(tx) + 0.5) * float(self.state.TILE_SIZE)
                py = (float(ty) + 0.5) * float(self.state.TILE_SIZE)
                model_id = str(rng.choice(car_pool))
                heading = 0.0 if (i % 2 == 0) else (math.pi / 2)
                fuel = float(rng.uniform(18.0, 96.0)) if rng.random() < 0.85 else float(rng.uniform(0.0, 28.0))
                cars.append(
                    HardcoreSurvivalState._ParkedCar(
                        pos=pygame.Vector2(px, py),
                        model_id=model_id,
                        heading=float(heading),
                        fuel=float(fuel),
                    )
                )

            if school:
                # A few bikes near the parking lot.
                self._spawn_two_wheelers(
                    tiles,
                    bikes,
                    cx,
                    cy,
                    rng=rng,
                    count=rng.randint(1, 3),
                    models=["bike_lady", "bike_mountain", "bike_auto"],
                    buildings=buildings,
                    reserved=reserved,
                )

        def _spawn_two_wheelers(
            self,
            tiles: list[int],
            bikes: list["HardcoreSurvivalState._ParkedBike"],
            cx: int,
            cy: int,
            *,
            rng: random.Random,
            count: int,
            models: list[str],
            buildings: list[tuple[int, int, int, int, int, int]] | None = None,
            reserved: set[tuple[int, int]] | None = None,
        ) -> None:
            if count <= 0 or not models:
                return

            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            base_tx = int(cx) * int(self.state.CHUNK_SIZE)
            base_ty = int(cy) * int(self.state.CHUNK_SIZE)
            candidates: list[tuple[int, int]] = []
            for y in range(2, self.state.CHUNK_SIZE - 2):
                for x in range(2, self.state.CHUNK_SIZE - 2):
                    t = int(tiles[idx(int(x), int(y))])
                    if t in (int(self.state.T_ROAD), int(self.state.T_WALL), int(self.state.T_DOOR)):
                        continue
                    if t not in (
                        int(self.state.T_PAVEMENT),
                        int(self.state.T_PARKING),
                        int(self.state.T_SIDEWALK),
                        int(self.state.T_BRICK),
                        int(self.state.T_CONCRETE),
                    ):
                        continue
                    # Avoid spawning right next to building walls/doors (looks like bikes are "on the facade").
                    near_wall = False
                    for ny in range(int(y) - 2, int(y) + 3):
                        for nx in range(int(x) - 2, int(x) + 3):
                            if not (0 <= int(nx) < int(self.state.CHUNK_SIZE) and 0 <= int(ny) < int(self.state.CHUNK_SIZE)):
                                continue
                            nt = int(tiles[idx(int(nx), int(ny))])        
                            if nt in (int(self.state.T_WALL), int(self.state.T_DOOR)):
                                near_wall = True
                                break
                        if near_wall:
                            break
                    if near_wall:
                        continue
                    candidates.append((int(x), int(y)))
            if not candidates:
                return
            rng.shuffle(candidates)
            want = int(clamp(int(count), 0, len(candidates)))
            dirs = ["up", "down", "left", "right"]
            tile_size = int(self.state.TILE_SIZE)
            chunk_size = int(self.state.CHUNK_SIZE)
            t_floor = int(self.state.T_FLOOR)
            t_door = int(self.state.T_DOOR)

            def tile_blocks_vehicle(t: int) -> bool:
                t = int(t)
                if t in (t_floor, t_door):
                    return True
                tdef = self.state._TILES.get(int(t))
                if tdef is None:
                    return False
                return bool(getattr(tdef, "solid", False))

            def rect_clear(r: pygame.Rect) -> bool:
                left = int(math.floor(r.left / tile_size))
                right = int(math.floor((r.right - 1) / tile_size))
                top = int(math.floor(r.top / tile_size))
                bottom = int(math.floor((r.bottom - 1) / tile_size))
                for ty in range(int(top), int(bottom) + 1):
                    ly = int(ty - base_ty)
                    if not (0 <= ly < chunk_size):
                        return False
                    for tx in range(int(left), int(right) + 1):
                        lx = int(tx - base_tx)
                        if not (0 <= lx < chunk_size):
                            return False
                        if tile_blocks_vehicle(int(tiles[idx(int(lx), int(ly))])):
                            return False
                return True

            def inside_any_building(tx: int, ty: int) -> bool:
                if not buildings:
                    return False
                for bx0, by0, bw, bh, _roof_kind, _floors in buildings:
                    if int(bx0) <= int(tx) < int(bx0) + int(bw) and int(by0) <= int(ty) < int(by0) + int(bh):
                        return True
                return False

            placed = 0
            for sx, sy in candidates:
                if placed >= want:
                    break
                tx = base_tx + int(sx)
                ty = base_ty + int(sy)
                if inside_any_building(int(tx), int(ty)):
                    continue

                mid = str(rng.choice(models))
                w_px, h_px = self.state._two_wheel_collider_px(mid)
                px = (float(tx) + 0.5) * float(tile_size)
                py = (float(ty) + 0.5) * float(tile_size)
                rect = pygame.Rect(
                    int(iround(float(px) - float(w_px) / 2.0)),
                    int(iround(float(py) - float(h_px) / 2.0)),
                    int(w_px),
                    int(h_px),
                )
                if not rect_clear(rect):
                    continue

                d = str(rng.choice(dirs))
                fuel = 0.0
                if str(mid).startswith("moto"):
                    fuel = float(rng.uniform(25.0, 95.0))
                elif str(mid) == "bike_auto":
                    fuel = float(rng.uniform(40.0, 100.0))
                bikes.append(
                    HardcoreSurvivalState._ParkedBike(pos=pygame.Vector2(px, py), model_id=mid, dir=d, fuel=float(fuel))
                )
                if reserved is not None:
                    reserved.add((int(sx), int(sy)))
                placed += 1

        def _stamp_outdoor_decor(
            self,
            tiles: list[int],
            props: list["HardcoreSurvivalState._WorldProp"],
            cx: int,
            cy: int,
            *,
            rng: random.Random,
        ) -> None:
            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            base_tx = int(cx) * int(self.state.CHUNK_SIZE)
            base_ty = int(cy) * int(self.state.CHUNK_SIZE)

            def far_from_existing(px: float, py: float, *, min_d: float) -> bool:
                md2 = float(min_d) * float(min_d)
                for p in props:
                    pos = getattr(p, "pos", None)
                    if pos is None:
                        continue
                    d2 = float((pygame.Vector2(pos) - pygame.Vector2(px, py)).length_squared())
                    if d2 < md2:
                        return False
                return True

            t_sand = int(self.state.T_SAND)
            t_board = int(self.state.T_BOARDWALK)
            t_water = int(self.state.T_WATER)
            t_highway = int(self.state.T_HIGHWAY)

            # Beach amusements: place a couple of abandoned toys near the boardwalk.
            beach_cand: list[tuple[int, int]] = []
            for y in range(2, int(self.state.CHUNK_SIZE) - 2):
                for x in range(2, int(self.state.CHUNK_SIZE) - 2):
                    t = int(tiles[idx(int(x), int(y))])
                    if t not in (t_sand, t_board):
                        continue
                    near = False
                    for nx, ny in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
                        nt = int(tiles[idx(int(nx), int(ny))])
                        if nt in (t_board, t_water):
                            near = True
                            break
                    if near:
                        beach_cand.append((int(x), int(y)))
            if len(beach_cand) >= 36:
                rng.shuffle(beach_cand)
                want = int(rng.randint(1, 3))
                toy_pool = ["toy_seesaw", "toy_carousel", "toy_swing"]
                for x, y in beach_cand:
                    if want <= 0:
                        break
                    wx = int(base_tx + int(x))
                    wy = int(base_ty + int(y))
                    px = (float(wx) + 0.5) * float(self.state.TILE_SIZE)
                    py = (float(wy) + 0.5) * float(self.state.TILE_SIZE)
                    if not far_from_existing(px, py, min_d=30.0):
                        continue
                    props.append(
                        HardcoreSurvivalState._WorldProp(
                            pos=pygame.Vector2(px, py),
                            prop_id=str(rng.choice(toy_pool)),
                            variant=int(rng.randint(0, 7)),
                            dir=str(rng.choice(["left", "right", "up", "down"])),
                        )
                    )
                    want -= 1

            # Abandoned highways: occasional billboards near the shoulder.
            bill_cand: list[tuple[int, int]] = []
            for y in range(2, int(self.state.CHUNK_SIZE) - 2):
                for x in range(2, int(self.state.CHUNK_SIZE) - 2):
                    t = int(tiles[idx(int(x), int(y))])
                    if t in (t_highway, int(self.state.T_WALL), int(self.state.T_DOOR)):
                        continue
                    if not (
                        int(tiles[idx(int(x) + 1, int(y))]) == t_highway
                        or int(tiles[idx(int(x) - 1, int(y))]) == t_highway
                        or int(tiles[idx(int(x), int(y) + 1)]) == t_highway
                        or int(tiles[idx(int(x), int(y) - 1)]) == t_highway
                    ):
                        continue
                    tdef = self.state._TILES.get(int(t))
                    if tdef is not None and bool(getattr(tdef, "solid", False)):
                        continue
                    bill_cand.append((int(x), int(y)))

            if bill_cand and rng.random() < 0.55:
                rng.shuffle(bill_cand)
                want = 1 if len(bill_cand) >= 18 else 0
                for x, y in bill_cand:
                    if want <= 0:
                        break
                    wx = int(base_tx + int(x))
                    wy = int(base_ty + int(y))
                    px = (float(wx) + 0.5) * float(self.state.TILE_SIZE)
                    py = (float(wy) + 0.5) * float(self.state.TILE_SIZE)
                    if not far_from_existing(px, py, min_d=26.0):
                        continue
                    props.append(
                        HardcoreSurvivalState._WorldProp(
                            pos=pygame.Vector2(px, py),
                            prop_id="billboard",
                            variant=int(rng.randint(0, 7)),
                            dir=str(rng.choice(["left", "right", "up", "down"])),
                        )
                    )
                    want -= 1

        def _stamp_city_decor(
            self,
            tiles: list[int],
            props: list["HardcoreSurvivalState._WorldProp"],
            cx: int,
            cy: int,
            *,
            rng: random.Random,
        ) -> None:
            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            base_tx = int(cx) * int(self.state.CHUNK_SIZE)
            base_ty = int(cy) * int(self.state.CHUNK_SIZE)

            # Billboards near streets (non-blocking decoration).
            bill_cand: list[tuple[int, int]] = []
            for y in range(2, int(self.state.CHUNK_SIZE) - 2):
                for x in range(2, int(self.state.CHUNK_SIZE) - 2):
                    t = int(tiles[idx(int(x), int(y))])
                    if t not in (
                        int(self.state.T_SIDEWALK),
                        int(self.state.T_PAVEMENT),
                        int(self.state.T_CONCRETE),
                        int(self.state.T_BRICK),
                        int(self.state.T_PARKING),
                    ):
                        continue
                    near_road = False
                    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        if int(tiles[idx(int(x + dx), int(y + dy))]) == int(self.state.T_ROAD):
                            near_road = True
                            break
                    if not near_road:
                        continue
                    bill_cand.append((int(x), int(y)))
            rng.shuffle(bill_cand)

            want_bill = 0
            if bill_cand and rng.random() < 0.55:
                want_bill = 1 if rng.random() < 0.75 else 2

            def far_from_existing(px: float, py: float, *, min_d: float) -> bool:
                md2 = float(min_d) * float(min_d)
                for pr in props:
                    dx = float(pr.pos.x) - float(px)
                    dy = float(pr.pos.y) - float(py)
                    if dx * dx + dy * dy < md2:
                        return False
                return True

            for x, y in bill_cand:
                if want_bill <= 0:
                    break
                wx = int(base_tx + int(x))
                wy = int(base_ty + int(y))
                px = (float(wx) + 0.5) * float(self.state.TILE_SIZE)
                py = (float(wy) + 0.5) * float(self.state.TILE_SIZE)
                if not far_from_existing(px, py, min_d=26.0):
                    continue
                props.append(
                    HardcoreSurvivalState._WorldProp(
                        pos=pygame.Vector2(px, py),
                        prop_id="billboard",
                        variant=int(rng.randint(0, 7)),
                        dir=str(rng.choice(["left", "right", "up", "down"])),
                    )
                )
                want_bill -= 1

            # Park toys: only inside 3x3 grass/forest clusters.
            park_cand: list[tuple[int, int]] = []
            for y in range(3, int(self.state.CHUNK_SIZE) - 3):
                for x in range(3, int(self.state.CHUNK_SIZE) - 3):
                    t0 = int(tiles[idx(int(x), int(y))])
                    if t0 not in (int(self.state.T_GRASS), int(self.state.T_FOREST)):
                        continue
                    ok = True
                    for yy in range(int(y) - 1, int(y) + 2):
                        for xx in range(int(x) - 1, int(x) + 2):
                            tt = int(tiles[idx(int(xx), int(yy))])
                            if tt not in (int(self.state.T_GRASS), int(self.state.T_FOREST)):
                                ok = False
                                break
                        if not ok:
                            break
                    if ok:
                        park_cand.append((int(x), int(y)))
            rng.shuffle(park_cand)

            want_toys = 0
            if len(park_cand) >= 70:
                want_toys = int(rng.randint(1, 3))
            elif len(park_cand) >= 36:
                want_toys = int(rng.randint(0, 2))
            elif len(park_cand) >= 20:
                want_toys = int(rng.randint(0, 1))

            toy_pool = ["toy_seesaw", "toy_carousel", "toy_swing"]
            for x, y in park_cand:
                if want_toys <= 0:
                    break
                wx = int(base_tx + int(x))
                wy = int(base_ty + int(y))
                px = (float(wx) + 0.5) * float(self.state.TILE_SIZE)
                py = (float(wy) + 0.5) * float(self.state.TILE_SIZE)
                if not far_from_existing(px, py, min_d=30.0):
                    continue
                props.append(
                    HardcoreSurvivalState._WorldProp(
                        pos=pygame.Vector2(px, py),
                        prop_id=str(rng.choice(toy_pool)),
                        variant=int(rng.randint(0, 7)),
                        dir=str(rng.choice(["left", "right", "up", "down"])),
                    )
                )
                want_toys -= 1

        def _stamp_buildings(
            self,
            tiles: list[int],
            items: list["HardcoreSurvivalState._WorldItem"],
            buildings: list[tuple[int, int, int, int, int, int]],
            special_buildings: list["HardcoreSurvivalState._SpecialBuilding"],  
            props: list["HardcoreSurvivalState._WorldProp"],
            cx: int,
            cy: int,
            rng: random.Random,
            town_kind: str,
            reserved: set[tuple[int, int]] | None = None,
        ) -> None:
            tries = 0
            placed = 0
            want = 1
            mh_out: list[HardcoreSurvivalState._MultiHouse] | None = getattr(self, "_multi_houses_out", None)
            max_tries = 120 if town_kind in ("", "", "", "") else 60

            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            base_tx = int(cx) * int(self.state.CHUNK_SIZE)
            base_ty = int(cy) * int(self.state.CHUNK_SIZE)
            allow_overwrite_city_street = town_kind in ("", "", "")

            while placed < want and tries < max_tries:
                tries += 1
                building_floors = 0
                if town_kind == "":
                    w = rng.randint(20, 28)
                    h = rng.randint(14, 22)
                elif town_kind == "":
                    w = rng.randint(13, 19)
                    h = rng.randint(10, 16)
                elif town_kind == "":
                    w = rng.randint(12, 18)
                    h = rng.randint(10, 15)
                elif town_kind == "":
                    w = rng.randint(10, 15)
                    h = rng.randint(8, 12)
                elif town_kind == "":
                    w = rng.randint(14, 20)
                    h = rng.randint(12, 18)
                elif town_kind == "":
                    w = rng.randint(16, 23)
                    h = rng.randint(13, 19)
                elif town_kind == "":
                    w = rng.randint(22, 27)
                    h = rng.randint(22, 28)
                elif town_kind == "":
                    # Larger footprint so 2/3-unit apartments feel like real homes.
                    w = rng.randint(20, 24)
                    h = rng.randint(20, 26)
                elif town_kind == "":
                    w = rng.randint(22, 28)
                    h = rng.randint(20, 28)
                elif town_kind == "":
                    w = rng.randint(14, 20)
                    h = rng.randint(13, 19)
                elif town_kind == "":
                    w = rng.randint(9, 15)
                    h = rng.randint(8, 13)
                elif town_kind == "":
                    # Residential houses: keep them small (typical 12 story size).
                    w = rng.randint(6, 9)
                    h = rng.randint(6, 9)
                else:
                    w = rng.randint(8, 12)
                    h = rng.randint(7, 12)
                x0 = rng.randint(2, self.state.CHUNK_SIZE - w - 2)
                y0 = rng.randint(2, self.state.CHUNK_SIZE - h - 2)

                blocked = False
                for y in range(y0, y0 + h):
                    for x in range(x0, x0 + w):
                        if reserved is not None and (int(x), int(y)) in reserved:
                            blocked = True
                            break
                        t = tiles[idx(x, y)]
                        if int(t) == int(self.state.T_ROAD):
                            wx = int(base_tx + int(x))
                            wy = int(base_ty + int(y))
                            is_main = bool(self.is_road(wx, wy))
                            is_city_minor = bool(self.is_city_street(wx, wy)) and not is_main
                            if allow_overwrite_city_street and is_city_minor:
                                continue
                            blocked = True
                            break
                        if t not in (
                            self.state.T_GRASS,
                            self.state.T_FOREST,
                            self.state.T_WATER,
                            self.state.T_PAVEMENT,
                            self.state.T_PARKING,
                            self.state.T_COURT,
                            self.state.T_SIDEWALK,
                            self.state.T_BRICK,
                            self.state.T_CONCRETE,
                        ):
                            blocked = True
                            break
                    if blocked:
                        break
                if blocked:
                    continue

                is_highrise = town_kind in ("", "")
                roof_var_hint: int | None = None
                core_h = int(h) - 2
                if is_highrise:
                    tx0w = int(base_tx + x0)
                    ty0w = int(base_ty + y0)
                    roof_var_hint = int(self.state._hash2_u32(int(tx0w), int(ty0w), int(self.seed) ^ 0x7A11C1D3) & 0xFF)
                    max_f = int(max(2, int(getattr(self.state, "HIGHRISE_MAX_FLOORS", 10))))
                    lo = 8 if town_kind == "" else 6
                    lo = int(max(2, min(int(lo), int(max_f))))
                    building_floors = int(rng.randint(int(lo), int(max_f)))
                    cut_px = int(self.state._roof_cut_px(style=6, w=int(w), h=int(h), var=int(roof_var_hint), floors=int(building_floors)))
                    cut_tiles = int(cut_px) // int(max(1, int(self.state.TILE_SIZE)))
                    core_h = int(max(2, int(h) - 2 - int(cut_tiles)))
                    min_core_h = int(max(6, int(getattr(self.state, "HIGHRISE_MIN_FLOOR_TILES", 9))))
                    core_h = int(min(int(max(int(core_h), int(min_core_h))), int(max(2, int(h) - 2))))

                # Always use south-facing entrances so the single "front facade"
                # (bottom/S) matches the actual doorway + collision.
                door_side = "S"
                door_tiles: list[tuple[int, int]] = []
                if door_side == "N":
                    dx = rng.randint(x0 + 1, x0 + w - 3)
                    dy = y0
                    door_tiles = [(dx, dy), (dx + 1, dy)]
                elif door_side == "S":
                    dy = y0 + h - 1

                    def approach_clear(ddx0: int, ddy0: int) -> bool:
                        for ddx, ddy in ((ddx0, ddy0), (ddx0 + 1, ddy0)):
                            for step in range(1, 9):
                                px = int(ddx)
                                py = int(ddy + step)
                                if not (0 <= px < int(self.state.CHUNK_SIZE) and 0 <= py < int(self.state.CHUNK_SIZE)):
                                    break
                                tcur = int(tiles[idx(int(px), int(py))])
                                if tcur in (
                                    int(self.state.T_WALL),
                                    int(self.state.T_FLOOR),
                                    int(self.state.T_DOOR),
                                ):
                                    return False
                        return True

                    door_x_candidates = [int(x) for x in range(int(x0 + 1), int(x0 + w - 2))]
                    rng.shuffle(door_x_candidates)
                    door_x_candidates = [int(x) for x in door_x_candidates if approach_clear(int(x), int(dy))]
                    if not door_x_candidates:
                        continue
                    dx = int(rng.choice(door_x_candidates))
                    door_tiles = [(dx, dy), (dx + 1, dy)]
                elif door_side == "W":
                    dx = x0
                    dy = rng.randint(y0 + 1, y0 + h - 3)
                    door_tiles = [(dx, dy), (dx, dy + 1)]
                else:
                    dx = x0 + w - 1
                    dy = rng.randint(y0 + 1, y0 + h - 3)
                    door_tiles = [(dx, dy), (dx, dy + 1)]

                for y in range(y0, y0 + h):
                    for x in range(x0, x0 + w):
                        border = x in (x0, x0 + w - 1) or y in (y0, y0 + h - 1)
                        tiles[idx(x, y)] = self.state.T_WALL if border else self.state.T_FLOOR

                if is_highrise:
                    # Keep the 1F footprint pressed against the south facade:
                    # cut rows from the *top* of the interior, not the bottom.
                    top_cut = int(max(0, (int(h) - 2) - int(core_h)))
                    if top_cut > 0:
                        cut_y0 = int(y0 + 1)
                        cut_y1 = int(min(int(y0 + h - 1), int(cut_y0 + top_cut)))
                        for yy in range(int(cut_y0), int(cut_y1)):
                            for xx in range(int(x0 + 1), int(x0 + w - 1)):
                                tiles[idx(int(xx), int(yy))] = int(self.state.T_WALL)

                for dx, dy in door_tiles:
                    tiles[idx(dx, dy)] = self.state.T_DOOR

                # Carve a small approach path outside the door so buildings are
                # always reachable even if terrain noise produced water nearby.
                if door_side == "N":
                    ox, oy = 0, -1
                elif door_side == "S":
                    ox, oy = 0, 1
                elif door_side == "W":
                    ox, oy = -1, 0
                else:
                    ox, oy = 1, 0
                path_tile = int(self.state.T_SIDEWALK) if bool(self._is_city_chunk(int(cx), int(cy))) else int(self.state.T_ROAD)
                for dx, dy in door_tiles:
                    for step in range(1, 9):
                        px = dx + ox * step
                        py = dy + oy * step
                        if not (0 <= px < self.state.CHUNK_SIZE and 0 <= py < self.state.CHUNK_SIZE):
                            break
                        tcur = int(tiles[idx(int(px), int(py))])
                        if tcur in (int(self.state.T_WALL), int(self.state.T_FLOOR), int(self.state.T_DOOR)):
                            break
                        tiles[idx(px, py)] = path_tile
                        if reserved is not None:
                            reserved.add((int(px), int(py)))

                # Exterior signage so building type reads from outside.
                sign_id = "sign_home"
                if town_kind == "":
                    sign_id = "sign_hospital"
                elif town_kind == "":
                    sign_id = "sign_shop"
                elif town_kind == "":
                    sign_id = "sign_shop_big"
                elif town_kind == "":
                    sign_id = "sign_bookstore"
                elif town_kind == "":
                    sign_id = "sign_gunshop"
                elif town_kind == "":
                    sign_id = "sign_school"
                elif town_kind in ("", ""):
                    sign_id = "sign_prison"
                elif town_kind in ("", ""):
                    sign_id = "sign_highrise"
                elif town_kind == "":
                    sign_id = "sign_chinese"

                door_mx = int(round(sum(int(p[0]) for p in door_tiles) / max(1, len(door_tiles))))
                door_my = int(round(sum(int(p[1]) for p in door_tiles) / max(1, len(door_tiles))))
                out_x = door_mx + int(ox)
                out_y = door_my + int(oy)
                # Avoid placing a sign directly in front of the doorway (looks like it blocks the entrance).
                sign_candidates: list[tuple[int, int]] = []
                xs0 = [p[0] for p in door_tiles]
                ys0 = [p[1] for p in door_tiles]
                dx0 = int(min(xs0)) if xs0 else int(door_mx)
                dx1 = int(max(xs0)) if xs0 else int(door_mx)
                dy0 = int(max(ys0)) if ys0 else int(door_my)

                # Prefer placing signs on the ground outside the entrance (never on wall tiles),
                # so they don't look like they're floating on the facade.

                if door_side in ("N", "S"):
                    sign_candidates += [
                        (int(out_x) - 1, int(out_y)),
                        (int(out_x) + 1, int(out_y)),
                        (int(out_x) - 2, int(out_y)),
                        (int(out_x) + 2, int(out_y)),
                    ]
                else:
                    sign_candidates += [
                        (int(out_x), int(out_y) - 1),
                        (int(out_x), int(out_y) + 1),
                        (int(out_x), int(out_y) - 2),
                        (int(out_x), int(out_y) + 2),
                    ]

                for sx, sy in sign_candidates:
                    if not (0 <= int(sx) < int(self.state.CHUNK_SIZE) and 0 <= int(sy) < int(self.state.CHUNK_SIZE)):
                        continue
                    tdef = self.state._TILES.get(int(tiles[idx(int(sx), int(sy))]))
                    if tdef is not None and bool(getattr(tdef, "solid", False)):
                        continue
                    wx = int(base_tx + int(sx))
                    wy = int(base_ty + int(sy))
                    px = (float(wx) + 0.5) * float(self.state.TILE_SIZE)
                    py = (float(wy) + 0.5) * float(self.state.TILE_SIZE)
                    props.append(
                        HardcoreSurvivalState._WorldProp(
                            pos=pygame.Vector2(px, py),
                            prop_id=str(sign_id),
                            variant=int(rng.randint(0, 7)),
                            dir=str({"N": "up", "S": "down", "W": "left", "E": "right"}.get(str(door_side), "down")),
                        )
                    )
                    break

                def near_door(x: int, y: int) -> bool:
                    for ddx, ddy in door_tiles:
                        if abs(int(x) - int(ddx)) <= 1 and abs(int(y) - int(ddy)) <= 1:
                            return True
                    return False

                # Interior layout (rooms + props). Keep a clear corridor so the
                # entrance always feels navigable.
                in_left = x0 + 1
                in_right = x0 + w - 2
                in_top = y0 + 1
                in_bottom = y0 + h - 2

                door_cx = sum(int(p[0]) for p in door_tiles) / max(1, len(door_tiles))
                door_cy = sum(int(p[1]) for p in door_tiles) / max(1, len(door_tiles))

                corridor: set[tuple[int, int]] = set()

                def mark_corridor(x: int, y: int) -> None:
                    if in_left <= int(x) <= in_right and in_top <= int(y) <= in_bottom:
                        corridor.add((int(x), int(y)))

                def set_interior(x: int, y: int, tile_id: int) -> None:
                    if not (in_left <= int(x) <= in_right and in_top <= int(y) <= in_bottom):
                        return
                    if near_door(int(x), int(y)):
                        return
                    if (int(x), int(y)) in corridor:
                        return
                    tiles[idx(int(x), int(y))] = int(tile_id)

                def clear_interior(x: int, y: int) -> None:
                    if not (in_left <= int(x) <= in_right and in_top <= int(y) <= in_bottom):
                        return
                    tiles[idx(int(x), int(y))] = self.state.T_FLOOR

                # Main corridor based on entrance side.
                if door_side in ("N", "S"):
                    cx_line = int(clamp(int(round(door_cx)), in_left, in_right))
                    for y in range(in_top, in_bottom + 1):
                        mark_corridor(cx_line, y)
                        mark_corridor(cx_line + 1, y)
                else:
                    cy_line = int(clamp(int(round(door_cy)), in_top, in_bottom))
                    for x in range(in_left, in_right + 1):
                        mark_corridor(x, cy_line)
                        mark_corridor(x, cy_line + 1)

                # Ensure the immediate area behind the door is clear.
                if door_side == "N":
                    for dx, _dy in door_tiles:
                        mark_corridor(dx, y0 + 1)
                        mark_corridor(dx, y0 + 2)
                elif door_side == "S":
                    for dx, _dy in door_tiles:
                        mark_corridor(dx, y0 + h - 2)
                        mark_corridor(dx, y0 + h - 3)
                elif door_side == "W":
                    for _dx, dy in door_tiles:
                        mark_corridor(x0 + 1, dy)
                        mark_corridor(x0 + 2, dy)
                else:
                    for _dx, dy in door_tiles:
                        mark_corridor(x0 + w - 2, dy)
                        mark_corridor(x0 + w - 3, dy)

                def build_room(rx: int, ry: int, rw: int, rh: int) -> tuple[int, int] | None:
                    # rx/ry are interior-floor top-left; walls wrap around.
                    rw = int(max(2, rw))
                    rh = int(max(2, rh))
                    rx = int(clamp(rx, in_left + 1, in_right - rw))
                    ry = int(clamp(ry, in_top + 1, in_bottom - rh))

                    for y in range(ry, ry + rh):
                        for x in range(rx, rx + rw):
                            clear_interior(x, y)

                    # Walls (only inside the building border).
                    for x in range(rx - 1, rx + rw + 1):
                        set_interior(x, ry - 1, self.state.T_WALL)
                        set_interior(x, ry + rh, self.state.T_WALL)
                    for y in range(ry - 1, ry + rh + 1):
                        set_interior(rx - 1, y, self.state.T_WALL)
                        set_interior(rx + rw, y, self.state.T_WALL)

                    # Door on the side facing the center.
                    cx = x0 + w / 2.0
                    cy = y0 + h / 2.0
                    side: str
                    if abs((rx + rw / 2.0) - cx) >= abs((ry + rh / 2.0) - cy):
                        side = "W" if (rx + rw / 2.0) > cx else "E"
                    else:
                        side = "N" if (ry + rh / 2.0) > cy else "S"

                    if side == "N":
                        dx = rx + rw // 2
                        dy = ry - 1
                    elif side == "S":
                        dx = rx + rw // 2
                        dy = ry + rh
                    elif side == "W":
                        dx = rx - 1
                        dy = ry + rh // 2
                    else:
                        dx = rx + rw
                        dy = ry + rh // 2

                    if in_left <= dx <= in_right and in_top <= dy <= in_bottom and not near_door(dx, dy):
                        tiles[idx(dx, dy)] = self.state.T_DOOR
                        # Clear a tiny landing outside the door.
                        if side == "N":
                            clear_interior(dx, dy + 1)
                        elif side == "S":
                            clear_interior(dx, dy - 1)
                        elif side == "W":
                            clear_interior(dx + 1, dy)
                        else:
                            clear_interior(dx - 1, dy)
                        mark_corridor(dx, dy)
                        return dx, dy
                    return None

                if town_kind == "":
                    # Bookstore: shelves in aisles + a small reading area.
                    backroom: tuple[int, int, int, int] | None = None
                    if w >= 12 and h >= 9 and rng.random() < 0.75:
                        rw = min(4, int(w) - 6)
                        rh = min(3, int(h) - 5)
                        rx = x0 + 2 if door_side in ("N", "S") else (x0 + w - rw - 2)
                        ry = y0 + h - rh - 2 if door_side == "N" else (y0 + 2)
                        backroom = (int(rx), int(ry), int(rw), int(rh))
                        build_room(int(rx), int(ry), int(rw), int(rh))

                    # Shelf islands (leave walkable aisles).
                    for y in range(y0 + 3, y0 + h - 3, 3):
                        for x in range(x0 + 2, x0 + w - 3, 4):
                            if backroom is not None:
                                bx, by, bw, bh = backroom
                                if (bx - 1) <= int(x) <= (bx + bw) and (by - 1) <= int(y) <= (by + bh):
                                    continue
                            if tiles[idx(int(x), int(y))] == self.state.T_FLOOR:
                                set_interior(int(x), int(y), self.state.T_SHELF)
                            if tiles[idx(int(x) + 1, int(y))] == self.state.T_FLOOR:
                                set_interior(int(x) + 1, int(y), self.state.T_SHELF)

                    # Reading tables nearer the entrance.
                    if door_side in ("N", "S"):
                        y = y0 + 3 if door_side == "N" else y0 + h - 4
                        for x in range(x0 + 3, x0 + w - 3, 5):
                            if tiles[idx(int(x), int(y))] == self.state.T_FLOOR:
                                set_interior(int(x), int(y), self.state.T_TABLE)

                    # Checkout counter near entrance.
                    if door_side in ("N", "S"):
                        y = y0 + 2 if door_side == "N" else y0 + h - 3
                        x0c = int(round(door_cx)) - 1
                        x1c = int(round(door_cx)) + 1
                        for x in range(x0c, x1c + 1):
                            if (int(x), int(y)) in corridor or near_door(int(x), int(y)):
                                continue
                            set_interior(int(x), int(y), self.state.T_TABLE)
                    else:
                        x = x0 + 2 if door_side == "W" else x0 + w - 3
                        y0c = int(round(door_cy)) - 1
                        y1c = int(round(door_cy)) + 1
                        for y in range(y0c, y1c + 1):
                            if (int(x), int(y)) in corridor or near_door(int(x), int(y)):
                                continue
                            set_interior(int(x), int(y), self.state.T_TABLE)

                    # Backroom storage shelves.
                    if backroom is not None:
                        bx, by, bw, bh = backroom
                        for x in range(bx, bx + bw):
                            if (x - bx) % 2 == 0:
                                for y in range(by, by + bh):
                                    if tiles[idx(x, y)] == self.state.T_FLOOR:
                                        tiles[idx(x, y)] = self.state.T_SHELF

                elif town_kind == "":
                    # Gun shop: wall racks + a counter + optional backroom.    
                    backroom: tuple[int, int, int, int] | None = None
                    if w >= 11 and h >= 9 and rng.random() < 0.85:
                        rw = min(4, int(w) - 6)
                        rh = min(3, int(h) - 5)
                        rx = x0 + 2 if door_side in ("N", "S") else (x0 + w - rw - 2)
                        ry = y0 + h - rh - 2 if door_side == "N" else (y0 + 2)
                        backroom = (int(rx), int(ry), int(rw), int(rh))
                        build_room(int(rx), int(ry), int(rw), int(rh))

                    # Wall racks (leave the main corridor clear).
                    for x in range(in_left + 1, in_right, 2):
                        set_interior(int(x), int(in_top + 1), self.state.T_SHELF)
                        set_interior(int(x), int(in_bottom - 1), self.state.T_SHELF)
                    for y in range(in_top + 2, in_bottom - 1, 2):
                        set_interior(int(in_left + 1), int(y), self.state.T_SHELF)
                        set_interior(int(in_right - 1), int(y), self.state.T_SHELF)

                    # A couple of display islands.
                    for y in range(y0 + 3, y0 + h - 3, 4):
                        for x in range(x0 + 3, x0 + w - 3, 5):
                            if backroom is not None:
                                bx, by, bw, bh = backroom
                                if (bx - 1) <= int(x) <= (bx + bw) and (by - 1) <= int(y) <= (by + bh):
                                    continue
                            if tiles[idx(int(x), int(y))] == self.state.T_FLOOR:
                                set_interior(int(x), int(y), self.state.T_SHELF)

                    # Counter near entrance.
                    if door_side in ("N", "S"):
                        y = y0 + 2 if door_side == "N" else y0 + h - 3
                        x0c = int(round(door_cx)) - 2
                        x1c = int(round(door_cx)) + 2
                        for x in range(x0c, x1c + 1):
                            if (int(x), int(y)) in corridor or near_door(int(x), int(y)):
                                continue
                            set_interior(int(x), int(y), self.state.T_TABLE)
                    else:
                        x = x0 + 2 if door_side == "W" else x0 + w - 3
                        y0c = int(round(door_cy)) - 2
                        y1c = int(round(door_cy)) + 2
                        for y in range(y0c, y1c + 1):
                            if (int(x), int(y)) in corridor or near_door(int(x), int(y)):
                                continue
                            set_interior(int(x), int(y), self.state.T_TABLE)

                    # Backroom storage shelves.
                    if backroom is not None:
                        bx, by, bw, bh = backroom
                        for x in range(bx, bx + bw):
                            if (x - bx) % 2 == 0:
                                for y in range(by, by + bh):
                                    if tiles[idx(x, y)] == self.state.T_FLOOR:
                                        tiles[idx(x, y)] = self.state.T_SHELF

                elif town_kind in ("", ""):
                    # Optional back room.
                    backroom: tuple[int, int, int, int] | None = None
                    if w >= 12 and h >= 9:
                        rw = min(5, int(w) - 6)
                        rh = min(4, int(h) - 5)
                        rx = x0 + 2 if door_side in ("N", "S") else (x0 + w - rw - 2)
                        ry = y0 + h - rh - 2 if door_side == "N" else (y0 + 2)
                        backroom = (int(rx), int(ry), int(rw), int(rh))
                        build_room(int(rx), int(ry), int(rw), int(rh))

                    cross_y = int(clamp(int(y0 + h // 2), in_top + 1, in_bottom - 1))
                    for x in range(x0 + 2, x0 + w - 2, 3):
                        for y in range(y0 + 2, y0 + h - 2):
                            if (int(x), int(y)) in corridor:
                                continue
                            if abs(int(y) - int(cross_y)) <= 0:
                                continue
                            if near_door(int(x), int(y)):
                                continue
                            if backroom is not None:
                                bx, by, bw, bh = backroom
                                if (bx - 1) <= int(x) <= (bx + bw) and (by - 1) <= int(y) <= (by + bh):
                                    continue
                            tiles[idx(int(x), int(y))] = self.state.T_SHELF

                    # Checkout counter near entrance.
                    if door_side in ("N", "S"):
                        y = y0 + 2 if door_side == "N" else y0 + h - 3
                        x0c = int(round(door_cx)) - 2
                        x1c = int(round(door_cx)) + 2
                        for x in range(x0c, x1c + 1):
                            if (int(x), int(y)) in corridor or near_door(int(x), int(y)):
                                continue
                            set_interior(int(x), int(y), self.state.T_TABLE)
                    else:
                        x = x0 + 2 if door_side == "W" else x0 + w - 3
                        y0c = int(round(door_cy)) - 2
                        y1c = int(round(door_cy)) + 2
                        for y in range(y0c, y1c + 1):
                            if (int(x), int(y)) in corridor or near_door(int(x), int(y)):
                                continue
                            set_interior(int(x), int(y), self.state.T_TABLE)

                    # Backroom storage shelves.
                    if backroom is not None:
                        bx, by, bw, bh = backroom
                        for x in range(bx, bx + bw):
                            if (x - bx) % 2 == 0:
                                for y in range(by, by + bh):
                                    if tiles[idx(x, y)] == self.state.T_FLOOR:
                                        tiles[idx(x, y)] = self.state.T_SHELF

                elif town_kind == "":
                    # Chinese restaurant: counter + dining tables + kitchen storage.
                    # Counter near the entrance.
                    if door_side in ("N", "S"):
                        cy = in_top + 1 if door_side == "N" else in_bottom - 1
                        for x in range(in_left + 1, in_right, 2):
                            if (int(x), int(cy)) in corridor or near_door(int(x), int(cy)):
                                continue
                            set_interior(int(x), int(cy), self.state.T_TABLE)
                    else:
                        cx2 = in_left + 1 if door_side == "W" else in_right - 1
                        for y in range(in_top + 1, in_bottom, 2):
                            if (int(cx2), int(y)) in corridor or near_door(int(cx2), int(y)):
                                continue
                            set_interior(int(cx2), int(y), self.state.T_TABLE)

                    # Dining tables in the main area.
                    for y in range(in_top + 2, in_bottom - 1, 3):
                        for x in range(in_left + 2, in_right - 1, 3):
                            if (int(x), int(y)) in corridor or near_door(int(x), int(y)):
                                continue
                            if tiles[idx(int(x), int(y))] == self.state.T_FLOOR:
                                tiles[idx(int(x), int(y))] = self.state.T_TABLE

                    # Kitchen shelves along one side.
                    kitchen_x = in_left if float(door_cx) > float((in_left + in_right) * 0.5) else in_right
                    for y in range(in_top + 2, in_bottom - 2, 2):
                        set_interior(int(kitchen_x), int(y), self.state.T_SHELF)

                elif town_kind == "":
                    # Residential: 2F houses stay on the world-map (no full-screen portal).
                    is_city = bool(self._is_city_chunk(int(cx), int(cy)))
                    r = float(rng.random())
                    floors = 1
                    if is_city:
                        if r < 0.35:
                            floors = 2
                    else:
                        # Some 2F houses also exist outside the dense city blocks.
                        if r < 0.18:
                            floors = 2
                    # Tiny footprints read better as 1F.
                    if int(w) < 7 or int(h) < 7:
                        floors = 1
                    building_floors = int(floors)

                    if False and floors > 1:
                        # Seal the world-map interior; enter via the door portal.
                        for y in range(int(y0 + 1), int(y0 + h - 1)):
                            for x in range(int(x0 + 1), int(x0 + w - 1)):
                                tiles[idx(int(x), int(y))] = self.state.T_WALL

                        tx0w = cx * self.state.CHUNK_SIZE + x0
                        ty0w = cy * self.state.CHUNK_SIZE + y0
                        doors_w = tuple(
                            (cx * self.state.CHUNK_SIZE + int(dx), cy * self.state.CHUNK_SIZE + int(dy))
                            for dx, dy in door_tiles
                        )
                        special_buildings.append(
                            HardcoreSurvivalState._SpecialBuilding(
                                kind="house",
                                name="",
                                tx0=int(tx0w),
                                ty0=int(ty0w),
                                w=int(w),
                                h=int(h),
                                door_tiles=doors_w,
                                floors=int(floors),
                            )
                        )
                    else:
                        # Single-floor house: bed + table + shelf.
                        bx = in_left + 1
                        if door_side in ("N", "S"):
                            if int(round(door_cx)) <= int((in_left + in_right) // 2):
                                bx = in_right - 2
                            else:
                                bx = in_left + 1
                        by = in_top + 1
                        if tiles[idx(bx, by)] == self.state.T_FLOOR and tiles[idx(bx + 1, by)] == self.state.T_FLOOR:
                            tiles[idx(bx, by)] = self.state.T_BED
                            tiles[idx(bx + 1, by)] = self.state.T_BED

                        tx0c = int(clamp(int(round((in_left + in_right) / 2.0)), in_left + 1, in_right - 1))
                        ty0c = int(clamp(int(round((in_top + in_bottom) / 2.0)), in_top + 1, in_bottom - 1))
                        if tiles[idx(tx0c, ty0c)] == self.state.T_FLOOR:
                            tiles[idx(tx0c, ty0c)] = self.state.T_TABLE

                        shelf_x = in_left if bx > int((in_left + in_right) // 2) else in_right
                        for y in range(in_top + 2, in_bottom - 1, 2):
                            set_interior(int(shelf_x), int(y), self.state.T_SHELF)

                        if int(floors) > 1:
                            # Add a simple staircase for 2F houses and register a 2F tile snapshot.
                            stair_pos: tuple[int, int] | None = None
                            cand = [
                                (int(tx0c), int(ty0c) - 2),
                                (int(tx0c) - 2, int(ty0c)),
                                (int(tx0c) + 2, int(ty0c)),
                                (int(in_left + 2), int(in_bottom - 2)),
                                (int(in_right - 2), int(in_bottom - 2)),
                            ]
                            for sx, sy in cand:
                                if not (int(in_left) <= int(sx) <= int(in_right) and int(in_top) <= int(sy) <= int(in_bottom)):
                                    continue
                                if tiles[idx(int(sx), int(sy))] != int(self.state.T_FLOOR):
                                    continue
                                tiles[idx(int(sx), int(sy))] = int(self.state.T_STAIRS_UP)
                                stair_pos = (int(sx), int(sy))
                                break

                            if stair_pos is None:
                                # No space: fall back to a normal 1F house.
                                building_floors = 1
                            else:
                                tx0w = cx * self.state.CHUNK_SIZE + x0
                                ty0w = cy * self.state.CHUNK_SIZE + y0
                                f1: list[int] = []
                                for yy in range(int(h)):
                                    for xx in range(int(w)):
                                        f1.append(int(tiles[idx(int(x0 + xx), int(y0 + yy))]))
                                f2 = list(f1)
                                for i2 in range(len(f2)):
                                    tcur = int(f2[i2])
                                    if tcur == int(self.state.T_DOOR):
                                        f2[i2] = int(self.state.T_WALL)
                                    elif tcur == int(self.state.T_STAIRS_UP):
                                        f2[i2] = int(self.state.T_STAIRS_DOWN)

                                if mh_out is not None:
                                    mh_out.append(
                                        HardcoreSurvivalState._MultiHouse(
                                            tx0=int(tx0w),
                                            ty0=int(ty0w),
                                            w=int(w),
                                            h=int(h),
                                            floors=int(building_floors),
                                            cur_floor=1,
                                            floor_tiles={1: f1, 2: f2},
                                        )
                                    )

                elif town_kind == "":
                    # Reception + ward split.
                    if door_side in ("N", "S"):
                        wy = y0 + 4 if door_side == "N" else y0 + h - 5
                        if in_top + 1 <= wy <= in_bottom - 1:
                            for x in range(in_left, in_right + 1):
                                if not near_door(x, wy):
                                    tiles[idx(x, wy)] = self.state.T_WALL
                            dx = int(clamp(int(round(door_cx)), in_left + 1, in_right - 1))
                            tiles[idx(dx, wy)] = self.state.T_DOOR
                            mark_corridor(dx, wy)

                        # Reception desks.
                        ry0 = in_top if door_side == "N" else (wy + 1)
                        ry1 = wy - 1 if door_side == "N" else in_bottom
                        desk_y = ry0 + 1 if door_side == "N" else ry1 - 1
                        for x in range(in_left + 1, in_right):
                            if (x, desk_y) in corridor or near_door(x, desk_y):
                                continue
                            if (x - (in_left + 1)) % 2 == 0:
                                set_interior(x, desk_y, self.state.T_TABLE)
                        # Ward beds (opposite side).
                        wy0 = wy + 1 if door_side == "N" else in_top
                        wy1 = in_bottom if door_side == "N" else wy - 1
                        for y in range(wy0 + 1, wy1, 2):
                            for x in (in_left + 1, in_right - 2):
                                if (x, y) in corridor or near_door(x, y):
                                    continue
                                if tiles[idx(x, y)] == self.state.T_FLOOR and tiles[idx(x + 1, y)] == self.state.T_FLOOR:
                                    tiles[idx(x, y)] = self.state.T_BED
                                    tiles[idx(x + 1, y)] = self.state.T_BED
                        # Supply closet.
                        if w >= 11 and h >= 9:
                            cxr = x0 + w - 6 if door_side in ("N", "S") else x0 + 2
                            cyr = y0 + h - 5 if door_side == "N" else (y0 + 2)
                            room = build_room(int(cxr), int(cyr), 3, 2)
                            if room is not None:
                                rx, ry, rw, rh = int(cxr), int(cyr), 3, 2
                                for x in range(rx, rx + rw):
                                    for y in range(ry, ry + rh):
                                        if tiles[idx(x, y)] == self.state.T_FLOOR:
                                            tiles[idx(x, y)] = self.state.T_SHELF
                    else:
                        wx = x0 + 4 if door_side == "W" else x0 + w - 5
                        if in_left + 1 <= wx <= in_right - 1:
                            for y in range(in_top, in_bottom + 1):
                                if not near_door(wx, y):
                                    tiles[idx(wx, y)] = self.state.T_WALL
                            dy = int(clamp(int(round(door_cy)), in_top + 1, in_bottom - 1))
                            tiles[idx(wx, dy)] = self.state.T_DOOR
                            mark_corridor(wx, dy)

                        # Reception desks.
                        rx0 = in_left if door_side == "W" else (wx + 1)
                        rx1 = wx - 1 if door_side == "W" else in_right
                        desk_x = rx0 + 1 if door_side == "W" else rx1 - 1
                        for y in range(in_top + 1, in_bottom):
                            if (desk_x, y) in corridor or near_door(desk_x, y):
                                continue
                            if (y - (in_top + 1)) % 2 == 0:
                                set_interior(desk_x, y, self.state.T_TABLE)

                        # Ward beds.
                        wx0 = wx + 1 if door_side == "W" else in_left
                        wx1 = in_right if door_side == "W" else wx - 1
                        for x in range(wx0 + 1, wx1, 3):
                            for y in (in_top + 1, in_bottom - 2):
                                if (x, y) in corridor or near_door(x, y):  
                                    continue
                                if tiles[idx(x, y)] == self.state.T_FLOOR and tiles[idx(x + 1, y)] == self.state.T_FLOOR:
                                    tiles[idx(x, y)] = self.state.T_BED    
                                    tiles[idx(x + 1, y)] = self.state.T_BED

                elif town_kind == "": 
                    # School: keep world-map interior (camera view) like other buildings. 
                    is_city = bool(self._is_city_chunk(int(cx), int(cy))) 
                    floors = int(rng.randint(3, 6)) if is_city else int(rng.randint(2, 4)) 
                    if (not is_city) and rng.random() < 0.35: 
                        floors = 1 
                    building_floors = int(floors) 
 
                    # Keep corridor clear, add desks + lockers (always on 1F). 
                    # Lockers along one side. 
                    if door_side in ("N", "S"): 
                        lx = in_left + 1 
                        for y in range(in_top + 1, in_bottom): 
                            if (lx, y) in corridor or near_door(lx, y): 
                                continue 
                            if (y - (in_top + 1)) % 2 == 0: 
                                set_interior(lx, y, self.state.T_SHELF) 
                    else: 
                        ly = in_top + 1 
                        for x in range(in_left + 1, in_right): 
                            if (x, ly) in corridor or near_door(x, ly): 
                                continue 
                            if (x - (in_left + 1)) % 2 == 0: 
                                set_interior(x, ly, self.state.T_SHELF) 
 
                    # Desks in rows (reads as classrooms). 
                    for y in range(in_top + 2, in_bottom, 2): 
                        for x in range(in_left + 2, in_right, 3): 
                            set_interior(x, y, self.state.T_TABLE) 
 
                    # Small office/storage room. 
                    if w >= 12 and h >= 9: 
                        rx = x0 + w - 6 if door_side in ("N", "S") else x0 + 2 
                        ry = y0 + 2 if door_side in ("N", "S") else y0 + h - 5 
                        room = build_room(int(rx), int(ry), 3, 2) 
                        if room is not None: 
                            for x in range(int(rx), int(rx) + 3): 
                                for y in range(int(ry), int(ry) + 2): 
                                    if tiles[idx(x, y)] == self.state.T_FLOOR and ((x + y) % 2 == 0): 
                                        tiles[idx(x, y)] = self.state.T_SHELF 
 
                    if int(floors) > 1: 
                        # Add a staircase and register multi-floor snapshots (like houses/highrise). 
                        stair_pos: tuple[int, int] | None = None 
                        tx0c = int(clamp(int(round((in_left + in_right) / 2.0)), in_left + 1, in_right - 1)) 
                        ty0c = int(clamp(int(round((in_top + in_bottom) / 2.0)), in_top + 1, in_bottom - 1)) 
                        cand = [ 
                            (int(tx0c), int(ty0c)), 
                            (int(tx0c + 2), int(ty0c)), 
                            (int(tx0c - 2), int(ty0c)), 
                            (int(tx0c), int(ty0c + 2)), 
                            (int(tx0c), int(ty0c - 2)), 
                            (int(in_left + 2), int(in_bottom - 2)), 
                            (int(in_right - 2), int(in_bottom - 2)), 
                        ] 
                        for sx, sy in cand: 
                            if not (int(in_left) <= int(sx) <= int(in_right) and int(in_top) <= int(sy) <= int(in_bottom)): 
                                continue 
                            if (int(sx), int(sy)) in corridor or near_door(int(sx), int(sy)): 
                                continue 
                            if tiles[idx(int(sx), int(sy))] != int(self.state.T_FLOOR): 
                                continue 
                            tiles[idx(int(sx), int(sy))] = int(self.state.T_STAIRS_UP) 
                            stair_pos = (int(sx), int(sy)) 
                            break 
 
                        if stair_pos is None: 
                            building_floors = 1 
                        else: 
                            tx0w = cx * self.state.CHUNK_SIZE + x0 
                            ty0w = cy * self.state.CHUNK_SIZE + y0 
                            f1: list[int] = [] 
                            for yy in range(int(h)): 
                                for xx in range(int(w)): 
                                    f1.append(int(tiles[idx(int(x0 + xx), int(y0 + yy))])) 
 
                            f_up = list(f1) 
                            for i2 in range(len(f_up)): 
                                tcur = int(f_up[i2]) 
                                if tcur == int(self.state.T_DOOR): 
                                    f_up[i2] = int(self.state.T_WALL) 
                                elif tcur == int(self.state.T_STAIRS_UP): 
                                    f_up[i2] = int(self.state.T_STAIRS_DOWN) 
 
                            if mh_out is not None: 
                                floor_tiles: dict[int, list[int]] = {1: f1} 
                                for fl in range(2, int(building_floors) + 1): 
                                    floor_tiles[int(fl)] = f_up 
                                mh_out.append( 
                                    HardcoreSurvivalState._MultiHouse( 
                                        tx0=int(tx0w), 
                                        ty0=int(ty0w), 
                                        w=int(w), 
                                        h=int(h), 
                                        floors=int(building_floors), 
                                        cur_floor=1, 
                                        floor_tiles=floor_tiles, 
                                    ) 
                                ) 
 
                elif town_kind in ("", ""): 
                    # High-rise: keep world-map interior walkable (no full-screen portal). 
                    tx0w = cx * self.state.CHUNK_SIZE + x0 
                    ty0w = cy * self.state.CHUNK_SIZE + y0 
                    doors_w = tuple((cx * self.state.CHUNK_SIZE + int(dx), cy * self.state.CHUNK_SIZE + int(dy)) for dx, dy in door_tiles)
                    floors = int(building_floors)
                    apt_doors: list[tuple[int, int, bool]] = []

                    # Elevator tile inside the lobby (world-map multi-floor switching).
                    try:
                        if door_tiles:
                            door_xs = [int(p[0]) for p in door_tiles]
                            door_y = int(max(int(p[1]) for p in door_tiles))
                            door_cx = int(round(sum(int(x) for x in door_xs) / max(1, len(door_xs))))
                            elev_x = int(clamp(int(door_cx), int(x0 + 1), int(x0 + w - 2)))
                            top_cut = int(max(0, (int(h) - 2) - int(core_h)))
                            floor_y0 = int(y0 + 1 + int(top_cut))
                            elev_y = int(clamp(int(door_y - 3), int(floor_y0), int(y0 + h - 2)))
                            if tiles[idx(int(elev_x), int(elev_y))] != int(self.state.T_WALL):
                                tiles[idx(int(elev_x), int(elev_y))] = int(self.state.T_ELEVATOR)
                    except Exception:
                        pass

                    # Interior: elevator lobby + 2/3 apartments (never single-unit).
                    try:
                        top_cut = int(max(0, (int(h) - 2) - int(core_h)))
                        floor_y0 = int(y0 + 1 + int(top_cut))
                        in_left = int(x0 + 1)
                        in_right = int(x0 + w - 2)
                        in_top = int(floor_y0)
                        in_bottom = int(y0 + h - 2)
                        usable_h = int(in_bottom - in_top + 1)
                        usable_w = int(in_right - in_left + 1)

                        if int(usable_h) >= 6 and int(usable_w) >= 7 and door_tiles:
                            door_xs = [int(p[0]) for p in door_tiles]
                            door_cx_i = int(round(sum(int(x) for x in door_xs) / max(1, len(door_xs))))

                            # Lobby takes the bottom slice; apartments sit above it.
                            # Keep the lobby compact so apartments feel like real homes.
                            lobby_h = int(clamp(int(round(float(usable_h) * 0.18)), 2, 3))
                            min_apt_h = 4
                            lobby_h = int(clamp(int(lobby_h), 2, max(2, int(usable_h) - int(min_apt_h))))
                            sep_y = int(in_bottom - int(lobby_h))
                            sep_y = int(clamp(int(sep_y), int(in_top + min_apt_h - 1), int(in_bottom - 2)))

                            # Keep a single elevator tile inside the lobby.
                            for yy in range(int(in_top), int(in_bottom) + 1):
                                for xx in range(int(in_left), int(in_right) + 1):
                                    if int(tiles[idx(int(xx), int(yy))]) == int(self.state.T_ELEVATOR):
                                        tiles[idx(int(xx), int(yy))] = int(self.state.T_FLOOR)

                            elev_x = int(clamp(int(door_cx_i), int(in_left + 1), int(in_right - 1)))
                            elev_y = int(clamp(int(sep_y + 1), int(sep_y + 1), int(in_bottom - 1)))
                            if int(tiles[idx(int(elev_x), int(elev_y))]) != int(self.state.T_WALL):
                                tiles[idx(int(elev_x), int(elev_y))] = int(self.state.T_ELEVATOR)

                            lobby_area: set[tuple[int, int]] = set()
                            for dy in (-1, 0, 1):
                                for dx in (-1, 0, 1):
                                    lobby_area.add((int(elev_x + dx), int(elev_y + dy)))

                            # Horizontal separator: lobby (south) vs apartments (north).
                            for xx in range(int(in_left), int(in_right) + 1):
                                tiles[idx(int(xx), int(sep_y))] = int(self.state.T_WALL)

                            # Always 2 units ().
                            units = 2
                            min_unit_w = 5 if int(usable_w) >= 11 else 3
                            if int(units) == 3:
                                min_unit_w = 5
                            unit_ranges: list[tuple[int, int]] = []
                            split_xs: list[int] = []
                            if int(units) == 2:
                                split_x = int(clamp(int(elev_x), int(in_left + min_unit_w), int(in_right - min_unit_w)))
                                split_xs = [int(split_x)]
                                unit_ranges = [(int(in_left), int(split_x - 1)), (int(split_x + 1), int(in_right))]
                            else:
                                x1 = int(in_left + (int(usable_w) // 3))
                                x2 = int(in_left + (int(usable_w) * 2) // 3)
                                x1 = int(clamp(int(x1), int(in_left + min_unit_w), int(in_right - 2 * min_unit_w - 1)))
                                x2 = int(clamp(int(x2), int(x1 + min_unit_w + 1), int(in_right - min_unit_w)))
                                split_xs = [int(x1), int(x2)]
                                unit_ranges = [
                                    (int(in_left), int(x1 - 1)),
                                    (int(x1 + 1), int(x2 - 1)),
                                    (int(x2 + 1), int(in_right)),
                                ]

                            # Vertical separators between units (only above the lobby line).
                            for sx in split_xs:
                                for yy in range(int(in_top), int(sep_y)):
                                    tiles[idx(int(sx), int(yy))] = int(self.state.T_WALL)

                            reserved: set[tuple[int, int]] = set(lobby_area)
                            # Apartment doors on the separator line.
                            seed_base = int(self.seed) ^ 0x6B8B4567
                            for ux0, ux1 in unit_ranges:
                                if int(ux1 - ux0 + 1) < 3:
                                    continue
                                dx = int(clamp(int((ux0 + ux1) // 2), int(ux0 + 1), int(ux1 - 1)))
                                # 1F: always locked; upper floors may have broken doors.
                                wx = int(base_tx + int(dx))
                                wy = int(base_ty + int(sep_y))
                                hh = int(self.state._hash2_u32(int(wx), int(wy), int(seed_base)))
                                broken_up = int(hh % 100) < 18
                                tiles[idx(int(dx), int(sep_y))] = int(self.state.T_DOOR_LOCKED)
                                apt_doors.append((int(dx), int(sep_y), bool(broken_up)))
                                for ddy in (-1, 0, 1):
                                    for ddx in (-1, 0, 1):
                                        reserved.add((int(dx + ddx), int(sep_y + ddy)))

                    except Exception:
                        pass

                    special_buildings.append(
                        HardcoreSurvivalState._SpecialBuilding(
                            kind="highrise",
                            name="",
                            tx0=int(tx0w),
                            ty0=int(ty0w),
                            w=int(w),
                            h=int(h),
                            door_tiles=doors_w,
                            floors=floors,
                        )
                    )

                    # Register as a multi-floor building so facade slicing + floor switching works.
                    if mh_out is not None and int(floors) > 1:
                        f1: list[int] = []
                        for yy in range(int(h)):
                            for xx in range(int(w)):
                                f1.append(int(tiles[idx(int(x0 + xx), int(y0 + yy))]))

                        f_up = list(f1)
                        for dx, dy in door_tiles:
                            i2 = int(dy - y0) * int(w) + int(dx - x0)
                            if 0 <= i2 < len(f_up):
                                f_up[int(i2)] = int(self.state.T_WALL)
                        # Upper floors: apply the broken/locked state for unit-entry doors.
                        try:
                            for dx, dy, broken_up in list(apt_doors):
                                i2 = int(dy - y0) * int(w) + int(dx - x0)
                                if 0 <= i2 < len(f_up):
                                    f_up[int(i2)] = int(self.state.T_DOOR_BROKEN) if bool(broken_up) else int(self.state.T_DOOR_LOCKED)
                        except Exception:
                            pass

                        floor_tiles: dict[int, list[int]] = {1: f1}
                        for fl in range(2, int(floors) + 1):
                            floor_tiles[int(fl)] = f_up

                        mh_out.append(
                            HardcoreSurvivalState._MultiHouse(
                                tx0=int(tx0w),
                                ty0=int(ty0w),
                                w=int(w),
                                h=int(h),
                                floors=int(floors),
                                cur_floor=1,
                                floor_tiles=floor_tiles,
                            )
                        )

                else:
                    # Prison: split into cell block + common area.        
                    if w >= h:
                        split_x = int(clamp(int(x0 + w // 2), in_left + 2, in_right - 2))
                        for y in range(in_top, in_bottom + 1):
                            if near_door(split_x, y):
                                continue
                            tiles[idx(split_x, y)] = self.state.T_WALL

                        cell_n = 3 if (in_bottom - in_top + 1) >= 7 else 2
                        total_h = int(in_bottom - in_top + 1)
                        # Horizontal separators for cells.
                        for i in range(1, cell_n):
                            by = in_top + (i * total_h) // cell_n
                            if not (in_top + 1 <= by <= in_bottom - 1):
                                continue
                            for x in range(in_left, split_x + 1):
                                if near_door(x, by):
                                    continue
                                tiles[idx(x, by)] = self.state.T_WALL

                        for i in range(cell_n):
                            y0c = in_top + (i * total_h) // cell_n
                            y1c = in_top + ((i + 1) * total_h) // cell_n - 1
                            dy = int(clamp((y0c + y1c) // 2, in_top + 1, in_bottom - 1))
                            if not near_door(split_x, dy):
                                tiles[idx(split_x, dy)] = self.state.T_DOOR
                                clear_interior(split_x + 1, dy)
                                mark_corridor(split_x, dy)

                            bx = in_left + 1
                            by = int(clamp(dy, in_top + 1, in_bottom - 1))
                            if tiles[idx(bx, by)] == self.state.T_FLOOR and tiles[idx(bx + 1, by)] == self.state.T_FLOOR:
                                tiles[idx(bx, by)] = self.state.T_BED
                                tiles[idx(bx + 1, by)] = self.state.T_BED
                            if rng.random() < 0.55:
                                tx = in_left + 1
                                ty = int(clamp(by - 1, in_top + 1, in_bottom - 1))
                                if tiles[idx(tx, ty)] == self.state.T_FLOOR:
                                    tiles[idx(tx, ty)] = self.state.T_TABLE

                        # Common tables on the right side.
                        for y in range(in_top + 1, in_bottom, 2):
                            for x in range(split_x + 2, in_right - 1, 3):
                                if (x, y) in corridor or near_door(x, y):
                                    continue
                                if tiles[idx(x, y)] == self.state.T_FLOOR:
                                    tiles[idx(x, y)] = self.state.T_TABLE
                    else:
                        split_y = int(clamp(int(y0 + h // 2), in_top + 2, in_bottom - 2))
                        for x in range(in_left, in_right + 1):
                            if near_door(x, split_y):
                                continue
                            tiles[idx(x, split_y)] = self.state.T_WALL

                        cell_n = 3 if (in_right - in_left + 1) >= 9 else 2
                        total_w = int(in_right - in_left + 1)
                        for i in range(1, cell_n):
                            bx = in_left + (i * total_w) // cell_n
                            if not (in_left + 1 <= bx <= in_right - 1):
                                continue
                            for y in range(in_top, split_y + 1):
                                if near_door(bx, y):
                                    continue
                                tiles[idx(bx, y)] = self.state.T_WALL

                        for i in range(cell_n):
                            x0c = in_left + (i * total_w) // cell_n
                            x1c = in_left + ((i + 1) * total_w) // cell_n - 1
                            dx = int(clamp((x0c + x1c) // 2, in_left + 1, in_right - 1))
                            if not near_door(dx, split_y):
                                tiles[idx(dx, split_y)] = self.state.T_DOOR
                                clear_interior(dx, split_y + 1)
                                mark_corridor(dx, split_y)

                            bx = int(clamp(dx, in_left + 1, in_right - 2))
                            by = in_top + 1
                            if tiles[idx(bx, by)] == self.state.T_FLOOR and tiles[idx(bx + 1, by)] == self.state.T_FLOOR:
                                tiles[idx(bx, by)] = self.state.T_BED
                                tiles[idx(bx + 1, by)] = self.state.T_BED
                            if rng.random() < 0.55:
                                tx = int(clamp(bx - 1, in_left + 1, in_right - 1))
                                ty = in_top + 1
                                if tiles[idx(tx, ty)] == self.state.T_FLOOR:
                                    tiles[idx(tx, ty)] = self.state.T_TABLE

                        for x in range(in_left + 1, in_right, 2):
                            for y in range(split_y + 2, in_bottom - 1, 3):
                                if (x, y) in corridor or near_door(x, y):
                                    continue
                                if tiles[idx(x, y)] == self.state.T_FLOOR:
                                    tiles[idx(x, y)] = self.state.T_TABLE

                # Prevent "see it but cannot enter" interior gaps: ensure all passable
                # tiles (floor/door) inside the building are reachable from the entrance.
                entrance_set: set[tuple[int, int]] = {(int(dx), int(dy)) for dx, dy in door_tiles}

                def passable(t: int) -> bool:
                    return int(t) in (
                        int(self.state.T_FLOOR),
                        int(self.state.T_DOOR),
                        int(self.state.T_ELEVATOR),
                    )

                # Start tiles: door tiles + the tile just inside the entrance.
                starts: list[tuple[int, int]] = []
                starts.extend([(int(dx), int(dy)) for dx, dy in door_tiles])
                if door_side == "N":
                    starts.extend([(int(dx), int(dy) + 1) for dx, dy in door_tiles])
                elif door_side == "S":
                    starts.extend([(int(dx), int(dy) - 1) for dx, dy in door_tiles])
                elif door_side == "W":
                    starts.extend([(int(dx) + 1, int(dy)) for dx, dy in door_tiles])
                else:
                    starts.extend([(int(dx) - 1, int(dy)) for dx, dy in door_tiles])
                starts = [
                    (sx, sy)
                    for (sx, sy) in starts
                    if (int(x0) <= int(sx) < int(x0 + w) and int(y0) <= int(sy) < int(y0 + h) and passable(tiles[idx(int(sx), int(sy))]))
                ]

                if starts:
                    passable_tiles: set[tuple[int, int]] = set()
                    for py in range(int(y0), int(y0 + h)):
                        for px in range(int(x0), int(x0 + w)):
                            if passable(tiles[idx(px, py)]):
                                passable_tiles.add((int(px), int(py)))

                    def flood(start_list: list[tuple[int, int]]) -> set[tuple[int, int]]:
                        seen: set[tuple[int, int]] = set()
                        stack: list[tuple[int, int]] = list(start_list)
                        while stack:
                            x, y = stack.pop()
                            x = int(x)
                            y = int(y)
                            if (x, y) in seen:
                                continue
                            if not (int(x0) <= x < int(x0 + w) and int(y0) <= y < int(y0 + h)):
                                continue
                            if not passable(tiles[idx(x, y)]):
                                continue
                            seen.add((x, y))
                            stack.extend([(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)])
                        return seen

                    solids = {
                        int(self.state.T_WALL),
                        int(self.state.T_TABLE),
                        int(self.state.T_SHELF),
                        int(self.state.T_BED),
                    }

                    # Try to connect unreachable pockets by opening a wall (door) or clearing a blocking prop.
                    for _ in range(40):
                        reachable = flood(starts)
                        unreachable = passable_tiles.difference(reachable)
                        if not unreachable:
                            break

                        opened = False
                        for py in range(int(in_top), int(in_bottom) + 1):
                            for px in range(int(in_left), int(in_right) + 1):
                                t = int(tiles[idx(px, py)])
                                if t not in solids:
                                    continue

                                has_reach = False
                                has_unreach = False
                                for nx, ny in ((px + 1, py), (px - 1, py), (px, py + 1), (px, py - 1)):
                                    if not (int(x0) <= nx < int(x0 + w) and int(y0) <= ny < int(y0 + h)):
                                        continue
                                    if not passable(tiles[idx(nx, ny)]):
                                        continue
                                    if (int(nx), int(ny)) in reachable:
                                        has_reach = True
                                    elif (int(nx), int(ny)) in unreachable:
                                        has_unreach = True
                                if has_reach and has_unreach:
                                    tiles[idx(px, py)] = self.state.T_DOOR if t == int(self.state.T_WALL) else self.state.T_FLOOR
                                    passable_tiles.add((int(px), int(py)))
                                    opened = True
                                    break
                            if opened:
                                break

                        if not opened:
                            # Fallback: seal unreachable walkable tiles so players never see fake rooms.
                            for ux, uy in unreachable:
                                if (int(ux), int(uy)) in entrance_set:
                                    continue
                                tiles[idx(int(ux), int(uy))] = self.state.T_WALL
                            break

                    # Remove dead-end internal doors (doors must connect >=2 passable neighbors).
                    for py in range(int(in_top), int(in_bottom) + 1):
                        for px in range(int(in_left), int(in_right) + 1):
                            if int(tiles[idx(px, py)]) != int(self.state.T_DOOR):
                                continue
                            if (int(px), int(py)) in entrance_set:
                                continue
                            n_pass = 0
                            for nx, ny in ((px + 1, py), (px - 1, py), (px, py + 1), (px, py - 1)):
                                if not (int(x0) <= nx < int(x0 + w) and int(y0) <= ny < int(y0 + h)):
                                    continue
                                if passable(tiles[idx(nx, ny)]):
                                    n_pass += 1
                            if n_pass < 2:
                                tiles[idx(px, py)] = self.state.T_WALL

                def pick_kind(kind: str, *, prefix: str | None = None, k: int = 10) -> list[str]:
                    kind = str(kind)
                    pool: list[str] = []
                    for iid, idef in self.state._ITEMS.items():
                        if idef is None:
                            continue
                        if str(getattr(idef, "kind", "")) != kind:
                            continue
                        if prefix is not None and not str(iid).startswith(str(prefix)):
                            continue
                        pool.append(str(iid))
                    if not pool:
                        return []
                    rng.shuffle(pool)
                    k = int(clamp(int(k), 0, len(pool)))
                    return pool[:k]

                foods = pick_kind("food", prefix="food_", k=18)
                drinks = pick_kind("drink", prefix="drink_", k=12)       
                meds = pick_kind("med", prefix="med_", k=12)
                mats = pick_kind("mat", k=8)
                tools = pick_kind("tool", k=6)
                melees = pick_kind("melee", prefix="melee_", k=5)
                clothes = pick_kind("clothes", prefix="clothes_", k=8)
                fuels = pick_kind("fuel", k=2)
                keys = pick_kind("key", k=2)

                loot_choices: list[str]
                if town_kind == "":
                    loot_choices = ["bandage", "medkit", "water"] + meds
                elif town_kind in ("", ""):
                    loot_choices = ["food_can", "water", "cola", "bandage", "medkit"] + foods + drinks + mats + tools + melees + clothes
                elif town_kind == "":
                    loot_choices = ["book", "paper", "map", "water", "cola", "bandage"] + foods + drinks
                elif town_kind == "":
                    loot_choices = [
                        "pistol",
                        "uzi",
                        "ak47",
                        "scar_l",
                        "ammo_9mm",
                        "ammo_9mm",
                        "ammo_556",
                        "ammo_556",
                        "ammo_762",
                        "ammo_762",
                        "ammo_rocket",
                        "mod_optic_reddot",
                        "mod_optic_4x",
                        "mod_optic_holo",
                        "mod_muzzle_suppressor_9mm",
                        "mod_muzzle_suppressor_rifle",
                        "mod_muzzle_comp_rifle",
                        "mod_muzzle_flash_hider_rifle",
                        "mod_undergrip_stab",
                        "mod_undergrip_bipod",
                        "mod_stock_tactical",
                        "mod_trigger_light",
                        "mod_mag_ext_pistol",
                        "mod_mag_ext_9mm",
                        "mod_mag_ext_rifle",
                        "mod_mag_drum_9mm",
                        "mod_mag_drum_rifle",
                        "scrap",
                        "bandage",
                        "knife",
                        "crowbar",
                    ] + mats + tools + melees + clothes
                    # Heavy weapons are rare even in gun shops.
                    if rng.random() < 0.07:
                        loot_choices.append("rpg")
                elif town_kind in ("", ""):
                    loot_choices = ["pistol", "ak47", "ammo_9mm", "ammo_762", "ammo_762", "scrap", "bandage", "crowbar"] + mats + melees + clothes
                elif town_kind == "":
                    loot_choices = ["food_can", "water", "cola", "bandage", "book", "paper"] + foods + drinks
                elif town_kind in ("", ""):
                    loot_choices = [
                        "food_can",
                        "water",
                        "cola",
                        "bandage",
                        "scrap",
                        "ammo_9mm",
                        "ammo_556",
                        "ammo_762",
                        "mod_optic_reddot",
                        "mod_muzzle_suppressor_9mm",
                        "mod_mag_ext_pistol",
                    ] + foods + drinks + mats + melees + clothes
                else:
                    loot_choices = ["food_can", "water", "cola", "bandage"] + foods[:8] + drinks[:6] + mats + melees + clothes

                # Vehicle keys / fuel are rare, but exist in the world so the hardcore loop works.
                key_ch = 0.08
                fuel_ch = 0.10
                if town_kind in ("", "", ""):
                    key_ch = 0.35
                    fuel_ch = 0.16
                elif town_kind in ("", ""):
                    key_ch = 0.12
                    fuel_ch = 0.28
                if keys and rng.random() < float(key_ch):
                    loot_choices += keys
                if fuels and rng.random() < float(fuel_ch):
                    loot_choices += fuels
                if not loot_choices:
                    loot_choices = ["food_can", "water"]

                loot_n = rng.randint(2, 4) if town_kind in ("", "", "", "", "") else rng.randint(2, 3)
                prelude = str(getattr(self.state, "world_gen_story_mode", "")) == "prelude"
                if prelude and town_kind in ("", "", ""):
                    loot_n = rng.randint(0, 1)

                # Place loot only on tiles reachable from the entrance, so we
                # don't create "see the item but cannot enter" situations.
                start: tuple[int, int] | None = None
                entrance_candidates: list[tuple[int, int]] = []
                if door_side == "N":
                    entrance_candidates = [(int(dx), int(dy) + 1) for dx, dy in door_tiles] + list(door_tiles)
                elif door_side == "S":
                    entrance_candidates = [(int(dx), int(dy) - 1) for dx, dy in door_tiles] + list(door_tiles)
                elif door_side == "W":
                    entrance_candidates = [(int(dx) + 1, int(dy)) for dx, dy in door_tiles] + list(door_tiles)
                else:
                    entrance_candidates = [(int(dx) - 1, int(dy)) for dx, dy in door_tiles] + list(door_tiles)

                for sx, sy in entrance_candidates:
                    if not (int(x0) <= int(sx) < int(x0 + w) and int(y0) <= int(sy) < int(y0 + h)):
                        continue
                    if tiles[idx(int(sx), int(sy))] in (self.state.T_FLOOR, self.state.T_DOOR):
                        start = (int(sx), int(sy))
                        break

                reachable_floor: list[tuple[int, int]] = []
                if start is not None:
                    seen: set[tuple[int, int]] = set()
                    stack: list[tuple[int, int]] = [start]
                    while stack:
                        x, y = stack.pop()
                        x = int(x)
                        y = int(y)
                        if (x, y) in seen:
                            continue
                        if not (int(x0) <= x < int(x0 + w) and int(y0) <= y < int(y0 + h)):
                            continue
                        t = tiles[idx(x, y)]
                        if t not in (self.state.T_FLOOR, self.state.T_DOOR):
                            continue
                        seen.add((x, y))
                        if t == self.state.T_FLOOR and not near_door(x, y):
                            reachable_floor.append((x, y))
                        stack.extend([(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)])

                reachable_shelf_front: list[tuple[int, int]] = []
                if reachable_floor:
                    for ix, iy in reachable_floor:
                        for nx, ny in ((ix + 1, iy), (ix - 1, iy), (ix, iy + 1), (ix, iy - 1)):
                            if not (int(x0) <= int(nx) < int(x0 + w) and int(y0) <= int(ny) < int(y0 + h)):
                                continue
                            if int(tiles[idx(int(nx), int(ny))]) == int(self.state.T_SHELF):
                                reachable_shelf_front.append((int(ix), int(iy)))
                                break

                if reachable_floor:
                    if prelude and reachable_shelf_front:
                        # Neat shelf-front placement during the pre-apocalypse days.
                        reachable_floor = sorted(reachable_shelf_front, key=lambda p: (int(p[1]), int(p[0])))
                    else:
                        rng.shuffle(reachable_floor)

                # Multi-floor houses share the same world-tile footprint for 1F/2F.
                # To avoid items appearing on the "wrong" floor, don't spawn loot
                # inside 2F houses for now.
                if int(building_floors) > 1 and town_kind in ("", "", ""):
                    reachable_floor = []

                spot_i = 0
                for _ in range(loot_n):
                    if spot_i >= len(reachable_floor):
                        break
                    ix, iy = reachable_floor[spot_i]
                    spot_i += 1

                    item_id = rng.choice(loot_choices)
                    idef = self.state._ITEMS.get(item_id)
                    if idef is None:
                        continue
                    if idef.kind == "ammo":
                        qty = rng.randint(12, 28)
                    elif idef.kind == "mat":
                        qty = rng.randint(2, 6)
                    else:
                        qty = 1
                    qty = int(clamp(qty, 1, idef.stack))

                    tx = cx * self.state.CHUNK_SIZE + ix
                    ty = cy * self.state.CHUNK_SIZE + iy
                    px = (tx + 0.5) * self.state.TILE_SIZE
                    py = (ty + 0.5) * self.state.TILE_SIZE
                    items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(px, py), item_id=item_id, qty=qty))

                if town_kind in ("", "") and spot_i < len(reachable_floor):
                    ix, iy = reachable_floor[spot_i]
                    tx = cx * self.state.CHUNK_SIZE + ix
                    ty = cy * self.state.CHUNK_SIZE + iy
                    px = (tx + 0.5) * self.state.TILE_SIZE
                    py = (ty + 0.5) * self.state.TILE_SIZE
                    items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(px, py), item_id="pistol", qty=1))
                    items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(px, py + 6), item_id="ammo_9mm", qty=rng.randint(18, 34)))

                if town_kind == "" and spot_i < len(reachable_floor):
                    ix, iy = reachable_floor[spot_i]
                    tx = cx * self.state.CHUNK_SIZE + ix
                    ty = cy * self.state.CHUNK_SIZE + iy
                    px = (tx + 0.5) * self.state.TILE_SIZE
                    py = (ty + 0.5) * self.state.TILE_SIZE
                    items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(px, py), item_id="pistol", qty=1))
                    items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(px, py + 6), item_id="ammo_9mm", qty=rng.randint(20, 40)))

                roof_style = 0
                if town_kind == "":
                    roof_style = 1
                elif town_kind in ("", ""):
                    roof_style = 2
                elif town_kind == "":
                    roof_style = 7
                elif town_kind == "":
                    roof_style = 9
                elif town_kind == "":
                    roof_style = 3
                elif town_kind in ("", ""):
                    roof_style = 4
                elif town_kind == "":
                    roof_style = 5
                elif town_kind in ("", ""):
                    roof_style = 6
                elif town_kind == "":
                    roof_style = 8
                roof_var = int(rng.randrange(0, 256))
                if int(roof_style) == 6 and roof_var_hint is not None:
                    roof_var = int(roof_var_hint) & 0xFF
                roof_kind = (int(roof_style) << 8) | int(roof_var)
                buildings.append(
                    (
                        cx * self.state.CHUNK_SIZE + x0,
                        cy * self.state.CHUNK_SIZE + y0,
                        w,
                        h,
                        int(roof_kind),
                        int(building_floors),
                    )
                )
                placed += 1

    @dataclass
    class _Player:
        pos: pygame.Vector2
        vel: pygame.Vector2
        facing: pygame.Vector2
        w: int = 8
        h: int = 12
        body_h: int = 12
        collider_h: int = 12
        hp: int = 100
        hunger: float = 100.0
        thirst: float = 100.0
        condition: float = 100.0
        morale: float = 100.0
        stamina: float = 100.0
        walk_phase: float = 0.0
        dir: str = "down"

        def rect_at(self, pos: pygame.Vector2 | None = None) -> pygame.Rect:
            p = self.pos if pos is None else pos
            h = int(getattr(self, "collider_h", self.h))
            return pygame.Rect(
                iround(float(p.x) - float(self.w) / 2.0),
                iround(float(p.y) - float(h) / 2.0),
                int(self.w),
                int(h),
            )

    def on_enter(self) -> None:
        # Worldgen style toggles (used by chunk generation before story init runs).
        # "prelude" => tidy interiors + shelf-ish loot placement.
        self.world_gen_story_mode = "prelude"

        self.seed = int(time.time()) & 0xFFFFFFFF
        self.world = HardcoreSurvivalState._World(self, seed=self.seed)
        spawn_tx, spawn_ty = self.world.spawn_tile()
        # Preload the main city area so POI icons (e.g., gunshop/bookstore) show up
        # quickly on the minimap/world-map without requiring long travel.
        try:
            ccx = int(getattr(self.world, "city_cx", 0))
            ccy = int(getattr(self.world, "city_cy", 0))
            cr = max(0, int(getattr(self.world, "city_radius", 0)))
            for cy in range(int(ccy) - int(cr), int(ccy) + int(cr) + 1):
                for cx in range(int(ccx) - int(cr), int(ccx) + int(cr) + 1):
                    self.world.request_chunk(int(cx), int(cy))
        except Exception:
            pass

        # POI cache for minimap edge-indicators.
        self._poi_cache: dict[str, list[tuple[int, int]]] = {}
        self._poi_scanned_chunks: set[tuple[int, int]] = set()
        self._poi_cache_t = 0.0
        spawn_px = (spawn_tx + 0.5) * self.TILE_SIZE
        spawn_py = (spawn_ty + 0.5) * self.TILE_SIZE
        self.avatar = getattr(self, "avatar", None) or SurvivalAvatar()
        self.avatar.clamp_all()
        self.clothes_id: str | None = None
        try:
            starter = self._OUTFIT_TO_CLOTHES.get(int(getattr(self.avatar, "outfit", 0)))
            self.clothes_id = str(starter) if starter else None
        except Exception:
            self.clothes_id = None
        self.player = HardcoreSurvivalState._Player(
            pos=pygame.Vector2(spawn_px, spawn_py),
            vel=pygame.Vector2(0, 0),
            facing=pygame.Vector2(1, 0),
        )
        # Apply appearance + body size.
        self.player_frames = HardcoreSurvivalState.build_avatar_player_frames(self.avatar, run=False)
        self.player_frames_run = HardcoreSurvivalState.build_avatar_player_frames(self.avatar, run=True)
        self.cyclist_frames = HardcoreSurvivalState.build_avatar_cyclist_frames(self.avatar)
        self.player_sprinting = False
        gender = int(self.avatar.gender) % len(SURVIVAL_GENDER_OPTIONS)
        height = int(self.avatar.height) % len(SURVIVAL_HEIGHT_OPTIONS)
        self.player.w = 8 if gender == 0 else 7
        body_h = int((11, 12, 13)[height])
        self.player.body_h = int(body_h)
        self.player.h = int(body_h)
        self.player.collider_h = int(clamp(int(body_h) - 3, 8, int(self.TILE_SIZE) - 1))
        # Shared player collider used in full-screen interiors (house/school/high-rise).
        self.int_player_w = (10 if gender == 0 else 9)
        self.int_player_h = 14 + (height - 1)
        self.inventory = HardcoreSurvivalState._Inventory(slots=[None] * 16)
        self.inv_open = False
        self.inv_index = 0
        # Inventory UI state (hover / drag / context actions).
        self._inv_hover_idx: int | None = None
        self._inv_mouse_down: bool = False
        self._inv_mouse_down_idx: int = -1
        self._inv_mouse_down_pos: tuple[int, int] | None = None
        self._inv_dragging: bool = False
        self._inv_drag_from_idx: int = -1
        self._inv_drag_pos: tuple[int, int] | None = None
        self._inv_drag_over_idx: int | None = None
        self._inv_ctx_open: bool = False
        self._inv_ctx_idx: int = -1
        self._inv_ctx_rect: pygame.Rect | None = None
        self._inv_ctx_buttons: list[tuple[pygame.Rect, str]] = []
        self.pause_open = False
        self.pause_rects: list[tuple[pygame.Rect, str]] = []
        self.rv_storage = HardcoreSurvivalState._Inventory(slots=[None] * 24, cols=6)
        # Apartment home storage (openable cabinets).
        self.home_storage = HardcoreSurvivalState._Inventory(slots=[None] * 30, cols=6)
        self.fridge_storage = HardcoreSurvivalState._Inventory(slots=[None] * 12, cols=4)
        # High-rise rooms (home + break-in apartments) share the same storage UI.
        self.hr_current_room = ""
        self.hr_room_storages: dict[str, tuple[HardcoreSurvivalState._Inventory, HardcoreSurvivalState._Inventory]] = {}
        self.hr_room_floor_items: dict[str, list[HardcoreSurvivalState._WorldItem]] = {}
        self.hr_floor_items: list[HardcoreSurvivalState._WorldItem] = []
        self.hr_room_lights: dict[str, bool] = {}
        self.home_ui_open = False
        self.home_ui_focus: str = "storage"  # player | storage
        self.home_ui_storage_kind: str = "cabinet"  # cabinet | fridge   
        self.home_ui_player_index = 0
        self.home_ui_storage_index = 0
        self.home_ui_status = ""
        self.home_ui_status_left = 0.0
        self.home_ui_open_block: tuple[int, int, int, int] | None = None
        # Some starter supplies at home.
        self.home_storage.add("food_can", 4, self._ITEMS)
        self.home_storage.add("bandage", 6, self._ITEMS)
        self.home_storage.add("cup", 1, self._ITEMS)
        self.inventory.add("key_rv", 1, self._ITEMS)
        self.home_storage.add("key_moto", 1, self._ITEMS)
        self.inventory.add("key_house", 1, self._ITEMS)
        self.fridge_storage.add("water", 2, self._ITEMS)
        self.fridge_storage.add("cola", 2, self._ITEMS)
        # Some visible "snacks" so home doesn't feel empty.
        for iid, qty in (
            ("food_chips_bbq", 2),
            ("food_candy_sweet", 2),
            ("food_chocolate_plain", 2),
            ("food_nuts_plain", 2),
        ):
            self.home_storage.add(iid, int(qty), self._ITEMS)
        for iid, qty in (
            ("drink_water_mineral_plain", 2),
            ("drink_tea_lemon", 1),
        ):
            self.fridge_storage.add(iid, int(qty), self._ITEMS)
        # Simple pose / action state (sit / sleep) used in interiors.
        self.player_pose: str | None = None  # sit | sleep
        self.player_pose_space: str = ""  # hr | rv
        self.player_pose_left = 0.0
        self.player_pose_anchor: tuple[float, float] | None = None
        self.player_pose_phase = 0.0
        self.hint_text = ""
        self.hint_left = 0.0
        self.gun: HardcoreSurvivalState._Gun | None = None
        self.melee_weapon_id: str | None = None
        self.bullets: list[HardcoreSurvivalState._Bullet] = []
        self.thrown_furniture: list[HardcoreSurvivalState._ThrownFurniture] = []
        self.zombies: list[HardcoreSurvivalState._Zombie] = []
        self.spawn_left = 8.0
        self.zombie_cap = 8
        self.zombie_frozen = False
        self.dead_left = 0.0
        self.starve_accum = 0.0
        # Bleeding / wounds (simple hardcore layer).
        # Stored as: body_part -> HP/sec bleed rate.
        self.bleed_accum = 0.0
        self.bleed_wounds: dict[str, float] = {}
        self.mount: str | None = None
        self.rv = HardcoreSurvivalState._RV(
            pos=pygame.Vector2(self.player.pos) + pygame.Vector2(34, 0),  
            vel=pygame.Vector2(0, 0),
            model_id="rv",
            fuel=100.0,
        )
        self._apply_rv_model()
        self.rv_hotwired = False
        self.rv_dir = "right"
        self.rv_anim = 0.0
        self.rv_headlights_on = True
        self.bike = HardcoreSurvivalState._Bike(
            pos=pygame.Vector2(self.player.pos) + pygame.Vector2(-28, 10),
            vel=pygame.Vector2(0, 0),
            model_id="bike_mountain",
        )
        self._apply_bike_model()
        self.bike_hotwired = False
        self._place_spawn_vehicles_safely()
        self.bike_dir = "right"
        self.bike_anim = 0.0
        self.aim_dir = pygame.Vector2(1, 0)
        self.cam_x = 0
        self.cam_y = 0
        self._reload_lock_dir: pygame.Vector2 | None = None
        # RV "interior" (world-map camera, NOT full-screen panel).
        self.rv_world_interior = False
        self._rv_world_return_pos: pygame.Vector2 | None = None
        self._rv_world_int_size = (9, 4)  # w, h (tiles)
        self._rv_world_int_active_key: tuple[int, int, int, int] | None = None
        self._rv_world_int_restore_tiles: dict[tuple[int, int], int] | None = None
        self._rv_world_int_exit_tile: tuple[int, int] | None = None
        self._rv_world_floor_base: dict[tuple[int, int], int] | None = None
        self._rv_world_fixed_furniture: set[tuple[int, int]] = set()
        self._rv_world_dash_tile: tuple[int, int] | None = None

        # High-rise interior (multi-floor apartment).
        self.hr_interior = False
        self.hr_int_pos = pygame.Vector2(0, 0)
        self.hr_int_vel = pygame.Vector2(0, 0)
        self.hr_int_facing = pygame.Vector2(0, 1)
        self.hr_int_walk_phase = 0.0
        self.hr_mode = "lobby"  # lobby | hall | home
        self.hr_floor = 1
        self.hr_layout: list[str] = list(self._HR_INT_LOBBY_LAYOUT)
        self.hr_building: HardcoreSurvivalState._SpecialBuilding | None = None
        self.hr_world_return = pygame.Vector2(self.player.pos)
        self.hr_auto_walk_to_elevator = False
        self.hr_auto_walk_delay = 0.0

        self.home_highrise_door: tuple[int, int] | None = None
        self.home_highrise_floor = 0
        self.home_highrise_door_index = 0
        self.home_highrise_unit = 0
        self.home_highrise_room = ""
        self.home_highrise_dialog_armed = True

        # Home lighting / in-world furniture moving (NO full-screen floorplan).
        self.home_light_on = True
        self.home_move_mode = False
        self.home_move_cursor = (0, 0)
        self.home_move_carry = None
        # World furniture durability (keyed by space/building-floor + tile).
        self.world_furniture_hp: dict[tuple[object, ...], int] = {}
        self.world_ctx_open = False
        self.world_ctx_target = None
        self.world_ctx_rects = []
        self.world_ctx_cooldown_left = 0.0
        self.world_ctx_idle_s = 0.0
        self.world_ctx_idle_target = None
        self.world_ctx_suppressed = None
        self.lamp_cfg_open = False
        self.lamp_cfg_target: tuple[int, int] | None = None
        self._rv_mode_btn_rects: dict[str, pygame.Rect] = {}
        self.lamp_cfg_rects: list[tuple[pygame.Rect, str]] = []
        self._last_cam_draw = (0, 0)
        self.world_tv_states: dict[tuple[int, int], bool] = {}

        self.hr_elevator_ui_open = False
        self.hr_elevator_sel = 0
        self.hr_elevator_cols = 4
        self.hr_max_floors = int(self._HR_INT_MAX_FLOORS_DEFAULT)
        self.hr_travel_active = False
        self.hr_travel_kind = ""
        self.hr_travel_from = 1
        self.hr_travel_to = 1
        self.hr_travel_display = 1
        self.hr_travel_dir = 1
        self.hr_travel_step_s = 0.35
        self.hr_travel_acc = 0.0
        self.hr_travel_done_left = -1.0
        self.hr_travel_spawn_at = "elevator"
        # World-map elevator UI (high-rise floors).
        self.world_elevator_ui_open = False
        self.world_elevator_sel = 0
        self.world_elevator_cols = 4
        self.world_elevator_input = ""
        self.world_elevator_options: list[int] = [1]
        self.world_elevator_chunk: HardcoreSurvivalState._Chunk | None = None
        self.world_elevator_mh: HardcoreSurvivalState._MultiHouse | None = None
        self.world_elevator_elev_tile: tuple[int, int] | None = None

        # School interior (multi-floor).
        self.sch_interior = False
        self.sch_int_pos = pygame.Vector2(0, 0)
        self.sch_int_vel = pygame.Vector2(0, 0)
        self.sch_int_facing = pygame.Vector2(0, 1)
        self.sch_int_walk_phase = 0.0
        self.sch_floor = 1
        self.sch_layout: list[str] = list(self._SCH_INT_LOBBY_LAYOUT)
        self.sch_building: HardcoreSurvivalState._SpecialBuilding | None = None
        self.sch_world_return = pygame.Vector2(self.player.pos)
        self.sch_elevator_ui_open = False
        self.sch_elevator_sel = 0
        self.sch_elevator_cols = 4
        self.sch_max_floors = int(self._SCH_INT_MAX_FLOORS_DEFAULT)
        self.sch_elevator_input = ""

        # House interior (23 floors).
        self.house_interior = False
        self.house_int_pos = pygame.Vector2(0, 0)
        self.house_int_vel = pygame.Vector2(0, 0)
        self.house_int_facing = pygame.Vector2(0, 1)
        self.house_int_walk_phase = 0.0
        self.house_floor = 1
        self.house_layout: list[str] = list(self._HOUSE_INT_F1_LAYOUT)
        self.house_building: HardcoreSurvivalState._SpecialBuilding | None = None
        self.house_world_return = pygame.Vector2(self.player.pos)
        self.house_max_floors = int(self._HOUSE_INT_MAX_FLOORS_DEFAULT)

        tx = int(math.floor(self.player.pos.x / self.TILE_SIZE))
        ty = int(math.floor(self.player.pos.y / self.TILE_SIZE))
        spawn_chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
        # Pick a reliable home entrance near spawn (guarantees the map marker exists).
        spawn_cx = int(spawn_tx) // self.CHUNK_SIZE
        spawn_cy = int(spawn_ty) // self.CHUNK_SIZE
        best_home: tuple[int, int, int, int] | None = None  # (d2, tx, ty, floors)
        # Search a few chunks around spawn so it also finds the nearby compound towers.
        search_r = 4
        for cy2 in range(int(spawn_cy) - int(search_r), int(spawn_cy) + int(search_r) + 1):
            for cx2 in range(int(spawn_cx) - int(search_r), int(spawn_cx) + int(search_r) + 1):
                chunk2 = self.world.get_chunk(int(cx2), int(cy2))
                for sb in getattr(chunk2, "special_buildings", []):
                    if getattr(sb, "kind", "") != "highrise":
                        continue
                    floors2 = int(getattr(sb, "floors", 0) or 0)
                    if floors2 <= 0:
                        floors2 = int(self._HR_INT_MAX_FLOORS_DEFAULT)
                    for dtile in tuple(getattr(sb, "door_tiles", ()) or ()):
                        hx, hy = int(dtile[0]), int(dtile[1])
                        d2 = (hx - int(spawn_tx)) ** 2 + (hy - int(spawn_ty)) ** 2
                        if best_home is None or d2 < int(best_home[0]):
                            best_home = (int(d2), int(hx), int(hy), int(floors2))

        floors = int(self._HR_INT_MAX_FLOORS_DEFAULT)
        if best_home is not None:
            _d2, hx, hy, floors = best_home
            self.home_highrise_door = (int(hx), int(hy))
        else:
            # Fallback: still show a marker instead of having "no home".
            self.home_highrise_door = (int(spawn_tx), int(spawn_ty))

        # Fixed "Chinese community" home for now: 6F room 602.
        self.home_highrise_floor = int(clamp(6, 2, int(floors)))
        # Unit numbering follows the door list order: 01..N
        self.home_highrise_unit = 2
        door_count = int(max(1, len(self._HR_INT_APT_DOORS)))
        self.home_highrise_unit = int(clamp(int(self.home_highrise_unit), 1, door_count))
        self.home_highrise_door_index = int(self.home_highrise_unit - 1)
        self.home_highrise_room = f"{int(self.home_highrise_floor)}{int(self.home_highrise_unit):02d}"
        try:
            if str(self.home_highrise_room).strip():
                self.hr_room_storages[str(self.home_highrise_room)] = (self.home_storage, self.fridge_storage)
        except Exception:
            pass
        self._set_hint(f"{self.home_highrise_room}", seconds=2.0)

        # Ensure the starter vehicles don't spawn "inside" a building.
        def vehicle_clear(p: pygame.Vector2, w: int, h: int) -> bool:
            r = pygame.Rect(int(round(p.x - w / 2)), int(round(p.y - h / 2)), int(w), int(h))
            return len(self._collide_rect_world_vehicle(r)) == 0

        def find_clear_vehicle_pos(desired: pygame.Vector2, *, w: int, h: int, max_r_tiles: int = 18) -> pygame.Vector2:
            base_tx = int(math.floor(float(desired.x) / float(self.TILE_SIZE)))
            base_ty = int(math.floor(float(desired.y) / float(self.TILE_SIZE)))
            if vehicle_clear(desired, int(w), int(h)):
                return pygame.Vector2(desired)
            for r in range(1, int(max_r_tiles) + 1):
                for dy2 in (-r, r):
                    for dx2 in range(-r, r + 1):
                        tx2 = int(base_tx + dx2)
                        ty2 = int(base_ty + dy2)
                        px = (float(tx2) + 0.5) * float(self.TILE_SIZE)
                        py = (float(ty2) + 0.5) * float(self.TILE_SIZE)
                        cand = pygame.Vector2(px, py)
                        if vehicle_clear(cand, int(w), int(h)):
                            return cand
                for dx2 in (-r, r):
                    for dy2 in range(-r + 1, r):
                        tx2 = int(base_tx + dx2)
                        ty2 = int(base_ty + dy2)
                        px = (float(tx2) + 0.5) * float(self.TILE_SIZE)
                        py = (float(ty2) + 0.5) * float(self.TILE_SIZE)
                        cand = pygame.Vector2(px, py)
                        if vehicle_clear(cand, int(w), int(h)):
                            return cand
            return pygame.Vector2(desired)

        self.rv.pos = find_clear_vehicle_pos(pygame.Vector2(self.rv.pos), w=int(self.rv.w), h=int(self.rv.h))
        self.bike.pos = find_clear_vehicle_pos(pygame.Vector2(self.bike.pos), w=int(self.bike.w), h=int(self.bike.h))

        # Spawn safety net: ensure the player never starts overlapped with the
        # RV/bike/building colliders (which can feel like "stuck in RV").
        try:
            self._ensure_player_spawn_clear()
        except Exception:
            pass

        spawn_chunk.items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(self.player.pos) + pygame.Vector2(18, 0), item_id="pistol", qty=1))
        spawn_chunk.items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(self.player.pos) + pygame.Vector2(18, 10), item_id="ammo_9mm", qty=24))
        # Default start: spring morning (season is derived from day index).
        self.world_time_s = float(self.DAY_LENGTH_S) * float(self.START_DAY_FRACTION)
        self._debug = False
        self._gallery_open = False
        self._gallery_page = 0  # 0=cars, 1=bike
        self._roof_cache: dict[tuple[int, int, int, int], pygame.Surface] = {}
        self._sprite_outline_cache: dict[tuple[int, int, int, int], pygame.Surface] = {}
        self._door_open_anim: dict[tuple[int, int], float] = {}
        self._hover_tooltip: tuple[list[str], tuple[int, int]] | None = None
        # Simple dialog / typewriter box (used for home guidance, etc).
        self.dialog_open = False
        self.dialog_title = ""
        self.dialog_text_full = ""
        self.dialog_reveal = 0.0  # float char cursor
        self.dialog_speed = 42.0  # chars/sec
        self.dialog_blink = 0.0
        # Conversation/dialog with choices (NPC/story). Separate from the simple
        # dialog so existing prompts keep working.
        self.conv_open = False
        self.conv_script = ""
        self.conv_node = ""
        self.conv_ctx: dict[str, object] = {}
        self.conv_speaker = ""
        self.conv_text_full = ""
        self.conv_options: list[dict[str, object]] = []
        self.conv_reveal = 0.0
        self.conv_speed = 60.0
        self.conv_blink = 0.0
        self.conv_choice = 0
        self.conv_option_rects: list[tuple[pygame.Rect, int]] = []
        # Non-blocking speech bubble (doesn't swallow input).
        self.speech_text = ""
        self.speech_left = 0.0
        # Timed "use toilet" action (world-map home).
        self.toilet_task: dict[str, object] | None = None
        # Timed "office work/clock-in" action (world-map office PC).
        self.work_task: dict[str, object] | None = None
        self.story_work_clocked_day = 0
        # Simple "held in hand" item (for carrying tools like cups).
        self.held_item: HardcoreSurvivalState._ItemStack | None = None
        # Flashlight (tool) state.
        self.flashlight_on = False
        self.muzzle_flash_left = 0.0
        self.noise_left = 0.0
        self.noise_radius = 0.0
        self.punch_left = 0.0
        self.punch_cooldown_left = 0.0
        self.punch_hit_done = False
        self.punch_dir = pygame.Vector2(1, 0)
        self.punch_hand = 0  # 0=left, 1=right (alternates each punch)
        self._melee_swing_id = "fist"
        self.hit_fx: list[HardcoreSurvivalState._HitFX] = []
        # Visual-only RNG: keep it separate so FX doesn't affect gameplay RNG.
        self.fx_rng = random.Random(self.seed ^ 0x51C0B1A7)

        # Weather (visual-first prototype).
        self.weather_kind = "clear"  # clear | cloudy | rain | storm | snow
        self.weather_intensity = 0.0  # 0..1
        self.weather_target_kind = "clear"
        self.weather_target_intensity = 0.0
        self.weather_day = 0
        self.weather_wind = 0.0  # px/s (screen-space drift)
        self.weather_wind_target = 0.0
        self.weather_flash_left = 0.0
        self.weather_rng = random.Random(self.seed ^ 0xA53C9F17)
        self._rain_drops: list[list[float]] = []  # [x, y, speed]
        self._snow_flakes: list[list[float]] = []  # [x, y, speed, drift]
        self._weather_layer = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        self._set_weather_targets_for_day(int(self.world_time_s / self.DAY_LENGTH_S) + 1)
        self.weather_kind = str(self.weather_target_kind)
        self.weather_intensity = float(self.weather_target_intensity)
        self.weather_wind = float(self.weather_wind_target)
        self.weather_day = int(self.world_time_s / self.DAY_LENGTH_S) + 1       
        self._sync_weather_particles()

        # Map UI.
        self.minimap_rect: pygame.Rect | None = None
        self.world_map_open = False
        self.world_map_scale = 3  # px per tile (big map)
        self.world_map_legend_open = True
        self.world_map_center = self._player_tile()
        self.world_map_markers: list[HardcoreSurvivalState._MapMarker] = []
        self.world_map_marker_next = 0
        self._world_map_cache_key: tuple[int, int, int, int, int, int] | None = None
        self._world_map_cache_scaled: pygame.Surface | None = None
        self._world_map_draw_rect: pygame.Rect | None = None
        self._world_map_start_tile: tuple[int, int] = (0, 0)
        self.world_map_dragging = False
        self.world_map_drag_start: tuple[int, int] = (0, 0)
        self.world_map_drag_center: tuple[int, int] = (0, 0)

        # Story mode (disaster prelude) bootstrap.
        self._story_init()
        # Crime / wanted (pre-apocalypse sandbox layer).
        self.crime_heat = 0.0
        self.wanted_level = 0
        self.crime_spawn_left = 0.0
        self.crime_last_reason = ""
        self.crime_heli_phase = 0.0

    def handle_event(self, event: pygame.event.Event) -> None:
        if bool(getattr(self, "pause_open", False)):
            if event.type == pygame.KEYDOWN and int(event.key) in (pygame.K_ESCAPE,):
                self._pause_close_menu()
                return
            if event.type == pygame.KEYDOWN and int(event.key) in (pygame.K_RETURN, pygame.K_SPACE):
                self._pause_activate("resume")
                return
            if event.type == pygame.MOUSEBUTTONDOWN and int(getattr(event, "button", 0)) == 1:
                self._handle_pause_menu_mouse(event)
                return
            return

        if bool(getattr(self, "lamp_cfg_open", False)):
            if event.type == pygame.KEYDOWN and int(event.key) in (pygame.K_ESCAPE,):
                self._lamp_cfg_close()
                return
            if event.type == pygame.MOUSEBUTTONDOWN and int(getattr(event, "button", 0)) == 1:
                self._handle_lamp_cfg_mouse(event)
                return

        if getattr(self, "world_map_open", False):
            if event.type == pygame.KEYDOWN:
                self._handle_world_map_key(int(event.key))
                return
            if event.type in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION, pygame.MOUSEWHEEL):
                self._handle_world_map_mouse(event)
                return

        # High-rise travel (elevator/stairs) blocks input while the timer runs.
        if bool(getattr(self, "hr_interior", False)) and bool(getattr(self, "hr_travel_active", False)):
            return

        if getattr(self, "conv_open", False):
            if event.type == pygame.KEYDOWN:
                self._conv_handle_key(int(getattr(event, "key", 0)))
                return
            if event.type in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONDOWN):
                self._conv_handle_mouse(event)
                return
            return

        if getattr(self, "dialog_open", False):
            if event.type == pygame.KEYDOWN:
                if int(event.key) in (pygame.K_ESCAPE,):
                    self._dialog_close()
                    return
                if int(event.key) in (pygame.K_SPACE, pygame.K_RETURN, pygame.K_e):
                    if not self._dialog_finished():
                        self._dialog_finish()
                    else:
                        self._dialog_close()
                    return
                # Swallow other UI keys while the dialog is up.
                return
            if event.type == pygame.MOUSEBUTTONDOWN and int(getattr(event, "button", 0)) == 1:
                if not self._dialog_finished():
                    self._dialog_finish()
                else:
                    self._dialog_close()
                return

        if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1 and not bool(getattr(self, "home_ui_open", False)):
            internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
            if internal is not None and isinstance(getattr(self, "minimap_rect", None), pygame.Rect):
                if self.minimap_rect.collidepoint(internal):
                    self._toggle_world_map(open=True)
                    return
            if self._handle_hr_interior_ui_mouse(event):
                return

        if getattr(self, "home_ui_open", False):
            if event.type == pygame.KEYDOWN:
                self._handle_home_ui_key(int(event.key))
                return
            if event.type in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION, pygame.MOUSEWHEEL):
                self._handle_home_ui_mouse(event)
                return

        if getattr(self, "world_elevator_ui_open", False):
            if event.type == pygame.KEYDOWN:
                self._handle_world_elevator_ui_key(int(event.key))
                return
            if event.type == pygame.MOUSEWHEEL:
                self._handle_world_elevator_ui_wheel(event)
                return
            if event.type in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION):
                self._handle_world_elevator_ui_mouse(event)
                return
            return

        if getattr(self, "sch_elevator_ui_open", False):
            if event.type == pygame.KEYDOWN:
                self._handle_sch_elevator_ui_key(int(event.key))        
                return
            if event.type == pygame.MOUSEWHEEL:
                self._handle_sch_elevator_ui_wheel(event)
                return
            if event.type in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION):
                self._handle_sch_elevator_ui_mouse(event)
                return
            return

        if getattr(self, "hr_elevator_ui_open", False):
            if event.type == pygame.KEYDOWN:
                self._handle_hr_elevator_ui_key(int(event.key))
                return
            if event.type == pygame.MOUSEWHEEL:
                self._handle_hr_elevator_ui_wheel(event)
                return
            if event.type in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION):
                self._handle_hr_elevator_ui_mouse(event)
                return
            return

        if getattr(self, "hr_interior", False) and bool(getattr(self, "hr_edit_mode", False)):
            if self._hr_edit_handle_mouse(event):
                return

        if self.inv_open:
            if event.type in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION):
                self._handle_inventory_mouse(event)
                return

        if event.type == pygame.MOUSEBUTTONDOWN:
            if self._handle_rv_mode_buttons_mouse(event):
                return
            if self._handle_world_furniture_carry_mouse(event):
                return
            if self._handle_world_context_menu_mouse(event):
                return

        if event.type == pygame.KEYDOWN:
            if getattr(self, "_gallery_open", False):
                if event.key in (pygame.K_ESCAPE, pygame.K_F2):
                    self._gallery_open = False
                    return
                if event.key in (pygame.K_TAB, pygame.K_RIGHT, pygame.K_d):
                    self._gallery_page = (int(self._gallery_page) + 1) % 2
                    return
                if event.key in (pygame.K_LEFT, pygame.K_a):
                    self._gallery_page = (int(self._gallery_page) - 1) % 2
                    return
                return
            if bool(getattr(self, "home_move_mode", False)):
                self._handle_home_move_mode_key(int(event.key))
                return
            if self._world_furniture_carry_active() and event.key in (pygame.K_ESCAPE, pygame.K_q):
                self._home_move_cancel()
                self._set_hint("", seconds=0.8)
                return
            if event.key in (pygame.K_m,):
                self._toggle_world_map()
                return
            if getattr(self, "house_interior", False):
                if event.key in (pygame.K_ESCAPE,):
                    self._house_interior_exit()
                    return
                if event.key in (pygame.K_e, pygame.K_RETURN, pygame.K_SPACE):
                    self._house_interior_interact()
                    return
                if event.key in (pygame.K_f, pygame.K_v, pygame.K_h, pygame.K_b):
                    return
            if getattr(self, "sch_interior", False):
                if event.key in (pygame.K_ESCAPE,):
                    self._sch_interior_exit()
                    return
                if event.key in (pygame.K_e, pygame.K_RETURN, pygame.K_SPACE):
                    self._sch_interior_interact()
                    return
                if event.key in (pygame.K_f, pygame.K_v, pygame.K_h, pygame.K_b):
                    return
            if getattr(self, "hr_interior", False):
                if event.key in (pygame.K_ESCAPE,):
                    if str(getattr(self, "hr_mode", "lobby")) == "home":
                        self._hr_leave_home()
                    else:
                        self._hr_interior_exit()
                    return
                if event.key in (pygame.K_r,) and str(getattr(self, "hr_mode", "lobby")) == "home":
                    self._hr_toggle_edit_mode()
                    return
                if getattr(self, "hr_edit_mode", False):
                    if event.key in (pygame.K_TAB,):
                        self._hr_edit_cycle(1)
                        return
                    if event.key in (pygame.K_LEFT, pygame.K_a):
                        self._hr_edit_move(-1, 0)
                        return
                    if event.key in (pygame.K_RIGHT, pygame.K_d):
                        self._hr_edit_move(1, 0)
                        return
                    if event.key in (pygame.K_UP, pygame.K_w):
                        self._hr_edit_move(0, -1)
                        return
                    if event.key in (pygame.K_DOWN, pygame.K_s):
                        self._hr_edit_move(0, 1)
                        return
                    if event.key in (pygame.K_e, pygame.K_RETURN, pygame.K_SPACE):
                        return
                if event.key in (pygame.K_e, pygame.K_RETURN, pygame.K_SPACE):
                    self._hr_interior_interact()
                    return
                if event.key in (pygame.K_f, pygame.K_v, pygame.K_h, pygame.K_b):
                    return
            if event.key in (pygame.K_ESCAPE,):
                if self.inv_open:
                    self.inv_open = False
                    self._inv_clear_ui_state()
                else:
                    self._pause_open_menu()
                return
            if event.key in (pygame.K_TAB,):
                self.inv_open = not self.inv_open
                # Reset transient inventory UI state (hover/drag/context) on both
                # open and close so stale popups can't leak across sessions.
                self._inv_clear_ui_state()
                return
            if not self.inv_open and event.key in (pygame.K_g,):
                self._toggle_home_move_mode()
                return
            if event.key in (pygame.K_F2,):
                self.inv_open = False
                self._gallery_page = 0
                self._gallery_open = not bool(getattr(self, "_gallery_open", False))
                return
            if event.key in (pygame.K_e,):
                self._interact_primary()
                return
            if not self.inv_open and event.key in (pygame.K_l,):
                self._toggle_door_lock()
                return
            if not self.inv_open and event.key in (pygame.K_b,):
                self._toggle_barricade()
                return
            if not self.inv_open and event.key in (pygame.K_h,):
                # H: driving RV -> toggle headlights; otherwise near RV -> enter/exit RV interior; elsewhere -> quick home teleport.
                if self.mount == "rv":
                    self.rv_headlights_on = not bool(getattr(self, "rv_headlights_on", True))
                    self._set_hint("" if bool(self.rv_headlights_on) else "", seconds=0.9)
                elif (bool(getattr(self, "rv_world_interior", False)) or self._can_access_rv()) and str(getattr(self.rv, "model_id", "rv")) == "rv":
                    self._rv_world_interior_toggle()
                else:
                    self._teleport_to_bathroom()
                return
            if not self.inv_open and event.key in (pygame.K_f,):
                if bool(getattr(self, "rv_world_interior", False)):
                    # In RV world-interior: start driving immediately (no need to find the seat).
                    self._rv_world_try_drive_from_anywhere()
                    return
                self._toggle_vehicle()
                return
            if not self.inv_open and event.key in (pygame.K_r,):
                self._start_reload()
                return
            if not self.inv_open and event.key in (pygame.K_t,):
                self._flashlight_toggle()
                return
            if event.key in (pygame.K_x,):
                self._stow_held_item()
                return
            if not self.inv_open and event.key in (pygame.K_j,):
                self._start_punch()
                return
            if not self.inv_open and event.key in (pygame.K_v,):
                self._cycle_rv_model()
                return
            if self.inv_open and event.key in (pygame.K_q,):
                self._drop_selected()
                return
            if self.inv_open and event.key in (pygame.K_LEFT, pygame.K_a):
                self.inv_index = (self.inv_index - 1) % len(self.inventory.slots)
                return
            if self.inv_open and event.key in (pygame.K_RIGHT, pygame.K_d):
                self.inv_index = (self.inv_index + 1) % len(self.inventory.slots)
                return
            if self.inv_open and event.key in (pygame.K_UP, pygame.K_w):
                self.inv_index = (self.inv_index - self.inventory.cols) % len(self.inventory.slots)
                return
            if self.inv_open and event.key in (pygame.K_DOWN, pygame.K_s):
                self.inv_index = (self.inv_index + self.inventory.cols) % len(self.inventory.slots)
                return
            if self.inv_open and event.key in (pygame.K_RETURN, pygame.K_SPACE):
                self._equip_selected()
                return
            if event.key in (pygame.K_F3,):
                self._debug = not self._debug
                return

    def _inv_clear_ui_state(self) -> None:
        self._inv_hover_idx = None
        self._inv_mouse_down = False
        self._inv_mouse_down_idx = -1
        self._inv_mouse_down_pos = None
        self._inv_dragging = False
        self._inv_drag_from_idx = -1
        self._inv_drag_pos = None
        self._inv_drag_over_idx = None
        self._inv_ctx_open = False
        self._inv_ctx_idx = -1
        self._inv_ctx_rect = None
        self._inv_ctx_buttons = []

    def _inv_layout(self) -> tuple[pygame.Rect, pygame.Rect, pygame.Rect, int, int, int, int, int, int]:
        cols = max(1, int(self.inventory.cols))
        rows = int(math.ceil(len(self.inventory.slots) / cols))
        slot = 30
        gap = 4
        grid_w = cols * slot + (cols - 1) * gap
        grid_h = rows * slot + (rows - 1) * gap
        panel_pad_x = 10
        header_h = 26
        footer_gap = 10
        footer_outer_h = 52

        panel_w = int(grid_w + panel_pad_x * 2)
        panel_h = int(header_h + grid_h + footer_gap + footer_outer_h)
        panel_x = int((INTERNAL_W - panel_w) // 2)
        panel_y = int((INTERNAL_H - panel_h) // 2)
        panel = pygame.Rect(int(panel_x), int(panel_y), int(panel_w), int(panel_h))

        x0 = int(panel_x + panel_pad_x)
        y0 = int(panel_y + header_h)
        grid = pygame.Rect(int(x0), int(y0), int(grid_w), int(grid_h))
        footer = pygame.Rect(int(panel.x + 8), int(grid.bottom + footer_gap), int(panel.w - 16), int(footer_outer_h - 6))
        return grid, panel, footer, int(x0), int(y0), int(cols), int(rows), int(slot), int(gap)

    def _inv_hit_test(self, mx: int, my: int) -> int | None:
        grid, _panel, _footer, x0, y0, cols, _rows, slot, gap = self._inv_layout()
        if not grid.collidepoint(int(mx), int(my)):
            return None
        cell = int(slot + gap)
        if cell <= 0:
            return None
        lx = int(mx - int(x0))
        ly = int(my - int(y0))
        cx = int(lx // cell)
        cy = int(ly // cell)
        if cx < 0 or cy < 0 or cx >= int(cols):
            return None
        # Ignore clicks on the gap area.
        if int(lx % cell) >= int(slot) or int(ly % cell) >= int(slot):
            return None
        idx = int(cy * int(cols) + cx)
        if not (0 <= idx < len(self.inventory.slots)):
            return None
        return int(idx)

    def _inv_primary_label(self, idef: "HardcoreSurvivalState._ItemDef") -> str | None:
        kind = str(getattr(idef, "kind", ""))
        if kind == "food":
            return ""
        if kind == "drink":
            return ""
        if kind == "med":
            return ""
        if kind == "fuel":
            return "" if str(getattr(idef, "id", "")) == "gas_can" else ""
        if kind == "clothes":
            return ""
        if kind == "gun":
            return ""
        if kind == "melee":
            return ""
        if kind == "gun_mod":
            return ""
        if kind == "tool":
            held = getattr(self, "held_item", None)
            if isinstance(held, HardcoreSurvivalState._ItemStack) and str(getattr(held, "item_id", "")) == str(getattr(idef, "id", "")):
                return ""
            return ""
        if str(getattr(idef, "id", "")) == "battery":
            held = getattr(self, "held_item", None)
            if isinstance(held, HardcoreSurvivalState._ItemStack) and str(getattr(held, "item_id", "")) == "flashlight":
                return ""
        return None

    def _inv_open_ctx(self, idx: int) -> None:
        idx = int(idx)
        if not (0 <= idx < len(self.inventory.slots)):
            self._inv_ctx_open = False
            self._inv_ctx_idx = -1
            return
        if self.inventory.slots[idx] is None:
            self._inv_ctx_open = False
            self._inv_ctx_idx = -1
            return
        self._inv_ctx_open = True
        self._inv_ctx_idx = int(idx)

    def _inv_perform_action(self, action: str, *, idx: int | None = None) -> None:
        action = str(action)
        if idx is not None:
            self.inv_index = int(idx)
        if action == "primary":
            self._equip_selected()
            return
        if action == "drop":
            self._drop_selected()
            return

    def _handle_inventory_mouse(self, event: pygame.event.Event) -> None:
        if not self.inv_open:
            return
        if not hasattr(event, "pos"):
            return
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return
        mx, my = int(internal[0]), int(internal[1])

        # Keep hover responsive even without a redraw (drag threshold logic).
        try:
            self._inv_hover_idx = self._inv_hit_test(int(mx), int(my))
        except Exception:
            self._inv_hover_idx = None

        if event.type == pygame.MOUSEMOTION:
            if bool(getattr(self, "_inv_dragging", False)):
                self._inv_drag_pos = (int(mx), int(my))
                self._inv_drag_over_idx = self._inv_hit_test(int(mx), int(my))
                return
            if bool(getattr(self, "_inv_mouse_down", False)) and self._inv_mouse_down_pos is not None:
                down_idx = int(getattr(self, "_inv_mouse_down_idx", -1))
                if 0 <= down_idx < len(self.inventory.slots) and self.inventory.slots[down_idx] is not None:
                    dx = int(mx) - int(self._inv_mouse_down_pos[0])
                    dy = int(my) - int(self._inv_mouse_down_pos[1])
                    if (dx * dx + dy * dy) >= (5 * 5):
                        # Start drag.
                        self._inv_dragging = True
                        self._inv_drag_from_idx = int(down_idx)
                        self._inv_drag_pos = (int(mx), int(my))
                        self._inv_drag_over_idx = self._inv_hit_test(int(mx), int(my))
                        self._inv_ctx_open = False
                        self._inv_ctx_idx = -1
                        self._inv_ctx_rect = None
                        self._inv_ctx_buttons = []
                return
            return

        if event.type == pygame.MOUSEBUTTONUP:
            btn = int(getattr(event, "button", 0))
            if btn != 1:
                return
            if not bool(getattr(self, "_inv_mouse_down", False)):
                return

            hit_idx = self._inv_hit_test(int(mx), int(my))
            down_idx = int(getattr(self, "_inv_mouse_down_idx", -1))

            if bool(getattr(self, "_inv_dragging", False)):
                from_idx = int(getattr(self, "_inv_drag_from_idx", -1))
                to_idx = int(hit_idx) if hit_idx is not None else int(from_idx)
                if 0 <= from_idx < len(self.inventory.slots) and 0 <= to_idx < len(self.inventory.slots):
                    if to_idx != from_idx:
                        self.inventory.slots[from_idx], self.inventory.slots[to_idx] = (
                            self.inventory.slots[to_idx],
                            self.inventory.slots[from_idx],
                        )
                    self.inv_index = int(to_idx)
                # End drag.
                self._inv_mouse_down = False
                self._inv_mouse_down_idx = -1
                self._inv_mouse_down_pos = None
                self._inv_dragging = False
                self._inv_drag_from_idx = -1
                self._inv_drag_pos = None
                self._inv_drag_over_idx = None
                return

            # Click release: open the action menu (double-click still triggers primary).
            if hit_idx is not None and int(hit_idx) == int(down_idx):
                self.inv_index = int(hit_idx)
                st = self.inventory.slots[int(hit_idx)]
                if st is not None:
                    now_ms = int(pygame.time.get_ticks())
                    last_ms = int(getattr(self, "_inv_last_click_ms", -999999))
                    last_idx = int(getattr(self, "_inv_last_click_idx", -1))
                    is_double = int(hit_idx) == int(last_idx) and (now_ms - last_ms) <= 320
                    self._inv_last_click_ms = int(now_ms)
                    self._inv_last_click_idx = int(hit_idx)
                    if is_double:
                        self._inv_perform_action("primary", idx=int(hit_idx))
                        self._inv_ctx_open = False
                        self._inv_ctx_idx = -1
                        self._inv_ctx_rect = None
                        self._inv_ctx_buttons = []
                    else:
                        if bool(getattr(self, "_inv_ctx_open", False)) and int(getattr(self, "_inv_ctx_idx", -1)) == int(hit_idx):
                            self._inv_ctx_open = False
                            self._inv_ctx_idx = -1
                            self._inv_ctx_rect = None
                            self._inv_ctx_buttons = []
                        else:
                            self._inv_open_ctx(int(hit_idx))
                else:
                    self._inv_ctx_open = False
                    self._inv_ctx_idx = -1
                    self._inv_ctx_rect = None
                    self._inv_ctx_buttons = []

            self._inv_mouse_down = False
            self._inv_mouse_down_idx = -1
            self._inv_mouse_down_pos = None
            return

        if event.type != pygame.MOUSEBUTTONDOWN:
            return

        btn = int(getattr(event, "button", 0))
        if btn not in (1, 3):
            return

        # If an inventory context menu is open, let its buttons consume the click.
        if bool(getattr(self, "_inv_ctx_open", False)):
            for r, action in list(getattr(self, "_inv_ctx_buttons", [])):
                if r.collidepoint(int(mx), int(my)):
                    self._inv_perform_action(str(action), idx=int(getattr(self, "_inv_ctx_idx", self.inv_index)))
                    self._inv_ctx_open = False
                    self._inv_ctx_idx = -1
                    self._inv_ctx_rect = None
                    self._inv_ctx_buttons = []
                    return
            menu_r = getattr(self, "_inv_ctx_rect", None)
            if isinstance(menu_r, pygame.Rect) and not menu_r.collidepoint(int(mx), int(my)):
                self._inv_ctx_open = False
                self._inv_ctx_idx = -1
                self._inv_ctx_rect = None
                self._inv_ctx_buttons = []

        idx = self._inv_hit_test(int(mx), int(my))
        if idx is None:
            if btn == 1:
                self._inv_mouse_down = False
                self._inv_mouse_down_idx = -1
                self._inv_mouse_down_pos = None
            return

        self.inv_index = int(idx)

        if btn == 3:
            # Right-click: open actions immediately (no drag).
            self._inv_open_ctx(int(idx))
            return

        # Left button down: start a click/drag gesture.
        self._inv_mouse_down = True
        self._inv_mouse_down_idx = int(idx)
        self._inv_mouse_down_pos = (int(mx), int(my))
        self._inv_dragging = False
        self._inv_drag_from_idx = -1
        self._inv_drag_pos = (int(mx), int(my))
        self._inv_drag_over_idx = int(idx)
        return

    def _apply_rv_model(self) -> None:
        mid = getattr(self.rv, "model_id", "schoolbus")
        model = self._CAR_MODELS.get(str(mid))
        if model is None:
            model = self._CAR_MODELS["schoolbus"]
            self.rv.model_id = model.id
        self.rv.w = int(model.collider[0])
        self.rv.h = int(model.collider[1])

    def _two_wheel_name(self, model_id: str) -> str:
        model_id = str(model_id)
        name_map = {
            "bike": "",
            "bike_lady": "",
            "bike_mountain": "",
            "bike_auto": "",
            "moto": "",
            "moto_lux": "",
            "moto_long": "",
        }
        return str(name_map.get(model_id, model_id))

    def _two_wheel_collider_px(self, model_id: str) -> tuple[int, int]:
        mid = str(model_id)
        collider_map: dict[str, tuple[int, int]] = {
            "bike": (14, 10),
            "bike_lady": (14, 10),
            "bike_mountain": (14, 10),
            "bike_auto": (14, 10),
            "moto": (16, 12),
            "moto_lux": (16, 12),
            "moto_long": (18, 12),
        }
        return collider_map.get(mid, (14, 10))

    def _apply_bike_model(self) -> None:
        if not hasattr(self, "bike") or self.bike is None:
            return
        mid = str(getattr(self.bike, "model_id", "bike"))
        if mid not in self._TWO_WHEEL_FRAMES:
            mid = "bike"
            self.bike.model_id = mid

        w, h = self._two_wheel_collider_px(mid)
        self.bike.w = int(w)
        self.bike.h = int(h)

    def _ensure_player_spawn_clear(self) -> None:
        # Try a depenetration pass first (cheap and preserves intended spawn).
        try:
            self.player.pos = self._move_box(
                pygame.Vector2(self.player.pos),
                pygame.Vector2(0, 0),
                0.0,
                w=int(getattr(self.player, "w", 8)),
                h=int(getattr(self.player, "collider_h", getattr(self.player, "h", 12))),
                collide_fn=self._collide_rect_world,
            )
        except Exception:
            pass

        try:
            rect0 = self.player.rect_at(self.player.pos)
            if not self._collide_rect_world(rect0):
                return
        except Exception:
            return

        # Hard fallback: nearest free tile around current spawn.
        ts = int(self.TILE_SIZE)
        if ts <= 0:
            return
        try:
            base_tx = int(math.floor(float(self.player.pos.x) / float(ts)))
            base_ty = int(math.floor(float(self.player.pos.y) / float(ts)))
        except Exception:
            return

        def tile_center(tx: int, ty: int) -> pygame.Vector2:
            return pygame.Vector2((float(tx) + 0.5) * float(ts), (float(ty) + 0.5) * float(ts))

        def is_free_at(tx: int, ty: int) -> bool:
            tx = int(tx)
            ty = int(ty)
            try:
                tid = int(self.world.peek_tile(int(tx), int(ty)))
            except Exception:
                return False
            if bool(self._tile_solid(int(tid))):
                return False
            p = tile_center(int(tx), int(ty))
            try:
                r = self.player.rect_at(p)
                return len(self._collide_rect_world(r)) == 0
            except Exception:
                return False

        best: tuple[int, int] | None = None
        max_r = 28
        for r in range(0, int(max_r) + 1):
            for dy in range(-int(r), int(r) + 1):
                for dx in range(-int(r), int(r) + 1):
                    if max(abs(int(dx)), abs(int(dy))) != int(r):
                        continue
                    tx = int(base_tx + int(dx))
                    ty = int(base_ty + int(dy))
                    if not is_free_at(int(tx), int(ty)):
                        continue
                    best = (int(tx), int(ty))
                    break
                if best is not None:
                    break
            if best is not None:
                break

        if best is None:
            return
        bx, by = best
        self.player.vel.update(0, 0)
        self.player.pos.update((float(bx) + 0.5) * float(ts), (float(by) + 0.5) * float(ts))

    def _place_spawn_vehicles_safely(self) -> None:
        # Ensure the spawned RV/bike don't start overlapped with buildings/walls,
        # which would make vehicles appear "unable to move".
        if not hasattr(self, "world") or self.world is None:
            return
        if not hasattr(self, "player") or self.player is None:
            return
        rv_obj = getattr(self, "rv", None)
        bike_obj = getattr(self, "bike", None)
        if rv_obj is None and bike_obj is None:
            return

        try:
            base_tx = int(math.floor(float(self.player.pos.x) / float(self.TILE_SIZE)))
            base_ty = int(math.floor(float(self.player.pos.y) / float(self.TILE_SIZE)))
        except Exception:
            return

        player_rect = self.player.rect_at(self.player.pos)
        ts = int(self.TILE_SIZE)
        if ts <= 0:
            return

        prefer_score = {
            int(self.T_ROAD): 0,
            int(self.T_HIGHWAY): 0,
            int(self.T_PARKING): 1,
            int(self.T_PAVEMENT): 1,
            int(self.T_CONCRETE): 1,
            int(self.T_SIDEWALK): 1,
            int(self.T_BRICK): 1,
        }

        def find_free_center_for_mount(mount: str, *, w: int, h: int, min_r: int, max_r: int) -> pygame.Vector2 | None:
            w = int(w)
            h = int(h)
            if w <= 0 or h <= 0:
                return None
            min_r = int(max(0, int(min_r)))
            max_r = int(max(int(min_r), int(max_r)))

            saved_mount = getattr(self, "mount", None)
            self.mount = str(mount)
            try:
                best: pygame.Vector2 | None = None
                best_key: tuple[int, int, int] | None = None
                for r in range(int(min_r), int(max_r) + 1):
                    for dy in range(-int(r), int(r) + 1):
                        for dx in range(-int(r), int(r) + 1):
                            if max(abs(int(dx)), abs(int(dy))) != int(r):
                                continue
                            tx = int(base_tx + int(dx))
                            ty = int(base_ty + int(dy))
                            try:
                                tid = int(self.world.get_tile(int(tx), int(ty)))
                            except Exception:
                                tid = int(self.T_GRASS)
                            score = int(prefer_score.get(int(tid), 3))

                            cx = (float(tx) + 0.5) * float(ts)
                            cy = (float(ty) + 0.5) * float(ts)
                            rect = pygame.Rect(
                                iround(float(cx) - float(w) / 2.0),
                                iround(float(cy) - float(h) / 2.0),
                                int(w),
                                int(h),
                            )
                            if rect.colliderect(player_rect.inflate(8, 8)):
                                continue
                            if self._collide_rect_world_vehicle(rect):
                                continue

                            key = (int(score), int(r), int(abs(int(dx)) + abs(int(dy))))
                            if best_key is None or key < best_key:
                                best_key = key
                                best = pygame.Vector2(float(cx), float(cy))

                    # Early exit if we found a very good candidate.
                    if best is not None and best_key is not None and int(best_key[0]) == 0 and int(r) <= int(min_r) + 2:
                        break
                return best
            finally:
                self.mount = saved_mount

        # Place RV first (bike is treated as solid during the search).
        if rv_obj is not None:
            try:
                rv_w0 = int(getattr(rv_obj, "w", 0))
                rv_h0 = int(getattr(rv_obj, "h", 0))
                rv_sizes: list[tuple[int, int]] = []
                if rv_w0 > 0 and rv_h0 > 0:
                    rv_sizes.append((int(rv_w0), int(rv_h0)))
                # Fallback: if the visual footprint is too large to fit common roads,
                # search using the driving collider (tighter).
                try:
                    mid = str(getattr(rv_obj, "model_id", "rv"))
                    model = self._CAR_MODELS.get(mid) or self._CAR_MODELS.get("rv")
                    dc = getattr(model, "drive_collider", None) if model is not None else None
                    if isinstance(dc, tuple) and len(dc) == 2:
                        dcw, dch = int(dc[0]), int(dc[1])
                        if dcw > 0 and dch > 0:
                            rv_sizes.append((int(dcw), int(dch)))
                except Exception:
                    pass
                # De-dup while preserving order.
                seen_sz: set[tuple[int, int]] = set()
                rv_sizes2: list[tuple[int, int]] = []
                for s in rv_sizes:
                    key = (int(s[0]), int(s[1]))
                    if key in seen_sz:
                        continue
                    seen_sz.add(key)
                    rv_sizes2.append(key)

                for w, h in rv_sizes2:
                    rv_pos = find_free_center_for_mount("rv", w=int(w), h=int(h), min_r=3, max_r=40)
                    if rv_pos is not None:
                        rv_obj.pos.update(rv_pos)
                        break
            except Exception:
                pass

        # Then place the bike (RV treated as solid).
        if bike_obj is not None:
            try:
                bike_w = int(getattr(bike_obj, "w", 0))
                bike_h = int(getattr(bike_obj, "h", 0))
                bike_pos = find_free_center_for_mount("bike", w=bike_w, h=bike_h, min_r=2, max_r=24)
                if bike_pos is not None:
                    bike_obj.pos.update(bike_pos)
            except Exception:
                pass

    def _rv_try_unstuck_nearby(self) -> bool:
        """Try to relocate the RV to a nearby free road-ish tile.

        This is a safety net for situations where the RV can become effectively immobile
        due to dense city facades/props or unlucky placement near solid geometry.
        """
        if not hasattr(self, "world") or self.world is None:
            return False
        if not hasattr(self, "rv") or self.rv is None:
            return False
        try:
            ts = int(self.TILE_SIZE)
            if ts <= 0:
                return False
            base_tx = int(math.floor(float(self.rv.pos.x) / float(ts)))
            base_ty = int(math.floor(float(self.rv.pos.y) / float(ts)))
        except Exception:
            return False

        # Use the driving collider if defined; it better represents the "drivable" envelope.
        try:
            mid = str(getattr(self.rv, "model_id", "rv"))
            model = self._CAR_MODELS.get(mid) or self._CAR_MODELS.get("rv")
        except Exception:
            model = None

        w = int(max(2, int(getattr(self.rv, "w", 0))))
        h = int(max(2, int(getattr(self.rv, "h", 0))))
        try:
            dc = getattr(model, "drive_collider", None) if model is not None else None
            if isinstance(dc, tuple) and len(dc) == 2:
                dw, dh = int(dc[0]), int(dc[1])
                if dw > 0 and dh > 0:
                    w = int(max(2, min(int(w), int(dw))))
                    h = int(max(2, min(int(h), int(dh))))
        except Exception:
            pass

        prefer_score = {
            int(self.T_ROAD): 0,
            int(self.T_HIGHWAY): 0,
            int(self.T_PARKING): 1,
            int(self.T_PAVEMENT): 2,
            int(self.T_CONCRETE): 2,
            int(self.T_SIDEWALK): 3,
            int(self.T_BRICK): 3,
            int(self.T_GRASS): 4,
        }

        def rect_at_center(cx: float, cy: float) -> pygame.Rect:
            return pygame.Rect(
                iround(float(cx) - float(w) / 2.0),
                iround(float(cy) - float(h) / 2.0),
                int(w),
                int(h),
            )

        def rect_at_center_wh(cx: float, cy: float, ww: int, hh: int) -> pygame.Rect:
            ww = int(max(2, int(ww)))
            hh = int(max(2, int(hh)))
            return pygame.Rect(
                iround(float(cx) - float(ww) / 2.0),
                iround(float(cy) - float(hh) / 2.0),
                int(ww),
                int(hh),
            )

        def ang_diff(a: float, b: float) -> float:
            d = float((float(a) - float(b) + math.pi) % (math.tau) - math.pi)
            return abs(float(d))

        def corridor_ok(cx: float, cy: float, heading: float, ww: int, hh: int) -> bool:
            try:
                base = rect_at_center_wh(float(cx), float(cy), int(ww), int(hh))
                if self._collide_rect_world_vehicle(base):
                    return False
                fwd = pygame.Vector2(math.cos(float(heading)), math.sin(float(heading)))
                if fwd.length_squared() <= 0.001:
                    fwd = pygame.Vector2(1, 0)
                else:
                    fwd = fwd.normalize()
                step = float(max(6.0, float(ts) * 0.85))
                for sgn in (1.0, -1.0):
                    nx = float(cx) + float(fwd.x) * float(step) * float(sgn)
                    ny = float(cy) + float(fwd.y) * float(step) * float(sgn)
                    r2 = rect_at_center_wh(float(nx), float(ny), int(ww), int(hh))
                    if not self._collide_rect_world_vehicle(r2):
                        return True
                return False
            except Exception:
                return False

        best: tuple[pygame.Vector2, float, int, int] | None = None  # (pos, heading, score, r)
        best_key: tuple[int, int, int, int] | None = None
        max_r = 16  # tiles
        cur_heading = float(getattr(self.rv, "heading", 0.0))
        headings = (0.0, math.pi / 2.0, math.pi, 3.0 * math.pi / 2.0)
        for r in range(0, int(max_r) + 1):
            for dy in range(-int(r), int(r) + 1):
                for dx in range(-int(r), int(r) + 1):
                    if max(abs(int(dx)), abs(int(dy))) != int(r):
                        continue
                    tx = int(base_tx + int(dx))
                    ty = int(base_ty + int(dy))
                    try:
                        tid = int(self.world.get_tile(int(tx), int(ty)))
                    except Exception:
                        tid = int(self.T_GRASS)
                    score = int(prefer_score.get(int(tid), 5))

                    cx = (float(tx) + 0.5) * float(ts)
                    cy = (float(ty) + 0.5) * float(ts)
                    # Pick a cardinal heading that has some forward/back clearance so the RV
                    # can actually start moving immediately after relocation.
                    picked_heading: float | None = None
                    picked_diff: float | None = None
                    for hd in headings:
                        # Driving uses a stable AABB; swap dims when driving mostly vertical.
                        if hd in (math.pi / 2.0, 3.0 * math.pi / 2.0):
                            ww, hh = int(h), int(w)
                        else:
                            ww, hh = int(w), int(h)
                        if not corridor_ok(float(cx), float(cy), float(hd), int(ww), int(hh)):
                            continue
                        diff = float(ang_diff(float(cur_heading), float(hd)))
                        if picked_diff is None or diff < float(picked_diff):
                            picked_diff = float(diff)
                            picked_heading = float(hd)

                    if picked_heading is None:
                        continue

                    key = (int(score), int(r), int(abs(int(dx)) + abs(int(dy))), int(round(float(picked_diff or 0.0) * 1000.0)))
                    if best_key is None or key < best_key:
                        best_key = key
                        best = (pygame.Vector2(float(cx), float(cy)), float(picked_heading), int(score), int(r))

            # Early exit if we found a great road/highway candidate quickly.
            if best is not None and best_key is not None and int(best_key[0]) == 0 and int(r) <= 5:
                break

        if best is None:
            return False

        try:
            pos, hd, _score, _r = best
            self.rv.pos.update(pos)
            self.rv.heading = float(hd)
            # Keep the axis hint consistent with the snapped heading.
            self._rv_drive_axis = 1 if float(hd) in (math.pi / 2.0, 3.0 * math.pi / 2.0) else 0
            self.rv.vel.update(0, 0)
            self.rv.speed = 0.0
            self.rv.steer = 0.0
        except Exception:
            return False
        return True

    def _bike_base_speed(self) -> float:
        mid = str(getattr(getattr(self, "bike", None), "model_id", "bike"))
        speed_map: dict[str, float] = {
            "bike": 92.0,
            "bike_lady": 90.0,
            "bike_mountain": 96.0,
            "bike_auto": 108.0,
            "moto": 148.0,
            "moto_lux": 158.0,
            "moto_long": 152.0,
        }
        return float(speed_map.get(mid, 92.0))

    def _bike_uses_stamina(self) -> bool:
        mid = str(getattr(getattr(self, "bike", None), "model_id", "bike"))
        if mid.startswith("moto"):
            return False
        if mid == "bike_auto":
            return False
        return True

    def _sprite_baseline_y(self, spr: pygame.Surface) -> int:
        cache = getattr(self, "_sprite_baseline_cache", None)
        if cache is None:
            cache = {}
            self._sprite_baseline_cache = cache
        key = int(id(spr))
        by = cache.get(key)
        if by is not None:
            return int(by)

        w, h = spr.get_size()
        baseline = int(h - 1)
        for y in range(int(h) - 1, -1, -1):
            for x in range(int(w)):
                if int(spr.get_at((int(x), int(y))).a) > 0:
                    baseline = int(y)
                    cache[key] = int(baseline)
                    return int(baseline)
        cache[key] = int(baseline)
        return int(baseline)

    def _two_wheel_shadow_rect(
        self,
        spr_rect: pygame.Rect,
        d: str,
        *,
        ground_y: int | None = None,
    ) -> pygame.Rect:
        d = str(d)
        if d in ("left", "right"):
            shadow_w = max(12, int(spr_rect.w) - 3)
        else:
            shadow_w = max(10, int(spr_rect.w) - 6)
        shadow_h = 4
        shadow = pygame.Rect(0, 0, int(shadow_w), int(shadow_h))
        cy = int(spr_rect.bottom - 2) if ground_y is None else int(ground_y - 2)
        shadow.center = (int(spr_rect.centerx), int(cy))
        return shadow

    def _cycle_rv_model(self) -> None:
        if not hasattr(self, "rv") or self.rv is None:
            return
        rv_d2 = float((self.player.pos - self.rv.pos).length_squared())
        can_change = self.mount == "rv" or rv_d2 <= (36.0 * 36.0)
        if not can_change:
            return

        ids = list(self._CAR_MODELS.keys())
        if not ids:
            return
        cur = str(getattr(self.rv, "model_id", ids[0]))
        try:
            idx = ids.index(cur)
        except ValueError:
            idx = 0
        self.rv.model_id = ids[(idx + 1) % len(ids)]
        self._apply_rv_model()
        model = self._CAR_MODELS.get(str(self.rv.model_id))
        name = model.name if model is not None else str(self.rv.model_id)
        self._set_hint(f"{name}", seconds=1.5)

    def _set_home_ui_status(self, text: str, *, seconds: float = 1.6) -> None:
        self.home_ui_status = str(text)
        self.home_ui_status_left = float(max(0.0, seconds))

    def _clear_player_pose(self) -> None:
        prev_pose = str(getattr(self, "player_pose", "") or "")
        prev_space = str(getattr(self, "player_pose_space", "") or "")
        self.player_pose = None
        self.player_pose_space = ""
        self.player_pose_left = 0.0
        self.player_pose_anchor = None
        self.player_pose_phase = 0.0
        if prev_space == "world" and prev_pose in ("sleep", "sit"):
            self.world_ctx_cooldown_left = max(float(getattr(self, "world_ctx_cooldown_left", 0.0)), 1.0)

    def _set_player_pose(
        self,
        pose: str,
        *,
        space: str,
        anchor: tuple[float, float],
        seconds: float = 0.0,
    ) -> None:
        self.player_pose = str(pose)
        self.player_pose_space = str(space)
        self.player_pose_anchor = (float(anchor[0]), float(anchor[1]))
        self.player_pose_left = float(max(0.0, seconds))
        self.player_pose_phase = 0.0

    def _get_pose_sprite(self, pose: str, *, direction: str = "down", frame: int = 0) -> pygame.Surface:
        av = getattr(self, "avatar", None) or SurvivalAvatar()
        av.clamp_all()
        direction = str(direction)
        if direction not in ("down", "up", "right", "left"):
            direction = "down"
        key = (
            str(pose),
            str(direction),
            int(frame) % 2,
            int(av.gender),
            int(av.height),
            int(av.face),
            int(av.eyes),
            int(av.hair),
            int(av.nose),
            int(av.outfit),
        )
        cache = getattr(self, "_pose_sprite_cache", None)
        if not isinstance(cache, dict):
            cache = {}
            self._pose_sprite_cache = cache
        spr = cache.get(key)
        if isinstance(spr, pygame.Surface):
            return spr
        if str(pose) == "sleep":
            spr = HardcoreSurvivalState._make_avatar_pose_sleep_sprite(int(frame), avatar=av)
        else:
            spr = HardcoreSurvivalState._make_avatar_pose_sit_sprite(str(direction), avatar=av)
        cache[key] = spr
        return spr

    def _rv_collider_rect_at(self, pos: pygame.Vector2 | None = None) -> pygame.Rect:
        # RV sprite rotates, but collisions used to stay as a fixed axis-aligned box.
        # That made it feel like you can't walk close to the RV (especially when the
        # RV faces up/down). Use the rotated AABB instead.
        try:
            if pos is None:
                pos = pygame.Vector2(getattr(self.rv, "pos", pygame.Vector2(0, 0)))
            else:
                pos = pygame.Vector2(pos)
            w0 = float(getattr(self.rv, "w", 0.0))
            h0 = float(getattr(self.rv, "h", 0.0))
            heading = float(getattr(self.rv, "heading", 0.0))
            if w0 <= 0.0 or h0 <= 0.0:
                return pygame.Rect(int(round(float(pos.x))), int(round(float(pos.y))), 1, 1)
            c = abs(math.cos(float(heading)))
            s = abs(math.sin(float(heading)))
            ww = w0 * c + h0 * s
            hh = w0 * s + h0 * c
            w = int(max(1, int(round(float(ww)))))
            h = int(max(1, int(round(float(hh)))))
            return pygame.Rect(
                iround(float(pos.x) - float(w) / 2.0),
                iround(float(pos.y) - float(h) / 2.0),
                int(w),
                int(h),
            )
        except Exception:
            try:
                if pos is None:
                    pos = pygame.Vector2(getattr(self.rv, "pos", pygame.Vector2(0, 0)))
                w = int(max(1, int(getattr(self.rv, "w", 1))))
                h = int(max(1, int(getattr(self.rv, "h", 1))))
                return pygame.Rect(
                    iround(float(pos.x) - float(w) / 2.0),
                    iround(float(pos.y) - float(h) / 2.0),
                    int(w),
                    int(h),
                )
            except Exception:
                return pygame.Rect(0, 0, 1, 1)

    def _can_access_rv(self) -> bool:
        if self.mount == "rv":
            return True
        try:
            pad = 24
            r = self._rv_collider_rect_at().inflate(int(pad * 2), int(pad * 2))
            return bool(r.collidepoint(int(round(float(self.player.pos.x))), int(round(float(self.player.pos.y)))))
        except Exception:
            return (self.player.pos - self.rv.pos).length_squared() <= (36.0 * 36.0)

    def _ensure_rv_world_interior_built(self) -> bool:
        # Build a temporary RV room on the world map (same camera/tile mode).
        # The stamped tiles are restored on exit so the outside world is unchanged.
        if isinstance(getattr(self, "_rv_world_int_restore_tiles", None), dict) and isinstance(getattr(self, "_rv_world_int_active_key", None), tuple):
            return True

        size = getattr(self, "_rv_world_int_size", (16, 10))
        try:
            w, h = int(size[0]), int(size[1])
        except Exception:
            w, h = 16, 10
        w = int(max(6, min(28, int(w))))
        # Allow smaller RVs to still have a walkable interior.
        h = int(max(3, min(20, int(h))))

        # Stamp the room inside the RV's own footprint (not a separate far-away area).
        rv_rect = self.rv.rect()
        rv_tx0 = int(math.floor(float(rv_rect.left) / float(self.TILE_SIZE)))
        rv_ty0 = int(math.floor(float(rv_rect.top) / float(self.TILE_SIZE)))
        rv_tx1 = int(math.floor(float(rv_rect.right - 1) / float(self.TILE_SIZE)))
        rv_ty1 = int(math.floor(float(rv_rect.bottom - 1) / float(self.TILE_SIZE)))
        rv_w_tiles = int(rv_tx1 - rv_tx0 + 1)
        rv_h_tiles = int(rv_ty1 - rv_ty0 + 1)
        if int(rv_w_tiles) < int(w) or int(rv_h_tiles) < int(h):
            self._set_hint("", seconds=1.2)
            return False

        tx0 = int(rv_tx0 + max(0, (int(rv_w_tiles) - int(w)) // 2))
        ty0 = int(rv_ty0 + max(0, (int(rv_h_tiles) - int(h)) // 2))

        # Safety: if the RV is parked overlapping buildings/water, don't stamp.
        for yy in range(int(h)):
            for xx in range(int(w)):
                wx = int(tx0 + xx)
                wy = int(ty0 + yy)
                if self._peek_building_at_tile(int(wx), int(wy)) is not None:
                    self._set_hint("", seconds=1.2)
                    return False
                t = int(self.world.peek_tile(int(wx), int(wy), default=int(self.T_GRASS)))
                if int(t) == int(self.T_WATER):
                    self._set_hint("", seconds=1.2)
                    return False

        key = (int(tx0), int(ty0), int(w), int(h))

        restore: dict[tuple[int, int], int] = {}
        for yy in range(int(h)):
            for xx in range(int(w)):
                wx = int(tx0 + xx)
                wy = int(ty0 + yy)
                restore[(int(wx), int(wy))] = int(self.world.get_tile(int(wx), int(wy)))

        self._rv_world_int_restore_tiles = restore
        self._rv_world_int_active_key = key

        # Reset RV interior helpers (rebuilt each time).
        self._rv_world_floor_base = None
        self._rv_world_fixed_furniture = set()
        self._rv_world_dash_tile = None

        # Stamp: floor everywhere. The RV room is "enclosed" via thin collision bounds
        # (so the 1-tile wall border doesn't eat 2/3 of the usable space on small RVs).
        for yy in range(int(h)):
            for xx in range(int(w)):
                wx = int(tx0 + xx)
                wy = int(ty0 + yy)
                self._world_set_tile(int(wx), int(wy), int(self.T_FLOOR))

        # Exit marker tile (press E/H to leave).
        # Place the door on the living (rear) side so it doesn't collide with the cabin partition.
        exit_tx = int(tx0 + 1)
        exit_ty = int(ty0 + h - 2)
        self._rv_world_int_exit_tile = (int(exit_tx), int(exit_ty))
        self._world_set_tile(int(exit_tx), int(exit_ty), int(self.T_DOOR))

        fx0 = int(tx0 + 1)
        fx1 = int(tx0 + int(w) - 2)
        fy0 = int(ty0 + 1)
        fy1 = int(ty0 + int(h) - 2)

        # Driver cabin: vertical partition + distinct floor tone (cockpit).
        part_x: int | None = None
        cabin_x0: int | None = None
        try:
            inner_w = int(max(1, int(w) - 2))
            cabin_inner_w = int(clamp(int(inner_w // 3), 3, 5))
            cabin_x0 = int(fx1 - cabin_inner_w + 1)
            cand_part = int(cabin_x0 - 1)
            if int(fx0 + 2) <= int(cand_part) <= int(fx1 - 2):
                part_x = int(cand_part)
                # Door opening near the middle of the usable interior band.
                door_y = int((int(fy0) + int(fy1)) // 2)
                door_y = int(clamp(int(door_y), int(fy0), int(fy1)))
                for yy in range(int(fy0), int(fy1) + 1):
                    if int(yy) == int(door_y):
                        continue
                    self._world_set_tile(int(part_x), int(yy), int(self.T_WALL))
                # Mark the opening as a (passable) door/curtain so the separation reads visually.
                try:
                    if int(self.world.peek_tile(int(part_x), int(door_y), default=int(self.T_FLOOR))) == int(self.T_FLOOR):
                        self._world_set_tile(int(part_x), int(door_y), int(self.T_DOOR_BROKEN))
                except Exception:
                    pass
        except Exception:
            part_x = None
            cabin_x0 = None

        # Cabin floor tone: make the cockpit read as a different material.
        try:
            if cabin_x0 is not None:
                for yy in range(int(fy0), int(fy1) + 1):
                    # Include one extra column at the very front edge so the steering
                    # wheel can sit "more forward" without looking outside the cockpit.
                    for xx in range(int(cabin_x0), int(fx1) + 2):
                        if int(self.world.peek_tile(int(xx), int(yy), default=int(self.T_FLOOR))) == int(self.T_FLOOR):
                            self._world_set_tile(int(xx), int(yy), int(self.T_CONCRETE))
        except Exception:
            pass

        living_x1 = int(fx1 if part_x is None else int(part_x - 1))

        # Base floor map (for RV furniture moving): record the intended walkable tile under furniture.
        try:
            base: dict[tuple[int, int], int] = {}
            for yy in range(int(h)):
                for xx in range(int(w)):
                    wx = int(tx0 + xx)
                    wy = int(ty0 + yy)
                    tid = int(self.world.peek_tile(int(wx), int(wy), default=int(self.T_FLOOR)))
                    if tid in (int(self.T_FLOOR), int(self.T_BOARDWALK), int(self.T_CONCRETE)):
                        base[(int(wx), int(wy))] = int(tid)
            self._rv_world_floor_base = base
        except Exception:
            self._rv_world_floor_base = None

        # Bed (2 tiles, living area).
        bed_y = int(clamp(int(fy0 + 1), int(fy0), int(fy1)))
        bed_x0 = int(clamp(int(fx0 + 1), int(fx0), int(living_x1 - 1)))
        if int(bed_x0 + 1) <= int(living_x1) and int(fy0) <= int(bed_y) <= int(fy1):
            for bx in (int(bed_x0), int(bed_x0 + 1)):
                if int(self.world.peek_tile(int(bx), int(bed_y))) in (
                    int(self.T_FLOOR),
                    int(self.T_BOARDWALK),
                    int(self.T_CONCRETE),
                ):
                    self._world_set_tile(int(bx), int(bed_y), int(self.T_BED))

        # Cabinet (living area, away from the exit tile).
        cab_x = int(clamp(int(fx0 + 1), int(fx0), int(living_x1)))
        cab_y = int(clamp(int(fy1 - 1), int(fy0), int(fy1)))
        if (int(cab_x), int(cab_y)) != (int(exit_tx), int(exit_ty)):
            if int(self.world.peek_tile(int(cab_x), int(cab_y))) in (
                int(self.T_FLOOR),
                int(self.T_BOARDWALK),
                int(self.T_CONCRETE),
            ):
                self._world_set_tile(int(cab_x), int(cab_y), int(self.T_CABINET))

        # Cabin: seats + steering wheel at the very front (right side).
        # These tiles are fixed (not movable).
        self._rv_world_driver_seat_tile = None
        try:
            fixed: set[tuple[int, int]] = getattr(self, "_rv_world_fixed_furniture", set())
            driver_y = int(fy0)
            pass_y = int(fy1)

            cab_start = int(fx0)
            try:
                if cabin_x0 is not None:
                    cab_start = int(cabin_x0)
                elif part_x is not None:
                    cab_start = int(part_x + 1)
            except Exception:
                cab_start = int(fx0)
            cab_end = int(fx1)

            # Push the steering wheel 1 tile further forward (to the right/front edge).
            # Keep the seats just behind it so they still "face the windshield".
            wheel_x = int(cab_end + 1)
            seat_x = int(max(int(cab_start), int(wheel_x) - 1))

            if int(self.world.peek_tile(int(seat_x), int(driver_y))) in (
                int(self.T_FLOOR),
                int(self.T_BOARDWALK),
                int(self.T_CONCRETE),
            ):
                self._world_set_tile(int(seat_x), int(driver_y), int(self.T_CHAIR))
                self._rv_world_driver_seat_tile = (int(seat_x), int(driver_y))
                fixed.add((int(seat_x), int(driver_y)))
            if int(self.world.peek_tile(int(seat_x), int(pass_y))) in (
                int(self.T_FLOOR),
                int(self.T_BOARDWALK),
                int(self.T_CONCRETE),
            ):
                if (int(seat_x), int(pass_y)) != (int(exit_tx), int(exit_ty)) and (int(seat_x), int(pass_y)) != (int(seat_x), int(driver_y)):
                    self._world_set_tile(int(seat_x), int(pass_y), int(self.T_CHAIR))
                    fixed.add((int(seat_x), int(pass_y)))

            # Steering wheel at the very front (by the "windshield").
            if (int(wheel_x), int(driver_y)) not in ((int(exit_tx), int(exit_ty)), (int(seat_x), int(driver_y)), (int(seat_x), int(pass_y))):
                if int(self.world.peek_tile(int(wheel_x), int(driver_y))) in (
                    int(self.T_FLOOR),
                    int(self.T_BOARDWALK),
                    int(self.T_CONCRETE),
                ):
                    self._world_set_tile(int(wheel_x), int(driver_y), int(self.T_STEER))
                    fixed.add((int(wheel_x), int(driver_y)))

            # Dash/console: keep it at the very front (passenger side) so the
            # cockpit reads as "seats facing the front window".
            self._rv_world_dash_tile = None
            dash_tx, dash_ty = int(wheel_x), int(pass_y)
            if (int(dash_tx), int(dash_ty)) not in (
                (int(exit_tx), int(exit_ty)),
                (int(seat_x), int(driver_y)),
                (int(seat_x), int(pass_y)),
                (int(wheel_x), int(driver_y)),
            ):
                if int(self.world.peek_tile(int(dash_tx), int(dash_ty))) in (
                    int(self.T_FLOOR),
                    int(self.T_BOARDWALK),
                    int(self.T_CONCRETE),
                ):
                    self._world_set_tile(int(dash_tx), int(dash_ty), int(self.T_TABLE))
                    fixed.add((int(dash_tx), int(dash_ty)))
                    self._rv_world_dash_tile = (int(dash_tx), int(dash_ty))
            self._rv_world_fixed_furniture = set(fixed)
        except Exception:
            self._rv_world_driver_seat_tile = None
            self._rv_world_dash_tile = None
            self._rv_world_fixed_furniture = set()

        return True

    def _rv_world_try_drive_from_seat(self) -> bool:
        if not bool(getattr(self, "rv_world_interior", False)):
            return False
        seat = getattr(self, "_rv_world_driver_seat_tile", None)
        if not (isinstance(seat, tuple) and len(seat) == 2):
            # Fallback: if the seat marker is missing for any reason, still allow driving.
            return bool(self._rv_world_try_drive_from_anywhere())
        tx, ty = self._player_tile()
        sx, sy = int(seat[0]), int(seat[1])
        if abs(int(tx) - int(sx)) > 1 or abs(int(ty) - int(sy)) > 1:
            self._set_hint("F", seconds=1.2)
            return True
        if int(self.inventory.count("key_rv")) <= 0:
            self._set_hint("", seconds=1.1)
            return True

        # Teardown interior tiles but keep the player on the RV so driving starts immediately.
        self._clear_player_pose()
        self.rv_world_interior = False
        self.player.vel.update(0, 0)

        restore = getattr(self, "_rv_world_int_restore_tiles", None)
        if isinstance(restore, dict):
            for (rtx, rty), tid in list(restore.items()):
                try:
                    self._world_set_tile(int(rtx), int(rty), int(tid))
                except Exception:
                    pass
        self._rv_world_int_restore_tiles = None
        self._rv_world_int_active_key = None
        self._rv_world_int_exit_tile = None
        self._rv_world_return_pos = None

        self.mount = "rv"
        self.rv.vel.update(0, 0)
        self.rv.speed = 0.0
        self.player.pos.update(self.rv.pos)
        self.player.vel.update(0, 0)
        self._set_hint("", seconds=0.9)
        return True

    def _rv_world_try_drive_from_anywhere(self) -> bool:
        if not bool(getattr(self, "rv_world_interior", False)):
            return False
        if int(self.inventory.count("key_rv")) <= 0:
            self._set_hint("", seconds=1.1)
            return True

        # Teardown interior tiles but keep the player on the RV so driving starts immediately.
        self._clear_player_pose()
        self.rv_world_interior = False
        self.player.vel.update(0, 0)

        restore = getattr(self, "_rv_world_int_restore_tiles", None)
        if isinstance(restore, dict):
            for (rtx, rty), tid in list(restore.items()):
                try:
                    self._world_set_tile(int(rtx), int(rty), int(tid))
                except Exception:
                    pass
        self._rv_world_int_restore_tiles = None
        self._rv_world_int_active_key = None
        self._rv_world_int_exit_tile = None
        self._rv_world_return_pos = None

        self.mount = "rv"
        self.rv.vel.update(0, 0)
        self.rv.speed = 0.0
        self.player.pos.update(self.rv.pos)
        self.player.vel.update(0, 0)
        self._set_hint("", seconds=0.9)
        return True

    def _rv_world_interior_toggle(self) -> None:
        if bool(getattr(self, "rv_world_interior", False)):
            self._rv_world_interior_exit()
            return
        if str(getattr(self.rv, "model_id", "rv")) != "rv":
            self._set_hint("", seconds=1.1)
            return
        if not self._can_access_rv():
            self._set_hint("H", seconds=1.2)
            return
        if self.mount == "rv" and abs(float(getattr(self.rv, "speed", 0.0))) > 1.0:
            self._set_hint("", seconds=1.2)
            return
        self._rv_world_interior_enter()

    def _rv_world_interior_enter(self) -> None:
        if str(getattr(self.rv, "model_id", "rv")) != "rv":
            self._set_hint("", seconds=1.1)
            return
        self.inv_open = False
        self.world_map_open = False
        self._gallery_open = False
        self.rv_ui_open = False
        self._clear_player_pose()
        self.player.vel.update(0, 0)
        self.player.walk_phase *= 0.85

        # Remember where to return when leaving the RV interior.
        # If we entered from driving mode, the player is at the RV center (inside its collider),
        # so pick a safe "outside the RV" return position.
        was_driving = getattr(self, "mount", None) == "rv"
        ret_pos = pygame.Vector2(self.player.pos)
        if was_driving:
            try:
                vehicle_pos = pygame.Vector2(self.rv.pos)
                vw, vh = float(getattr(self.rv, "w", 0)), float(getattr(self.rv, "h", 0))
                ph = float(max(int(self.player.w), int(getattr(self.player, "collider_h", self.player.h)))) / 2.0
                heading = float(getattr(self.rv, "heading", 0.0))
                fwd = pygame.Vector2(math.cos(float(heading)), math.sin(float(heading)))
                if fwd.length_squared() < 0.001:
                    fwd = pygame.Vector2(1, 0)
                fwd = fwd.normalize()
                right = pygame.Vector2(-float(fwd.y), float(fwd.x))
                side_margin = float(vh) / 2.0 + float(ph) + 8.0
                fwd_margin = float(vw) / 2.0 + float(ph) + 8.0
                candidates = [
                    right * float(side_margin),
                    -right * float(side_margin),
                    fwd * float(fwd_margin),
                    -fwd * float(fwd_margin),
                    pygame.Vector2(float(vw) / 2.0 + float(ph) + 10.0, 0),
                    pygame.Vector2(-(float(vw) / 2.0 + float(ph) + 10.0), 0),
                    pygame.Vector2(0, float(vh) / 2.0 + float(ph) + 10.0),
                    pygame.Vector2(0, -(float(vh) / 2.0 + float(ph) + 10.0)),
                ]
                # Make the RV solid for collision checks.
                self.mount = None
                ignore_rect: pygame.Rect | None = None
                try:
                    ignore_rect = self._rv_collider_rect_at(vehicle_pos)
                except Exception:
                    ignore_rect = None

                def path_clear(dst: pygame.Vector2) -> bool:
                    try:
                        a = pygame.Vector2(vehicle_pos)
                        b = pygame.Vector2(dst)
                        d = b - a
                        dist = float(d.length())
                        if dist <= 0.5:
                            return True
                        step_len = max(1.0, float(self.TILE_SIZE) / 4.0)
                        steps = int(clamp(int(math.ceil(dist / step_len)), 1, 80))
                        for i in range(1, int(steps) + 1):
                            t = float(i) / float(steps)
                            p2 = a + d * t
                            hits = self._collide_rect_world(self.player.rect_at(p2))
                            if not hits:
                                continue
                            for hh in hits:
                                if ignore_rect is not None and hh == ignore_rect:
                                    continue
                                return False
                        return True
                    except Exception:
                        return False

                for off in candidates:
                    p = vehicle_pos + off
                    if not self._collide_rect_world(self.player.rect_at(p)) and path_clear(p):
                        ret_pos = pygame.Vector2(p)
                        break
            except Exception:
                pass

        if was_driving:
            # If we couldn't find a safe "outside" spot, don't enter the interior.
            # Otherwise the player can end up clipped into walls/buildings when exiting.
            try:
                vehicle_pos = pygame.Vector2(self.rv.pos)
                if (pygame.Vector2(ret_pos) - vehicle_pos).length_squared() <= 0.75:
                    self.mount = "rv"
                    self.player.pos.update(self.rv.pos)
                    self._set_hint("No space to leave RV here", seconds=1.2)
                    return
            except Exception:
                pass

        self._rv_world_return_pos = pygame.Vector2(ret_pos)
        self.mount = None
        self.rv.vel.update(0, 0)
        self.bike.vel.update(0, 0)

        if not self._ensure_rv_world_interior_built():
            # Keep the detailed reason set by _ensure_rv_world_interior_built().
            if not str(getattr(self, "hint_text", "")).strip():
                self._set_hint("", seconds=1.2)
            return

        ex = getattr(self, "_rv_world_int_exit_tile", None)
        spawn: tuple[int, int] | None = None
        if isinstance(ex, tuple) and len(ex) == 2:
            exx, exy = int(ex[0]), int(ex[1])
            for tx, ty in (
                (exx, exy - 1),
                (exx - 1, exy - 1),
                (exx + 1, exy - 1),
                (exx, exy),
            ):
                if not bool(self._tile_solid(int(self.world.peek_tile(int(tx), int(ty), default=int(self.T_WALL))))):
                    spawn = (int(tx), int(ty))
                    break
        if spawn is None:
            spawn = self._player_tile()

        spawn_tx, spawn_ty = spawn
        self.player.pos.update((float(spawn_tx) + 0.5) * float(self.TILE_SIZE), (float(spawn_ty) + 0.5) * float(self.TILE_SIZE))
        self.rv_world_interior = True
        self._set_hint("E / F / H", seconds=1.4)

    def _rv_world_interior_exit(self) -> None:
        if not bool(getattr(self, "rv_world_interior", False)):
            return
        self._clear_player_pose()
        self.rv_world_interior = False
        self.player.vel.update(0, 0)

        # Restore the outside world tiles we overwrote.
        restore = getattr(self, "_rv_world_int_restore_tiles", None)
        if isinstance(restore, dict):
            for (tx, ty), tid in list(restore.items()):
                try:
                    self._world_set_tile(int(tx), int(ty), int(tid))
                except Exception:
                    pass
        self._rv_world_int_restore_tiles = None
        self._rv_world_int_active_key = None
        self._rv_world_int_exit_tile = None

        ret = getattr(self, "_rv_world_return_pos", None)
        if isinstance(ret, pygame.Vector2):
            self.player.pos.update(ret)
        self._rv_world_return_pos = None
        self._set_hint("", seconds=0.9)

    def _try_exit_rv_world_interior(self) -> bool:
        if not bool(getattr(self, "rv_world_interior", False)):
            return False
        ex = getattr(self, "_rv_world_int_exit_tile", None)
        if not (isinstance(ex, tuple) and len(ex) == 2):
            return False
        tx, ty = self._player_tile()
        if abs(int(tx) - int(ex[0])) <= 1 and abs(int(ty) - int(ex[1])) <= 1:
            self._rv_world_interior_exit()
            return True
        return False

    def _sch_int_set_layout(self, layout: list[str]) -> None:
        self.sch_layout = [str(r) for r in layout]

    def _sch_int_find(self, ch: str, *, layout: list[str] | None = None) -> tuple[int, int] | None:
        ch = str(ch)[:1]
        rows = self.sch_layout if layout is None else layout
        for y, row in enumerate(rows):
            x = str(row).find(ch)
            if x >= 0:
                return int(x), int(y)
        return None

    def _sch_int_char_at(self, x: int, y: int) -> str:
        x = int(x)
        y = int(y)
        if not (0 <= x < int(self._SCH_INT_W) and 0 <= y < int(self._SCH_INT_H)):
            return "W"
        row = self.sch_layout[y] if 0 <= y < len(self.sch_layout) else ""
        if 0 <= x < len(row):
            return row[x]
        return "W"

    def _sch_int_solid_tile(self, ch: str) -> bool:
        ch = str(ch)[:1]
        return ch not in (".", "D", "E", "^", "v")

    def _sch_int_move_box(self, pos: pygame.Vector2, vel: pygame.Vector2, dt: float, *, w: int, h: int) -> pygame.Vector2:
        tile = int(self._SCH_INT_TILE_SIZE)
        rect = pygame.Rect(int(round(pos.x - w / 2)), int(round(pos.y - h / 2)), int(w), int(h))
        dx = float(vel.x * dt)
        dy = float(vel.y * dt)

        def collide(r: pygame.Rect) -> list[pygame.Rect]:
            left = int(math.floor(r.left / tile))
            right = int(math.floor((r.right - 1) / tile))
            top = int(math.floor(r.top / tile))
            bottom = int(math.floor((r.bottom - 1) / tile))
            hits: list[pygame.Rect] = []
            for ty in range(top, bottom + 1):
                for tx in range(left, right + 1):
                    ch = self._sch_int_char_at(tx, ty)
                    if not self._sch_int_solid_tile(ch):
                        continue
                    tr = pygame.Rect(tx * tile, ty * tile, tile, tile)
                    if r.colliderect(tr):
                        hits.append(tr)
            return hits

        if dx != 0.0:
            rect.x += int(round(dx))
            for hit in collide(rect):
                if dx > 0:
                    rect.right = hit.left
                else:
                    rect.left = hit.right

        if dy != 0.0:
            rect.y += int(round(dy))
            for hit in collide(rect):
                if dy > 0:
                    rect.bottom = hit.top
                else:
                    rect.top = hit.bottom

        pad = 3
        half_w = float(w) / 2.0
        half_h = float(h) / 2.0
        min_x = tile + half_w + pad
        min_y = tile + half_h + pad
        max_x = int(self._SCH_INT_W) * tile - tile - half_w - pad
        max_y = int(self._SCH_INT_H) * tile - tile - half_h - pad
        rect.centerx = int(clamp(rect.centerx, min_x, max_x))
        rect.centery = int(clamp(rect.centery, min_y, max_y))

        return pygame.Vector2(rect.centerx, rect.centery)

    def _sch_int_player_tile(self) -> tuple[int, int]:
        tile = int(self._SCH_INT_TILE_SIZE)
        tx = int(math.floor(float(self.sch_int_pos.x) / tile))
        ty = int(math.floor(float(self.sch_int_pos.y) / tile))
        return tx, ty

    def _sch_set_floor(self, floor: int, *, spawn_at: str = "elevator") -> None:
        max_f = int(max(1, int(getattr(self, "sch_max_floors", int(self._SCH_INT_MAX_FLOORS_DEFAULT)))))
        floor = int(clamp(int(floor), 1, max_f))
        self.sch_floor = int(floor)
        if floor <= 1:
            self._sch_int_set_layout(self._SCH_INT_LOBBY_LAYOUT)
        else:
            self._sch_int_set_layout(self._SCH_INT_FLOOR_LAYOUT)

        tile = int(self._SCH_INT_TILE_SIZE)
        target = "E"
        if spawn_at == "stairs_up":
            target = "^"
        elif spawn_at == "stairs_down":
            target = "v"
        elif spawn_at == "door_inside":
            target = "D"

        pt = self._sch_int_find(target)
        if pt is None:
            self.sch_int_pos = pygame.Vector2((self._SCH_INT_W / 2.0) * tile, (self._SCH_INT_H / 2.0) * tile)
        else:
            sx, sy = pt
            if spawn_at == "door_inside":
                spawn = (sx - 1, sy) if sx >= int(self._SCH_INT_W) - 1 else (sx + 1, sy)
                px, py = int(spawn[0]), int(spawn[1])
                if self._sch_int_solid_tile(self._sch_int_char_at(px, py)):
                    px, py = int(sx), int(sy)
                self.sch_int_pos = pygame.Vector2((px + 0.5) * tile, (py + 0.5) * tile)
            else:
                self.sch_int_pos = pygame.Vector2((sx + 0.5) * tile, (sy + 0.5) * tile)
        self.sch_int_vel = pygame.Vector2(0, 0)
        self.sch_int_facing = pygame.Vector2(0, 1)
        self.sch_int_walk_phase = 0.0

    def _sch_elevator_open(self) -> None:
        if not getattr(self, "sch_interior", False):
            return
        max_f = int(max(1, int(getattr(self, "sch_max_floors", int(self._SCH_INT_MAX_FLOORS_DEFAULT)))))
        options = list(range(max_f, 0, -1))
        self.sch_elevator_options = options
        cur = int(getattr(self, "sch_floor", 1))
        try:
            self.sch_elevator_sel = int(options.index(cur))
        except ValueError:
            self.sch_elevator_sel = 0
        self.sch_elevator_input = ""
        self.sch_elevator_ui_open = True
        self._set_hint(" | PgUp/PgDn |  | Enter", seconds=1.8)

    def _handle_sch_elevator_ui_wheel(self, event: pygame.event.Event) -> None:
        if not getattr(self, "sch_elevator_ui_open", False):
            return
        options: list[int] = list(getattr(self, "sch_elevator_options", []))
        if not options:
            options = [1]
            self.sch_elevator_options = options
        n = len(options)
        cols = max(1, int(getattr(self, "sch_elevator_cols", 4)))
        rows_per_page = 4
        page_size = max(1, cols * rows_per_page)
        step = cols
        if pygame.key.get_mods() & pygame.KMOD_SHIFT:
            step = page_size
        dy = int(getattr(event, "y", 0))
        if dy == 0:
            return
        sel = int(getattr(self, "sch_elevator_sel", 0)) % n
        sel = (sel - step) % n if dy > 0 else (sel + step) % n
        self.sch_elevator_sel = int(sel)
        self.sch_elevator_input = ""

    def _handle_sch_elevator_ui_mouse(self, event: pygame.event.Event) -> None:
        if not getattr(self, "sch_elevator_ui_open", False):
            return

        et = int(getattr(event, "type", 0))
        button = int(getattr(event, "button", 0))
        if et == int(pygame.MOUSEBUTTONDOWN) and button == 3:
            self.sch_elevator_ui_open = False
            self.sch_elevator_input = ""
            return

        if et not in (int(pygame.MOUSEMOTION), int(pygame.MOUSEBUTTONDOWN)):
            return
        if et == int(pygame.MOUSEBUTTONDOWN) and button != 1:
            return

        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return
        mx, my = int(internal[0]), int(internal[1])

        options: list[int] = list(getattr(self, "sch_elevator_options", []))
        if not options:
            options = [1]
            self.sch_elevator_options = options
        cols = max(1, int(getattr(self, "sch_elevator_cols", 4)))
        rows_per_page = 4
        n = len(options)
        page_size = max(1, cols * rows_per_page)
        sel_i = int(getattr(self, "sch_elevator_sel", 0)) % max(1, n)
        page = int(sel_i // page_size)
        start = int(page * page_size)
        end = int(min(int(n), int(start + page_size)))
        page_opts = list(options[start:end])
        rows = int(max(1, int(math.ceil(float(len(page_opts)) / float(cols)))))

        btn_w = 56
        btn_h = 28
        gap = 8
        grid_w = cols * btn_w + (cols - 1) * gap
        grid_h = rows * btn_h + (rows - 1) * gap
        panel = pygame.Rect(0, 0, grid_w + 40, grid_h + 98)
        panel.center = (INTERNAL_W // 2, INTERNAL_H // 2)

        x0 = panel.centerx - grid_w // 2
        y0 = panel.top + 66
        hit_i: int | None = None
        hit_floor: int | None = None
        for local_i, f in enumerate(page_opts):
            r = int(local_i) // cols
            c = int(local_i) % cols
            x = x0 + c * (btn_w + gap)
            y = y0 + r * (btn_h + gap)
            br = pygame.Rect(x, y, btn_w, btn_h)
            if br.collidepoint(mx, my):
                hit_i = int(start) + int(local_i)
                hit_floor = int(f)
                break

        if hit_i is None or hit_floor is None:
            return

        self.sch_elevator_sel = int(hit_i)
        self.sch_elevator_input = ""
        if et == int(pygame.MOUSEBUTTONDOWN) and button == 1:
            self.sch_elevator_ui_open = False
            self._sch_set_floor(int(hit_floor), spawn_at="elevator")

    def _handle_sch_elevator_ui_key(self, key: int) -> None:
        if not getattr(self, "sch_elevator_ui_open", False):
            return
        options: list[int] = list(getattr(self, "sch_elevator_options", []))
        if not options:
            options = [1]
            self.sch_elevator_options = options
        n = len(options)
        cols = max(1, int(getattr(self, "sch_elevator_cols", 4)))
        rows_per_page = 4
        page_size = max(1, cols * rows_per_page)
        sel = int(getattr(self, "sch_elevator_sel", 0)) % n

        digit = self._key_digit(int(key))
        if digit is not None:
            cur = str(getattr(self, "sch_elevator_input", ""))
            if len(cur) < 3:
                self.sch_elevator_input = cur + digit
            return
        if key in (pygame.K_BACKSPACE, pygame.K_DELETE):
            cur = str(getattr(self, "sch_elevator_input", ""))
            self.sch_elevator_input = cur[:-1]
            return

        if key in (pygame.K_ESCAPE,):
            self.sch_elevator_ui_open = False
            self.sch_elevator_input = ""
            return
        if key in (pygame.K_RETURN, pygame.K_SPACE, pygame.K_e):
            self.sch_elevator_ui_open = False
            typed = str(getattr(self, "sch_elevator_input", "")).strip()
            self.sch_elevator_input = ""
            if typed:
                try:
                    target = int(typed)
                except ValueError:
                    target = int(options[sel])
                self._sch_set_floor(int(target), spawn_at="elevator")
            else:
                self._sch_set_floor(int(options[sel]), spawn_at="elevator")
            return

        if key in (pygame.K_PAGEUP,):
            self.sch_elevator_sel = int((sel - page_size) % n)
            self.sch_elevator_input = ""
            return
        if key in (pygame.K_PAGEDOWN,):
            self.sch_elevator_sel = int((sel + page_size) % n)
            self.sch_elevator_input = ""
            return
        if key in (pygame.K_HOME,):
            self.sch_elevator_sel = 0
            self.sch_elevator_input = ""
            return
        if key in (pygame.K_END,):
            self.sch_elevator_sel = int(n - 1)
            self.sch_elevator_input = ""
            return

        if key in (pygame.K_LEFT, pygame.K_a):
            self.sch_elevator_sel = int((sel - 1) % n)
        elif key in (pygame.K_RIGHT, pygame.K_d):
            self.sch_elevator_sel = int((sel + 1) % n)
        elif key in (pygame.K_UP, pygame.K_w):
            self.sch_elevator_sel = int((sel - cols) % n)
        elif key in (pygame.K_DOWN, pygame.K_s):
            self.sch_elevator_sel = int((sel + cols) % n)
        self.sch_elevator_input = ""

    def _sch_interior_enter(self, sb: HardcoreSurvivalState._SpecialBuilding) -> None:
        self.inv_open = False
        self.rv_ui_open = False
        self.hr_elevator_ui_open = False
        self._gallery_open = False
        self.sch_interior = True
        self.sch_elevator_ui_open = False
        self.mount = None
        self.player.vel.update(0, 0)
        self.player.walk_phase *= 0.85
        self.rv.vel.update(0, 0)
        self.bike.vel.update(0, 0)

        self.sch_building = sb
        self.sch_max_floors = int(getattr(sb, "floors", 0) or int(self._SCH_INT_MAX_FLOORS_DEFAULT))
        if self.sch_max_floors <= 0:
            self.sch_max_floors = int(self._SCH_INT_MAX_FLOORS_DEFAULT)
        self.sch_world_return = pygame.Vector2(self.player.pos)
        self._sch_set_floor(1, spawn_at="door_inside")
        self._set_hint("E/ | Esc", seconds=1.6)

    def _sch_interior_exit(self) -> None:
        if not getattr(self, "sch_interior", False):
            return
        self.sch_interior = False
        self.sch_elevator_ui_open = False
        self.sch_building = None
        self.sch_floor = 1
        self._sch_int_set_layout(self._SCH_INT_LOBBY_LAYOUT)
        self.player.pos.update(self.sch_world_return)
        self._set_hint("", seconds=1.0)

    def _sch_interior_interact(self) -> None:
        if not getattr(self, "sch_interior", False):
            return
        tx, ty = self._sch_int_player_tile()
        candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
        chosen: tuple[int, int, str] | None = None
        for cx, cy in candidates:
            ch = self._sch_int_char_at(cx, cy)
            if ch in ("D", "E", "^", "v"):
                chosen = (int(cx), int(cy), str(ch))
                break
        if chosen is None:
            self._set_hint("", seconds=1.0)
            return
        _cx, _cy, ch = chosen
        if ch == "E":
            self._sch_elevator_open()
            return
        if ch == "D":
            self._sch_interior_exit()
            return

        floor = int(getattr(self, "sch_floor", 1))
        max_f = int(max(1, int(getattr(self, "sch_max_floors", int(self._SCH_INT_MAX_FLOORS_DEFAULT)))))
        if ch == "^":
            if floor >= max_f:
                self._set_hint("", seconds=1.2)
                return
            self._sch_set_floor(int(floor + 1), spawn_at="stairs_down")
            self._set_hint(f"{int(floor + 1)}F", seconds=0.9)
            return
        if ch == "v":
            if floor <= 1:
                self._set_hint("", seconds=1.2)
                return
            self._sch_set_floor(int(floor - 1), spawn_at="stairs_up")   
            self._set_hint(f"{int(floor - 1)}F", seconds=0.9)     
            return
        self._set_hint("", seconds=1.0)

    def _house_int_set_layout(self, layout: list[str]) -> None:
        self.house_layout = [str(r) for r in layout]

    def _house_int_find(self, ch: str, *, layout: list[str] | None = None) -> tuple[int, int] | None:
        ch = str(ch)[:1]
        rows = self.house_layout if layout is None else layout
        for y, row in enumerate(rows):
            x = str(row).find(ch)
            if x >= 0:
                return int(x), int(y)
        return None

    def _house_int_char_at(self, x: int, y: int) -> str:
        x = int(x)
        y = int(y)
        if not (0 <= x < int(self._HOUSE_INT_W) and 0 <= y < int(self._HOUSE_INT_H)):
            return "W"
        row = self.house_layout[y] if 0 <= y < len(self.house_layout) else ""
        if 0 <= x < len(row):
            return row[x]
        return "W"

    def _house_int_solid_tile(self, ch: str) -> bool:
        ch = str(ch)[:1]
        return ch not in (".", "D", "^", "v", ",", "d")

    def _house_int_move_box(self, pos: pygame.Vector2, vel: pygame.Vector2, dt: float, *, w: int, h: int) -> pygame.Vector2:
        tile = int(self._HOUSE_INT_TILE_SIZE)
        rect = pygame.Rect(int(round(pos.x - w / 2)), int(round(pos.y - h / 2)), int(w), int(h))
        dx = float(vel.x * dt)
        dy = float(vel.y * dt)

        def collide(r: pygame.Rect) -> list[pygame.Rect]:
            left = int(math.floor(r.left / tile))
            right = int(math.floor((r.right - 1) / tile))
            top = int(math.floor(r.top / tile))
            bottom = int(math.floor((r.bottom - 1) / tile))
            hits: list[pygame.Rect] = []
            for ty in range(top, bottom + 1):
                for tx in range(left, right + 1):
                    ch = self._house_int_char_at(tx, ty)
                    if not self._house_int_solid_tile(ch):
                        continue
                    tr = pygame.Rect(tx * tile, ty * tile, tile, tile)
                    if r.colliderect(tr):
                        hits.append(tr)
            return hits

        if dx != 0.0:
            rect.x += int(round(dx))
            for hit in collide(rect):
                if dx > 0:
                    rect.right = hit.left
                else:
                    rect.left = hit.right

        if dy != 0.0:
            rect.y += int(round(dy))
            for hit in collide(rect):
                if dy > 0:
                    rect.bottom = hit.top
                else:
                    rect.top = hit.bottom

        pad = 3
        half_w = float(w) / 2.0
        half_h = float(h) / 2.0
        min_x = tile + half_w + pad
        min_y = tile + half_h + pad
        max_x = int(self._HOUSE_INT_W) * tile - tile - half_w - pad
        max_y = int(self._HOUSE_INT_H) * tile - tile - half_h - pad
        rect.centerx = int(clamp(rect.centerx, min_x, max_x))
        rect.centery = int(clamp(rect.centery, min_y, max_y))

        return pygame.Vector2(rect.centerx, rect.centery)

    def _house_int_player_tile(self) -> tuple[int, int]:
        tile = int(self._HOUSE_INT_TILE_SIZE)
        tx = int(math.floor(float(self.house_int_pos.x) / tile))
        ty = int(math.floor(float(self.house_int_pos.y) / tile))
        return tx, ty

    def _house_set_floor(self, floor: int, *, spawn_at: str = "door_inside") -> None:
        max_f = int(max(1, int(getattr(self, "house_max_floors", int(self._HOUSE_INT_MAX_FLOORS_DEFAULT)))))
        floor = int(clamp(int(floor), 1, max_f))
        self.house_floor = int(floor)
        if floor <= 1:
            self._house_int_set_layout(self._HOUSE_INT_F1_LAYOUT)
        else:
            self._house_int_set_layout(self._HOUSE_INT_FLOOR_LAYOUT)

        tile = int(self._HOUSE_INT_TILE_SIZE)
        target = "^"
        if spawn_at == "stairs_up":
            target = "^"
        elif spawn_at == "stairs_down":
            target = "v"
        elif spawn_at == "door_inside":
            target = "D"

        pt = self._house_int_find(target)
        if pt is None:
            self.house_int_pos = pygame.Vector2((self._HOUSE_INT_W / 2.0) * tile, (self._HOUSE_INT_H / 2.0) * tile)
        else:
            sx, sy = pt
            if spawn_at == "door_inside":
                spawn = (sx - 1, sy) if sx >= int(self._HOUSE_INT_W) - 1 else (sx + 1, sy)
                px, py = int(spawn[0]), int(spawn[1])
                if self._house_int_solid_tile(self._house_int_char_at(px, py)):
                    px, py = int(sx), int(sy)
                self.house_int_pos = pygame.Vector2((px + 0.5) * tile, (py + 0.5) * tile)
            else:
                self.house_int_pos = pygame.Vector2((sx + 0.5) * tile, (sy + 0.5) * tile)

        self.house_int_vel = pygame.Vector2(0, 0)
        self.house_int_facing = pygame.Vector2(0, 1)
        self.house_int_walk_phase = 0.0

    def _house_interior_enter(self, sb: HardcoreSurvivalState._SpecialBuilding) -> None:
        self.inv_open = False
        self.rv_ui_open = False
        self.home_ui_open = False
        self.hr_elevator_ui_open = False
        self.sch_elevator_ui_open = False
        self._gallery_open = False
        self.house_interior = True
        self.mount = None
        self.player.vel.update(0, 0)
        self.player.walk_phase *= 0.85
        self.rv.vel.update(0, 0)
        self.bike.vel.update(0, 0)

        self.house_building = sb
        self.house_max_floors = int(getattr(sb, "floors", 0) or int(self._HOUSE_INT_MAX_FLOORS_DEFAULT))
        if self.house_max_floors <= 0:
            self.house_max_floors = int(self._HOUSE_INT_MAX_FLOORS_DEFAULT)
        self.house_world_return = pygame.Vector2(self.player.pos)
        self._house_set_floor(1, spawn_at="door_inside")
        self._set_hint("E | Esc", seconds=1.6)

    def _house_interior_exit(self) -> None:
        if not getattr(self, "house_interior", False):
            return
        self._clear_player_pose()
        self.house_interior = False
        self.house_building = None
        self.house_floor = 1
        self._house_int_set_layout(self._HOUSE_INT_F1_LAYOUT)
        self.player.pos.update(self.house_world_return)
        self._set_hint("", seconds=1.0)

    def _house_interior_interact(self) -> None:
        if not getattr(self, "house_interior", False):
            return
        tx, ty = self._house_int_player_tile()
        candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
        chosen: tuple[int, int, str] | None = None
        for cx, cy in candidates:
            ch = self._house_int_char_at(cx, cy)
            if ch in ("D", "^", "v"):
                chosen = (int(cx), int(cy), str(ch))
                break
        if chosen is None:
            self._set_hint("", seconds=1.0)
            return
        _cx, _cy, ch = chosen

        floor = int(getattr(self, "house_floor", 1))
        max_f = int(max(1, int(getattr(self, "house_max_floors", int(self._HOUSE_INT_MAX_FLOORS_DEFAULT)))))

        if ch == "D":
            if floor > 1:
                self._set_hint("", seconds=1.2)
                return
            self._house_interior_exit()
            return

        if ch == "^":
            if floor >= max_f:
                self._set_hint("", seconds=1.2)
                return
            self._house_set_floor(int(floor + 1), spawn_at="stairs_down")
            self._set_hint(f"{int(floor + 1)}F", seconds=0.9)
            return

        if ch == "v":
            if floor <= 1:
                self._set_hint("", seconds=1.2)
                return
            self._house_set_floor(int(floor - 1), spawn_at="stairs_up")
            self._set_hint(f"{int(floor - 1)}F", seconds=0.9)
            return

        self._set_hint("", seconds=1.0)

    def _hr_int_set_layout(self, layout: list[str]) -> None:
        self.hr_layout = [str(r) for r in layout]

    def _hr_int_find(self, ch: str, *, layout: list[str] | None = None) -> tuple[int, int] | None:
        ch = str(ch)[:1]
        rows = self.hr_layout if layout is None else layout
        for y, row in enumerate(rows):
            x = str(row).find(ch)
            if x >= 0:
                return int(x), int(y)
        return None

    def _hr_int_char_at(self, x: int, y: int) -> str:
        x = int(x)
        y = int(y)
        if not (0 <= x < int(self._HR_INT_W) and 0 <= y < int(self._HR_INT_H)):
            return "W"
        row = self.hr_layout[y] if 0 <= y < len(self.hr_layout) else ""
        if 0 <= x < len(row):
            return row[x]
        return "W"

    def _hr_int_solid_tile(self, ch: str) -> bool:
        ch = str(ch)[:1]
        return ch not in (".", ",", "D", "E", "L", "^", "v")

    def _hr_int_move_box(self, pos: pygame.Vector2, vel: pygame.Vector2, dt: float, *, w: int, h: int) -> pygame.Vector2:
        # Match the collision/slide behavior of other interior scenes (house/school/RV).
        tile = int(self._HR_INT_TILE_SIZE)
        rect = pygame.Rect(int(round(pos.x - w / 2)), int(round(pos.y - h / 2)), int(w), int(h))
        dx = float(vel.x * dt)
        dy = float(vel.y * dt)

        def collide(r: pygame.Rect) -> list[pygame.Rect]:
            left = int(math.floor(r.left / tile))
            right = int(math.floor((r.right - 1) / tile))
            top = int(math.floor(r.top / tile))
            bottom = int(math.floor((r.bottom - 1) / tile))
            hits: list[pygame.Rect] = []
            for ty in range(top, bottom + 1):
                for tx in range(left, right + 1):
                    ch = self._hr_int_char_at(tx, ty)
                    if not self._hr_int_solid_tile(ch):
                        continue
                    tr = pygame.Rect(tx * tile, ty * tile, tile, tile)
                    if r.colliderect(tr):
                        hits.append(tr)
            return hits

        if dx != 0.0:
            rect.x += int(round(dx))
            for hit in collide(rect):
                if dx > 0:
                    rect.right = hit.left
                else:
                    rect.left = hit.right

        if dy != 0.0:
            rect.y += int(round(dy))
            for hit in collide(rect):
                if dy > 0:
                    rect.bottom = hit.top
                else:
                    rect.top = hit.bottom

        pad = 3
        half_w = float(w) / 2.0
        half_h = float(h) / 2.0
        min_x = tile + half_w + pad
        min_y = tile + half_h + pad
        max_x = int(self._HR_INT_W) * tile - tile - half_w - pad
        max_y = int(self._HR_INT_H) * tile - tile - half_h - pad
        rect.centerx = int(clamp(rect.centerx, min_x, max_x))
        rect.centery = int(clamp(rect.centery, min_y, max_y))

        return pygame.Vector2(rect.centerx, rect.centery)

    def _hr_int_player_tile(self) -> tuple[int, int]:
        tile = int(self._HR_INT_TILE_SIZE)
        tx = int(math.floor(float(self.hr_int_pos.x) / tile))
        ty = int(math.floor(float(self.hr_int_pos.y) / tile))
        return tx, ty

    def _hr_int_block_bounds(self, x: int, y: int, ch: str) -> tuple[int, int, int, int] | None:
        ch = str(ch)[:1]
        x = int(x)
        y = int(y)
        w = int(self._HR_INT_W)
        h = int(self._HR_INT_H)
        if not (0 <= x < w and 0 <= y < h):
            return None
        if str(self._hr_int_char_at(x, y))[:1] != ch:
            return None
        seen: set[tuple[int, int]] = set()
        stack = [(x, y)]
        cells: list[tuple[int, int]] = []
        while stack:
            cx, cy = stack.pop()
            cx = int(cx)
            cy = int(cy)
            if (cx, cy) in seen:
                continue
            if not (0 <= cx < w and 0 <= cy < h):
                continue
            if str(self._hr_int_char_at(cx, cy))[:1] != ch:
                continue
            seen.add((cx, cy))
            cells.append((cx, cy))
            stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
        if not cells:
            return None
        min_x = min(int(p[0]) for p in cells)
        max_x = max(int(p[0]) for p in cells)
        min_y = min(int(p[1]) for p in cells)
        max_y = max(int(p[1]) for p in cells)
        return (int(min_x), int(min_y), int(max_x), int(max_y))

    def _hr_edit_rebuild_blocks(self) -> None:
        if not getattr(self, "hr_interior", False):
            self.hr_edit_blocks = []
            return
        if str(getattr(self, "hr_mode", "lobby")) != "home":
            self.hr_edit_blocks = []
            return
        layout = getattr(self, "hr_layout", None)
        if not isinstance(layout, list):
            self.hr_edit_blocks = []
            return

        movable = {"B", "S", "F", "K", "T", "C", "P", "X", "L"}
        w = int(self._HR_INT_W)
        h = int(self._HR_INT_H)
        seen: set[tuple[int, int]] = set()
        blocks: list[tuple[str, list[tuple[int, int]]]] = []

        for y in range(h):
            for x in range(w):
                ch = str(self._hr_int_char_at(x, y))[:1]
                if ch not in movable:
                    continue
                if (x, y) in seen:
                    continue
                cells: list[tuple[int, int]] = []
                stack = [(int(x), int(y))]
                while stack:
                    cx, cy = stack.pop()
                    cx = int(cx)
                    cy = int(cy)
                    if (cx, cy) in seen:
                        continue
                    if not (0 <= cx < w and 0 <= cy < h):
                        continue
                    if str(self._hr_int_char_at(cx, cy))[:1] != ch:
                        continue
                    seen.add((cx, cy))
                    cells.append((cx, cy))
                    stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
                if cells:
                    blocks.append((ch, cells))

        def sort_key(b: tuple[str, list[tuple[int, int]]]) -> tuple:
            ch, cells = b
            miny = min(int(p[1]) for p in cells)
            minx = min(int(p[0]) for p in cells)
            return (ch, miny, minx, len(cells))

        blocks.sort(key=sort_key)
        self.hr_edit_blocks = blocks
        self.hr_edit_index = int(clamp(int(getattr(self, "hr_edit_index", 0)), 0, max(0, len(blocks) - 1)))

    def _hr_toggle_edit_mode(self) -> None:
        if not getattr(self, "hr_interior", False):
            return
        if str(getattr(self, "hr_mode", "lobby")) != "home":
            return
        home_room = str(getattr(self, "home_highrise_room", "")).strip()
        cur_room = str(getattr(self, "hr_current_room", "")).strip()
        if home_room and cur_room and cur_room != home_room:
            self._set_hint("", seconds=1.1)
            return
        self.hr_edit_mode = not bool(getattr(self, "hr_edit_mode", False))
        self.hr_edit_dragging = False
        if self.hr_edit_mode:
            self._hr_edit_rebuild_blocks()
            if not getattr(self, "hr_edit_blocks", None):
                self.hr_edit_mode = False
                self._set_hint("", seconds=1.0)
                return
            self.hr_edit_index = int(
                clamp(int(getattr(self, "hr_edit_index", 0)), 0, len(self.hr_edit_blocks) - 1)
            )
            self._set_hint("Tab  /  /  / R ", seconds=1.8)
        else:
            self._set_hint("", seconds=1.0)

    def _hr_edit_cycle(self, delta: int = 1) -> None:
        blocks = getattr(self, "hr_edit_blocks", None)
        if not isinstance(blocks, list) or not blocks:
            return
        self.hr_edit_index = (int(getattr(self, "hr_edit_index", 0)) + int(delta)) % len(blocks)

    def _hr_edit_move(self, dx: int, dy: int) -> None:
        if not bool(getattr(self, "hr_edit_mode", False)):
            return
        if str(getattr(self, "hr_mode", "lobby")) != "home":
            return
        blocks = getattr(self, "hr_edit_blocks", None)
        if not isinstance(blocks, list) or not blocks:
            return
        idx = int(getattr(self, "hr_edit_index", 0)) % len(blocks)
        ch, cells = blocks[idx]
        w = int(self._HR_INT_W)
        h = int(self._HR_INT_H)
        dx = int(dx)
        dy = int(dy)
        if dx == 0 and dy == 0:
            return

        cell_set = set((int(x), int(y)) for x, y in cells)
        new_cells = [(int(x) + dx, int(y) + dy) for x, y in cell_set]

        for nx, ny in new_cells:
            if not (0 <= int(nx) < w and 0 <= int(ny) < h):
                return
            if (int(nx), int(ny)) in cell_set:
                continue
            dst = str(self._hr_int_char_at(nx, ny))[:1]
            if dst != ".":
                return

        rows = [list(str(r)) for r in getattr(self, "hr_layout", [])]
        if len(rows) < h:
            rows.extend([list("." * w) for _ in range(h - len(rows))])
        for oy in range(min(len(rows), h)):
            if len(rows[oy]) < w:
                rows[oy].extend(list("." * (w - len(rows[oy]))))

        for ox, oy in cell_set:
            if 0 <= int(oy) < h and 0 <= int(ox) < w:
                rows[int(oy)][int(ox)] = "."
        for nx, ny in new_cells:
            rows[int(ny)][int(nx)] = str(ch)[:1]

        self.hr_layout = ["".join(r[:w]) for r in rows[:h]]
        self.hr_home_layout = list(self.hr_layout)
        blocks[idx] = (str(ch)[:1], [(int(x), int(y)) for x, y in new_cells])

    def _hr_edit_handle_mouse(self, event: pygame.event.Event) -> bool:
        if not bool(getattr(self, "hr_edit_mode", False)):
            return False
        if not getattr(self, "hr_interior", False):
            return False
        if str(getattr(self, "hr_mode", "lobby")) != "home":
            return False
        if event.type not in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION):
            return False
        if not hasattr(event, "pos"):
            return False
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return False

        tile = int(self._HR_INT_TILE_SIZE)
        full_map_w = int(self._HR_INT_W) * tile
        full_map_h = int(self._HR_INT_H) * tile
        map_y0 = 38
        map_w = int(min(int(full_map_w), max(1, int(INTERNAL_W) - 20)))
        map_h = int(min(int(full_map_h), max(1, int(INTERNAL_H) - int(map_y0) - 10)))
        map_x0 = (INTERNAL_W - map_w) // 2
        map_rect = pygame.Rect(int(map_x0), int(map_y0), int(map_w), int(map_h))

        # Same camera math as the renderer (layout may exceed the viewport).
        cam = getattr(self, "_hr_int_draw_cam", None)
        if isinstance(cam, tuple) and len(cam) >= 2:
            cam_x, cam_y = int(cam[0]), int(cam[1])
        else:
            pose = str(getattr(self, "player_pose", "")).strip()
            pose_space = str(getattr(self, "player_pose_space", "")).strip()
            pose_anchor = getattr(self, "player_pose_anchor", None)
            use_pose = bool(pose and pose_space == "hr" and pose_anchor is not None)
            if use_pose:
                focus = pygame.Vector2(float(pose_anchor[0]), float(pose_anchor[1]))
            else:
                focus = pygame.Vector2(self.hr_int_pos)
            if int(full_map_w) <= int(map_w):
                cam_x = 0
            else:
                cam_x = int(clamp(float(focus.x) - float(map_w) / 2.0, 0.0, float(full_map_w - map_w)))
            if int(full_map_h) <= int(map_h):
                cam_y = 0
            else:
                cam_y = int(clamp(float(focus.y) - float(map_h) / 2.0, 0.0, float(full_map_h - map_h)))

        map_x = int(map_x0) - int(cam_x)
        map_y = int(map_y0) - int(cam_y)

        movable = {"B", "S", "F", "K", "T", "C", "P", "X"}

        if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
            if not map_rect.collidepoint(internal):
                return False
            ix = int((int(internal[0]) - int(map_x)) // max(1, int(tile)))
            iy = int((int(internal[1]) - int(map_y)) // max(1, int(tile)))
            ch = str(self._hr_int_char_at(ix, iy))[:1]
            if ch not in movable:
                return False
            blocks = getattr(self, "hr_edit_blocks", None)
            if not isinstance(blocks, list) or not blocks:
                self._hr_edit_rebuild_blocks()
                blocks = getattr(self, "hr_edit_blocks", None)
            if not isinstance(blocks, list) or not blocks:
                return False

            hit_i: int | None = None
            for i, (bch, cells) in enumerate(blocks):
                if str(bch)[:1] != ch:
                    continue
                for cx, cy in cells:
                    if int(cx) == int(ix) and int(cy) == int(iy):
                        hit_i = int(i)
                        break
                if hit_i is not None:
                    break
            if hit_i is None:
                return False

            self.hr_edit_index = int(hit_i)
            _bch, cells = blocks[hit_i]
            min_x = min(int(p[0]) for p in cells)
            min_y = min(int(p[1]) for p in cells)
            self.hr_edit_dragging = True
            self.hr_edit_drag_offset = (int(ix - min_x), int(iy - min_y))
            return True

        if event.type == pygame.MOUSEBUTTONUP and getattr(event, "button", 0) == 1:
            if bool(getattr(self, "hr_edit_dragging", False)):
                self.hr_edit_dragging = False
                return True
            return False

        if event.type == pygame.MOUSEMOTION:
            if not bool(getattr(self, "hr_edit_dragging", False)):
                return False
            if not map_rect.collidepoint(internal):
                return True
            ix = int((int(internal[0]) - int(map_x)) // max(1, int(tile)))
            iy = int((int(internal[1]) - int(map_y)) // max(1, int(tile)))
            off = getattr(self, "hr_edit_drag_offset", (0, 0))
            offx, offy = int(off[0]), int(off[1])
            target_min_x = int(ix - offx)
            target_min_y = int(iy - offy)

            blocks = getattr(self, "hr_edit_blocks", None)
            if not isinstance(blocks, list) or not blocks:
                return True
            idx = int(getattr(self, "hr_edit_index", 0)) % len(blocks)
            _ch, cells = blocks[idx]
            cur_min_x = min(int(p[0]) for p in cells)
            cur_min_y = min(int(p[1]) for p in cells)
            dx = int(target_min_x - cur_min_x)
            dy = int(target_min_y - cur_min_y)
            if dx != 0 or dy != 0:
                self._hr_edit_move(dx, dy)
            return True

        return False

    def _handle_hr_interior_ui_mouse(self, event: pygame.event.Event) -> bool:
        if not getattr(self, "hr_interior", False):
            return False
        if str(getattr(self, "hr_mode", "lobby")) != "home":
            return False
        if bool(getattr(self, "hr_edit_mode", False)):
            return False
        if event.type != pygame.MOUSEBUTTONDOWN or int(getattr(event, "button", 0)) != 1:
            return False
        if (
            bool(getattr(self, "inv_open", False))
            or bool(getattr(self, "home_ui_open", False))
            or bool(getattr(self, "hr_elevator_ui_open", False))
            or bool(getattr(self, "world_map_open", False))
        ):
            return False
        if not hasattr(event, "pos"):
            return False
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return False
        mx, my = int(internal[0]), int(internal[1])
        buttons = getattr(self, "_hr_int_ui_buttons", None)
        if not isinstance(buttons, list) or not buttons:
            return False
        for entry in list(buttons):
            if not isinstance(entry, tuple) or len(entry) < 3:
                continue
            action, room_id, rect = entry[0], entry[1], entry[2]
            payload = entry[3] if len(entry) >= 4 else None
            if not isinstance(rect, pygame.Rect):
                continue
            if not rect.collidepoint(mx, my):
                continue
            if str(action) == "toggle_lamp":
                self._hr_room_toggle_light(str(room_id))
                return True
            if str(action) == "hr_move":
                if not (isinstance(payload, tuple) and len(payload) == 2):
                    return True
                sel_tx, sel_ty = int(payload[0]), int(payload[1])
                if not bool(getattr(self, "hr_edit_mode", False)):
                    self._hr_toggle_edit_mode()
                if not bool(getattr(self, "hr_edit_mode", False)):
                    return True
                blocks = getattr(self, "hr_edit_blocks", None)
                if not isinstance(blocks, list) or not blocks:
                    return True
                for i, (_ch, cells) in enumerate(blocks):
                    for cx, cy in cells:
                        if int(cx) == int(sel_tx) and int(cy) == int(sel_ty):
                            self.hr_edit_index = int(i)
                            return True
                return True
        return False

    def _hr_make_hall_layout(self, floor: int) -> list[str]:
        doors = list(getattr(self, "_HR_INT_APT_DOORS", []))
        if not doors:
            return [str(r) for r in self._HR_INT_HALL_BASE]

        base = [str(r) for r in self._HR_INT_HALL_BASE]
        rows = [list(r) for r in base]

        # Mark the player's home door (green) on the home floor.
        home_floor = int(getattr(self, "hr_home_floor", -1))
        if int(floor) == int(home_floor):
            idx = int(getattr(self, "hr_home_door_index", 0)) % len(doors)
            hx, hy = doors[idx]
            if 0 <= int(hy) < len(rows) and 0 <= int(hx) < len(rows[int(hy)]):
                rows[int(hy)][int(hx)] = "H"

        # Mark some other unit doors as broken (enterable) so players can tell why it opens.
        states = getattr(self, "hr_apt_door_broken", None)
        if not isinstance(states, dict):
            states = {}
            self.hr_apt_door_broken = states
        sb = getattr(self, "hr_building", None)
        if isinstance(sb, HardcoreSurvivalState._SpecialBuilding):
            bkey = (int(sb.tx0), int(sb.ty0), int(sb.w), int(sb.h))
        else:
            bkey = (0, 0, 0, 0)
        seed_base = int(self.seed) ^ 0x6B8B4567
        for i, (dx, dy) in enumerate(doors):
            unit = int(i) + 1
            dx = int(dx)
            dy = int(dy)
            if not (0 <= dy < len(rows) and 0 <= dx < len(rows[dy])):
                continue
            if rows[dy][dx] == "H":
                continue
            door_key = (int(bkey[0]), int(bkey[1]), int(bkey[2]), int(bkey[3]), int(floor), int(unit))
            if door_key in states:
                broken = bool(states.get(door_key, False))
            else:
                hh = int(
                    self._hash2_u32(
                        int(bkey[0]) + int(floor) * 37 + int(unit) * 11,
                        int(bkey[1]) + int(floor) * 17 + int(unit) * 29,
                        int(seed_base),
                    )
                )
                broken = int(hh % 100) < 18
                states[door_key] = bool(broken)
            if broken and rows[dy][dx] == "A":
                rows[dy][dx] = "a"
        return ["".join(r) for r in rows]

    def _hr_set_floor(self, floor: int, *, spawn_at: str = "elevator") -> None:
        max_f = int(max(1, int(getattr(self, "hr_max_floors", int(self._HR_INT_MAX_FLOORS_DEFAULT)))))
        floor = int(clamp(int(floor), 1, max_f))
        self.hr_floor = int(floor)
        if floor <= 1:
            self.hr_mode = "lobby"
            self._hr_int_set_layout(self._HR_INT_LOBBY_LAYOUT)
        else:
            self.hr_mode = "hall"
            self._hr_int_set_layout(self._hr_make_hall_layout(floor))

        spawn_at = str(spawn_at)
        spawn_ch = "E"
        if spawn_at == "stairs_up":
            spawn_ch = "^"
        elif spawn_at == "stairs_down":
            spawn_ch = "v"

        elev = self._hr_int_find(str(spawn_ch)[:1])
        if elev is None:
            elev = self._hr_int_find("E")
        tile = int(self._HR_INT_TILE_SIZE)
        if elev is None:
            self.hr_int_pos = pygame.Vector2((self._HR_INT_W / 2.0) * tile, (self._HR_INT_H / 2.0) * tile)
        else:
            ex, ey = elev
            self.hr_int_pos = pygame.Vector2((ex + 0.5) * tile, (ey + 0.5) * tile)
        self.hr_int_vel = pygame.Vector2(0, 0)
        self.hr_int_facing = pygame.Vector2(0, 1)
        self.hr_int_walk_phase = 0.0

    def _hr_travel_start(self, target_floor: int, *, kind: str, spawn_at: str = "elevator") -> None:
        if not bool(getattr(self, "hr_interior", False)):
            return
        if bool(getattr(self, "hr_travel_active", False)):
            return
        kind = str(kind).strip() or "elevator"

        max_f = int(max(1, int(getattr(self, "hr_max_floors", int(self._HR_INT_MAX_FLOORS_DEFAULT)))))
        cur = int(getattr(self, "hr_floor", 1))
        target = int(clamp(int(target_floor), 1, int(max_f)))
        if int(target) == int(cur):
            self._set_hint(f" {int(cur)}F", seconds=0.8)
            return

        step = 0.35
        if kind != "elevator":
            step = 0.60

        self.inv_open = False
        self.home_ui_open = False
        self.home_ui_open_block = None
        self.world_map_open = False
        self._gallery_open = False
        self.hr_elevator_ui_open = False
        self.hr_elevator_input = ""
        self.hr_auto_walk_to_elevator = False
        self.hr_auto_walk_delay = 0.0
        self._clear_player_pose()

        self.hr_travel_active = True
        self.hr_travel_kind = kind
        self.hr_travel_from = int(cur)
        self.hr_travel_to = int(target)
        self.hr_travel_display = int(cur)
        self.hr_travel_dir = 1 if int(target) > int(cur) else -1
        self.hr_travel_step_s = float(max(0.10, float(step)))
        self.hr_travel_acc = 0.0
        self.hr_travel_done_left = -1.0
        self.hr_travel_spawn_at = str(spawn_at)
        self.hr_int_vel = pygame.Vector2(0, 0)

    def _hr_travel_update(self, dt: float) -> None:
        if not bool(getattr(self, "hr_travel_active", False)):
            return
        dt = float(dt)
        cur = int(getattr(self, "hr_travel_display", int(getattr(self, "hr_floor", 1))))
        target = int(getattr(self, "hr_travel_to", cur))
        step = float(getattr(self, "hr_travel_step_s", 0.35))
        step = float(max(0.06, step))
        direction = 1 if int(getattr(self, "hr_travel_dir", 1)) >= 0 else -1

        if int(cur) == int(target):
            done_left = float(getattr(self, "hr_travel_done_left", -1.0))
            if done_left < 0.0:
                self.hr_travel_done_left = 0.25
                return
            done_left = done_left - dt
            self.hr_travel_done_left = done_left
            if done_left <= 0.0:
                spawn_at = str(getattr(self, "hr_travel_spawn_at", "elevator"))
                self.hr_travel_active = False
                self.hr_travel_kind = ""
                self._hr_set_floor(int(target), spawn_at=spawn_at)
            return

        acc = float(getattr(self, "hr_travel_acc", 0.0)) + dt
        while acc >= step and int(cur) != int(target):
            acc -= step
            cur = int(cur) + int(direction)
            # Clamp so we never step beyond target.
            if direction > 0 and int(cur) > int(target):
                cur = int(target)
            elif direction < 0 and int(cur) < int(target):
                cur = int(target)
            self.hr_travel_display = int(cur)
        self.hr_travel_acc = float(acc)
        if int(cur) == int(target):
            self.hr_travel_done_left = 0.25

    def _hr_elevator_open(self) -> None:
        if not getattr(self, "hr_interior", False):
            return
        max_f = int(max(1, int(getattr(self, "hr_max_floors", int(self._HR_INT_MAX_FLOORS_DEFAULT)))))
        options = list(range(max_f, 0, -1))
        self.hr_elevator_options = options
        cur = int(getattr(self, "hr_floor", 1))
        try:
            self.hr_elevator_sel = int(options.index(cur))
        except ValueError:
            self.hr_elevator_sel = 0
        self.hr_elevator_input = ""
        self.hr_elevator_ui_open = True
        self._set_hint(" | PgUp/PgDn |  | Enter", seconds=1.8)

    def _key_digit(self, key: int) -> str | None:
        key = int(key)
        if int(pygame.K_0) <= key <= int(pygame.K_9):
            return chr(key)
        if int(pygame.K_KP0) <= key <= int(pygame.K_KP9):
            return str(int(key) - int(pygame.K_KP0))
        return None

    def _handle_hr_elevator_ui_wheel(self, event: pygame.event.Event) -> None:
        if not getattr(self, "hr_elevator_ui_open", False):
            return
        options: list[int] = list(getattr(self, "hr_elevator_options", []))
        if not options:
            options = [1]
            self.hr_elevator_options = options
        n = len(options)
        cols = max(1, int(getattr(self, "hr_elevator_cols", 4)))
        rows_per_page = 4
        page_size = max(1, cols * rows_per_page)
        step = cols
        if pygame.key.get_mods() & pygame.KMOD_SHIFT:
            step = page_size
        dy = int(getattr(event, "y", 0))
        if dy == 0:
            return
        sel = int(getattr(self, "hr_elevator_sel", 0)) % n
        sel = (sel - step) % n if dy > 0 else (sel + step) % n
        self.hr_elevator_sel = int(sel)
        self.hr_elevator_input = ""

    def _handle_hr_elevator_ui_mouse(self, event: pygame.event.Event) -> None:
        if not getattr(self, "hr_elevator_ui_open", False):
            return

        et = int(getattr(event, "type", 0))
        button = int(getattr(event, "button", 0))
        if et == int(pygame.MOUSEBUTTONDOWN) and button == 3:
            self.hr_elevator_ui_open = False
            self.hr_elevator_input = ""
            return

        if et not in (int(pygame.MOUSEMOTION), int(pygame.MOUSEBUTTONDOWN)):
            return
        if et == int(pygame.MOUSEBUTTONDOWN) and button != 1:
            return

        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return
        mx, my = int(internal[0]), int(internal[1])

        options: list[int] = list(getattr(self, "hr_elevator_options", []))
        if not options:
            options = [0]
            self.hr_elevator_options = options
        cols = max(1, int(getattr(self, "hr_elevator_cols", 4)))
        rows_per_page = 4
        n = len(options)
        page_size = max(1, cols * rows_per_page)
        sel_i = int(getattr(self, "hr_elevator_sel", 0)) % max(1, n)
        page = int(sel_i // page_size)
        start = int(page * page_size)
        end = int(min(int(n), int(start + page_size)))
        page_opts = list(options[start:end])
        rows = int(max(1, int(math.ceil(float(len(page_opts)) / float(cols)))))

        btn_w = 56
        btn_h = 28
        gap = 8
        grid_w = cols * btn_w + (cols - 1) * gap
        grid_h = rows * btn_h + (rows - 1) * gap
        panel = pygame.Rect(0, 0, grid_w + 40, grid_h + 98)
        panel.center = (INTERNAL_W // 2, INTERNAL_H // 2)

        x0 = panel.centerx - grid_w // 2
        y0 = panel.top + 66
        hit_i: int | None = None
        hit_floor: int | None = None
        for local_i, f in enumerate(page_opts):
            r = int(local_i) // cols
            c = int(local_i) % cols
            x = x0 + c * (btn_w + gap)
            y = y0 + r * (btn_h + gap)
            br = pygame.Rect(x, y, btn_w, btn_h)
            if br.collidepoint(mx, my):
                hit_i = int(start) + int(local_i)
                hit_floor = int(f)
                break

        if hit_i is None or hit_floor is None:
            return

        self.hr_elevator_sel = int(hit_i)
        self.hr_elevator_input = ""
        if et == int(pygame.MOUSEBUTTONDOWN) and button == 1:
            self.hr_elevator_ui_open = False
            self._hr_travel_start(int(hit_floor), kind="elevator", spawn_at="elevator")

    def _handle_hr_elevator_ui_key(self, key: int) -> None:
        if not getattr(self, "hr_elevator_ui_open", False):
            return
        options: list[int] = list(getattr(self, "hr_elevator_options", []))
        if not options:
            options = [0]
            self.hr_elevator_options = options
        n = len(options)
        cols = max(1, int(getattr(self, "hr_elevator_cols", 4)))
        rows_per_page = 4
        page_size = max(1, cols * rows_per_page)
        sel = int(getattr(self, "hr_elevator_sel", 0)) % n

        digit = self._key_digit(int(key))
        if digit is not None:
            cur = str(getattr(self, "hr_elevator_input", ""))
            if len(cur) < 3:
                self.hr_elevator_input = cur + digit
            return
        if key in (pygame.K_BACKSPACE, pygame.K_DELETE):
            cur = str(getattr(self, "hr_elevator_input", ""))
            self.hr_elevator_input = cur[:-1]
            return

        if key in (pygame.K_ESCAPE,):
            self.hr_elevator_ui_open = False
            self.hr_elevator_input = ""
            return
        if key in (pygame.K_RETURN, pygame.K_SPACE, pygame.K_e):
            self.hr_elevator_ui_open = False
            typed = str(getattr(self, "hr_elevator_input", "")).strip()
            self.hr_elevator_input = ""
            if typed:
                try:
                    target = int(typed)
                except ValueError:
                    target = int(options[sel])
                self._hr_travel_start(int(target), kind="elevator", spawn_at="elevator")
            else:
                self._hr_travel_start(int(options[sel]), kind="elevator", spawn_at="elevator")
            return

        if key in (pygame.K_PAGEUP,):
            self.hr_elevator_sel = int((sel - page_size) % n)
            self.hr_elevator_input = ""
            return
        if key in (pygame.K_PAGEDOWN,):
            self.hr_elevator_sel = int((sel + page_size) % n)
            self.hr_elevator_input = ""
            return
        if key in (pygame.K_HOME,):
            self.hr_elevator_sel = 0
            self.hr_elevator_input = ""
            return
        if key in (pygame.K_END,):
            self.hr_elevator_sel = int(n - 1)
            self.hr_elevator_input = ""
            return

        if key in (pygame.K_LEFT, pygame.K_a):
            self.hr_elevator_sel = int((sel - 1) % n)
        elif key in (pygame.K_RIGHT, pygame.K_d):
            self.hr_elevator_sel = int((sel + 1) % n)
        elif key in (pygame.K_UP, pygame.K_w):
            self.hr_elevator_sel = int((sel - cols) % n)
        elif key in (pygame.K_DOWN, pygame.K_s):
            self.hr_elevator_sel = int((sel + cols) % n)
        self.hr_elevator_input = ""

    def _world_elevator_open(self, chunk: "_Chunk", mh: "_MultiHouse", *, elev_tile: tuple[int, int]) -> None:
        floors = int(max(1, int(getattr(mh, "floors", 1))))
        floors = int(min(int(floors), int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
        if floors <= 1:
            self._set_hint("", seconds=1.0)
            return
        options = list(range(int(floors), 0, -1))
        self.world_elevator_options = options
        cur = int(max(1, int(getattr(mh, "cur_floor", 1))))
        cur = int(clamp(int(cur), 1, int(floors)))
        try:
            self.world_elevator_sel = int(options.index(int(cur)))
        except ValueError:
            self.world_elevator_sel = 0
        self.world_elevator_input = ""
        self.world_elevator_ui_open = True
        self.world_elevator_chunk = chunk
        self.world_elevator_mh = mh
        self.world_elevator_elev_tile = (int(elev_tile[0]), int(elev_tile[1]))
        self._set_hint(" | PgUp/PgDn |  | Enter", seconds=1.6)

    def _world_elevator_close(self) -> None:
        self.world_elevator_ui_open = False
        self.world_elevator_input = ""
        self.world_elevator_chunk = None
        self.world_elevator_mh = None
        self.world_elevator_elev_tile = None

    def _world_elevator_apply_floor(self, floor: int) -> None:
        chunk = getattr(self, "world_elevator_chunk", None)
        mh = getattr(self, "world_elevator_mh", None)
        if chunk is None or mh is None:
            return
        floors = int(max(1, int(getattr(mh, "floors", 1))))
        floors = int(min(int(floors), int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
        target = int(clamp(int(floor), 1, int(floors)))
        mh.cur_floor = int(target)
        self._multi_house_apply_floor(chunk, mh)

        elev = getattr(self, "world_elevator_elev_tile", None)
        if isinstance(elev, tuple) and len(elev) >= 2:
            ex, ey = int(elev[0]), int(elev[1])
            self.player.vel.update(0, 0)
            self.player.pos.update((float(ex) + 0.5) * float(self.TILE_SIZE), (float(ey) + 0.5) * float(self.TILE_SIZE))

        self._set_hint(f"{int(target)}F", seconds=0.8)

    def _handle_world_elevator_ui_wheel(self, event: pygame.event.Event) -> None:
        if not getattr(self, "world_elevator_ui_open", False):
            return
        options: list[int] = list(getattr(self, "world_elevator_options", []))
        if not options:
            options = [1]
            self.world_elevator_options = options
        n = len(options)
        cols = max(1, int(getattr(self, "world_elevator_cols", 4)))
        rows_per_page = 4
        page_size = max(1, cols * rows_per_page)
        step = cols
        if pygame.key.get_mods() & pygame.KMOD_SHIFT:
            step = page_size
        dy = int(getattr(event, "y", 0))
        if dy == 0:
            return
        sel = int(getattr(self, "world_elevator_sel", 0)) % n
        sel = (sel - step) % n if dy > 0 else (sel + step) % n
        self.world_elevator_sel = int(sel)
        self.world_elevator_input = ""

    def _handle_world_elevator_ui_mouse(self, event: pygame.event.Event) -> None:
        if not getattr(self, "world_elevator_ui_open", False):
            return

        et = int(getattr(event, "type", 0))
        button = int(getattr(event, "button", 0))
        if et == int(pygame.MOUSEBUTTONDOWN) and button == 3:
            self._world_elevator_close()
            return

        if et not in (int(pygame.MOUSEMOTION), int(pygame.MOUSEBUTTONDOWN)):
            return
        if et == int(pygame.MOUSEBUTTONDOWN) and button != 1:
            return

        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return
        mx, my = int(internal[0]), int(internal[1])

        options: list[int] = list(getattr(self, "world_elevator_options", []))
        if not options:
            options = [1]
            self.world_elevator_options = options
        cols = max(1, int(getattr(self, "world_elevator_cols", 4)))
        rows_per_page = 4
        n = len(options)
        page_size = max(1, cols * rows_per_page)
        sel_i = int(getattr(self, "world_elevator_sel", 0)) % max(1, n)
        page = int(sel_i // page_size)
        start = int(page * page_size)
        end = int(min(int(n), int(start + page_size)))
        page_opts = list(options[start:end])
        rows = int(max(1, int(math.ceil(float(len(page_opts)) / float(cols)))))

        btn_w = 56
        btn_h = 28
        gap = 8
        grid_w = cols * btn_w + (cols - 1) * gap
        grid_h = rows * btn_h + (rows - 1) * gap
        panel = pygame.Rect(0, 0, grid_w + 40, grid_h + 98)
        panel.center = (INTERNAL_W // 2, INTERNAL_H // 2)

        x0 = panel.centerx - grid_w // 2
        y0 = panel.top + 66
        hit_i: int | None = None
        hit_floor: int | None = None
        for local_i, f in enumerate(page_opts):
            r = int(local_i) // cols
            c = int(local_i) % cols
            x = x0 + c * (btn_w + gap)
            y = y0 + r * (btn_h + gap)
            br = pygame.Rect(x, y, btn_w, btn_h)
            if br.collidepoint(mx, my):
                hit_i = int(start) + int(local_i)
                hit_floor = int(f)
                break

        if hit_i is None or hit_floor is None:
            return

        self.world_elevator_sel = int(hit_i)
        self.world_elevator_input = ""
        if et == int(pygame.MOUSEBUTTONDOWN) and button == 1:
            self._world_elevator_apply_floor(int(hit_floor))
            self._world_elevator_close()

    def _handle_world_elevator_ui_key(self, key: int) -> None:
        if not getattr(self, "world_elevator_ui_open", False):
            return
        options: list[int] = list(getattr(self, "world_elevator_options", []))
        if not options:
            options = [1]
            self.world_elevator_options = options
        n = len(options)
        cols = max(1, int(getattr(self, "world_elevator_cols", 4)))
        rows_per_page = 4
        page_size = max(1, cols * rows_per_page)
        sel = int(getattr(self, "world_elevator_sel", 0)) % n

        digit = self._key_digit(int(key))
        if digit is not None:
            cur = str(getattr(self, "world_elevator_input", ""))
            if len(cur) < 3:
                self.world_elevator_input = cur + digit
            return
        if key in (pygame.K_BACKSPACE, pygame.K_DELETE):
            cur = str(getattr(self, "world_elevator_input", ""))
            self.world_elevator_input = cur[:-1]
            return

        if key in (pygame.K_ESCAPE,):
            self._world_elevator_close()
            return
        if key in (pygame.K_RETURN, pygame.K_SPACE, pygame.K_e):
            typed = str(getattr(self, "world_elevator_input", "")).strip()
            self.world_elevator_input = ""
            if typed:
                try:
                    target = int(typed)
                except ValueError:
                    target = int(options[sel])
                self._world_elevator_apply_floor(int(target))
            else:
                self._world_elevator_apply_floor(int(options[sel]))
            self._world_elevator_close()
            return

        if key in (pygame.K_PAGEUP,):
            self.world_elevator_sel = int((sel - page_size) % n)
            self.world_elevator_input = ""
            return
        if key in (pygame.K_PAGEDOWN,):
            self.world_elevator_sel = int((sel + page_size) % n)
            self.world_elevator_input = ""
            return
        if key in (pygame.K_HOME,):
            self.world_elevator_sel = 0
            self.world_elevator_input = ""
            return
        if key in (pygame.K_END,):
            self.world_elevator_sel = int(n - 1)
            self.world_elevator_input = ""
            return

        if key in (pygame.K_LEFT, pygame.K_a):
            self.world_elevator_sel = int((sel - 1) % n)
        elif key in (pygame.K_RIGHT, pygame.K_d):
            self.world_elevator_sel = int((sel + 1) % n)
        elif key in (pygame.K_UP, pygame.K_w):
            self.world_elevator_sel = int((sel - cols) % n)
        elif key in (pygame.K_DOWN, pygame.K_s):
            self.world_elevator_sel = int((sel + cols) % n)
        self.world_elevator_input = ""

    def _hr_room_seed(self, room_id: str) -> int:
        seed = 0
        for ch in str(room_id):
            seed = (seed * 131 + ord(ch)) & 0xFFFFFFFF
        return int(seed)

    def _hr_room_storages_bind(self, room_id: str, *, populate: bool) -> None:
        room_id = str(room_id).strip()
        if not room_id:
            return
        store = getattr(self, "hr_room_storages", None)
        if not isinstance(store, dict):
            store = {}
            self.hr_room_storages = store
        pair = store.get(room_id)
        if (
            not isinstance(pair, tuple)
            or len(pair) != 2
            or not isinstance(pair[0], HardcoreSurvivalState._Inventory)
            or not isinstance(pair[1], HardcoreSurvivalState._Inventory)
        ):
            cab = HardcoreSurvivalState._Inventory(slots=[None] * 30, cols=6)
            fr = HardcoreSurvivalState._Inventory(slots=[None] * 12, cols=4)
            store[room_id] = (cab, fr)
            if populate:
                self._hr_room_storages_populate(room_id, cab=cab, fridge=fr)
            pair = store.get(room_id)
        if isinstance(pair, tuple) and len(pair) == 2:
            self.home_storage, self.fridge_storage = pair
            self.hr_current_room = str(room_id)
            lights = getattr(self, "hr_room_lights", None)
            if not isinstance(lights, dict):
                lights = {}
                self.hr_room_lights = lights
            if str(room_id) not in lights:
                lights[str(room_id)] = True

    def _hr_room_floor_items_bind(self, room_id: str, *, populate: bool) -> None:
        room_id = str(room_id).strip()
        if not room_id:
            self.hr_floor_items = []
            return
        store = getattr(self, "hr_room_floor_items", None)
        if not isinstance(store, dict):
            store = {}
            self.hr_room_floor_items = store
        items = store.get(room_id)
        if not isinstance(items, list):
            items = []
            store[room_id] = items
            if populate:
                self._hr_room_floor_items_populate(room_id, items=items)
        self.hr_floor_items = items

    def _hr_room_floor_items_populate(self, room_id: str, *, items: list["HardcoreSurvivalState._WorldItem"]) -> None:
        # Deterministic per-room floor loot (visible snacks on the ground).
        seed = self._hr_room_seed(str(room_id)) ^ (int(self.seed) & 0xFFFFFFFF) ^ 0x51F00D
        rng = random.Random(int(seed))

        cache = getattr(self, "_item_kind_cache", None)
        if not isinstance(cache, dict):
            cache = {}
            self._item_kind_cache = cache

        def pool(kind: str) -> list[str]:
            key = str(kind)
            got = cache.get(key)
            if isinstance(got, list):
                return got
            out: list[str] = []
            for iid, idef in self._ITEMS.items():
                if idef is None:
                    continue
                if str(getattr(idef, "kind", "")) == key:
                    out.append(str(iid))
            cache[key] = out
            return out

        foods = pool("food")
        drinks = pool("drink")
        meds = pool("med")

        snack_like = ("chips", "jerky", "candy", "chocolate", "nuts", "driedfruit", "seaweed", "crackers", "energybar")
        snacks = [iid for iid in foods if any(str(iid).startswith(f"food_{b}_") for b in snack_like)]
        if not snacks:
            snacks = foods

        # Prefer placing loot on clear floor tiles in the home layout.
        # (If layout changes, we still validate walkability.)
        candidates = [
            (12, 5),
            (11, 5),
            (18, 5),
            (19, 5),
            (20, 5),
            (18, 4),
            (19, 4),
        ]
        floor_tiles: list[tuple[int, int]] = []
        for tx, ty in candidates:
            ch = self._hr_int_char_at(int(tx), int(ty))
            if not self._hr_int_solid_tile(ch):
                floor_tiles.append((int(tx), int(ty)))
        if not floor_tiles:
            return

        picks: list[tuple[str, int]] = []
        if snacks:
            picks.append((rng.choice(snacks), int(rng.randint(1, 2))))
        if snacks and rng.random() < 0.75:
            picks.append((rng.choice(snacks), 1))
        if drinks and rng.random() < 0.85:
            picks.append((rng.choice(drinks), 1))
        if meds and rng.random() < 0.25:
            picks.append((rng.choice(meds), 1))

        tile = int(self._HR_INT_TILE_SIZE)
        rng.shuffle(floor_tiles)
        for (iid, qty), (tx, ty) in zip(picks, floor_tiles):
            items.append(
                HardcoreSurvivalState._WorldItem(
                    pos=pygame.Vector2((float(tx) + 0.5) * float(tile), (float(ty) + 0.5) * float(tile)),
                    item_id=str(iid),
                    qty=int(qty),
                )
            )

    def _hr_room_storages_populate(
        self,
        room_id: str,
        *,
        cab: "HardcoreSurvivalState._Inventory",
        fridge: "HardcoreSurvivalState._Inventory",
    ) -> None:
        # Deterministic per-room loot (so it doesn't change every visit).
        seed = self._hr_room_seed(str(room_id)) ^ (int(self.seed) & 0xFFFFFFFF) ^ 0xC8A19D2B
        rng = random.Random(int(seed))

        cache = getattr(self, "_item_kind_cache", None)
        if not isinstance(cache, dict):
            cache = {}
            self._item_kind_cache = cache

        def pool(kind: str) -> list[str]:
            key = str(kind)
            got = cache.get(key)
            if isinstance(got, list):
                return got
            out: list[str] = []
            for iid, idef in self._ITEMS.items():
                if idef is None:
                    continue
                if str(getattr(idef, "kind", "")) == key:
                    out.append(str(iid))
            cache[key] = out
            return out

        foods = pool("food")
        drinks = pool("drink")
        meds = pool("med")
        mats = pool("mat")
        tools = pool("tool")
        ammo = pool("ammo")
        guns = pool("gun")

        if drinks:
            for _ in range(int(rng.randint(1, 3))):
                fridge.add(rng.choice(drinks), 1, self._ITEMS)
        if foods and rng.random() < 0.75:
            for _ in range(int(rng.randint(0, 2))):
                fridge.add(rng.choice(foods), 1, self._ITEMS)

        if foods:
            for _ in range(int(rng.randint(1, 4))):
                cab.add(rng.choice(foods), 1, self._ITEMS)
        if meds and rng.random() < 0.70:
            for _ in range(int(rng.randint(0, 2))):
                cab.add(rng.choice(meds), 1, self._ITEMS)
        if mats and rng.random() < 0.55:
            for _ in range(int(rng.randint(0, 2))):
                cab.add(rng.choice(mats), int(rng.randint(2, 6)), self._ITEMS)
        if tools and rng.random() < 0.50:
            for _ in range(int(rng.randint(0, 2))):
                cab.add(rng.choice(tools), 1, self._ITEMS)
        if ammo and rng.random() < 0.45:
            for _ in range(int(rng.randint(0, 2))):
                cab.add(rng.choice(ammo), int(rng.randint(10, 36)), self._ITEMS)
        if guns and rng.random() < 0.12:
            cab.add(rng.choice(guns), 1, self._ITEMS)

    def _hr_enter_home(self) -> None:
        self.hr_hall_pos_before_home = pygame.Vector2(self.hr_int_pos)
        self.hr_mode = "home"
        self.hr_edit_mode = False
        self.hr_edit_dragging = False
        self.home_ui_open = False
        self.home_ui_open_block = None
        home_room = str(getattr(self, "home_highrise_room", "")).strip()
        if home_room:
            # Home room was pre-filled in on_enter(); still bind with populate=True so
            # we can also initialize the visible floor loot once.
            self._hr_room_storages_bind(home_room, populate=True)
        want_ver = int(getattr(self, "_HR_INT_HOME_LAYOUT_VERSION", 0))
        cur_ver = int(getattr(self, "hr_home_layout_version", 0))
        layout = getattr(self, "hr_home_layout", None)
        need_reset = bool(int(cur_ver) != int(want_ver))
        if not need_reset:
            if not isinstance(layout, list):
                need_reset = True
            else:
                norm = [str(r) for r in layout]
                if len(norm) != int(self._HR_INT_H) or any(len(r) != int(self._HR_INT_W) for r in norm):
                    need_reset = True
                # If the saved layout predates the bathroom/toilet addition, refresh it.
                if not any("O" in r for r in norm):
                    need_reset = True
                if not need_reset:
                    layout = norm
                    self.hr_home_layout = list(norm)

        if need_reset:
            layout = [str(r) for r in self._HR_INT_HOME_LAYOUT]
            self.hr_home_layout = list(layout)
            self.hr_home_layout_version = int(want_ver)

        self._hr_int_set_layout(list(layout or self._HR_INT_HOME_LAYOUT))
        if home_room:
            self._hr_room_floor_items_bind(home_room, populate=True)
        else:
            self.hr_floor_items = []

        door = self._hr_int_find("D")
        tile = int(self._HR_INT_TILE_SIZE)
        sx = int(int(self._HR_INT_W) // 2)
        sy = int(int(self._HR_INT_H) // 2)
        if door is not None:
            dx, dy = door
            spawn = (dx - 1, dy) if dx >= int(self._HR_INT_W) - 1 else (dx + 1, dy)
            sx, sy = spawn
            if self._hr_int_solid_tile(self._hr_int_char_at(sx, sy)):
                sx, sy = int(dx), int(dy)
        self.hr_int_pos = pygame.Vector2((float(sx) + 0.5) * float(tile), (float(sy) + 0.5) * float(tile))
        self.hr_int_vel = pygame.Vector2(0, 0)
        self.hr_int_walk_phase = 0.0
        self._set_hint("E", seconds=1.1)

    def _hr_leave_home(self) -> None:
        floor = int(getattr(self, "hr_floor", 1))
        self._clear_player_pose()
        self.hr_mode = "hall"
        self.hr_edit_mode = False
        self.hr_edit_dragging = False
        self.home_ui_open = False
        self.home_ui_open_block = None
        self.hr_current_room = ""
        self.hr_floor_items = []
        self._hr_int_set_layout(self._hr_make_hall_layout(floor))        
        saved = getattr(self, "hr_hall_pos_before_home", None)
        if isinstance(saved, pygame.Vector2):
            self.hr_int_pos = pygame.Vector2(saved)
        self.hr_int_vel = pygame.Vector2(0, 0)
        self.hr_int_walk_phase = 0.0
        self._set_hint("", seconds=0.9)

    def _hr_interior_enter(self, sb: HardcoreSurvivalState._SpecialBuilding) -> None:
        self.inv_open = False
        self.rv_ui_open = False
        self._gallery_open = False
        self.hr_interior = True
        self.hr_elevator_ui_open = False
        self.hr_travel_active = False
        self.hr_travel_kind = ""
        self.hr_edit_mode = False
        self.hr_edit_dragging = False
        self.home_ui_open = False
        self.home_ui_open_block = None
        self.hr_edit_blocks: list[tuple[str, list[tuple[int, int]]]] = []
        self.hr_edit_index = 0
        self.mount = None
        self.player.vel.update(0, 0)
        self.player.walk_phase *= 0.85
        self.rv.vel.update(0, 0)
        self.bike.vel.update(0, 0)

        self.hr_building = sb
        self.hr_max_floors = int(getattr(sb, "floors", 0) or int(self._HR_INT_MAX_FLOORS_DEFAULT))
        if self.hr_max_floors <= 0:
            self.hr_max_floors = int(self._HR_INT_MAX_FLOORS_DEFAULT)

        home_door = getattr(self, "home_highrise_door", None)
        is_home = bool(home_door is not None and home_door in set(getattr(sb, "door_tiles", ())))
        if is_home:
            self.hr_home_floor = int(getattr(self, "home_highrise_floor", 0))
            self.hr_home_door_index = int(getattr(self, "home_highrise_door_index", 0))
        else:
            self.hr_home_floor = -1
            self.hr_home_door_index = 0

        self.hr_world_return = pygame.Vector2(self.player.pos)
        self._hr_set_floor(1)
        # Walk into the lobby, then auto-walk to the elevator and open the floor UI.
        self.hr_auto_walk_to_elevator = True
        self.hr_auto_walk_delay = 0.12

        door = self._hr_int_find("D")
        if door is not None:
            dx, dy = door
            tile = int(self._HR_INT_TILE_SIZE)
            spawn = (dx - 1, dy) if dx >= int(self._HR_INT_W) - 1 else (dx + 1, dy)
            sx, sy = spawn
            if self._hr_int_solid_tile(self._hr_int_char_at(sx, sy)):
                sx, sy = int(dx), int(dy)
            self.hr_int_pos = pygame.Vector2((sx + 0.5) * tile, (sy + 0.5) * tile)

        if is_home and int(self.hr_home_floor) > 0:
            home_room = str(getattr(self, "home_highrise_room", "")).strip()
            if home_room:
                self._set_hint(f" {home_room}", seconds=2.0)
            else:
                self._set_hint(f" {int(self.hr_home_floor)} ", seconds=2.0)
        else:
            self._set_hint("E", seconds=1.6)   

    def _hr_interior_exit(self) -> None:
        if not getattr(self, "hr_interior", False):
            return
        self._clear_player_pose()
        self.hr_interior = False
        self.hr_elevator_ui_open = False
        self.hr_travel_active = False
        self.hr_travel_kind = ""
        self.hr_edit_mode = False
        self.hr_edit_dragging = False
        self.home_ui_open = False
        self.home_ui_open_block = None
        self.hr_current_room = ""
        self.hr_building = None
        self.hr_mode = "lobby"
        self._hr_int_set_layout(self._HR_INT_LOBBY_LAYOUT)
        self.player.pos.update(self.hr_world_return)
        self._set_hint("", seconds=1.0)

    def _hr_room_toggle_light(self, room_id: str) -> bool:
        room_id = str(room_id).strip()
        lights = getattr(self, "hr_room_lights", None)
        if not isinstance(lights, dict):
            lights = {}
            self.hr_room_lights = lights
        if room_id and room_id not in lights:
            lights[room_id] = True
        cur = bool(lights.get(room_id, True)) if room_id else True
        if room_id:
            lights[room_id] = (not cur)
        new_state = bool(lights.get(room_id, True)) if room_id else cur
        self._set_hint("" if new_state else "", seconds=0.9)
        return bool(new_state)

    def _hr_interior_interact(self) -> None:
        if not getattr(self, "hr_interior", False):
            return
        mode = str(getattr(self, "hr_mode", "lobby"))

        # Visible floor loot in apartments (snacks / supplies).
        if mode == "home":
            items = getattr(self, "hr_floor_items", None)
            if isinstance(items, list) and items:
                focus = pygame.Vector2(self.hr_int_pos)
                best_i: int | None = None
                best_d2 = float("inf")
                for i, it in enumerate(items):
                    if not isinstance(it, HardcoreSurvivalState._WorldItem):
                        continue
                    d2 = float((pygame.Vector2(it.pos) - focus).length_squared())
                    if d2 < best_d2:
                        best_d2 = d2
                        best_i = int(i)
                if best_i is not None and best_d2 <= (22.0 * 22.0):
                    it = items[int(best_i)]
                    want = int(getattr(it, "qty", 1) or 1)
                    want = max(1, want)
                    left = int(self.inventory.add(str(getattr(it, "item_id", "")), want, self._ITEMS))
                    took = int(want - left)
                    if took > 0:
                        if left <= 0:
                            items.pop(int(best_i))
                        else:
                            it.qty = int(left)
                        idef = self._ITEMS.get(str(getattr(it, "item_id", "")))
                        name = str(getattr(idef, "name", getattr(it, "item_id", "")))
                        self._set_hint(f"+{took} {name}", seconds=0.9)
                        return
        tx, ty = self._hr_int_player_tile()
        candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
        chosen: tuple[int, int, str] | None = None
        interact = {"D", "E", "H", "A", "a", "B", "^", "v"}
        if mode == "home":
            interact.update({"S", "F", "C", "P", "X", "L", "O"})
        for cx, cy in candidates:
            ch = self._hr_int_char_at(cx, cy)
            if ch in interact:
                chosen = (cx, cy, ch)
                break
        if chosen is None:
            self._set_hint("", seconds=1.0)
            return

        # While sitting, prefer PC/TV over the seat tile so "E" doesn't just stand up.
        if (
            mode == "home"
            and str(getattr(self, "player_pose", "")) == "sit"
            and str(getattr(self, "player_pose_space", "")) == "hr"
            and chosen[2] == "C"
        ):
            for cx, cy in candidates:
                ch2 = self._hr_int_char_at(cx, cy)
                if ch2 in ("P", "X"):
                    chosen = (cx, cy, ch2)
                    break
        _cx, _cy, ch = chosen
        if ch == "E":
            self._hr_elevator_open()
            return
        if ch == "D":
            if mode == "home":
                self._hr_leave_home()
                return
            self._hr_interior_exit()
            return
        if ch == "L" and mode == "home":
            self._hr_room_toggle_light(str(getattr(self, "hr_current_room", "")).strip())
            return
        if ch in ("^", "v"):
            floor = int(getattr(self, "hr_floor", 1))
            max_f = int(max(1, int(getattr(self, "hr_max_floors", int(self._HR_INT_MAX_FLOORS_DEFAULT)))))
            if ch == "^":
                if floor >= max_f:
                    self._set_hint("", seconds=1.0)
                    return
                self._hr_travel_start(int(floor + 1), kind="stairs", spawn_at="stairs_down")
                return
            if floor <= 1:
                self._set_hint("", seconds=1.0)
                return
            self._hr_travel_start(int(floor - 1), kind="stairs", spawn_at="stairs_up")
            return
        if ch == "S" and mode == "home":
            w = int(self._HR_INT_W)
            h = int(self._HR_INT_H)
            seen: set[tuple[int, int]] = set()
            stack = [(int(_cx), int(_cy))]
            cells: list[tuple[int, int]] = []
            while stack:
                cx, cy = stack.pop()
                cx = int(cx)
                cy = int(cy)
                if (cx, cy) in seen:
                    continue
                if not (0 <= cx < w and 0 <= cy < h):
                    continue
                if str(self._hr_int_char_at(cx, cy))[:1] != "S":
                    continue
                seen.add((cx, cy))
                cells.append((cx, cy))
                stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
            if cells:
                min_x = min(int(p[0]) for p in cells)
                max_x = max(int(p[0]) for p in cells)
                min_y = min(int(p[1]) for p in cells)
                max_y = max(int(p[1]) for p in cells)
                self._home_ui_open(open_block=(int(min_x), int(min_y), int(max_x), int(max_y)), storage_kind="cabinet")
            else:
                self._home_ui_open(open_block=(int(_cx), int(_cy), int(_cx), int(_cy)), storage_kind="cabinet")
            return
        if ch == "F" and mode == "home":
            w = int(self._HR_INT_W)
            h = int(self._HR_INT_H)
            seen: set[tuple[int, int]] = set()
            stack = [(int(_cx), int(_cy))]
            cells: list[tuple[int, int]] = []
            while stack:
                cx, cy = stack.pop()
                cx = int(cx)
                cy = int(cy)
                if (cx, cy) in seen:
                    continue
                if not (0 <= cx < w and 0 <= cy < h):
                    continue
                if str(self._hr_int_char_at(cx, cy))[:1] != "F":
                    continue
                seen.add((cx, cy))
                cells.append((cx, cy))
                stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
            if cells:
                min_x = min(int(p[0]) for p in cells)
                max_x = max(int(p[0]) for p in cells)
                min_y = min(int(p[1]) for p in cells)
                max_y = max(int(p[1]) for p in cells)
                self._home_ui_open(open_block=(int(min_x), int(min_y), int(max_x), int(max_y)), storage_kind="fridge")
            else:
                self._home_ui_open(open_block=(int(_cx), int(_cy), int(_cx), int(_cy)), storage_kind="fridge")
            return
        if ch == "P" and mode == "home":
            if str(getattr(self, "player_pose", "")) != "sit" or str(getattr(self, "player_pose_space", "")) != "hr":
                self._set_hint("", seconds=1.0)
                return
            dx = int(_cx) - int(tx)
            dy = int(_cy) - int(ty)
            if abs(int(dx)) >= abs(int(dy)):
                self.hr_int_facing = pygame.Vector2(1 if int(dx) > 0 else -1 if int(dx) < 0 else 0, 0)
            else:
                self.hr_int_facing = pygame.Vector2(0, 1 if int(dy) > 0 else -1 if int(dy) < 0 else 0)
            self._toggle_world_map(open=True)
            self._set_hint("", seconds=1.0)
            return
        if ch == "X" and mode == "home":
            dx = int(_cx) - int(tx)
            dy = int(_cy) - int(ty)
            if abs(int(dx)) >= abs(int(dy)):
                self.hr_int_facing = pygame.Vector2(1 if int(dx) > 0 else -1 if int(dx) < 0 else 0, 0)
            else:
                self.hr_int_facing = pygame.Vector2(0, 1 if int(dy) > 0 else -1 if int(dy) < 0 else 0)
            room_id = str(getattr(self, "hr_current_room", "")).strip()
            tv_states = getattr(self, "hr_room_tvs", None)
            if not isinstance(tv_states, dict):
                tv_states = {}
                self.hr_room_tvs = tv_states
            if room_id:
                tv_states[room_id] = not bool(tv_states.get(room_id, False))
            tv_now = bool(tv_states.get(room_id, False)) if room_id else False
            if tv_now:
                self.player.morale = float(clamp(float(self.player.morale) + 2.0, 0.0, 100.0))
            self._gallery_open = False
            self._set_hint("" if tv_now else "", seconds=1.0)
            return
        if ch == "O" and mode == "home":
            mods = pygame.key.get_mods()
            is_shift = bool(int(mods) & int(pygame.KMOD_SHIFT))
            if is_shift:
                self.player.morale = float(clamp(float(self.player.morale) + 1.0, 0.0, 100.0))
                self._set_hint("", seconds=1.0)
            else:
                self.player.morale = float(clamp(float(self.player.morale) + 0.5, 0.0, 100.0))
                self._set_hint("Shift+E ", seconds=1.2)
            return
        if ch == "C" and mode == "home":
            if str(getattr(self, "player_pose", "")) == "sit" and str(getattr(self, "player_pose_space", "")) == "hr":
                self._clear_player_pose()
                self._set_hint("", seconds=0.8)
                return
            w = int(self._HR_INT_W)
            h = int(self._HR_INT_H)
            seen: set[tuple[int, int]] = set()
            stack = [(int(_cx), int(_cy))]
            cells: list[tuple[int, int]] = []
            while stack:
                cx, cy = stack.pop()
                cx = int(cx)
                cy = int(cy)
                if (cx, cy) in seen:
                    continue
                if not (0 <= cx < w and 0 <= cy < h):
                    continue
                if str(self._hr_int_char_at(cx, cy))[:1] != "C":
                    continue
                seen.add((cx, cy))
                cells.append((cx, cy))
                stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
            tile = int(self._HR_INT_TILE_SIZE)
            if cells:
                min_x = min(int(p[0]) for p in cells)
                max_x = max(int(p[0]) for p in cells)
                min_y = min(int(p[1]) for p in cells)
                max_y = max(int(p[1]) for p in cells)
                ax = (float(min_x + max_x + 1) * float(tile)) * 0.5
                ay = (float(min_y + max_y + 1) * float(tile)) * 0.5
            else:
                ax = (float(_cx) + 0.5) * float(tile)
                ay = (float(_cy) + 0.5) * float(tile)
            # Prefer a nearby walkable tile so sitting never snaps into walls/outside.
            prefer = pygame.Vector2(self.hr_int_pos)
            cand: list[tuple[float, int, int]] = []
            for sx, sy in (cells if cells else [(int(_cx), int(_cy))]):
                for dx2, dy2 in (
                    (1, 0),
                    (-1, 0),
                    (0, 1),
                    (0, -1),
                    (1, 1),
                    (1, -1),
                    (-1, 1),
                    (-1, -1),
                ):
                    nx = int(sx) + int(dx2)
                    ny = int(sy) + int(dy2)
                    if not (0 <= int(nx) < int(w) and 0 <= int(ny) < int(h)):
                        continue
                    if self._hr_int_solid_tile(self._hr_int_char_at(int(nx), int(ny))):
                        continue
                    cxp = (float(nx) + 0.5) * float(tile)
                    cyp = (float(ny) + 0.5) * float(tile)
                    d2 = float((cxp - prefer.x) ** 2 + (cyp - prefer.y) ** 2)
                    cand.append((d2, int(nx), int(ny)))
            if cand:
                cand.sort(key=lambda v: v[0])
                nx, ny = int(cand[0][1]), int(cand[0][2])
                ax = (float(nx) + 0.5) * float(tile)
                ay = (float(ny) + 0.5) * float(tile)
            self._set_player_pose("sit", space="hr", anchor=(ax, ay), seconds=0.0)
            self._set_hint("", seconds=1.4)
            return
        if ch == "B":
            self.player.stamina = 100.0
            self.player.morale = float(clamp(self.player.morale + 15.0, 0.0, 100.0))
            w = int(self._HR_INT_W)
            h = int(self._HR_INT_H)
            seen: set[tuple[int, int]] = set()
            stack = [(int(_cx), int(_cy))]
            cells: list[tuple[int, int]] = []
            while stack:
                cx, cy = stack.pop()
                cx = int(cx)
                cy = int(cy)
                if (cx, cy) in seen:
                    continue
                if not (0 <= cx < w and 0 <= cy < h):
                    continue
                if str(self._hr_int_char_at(cx, cy))[:1] != "B":
                    continue
                seen.add((cx, cy))
                cells.append((cx, cy))
                stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
            tile = int(self._HR_INT_TILE_SIZE)
            if cells:
                min_x = min(int(p[0]) for p in cells)
                max_x = max(int(p[0]) for p in cells)
                min_y = min(int(p[1]) for p in cells)
                max_y = max(int(p[1]) for p in cells)
                ax = (float(min_x + max_x + 1) * float(tile)) * 0.5
                ay = (float(min_y + max_y + 1) * float(tile)) * 0.5
            else:
                ax = (float(_cx) + 0.5) * float(tile)
                ay = (float(_cy) + 0.5) * float(tile)
            self._set_player_pose("sleep", space="hr", anchor=(ax, ay), seconds=2.6)
            self._set_hint(" / ", seconds=1.4)
            return
        if ch == "H":
            if mode == "hall" and int(getattr(self, "hr_floor", 1)) == int(getattr(self, "hr_home_floor", -1)):
                self._hr_enter_home()
                return
            self._set_hint("", seconds=1.2)
            return
        if ch in ("A", "a"):
            doors = list(getattr(self, "_HR_INT_APT_DOORS", []))
            unit = 0
            for i, (dx, dy) in enumerate(doors):
                if int(dx) == int(_cx) and int(dy) == int(_cy):
                    unit = int(i) + 1
                    break
            floor = int(getattr(self, "hr_floor", 1))
            base_room_id = f"{int(floor)}{int(unit):02d}" if unit > 0 else f"{int(floor)}??"
            home_room = str(getattr(self, "home_highrise_room", "")).strip()
            if home_room and base_room_id == home_room:
                if int(self.inventory.count("key_house")) <= 0:
                    self._set_hint("", seconds=1.1)
                    return
                self._hr_enter_home()
                return

            # Other units: locked unless the door is broken ('a').
            if ch != "a":
                self._set_hint("", seconds=1.2)
                return

            room_id = str(base_room_id)
            sb = getattr(self, "hr_building", None)
            if isinstance(sb, HardcoreSurvivalState._SpecialBuilding):
                room_id = f"{int(sb.tx0)}_{int(sb.ty0)}_{base_room_id}"

            # Break-in room: use the default apartment layout + per-room storage.
            self.hr_hall_pos_before_home = pygame.Vector2(self.hr_int_pos)
            self.hr_mode = "home"
            self.hr_edit_mode = False
            self.hr_edit_dragging = False
            self.home_ui_open = False
            self.home_ui_open_block = None
            self._hr_room_storages_bind(room_id, populate=True)
            self._hr_int_set_layout([str(r) for r in self._HR_INT_HOME_LAYOUT])
            self._hr_room_floor_items_bind(room_id, populate=True)

            door = self._hr_int_find("D")
            tile = int(self._HR_INT_TILE_SIZE)
            if door is None:
                self.hr_int_pos = pygame.Vector2((self._HR_INT_W / 2.0) * tile, (self._HR_INT_H / 2.0) * tile)
            else:
                dx, dy = door
                spawn = (dx - 1, dy) if dx >= int(self._HR_INT_W) - 1 else (dx + 1, dy)
                sx, sy = spawn
                if self._hr_int_solid_tile(self._hr_int_char_at(sx, sy)):
                    sx, sy = int(dx), int(dy)
                self.hr_int_pos = pygame.Vector2((sx + 0.5) * tile, (sy + 0.5) * tile)
            self.hr_int_vel = pygame.Vector2(0, 0)
            self.hr_int_walk_phase = 0.0
            self._set_hint(f"{base_room_id}", seconds=1.0)
            return
        self._set_hint("", seconds=1.0)

    def _update_gun_timers(self, dt: float, *, allow_fire: bool) -> None:
        if self.gun is None:
            return
        self.gun.cooldown_left = max(0.0, float(self.gun.cooldown_left) - dt)
        if self.gun.reload_left > 0.0:
            self.gun.reload_left = max(0.0, float(self.gun.reload_left) - dt)
            if self.gun.reload_left <= 0.0:
                self._reload_lock_dir = None
                gun_def = self._gun_effective_def(self.gun)
                if gun_def is not None:
                    need = int(gun_def.mag_size) - int(self.gun.mag)
                    if need > 0:
                        got = self.inventory.remove(gun_def.ammo_item, need)
                        self.gun.mag = int(self.gun.mag) + int(got)
            return
        if allow_fire and self.mount is None and pygame.mouse.get_pressed()[0]:
            self._fire()

    def _interior_floor_surface(self, w: int, h: int, *, kind: str) -> pygame.Surface:
        w = int(w)
        h = int(h)
        kind = str(kind)
        key = (kind, w, h)

        cache = getattr(self, "_int_floor_cache", None)
        if not isinstance(cache, dict):
            cache = {}
            self._int_floor_cache = cache
        cached = cache.get(key)
        if isinstance(cached, pygame.Surface):
            return cached

        def _tint(c: tuple[int, int, int], add: tuple[int, int, int]) -> tuple[int, int, int]:
            return (
                int(clamp(int(c[0]) + int(add[0]), 0, 255)),
                int(clamp(int(c[1]) + int(add[1]), 0, 255)),
                int(clamp(int(c[2]) + int(add[2]), 0, 255)),
            )

        surf = pygame.Surface((w, h))

        if kind == "rv":
            # RV interior: perfectly uniform floor color (no seams/boards), per user request.
            surf.fill((92, 82, 68))
        elif kind in ("home", "wood"):
            base = (102, 90, 72) if kind == "home" else (92, 82, 68)
            seam = _tint(base, (-20, -20, -22))
            seam2 = _tint(base, (-10, -10, -12))
            knot = _tint(base, (-28, -22, -18))
            hi = _tint(base, (18, 16, 14))
            board_h = 6
            surf.fill(base)

            for y0 in range(0, h, board_h):
                row = int(y0 // board_h)
                row_col = _tint(base, (2, 1, 0) if (row % 2 == 0) else (-2, -2, -3))
                surf.fill(row_col, pygame.Rect(0, y0, w, min(board_h, h - y0)))
                surf.fill(seam, pygame.Rect(0, y0, w, 1))

                # Staggered vertical seams so it reads like boards.
                off = (row * 17) % 29
                board_len = 46
                x = -off
                while x < w:
                    sx = int(x + board_len)
                    if 0 <= sx < w:
                        surf.fill(seam2, pygame.Rect(sx, y0 + 1, 1, min(board_h - 1, h - y0 - 1)))
                    x += board_len

                # Subtle grain / knots (deterministic).
                for gx in range((row * 13) % 31, w, 37):
                    gy = y0 + 2 + ((gx + row * 7) % 2)
                    if 0 <= gy < h:
                        surf.fill(knot, pygame.Rect(gx, gy, 2, 1))
                        if gx + 10 < w and row % 3 == 0:
                            surf.fill(hi, pygame.Rect(gx + 10, gy, 1, 1))

        elif kind in ("school", "linoleum"):
            # School: dirty linoleum tiles (checker + grout + specks).
            base1 = (74, 74, 82)
            base2 = (66, 66, 74)
            grout = (52, 52, 60)
            speck1 = (84, 84, 92)
            speck2 = (58, 58, 66)
            cell = 10
            for y0 in range(0, h, cell):
                for x0 in range(0, w, cell):
                    col = base1 if (((x0 // cell) + (y0 // cell)) % 2 == 0) else base2
                    surf.fill(col, pygame.Rect(x0, y0, min(cell, w - x0), min(cell, h - y0)))
            for x in range(0, w, cell):
                surf.fill(grout, pygame.Rect(x, 0, 1, h))
            for y in range(0, h, cell):
                surf.fill(grout, pygame.Rect(0, y, w, 1))
            for y in range(2, h, 11):
                for x in range((y * 7) % 13, w, 29):
                    surf.fill(speck1 if ((x + y) % 2 == 0) else speck2, pygame.Rect(x, y, 1, 1))
        else:
            # Lobby / hall: stone tile with subtle grid + speckles.      
            base = (70, 72, 78)
            grid = (56, 58, 64)
            speck1 = (82, 84, 90)
            speck2 = (60, 62, 68)
            surf.fill(base)
            cell = 20
            for x in range(0, w, cell):
                surf.fill(grid, pygame.Rect(x, 0, 1, h))
            for y in range(0, h, cell):
                surf.fill(grid, pygame.Rect(0, y, w, 1))
            for y in range(2, h, 9):
                for x in range((y * 7) % 11, w, 23):
                    surf.fill(speck1 if ((x + y) % 2 == 0) else speck2, pygame.Rect(x, y, 1, 1))

        cache[key] = surf
        return surf

    def _marble_surface(
        self,
        w: int,
        h: int,
        *,
        seed: int,
        base: tuple[int, int, int] = (220, 222, 228),
    ) -> pygame.Surface:
        w = int(max(1, w))
        h = int(max(1, h))
        seed = int(seed) & 0xFFFFFFFF
        base = (int(base[0]), int(base[1]), int(base[2]))
        key = (w, h, seed, base)

        cache = getattr(self, "_marble_cache", None)
        if not isinstance(cache, dict):
            cache = {}
            self._marble_cache = cache
        cached = cache.get(key)
        if isinstance(cached, pygame.Surface):
            return cached

        surf = pygame.Surface((w, h))
        surf.fill(base)

        rnd = random.Random(int(seed) ^ (int(w) << 16) ^ int(h) ^ 0xBADC0FFE)

        # Specks (reads like stone).
        specks = int(clamp((w * h) // 45, 10, 160))
        for _ in range(specks):
            x = int(rnd.randrange(w))
            y = int(rnd.randrange(h))
            d = int(rnd.randrange(-16, 10))
            col = (
                int(clamp(int(base[0]) + d, 0, 255)),
                int(clamp(int(base[1]) + d, 0, 255)),
                int(clamp(int(base[2]) + d, 0, 255)),
            )
            surf.set_at((x, y), col)

        vein_dark = (
            int(clamp(int(base[0]) - 28, 0, 255)),
            int(clamp(int(base[1]) - 28, 0, 255)),
            int(clamp(int(base[2]) - 24, 0, 255)),
        )
        vein_light = (
            int(clamp(int(base[0]) - 12, 0, 255)),
            int(clamp(int(base[1]) - 12, 0, 255)),
            int(clamp(int(base[2]) - 10, 0, 255)),
        )

        # A few drifting veins (deterministic, cached so no flicker).
        vein_count = int(clamp((w + h) // 28, 2, 5))
        for i in range(vein_count):
            x0 = int(rnd.randrange(-w // 2, w))
            y0 = int(rnd.randrange(0, h))
            x1 = int(rnd.randrange(w, int(w * 2.0)))
            y1 = int(clamp(int(y0 + rnd.randrange(-h // 2, h // 2)), 0, h - 1))

            steps = int(max(3, w // 10))
            px, py = x0, y0
            for s in range(steps):
                t = float(s + 1) / float(steps)
                nx = int(round(float(x0) + (float(x1) - float(x0)) * t + rnd.randrange(-2, 3)))
                ny = int(round(float(y0) + (float(y1) - float(y0)) * t + rnd.randrange(-2, 3)))
                pygame.draw.line(surf, vein_light, (px, py), (nx, ny), 1)
                if i % 2 == 0:
                    pygame.draw.line(surf, vein_dark, (px + 1, py), (nx + 1, ny), 1)
                px, py = nx, ny

        cache[key] = surf
        return surf

    def _window_view_surface(self, w: int, h: int) -> pygame.Surface:
        w = int(w)
        h = int(h)
        daylight, tday = self._daylight_amount()
        season = self._season_index()
        wkind = str(getattr(self, "weather_kind", "clear"))
        inten = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))

        tbin = int(clamp(int(tday * 64.0), 0, 63))
        dbin = int(clamp(int(daylight * 16.0), 0, 16))
        ibin = int(clamp(int(inten * 10.0), 0, 10))
        key = (w, h, int(season), str(wkind), int(tbin), int(dbin), int(ibin))

        cache = getattr(self, "_window_view_cache", None)
        if not isinstance(cache, dict):
            cache = {}
            self._window_view_cache = cache
        cached = cache.get(key)
        if isinstance(cached, pygame.Surface):
            return cached

        def _lerp(a: float, b: float, t: float) -> float:
            return float(a + (b - a) * t)

        def _lerp_c(a: tuple[int, int, int], b: tuple[int, int, int], t: float) -> tuple[int, int, int]:
            return (
                int(round(_lerp(float(a[0]), float(b[0]), t))),
                int(round(_lerp(float(a[1]), float(b[1]), t))),
                int(round(_lerp(float(a[2]), float(b[2]), t))),
            )

        def _mul_c(c: tuple[int, int, int], m: float) -> tuple[int, int, int]:
            return (
                int(clamp(int(round(float(c[0]) * m)), 0, 255)),
                int(clamp(int(round(float(c[1]) * m)), 0, 255)),
                int(clamp(int(round(float(c[2]) * m)), 0, 255)),
            )

        day_sky_top = (78, 146, 224)
        day_sky_bot = (166, 214, 252)
        night_sky_top = (8, 10, 18)
        night_sky_bot = (24, 28, 44)
        sky_top = _lerp_c(night_sky_top, day_sky_top, float(daylight))
        sky_bot = _lerp_c(night_sky_bot, day_sky_bot, float(daylight))

        gloom = 1.0
        if wkind == "cloudy":
            gloom = 1.0 - 0.22 * inten
        elif wkind == "rain":
            gloom = 1.0 - 0.30 * inten
        elif wkind == "storm":
            gloom = 1.0 - 0.44 * inten
        elif wkind == "snow":
            gloom = 1.0 - 0.18 * inten
        sky_top = _mul_c(sky_top, gloom)
        sky_bot = _mul_c(sky_bot, gloom)
        if wkind == "snow" and inten > 0.05:
            sky_top = _lerp_c(sky_top, (200, 210, 230), 0.18 * inten)
            sky_bot = _lerp_c(sky_bot, (230, 240, 250), 0.24 * inten)

        if season == 0:  # spring
            ground = (74, 150, 78)
        elif season == 1:  # summer
            ground = (58, 135, 66)
        elif season == 2:  # autumn
            ground = (122, 118, 70)
        else:  # winter
            ground = (160, 162, 176)
        ground = _mul_c(ground, 0.85 + 0.15 * daylight)
        if wkind == "snow" and inten > 0.15:
            ground = _lerp_c(ground, (210, 214, 224), 0.45 * inten)

        base = pygame.Surface((w, h))
        for yy in range(h):
            t = float(yy) / max(1.0, float(h - 1))
            base.fill(_lerp_c(sky_top, sky_bot, t), pygame.Rect(0, yy, w, 1))
        gh = max(3, int(h // 3))
        base.fill(ground, pygame.Rect(0, h - gh, w, gh))
        base.fill((16, 16, 22), pygame.Rect(0, h - gh, w, 1))

        # Dawn / dusk warm stripe near horizon.
        if 0.0 < daylight < 1.0:
            warm = (220, 150, 96) if tday < 0.5 else (226, 140, 86)
            warm_y = int(h - gh - 2)
            if 0 <= warm_y < h:
                base.fill(_mul_c(warm, 0.65), pygame.Rect(0, warm_y, w, 1))

        # Tiny silhouettes (reads as distant trees/buildings).
        if w >= 10 and h >= 8:
            base.fill((18, 18, 22), pygame.Rect(2, int(h - gh - 3), 2, 3))
            base.fill((18, 18, 22), pygame.Rect(int(w - 5), int(h - gh - 4), 3, 4))

        view = pygame.Surface((w, h), pygame.SRCALPHA)
        view.blit(base, (0, 0))

        # Glass tint + simple reflection lines.
        tint = pygame.Surface((w, h), pygame.SRCALPHA)
        tint.fill((60, 86, 120, 55))
        pygame.draw.line(tint, (240, 244, 255, 70), (1, 1), (w - 2, 1), 1)
        pygame.draw.line(tint, (210, 220, 240, 45), (1, 2), (w - 3, 2), 1)
        view.blit(tint, (0, 0))

        cache[key] = view
        return view

    def _draw_window_precip(self, surface: pygame.Surface, rect: pygame.Rect, *, kind: str, intensity: float) -> None:
        kind = str(kind)
        intensity = float(clamp(float(intensity), 0.0, 1.0))
        if intensity <= 0.05:
            return

        w = int(rect.w)
        h = int(rect.h)
        if w <= 0 or h <= 0:
            return

        t = float(getattr(self, "world_time_s", 0.0))
        overlay = pygame.Surface((w, h), pygame.SRCALPHA)

        if kind in ("rain", "storm"):
            alpha = int(clamp(int(70 + 140 * intensity), 0, 220))
            col = (220, 232, 255, alpha)
            step = max(4, int(round(8 - 3 * intensity)))
            speed = 140.0 if kind == "rain" else 220.0
            off = int((t * speed) % step)
            dx = max(5, int(round(h * 0.55)))
            for x in range(-h, w + h, step):
                xx = int(x + off)
                pygame.draw.line(overlay, col, (xx, 0), (xx + dx, h), 1)
            # A few bigger drops.
            if kind == "storm" and intensity > 0.35:
                for i in range(0, w, 9):
                    yy = int((i * 7 + int(t * 60)) % max(1, h))
                    overlay.fill((240, 246, 255, alpha), pygame.Rect(i, yy, 1, 2))

        elif kind == "snow":
            alpha = int(clamp(int(60 + 120 * intensity), 0, 210))
            col = (240, 244, 250, alpha)
            for y in range(1, h, 5):
                for x in range((y * 7 + int(t * 30)) % 9, w, 11):
                    overlay.fill(col, pygame.Rect(x, y, 1, 1))

        else:
            return

        surface.blit(overlay, rect.topleft)

    def _draw_rv_interior_scene(self, surface: pygame.Surface) -> None:
        # Removed: full-screen RV interior scene. The RV interior is now only
        # supported in world-camera mode via `_rv_world_interior`.
        return
        tile = int(self._RV_INT_TILE_SIZE)
        map_w = int(self._RV_INT_W) * tile
        map_h = int(self._RV_INT_H) * tile
        map_x = (INTERNAL_W - map_w) // 2
        map_y = 92
        panel = pygame.Rect(map_x - 10, map_y - 10, map_w + 20, map_h + 20)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (70, 70, 86), panel, 2, border_radius=12)

        # Cozier interior rendering (less grid, more furniture detail) inspired by the
        # user's reference screenshot.
        map_rect = pygame.Rect(map_x, map_y, map_w, map_h)
        surface.blit(self._interior_floor_surface(map_w, map_h, kind="rv"), map_rect.topleft)

        wall = (26, 26, 32)
        wall_hi = (56, 56, 70)
        wall_edge = (12, 12, 16)
        frame = (88, 80, 70)
        frame2 = (62, 56, 48)
        outline = (10, 10, 12)

        bed_matt = (186, 170, 156)
        bed_blank = (132, 154, 112)
        bed_blank2 = (108, 130, 92)
        pillow = (238, 238, 244)
        wood = (98, 78, 56)
        wood2 = (74, 58, 42)
        steel = (216, 220, 228)
        steel2 = (134, 140, 152)
        seat = (72, 86, 148)
        seat2 = (54, 64, 118)

        wkind = str(getattr(self, "weather_kind", "clear"))
        inten = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))
        glass_w = max(4, int(tile - 6))
        glass_h = max(4, int(tile - 8))
        win_view = self._window_view_surface(glass_w, glass_h)
        layout = self._vehicle_int_layout()

        bed_done: set[tuple[int, int]] = set()
        k_done: set[tuple[int, int]] = set()
        for y, row in enumerate(layout):
            for x in range(int(self._RV_INT_W)):
                ch = row[x] if x < len(row) else "W"
                r = pygame.Rect(map_x + x * tile, map_y + y * tile, tile, tile)

                if ch in ("W", "V"):
                    pygame.draw.rect(surface, wall, r)
                    pygame.draw.rect(surface, wall_hi, pygame.Rect(r.x, r.y, r.w, 4))
                    pygame.draw.rect(surface, wall_edge, r, 1)
                    pygame.draw.rect(surface, frame2, pygame.Rect(r.x, r.bottom - 4, r.w, 2))
                    if ch == "V":
                        glass = pygame.Rect(r.x + 3, r.y + 4, r.w - 6, r.h - 8)
                        wv = win_view
                        if wv.get_width() != glass.w or wv.get_height() != glass.h:
                            wv = pygame.transform.scale(wv, (int(glass.w), int(glass.h)))
                        surface.blit(wv, glass.topleft)
                        pygame.draw.rect(surface, frame, glass.inflate(4, 4), 1, border_radius=2)
                        pygame.draw.rect(surface, outline, glass, 1)
                        pygame.draw.line(surface, (40, 40, 50), (glass.centerx, glass.top + 1), (glass.centerx, glass.bottom - 2), 1)
                    continue

                if ch == "D":
                    dr = pygame.Rect(r.x + 4, r.y + 3, r.w - 8, r.h - 6)
                    pygame.draw.rect(surface, wood, dr, border_radius=2)
                    pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                    pygame.draw.rect(surface, wood2, pygame.Rect(dr.x + 2, dr.y + 2, dr.w - 4, 4))
                    pygame.draw.circle(surface, outline, (dr.right - 4, dr.centery), 2)
                    continue

                if ch == "B":
                    if (int(x), int(y)) in bed_done:
                        continue

                    bw = 1
                    while self._rv_int_char_at(int(x) + int(bw), int(y)) == "B":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._rv_int_char_at(int(x), int(ny)) != "B":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._rv_int_char_at(int(x) + int(dx), int(ny)) != "B":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1

                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            bed_done.add((int(x) + int(dx), int(y) + int(dy)))

                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    bed_r = br.inflate(-4, -8)
                    sh = pygame.Surface((bed_r.w, bed_r.h), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 90), sh.get_rect(), border_radius=6)
                    surface.blit(sh, (bed_r.x + 2, bed_r.y + 3))

                    pygame.draw.rect(surface, bed_matt, bed_r, border_radius=6)
                    pygame.draw.rect(surface, outline, bed_r, 1, border_radius=6)

                    hb = pygame.Rect(bed_r.x, bed_r.y, 8, bed_r.h)
                    pygame.draw.rect(surface, wood2, hb, border_radius=5)
                    pygame.draw.rect(surface, outline, hb, 1, border_radius=5)

                    p1 = pygame.Rect(bed_r.x + 10, bed_r.y + 4, max(10, bed_r.w // 5), 7)
                    p2 = pygame.Rect(p1.x, p1.y + 10, p1.w, 7)
                    pygame.draw.rect(surface, pillow, p1, border_radius=3)
                    pygame.draw.rect(surface, pillow, p2, border_radius=3)
                    pygame.draw.rect(surface, outline, p1, 1, border_radius=3)
                    pygame.draw.rect(surface, outline, p2, 1, border_radius=3)

                    bl = pygame.Rect(bed_r.x + 10, bed_r.y + 20, bed_r.w - 14, max(10, bed_r.h - 24))
                    pygame.draw.rect(surface, bed_blank, bl, border_radius=5)
                    pygame.draw.rect(surface, outline, bl, 1, border_radius=5)
                    for sx in range(bl.x + 6, bl.right - 4, 10):
                        pygame.draw.line(surface, bed_blank2, (sx, bl.y + 2), (sx, bl.bottom - 3), 1)
                    # Bed legs/frame (so it doesn't look like it floats).
                    floor_y = int(br.bottom - 3)
                    leg_y0 = int(bed_r.bottom - 2)
                    leg_h = int(floor_y - leg_y0)
                    if leg_h > 0:
                        leg_col = self._tint(wood2, add=(-12, -12, -12))
                        for lx in (int(bed_r.x + 6), int(bed_r.right - 8)):
                            leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                            surface.fill(leg_col, leg)
                            pygame.draw.rect(surface, outline, leg, 1)
                            surface.fill(leg_col, pygame.Rect(int(lx - 1), int(floor_y), 4, 1))
                    continue

                if ch == "S":
                    cab = pygame.Rect(r.x + 2, r.y + 6, r.w - 4, r.h - 10)
                    sh = pygame.Surface((cab.w, cab.h), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 80), sh.get_rect(), border_radius=4)
                    surface.blit(sh, (cab.x + 2, cab.y + 3))

                    pygame.draw.rect(surface, wood, cab, border_radius=3)
                    pygame.draw.rect(surface, outline, cab, 1, border_radius=3)
                    pygame.draw.rect(surface, wood2, pygame.Rect(cab.x + 1, cab.y + 1, cab.w - 2, 3))
                    pygame.draw.rect(surface, wood2, pygame.Rect(cab.x + 1, cab.bottom - 4, cab.w - 2, 3))

                    is_open = bool(getattr(self, "rv_ui_open", False)) and str(getattr(self, "rv_ui_focus", "map")) == "storage"
                    if is_open:
                        inner = cab.inflate(-4, -6)
                        pygame.draw.rect(surface, (20, 20, 24), inner, border_radius=2)
                        pygame.draw.rect(surface, outline, inner, 1, border_radius=2)
                        for sy in range(inner.y + 3, inner.bottom - 1, 5):
                            pygame.draw.line(surface, (44, 44, 52), (inner.x + 2, sy), (inner.right - 3, sy), 1)

                        door_w = max(4, int(cab.w // 4))
                        ld = pygame.Rect(cab.x + 1, cab.y + 3, door_w, cab.h - 6)
                        rd = pygame.Rect(cab.right - door_w - 1, cab.y + 3, door_w, cab.h - 6)
                        pygame.draw.rect(surface, wood, ld, border_radius=2)
                        pygame.draw.rect(surface, outline, ld, 1, border_radius=2)
                        pygame.draw.rect(surface, wood, rd, border_radius=2)
                        pygame.draw.rect(surface, outline, rd, 1, border_radius=2)
                        # Tiny visible supplies.
                        can = pygame.Rect(inner.x + 3, inner.y + 4, 3, 5)
                        surface.fill((180, 60, 70), can)
                        pygame.draw.rect(surface, outline, can, 1)
                        jar = pygame.Rect(inner.right - 7, inner.y + 5, 4, 4)
                        surface.fill((90, 140, 190), jar)
                        pygame.draw.rect(surface, outline, jar, 1)
                    else:
                        midx = int(cab.centerx)
                        pygame.draw.line(surface, wood2, (midx, cab.y + 4), (midx, cab.bottom - 5), 2)
                        pygame.draw.line(surface, outline, (midx, cab.y + 4), (midx, cab.bottom - 5), 1)
                        for hx in (midx - 4, midx + 3):
                            hrect = pygame.Rect(int(hx), cab.y + 8, 2, 5)
                            surface.fill((220, 220, 230), hrect)
                            pygame.draw.rect(surface, outline, hrect, 1)
                    continue

                if ch == "T":
                    top = pygame.Rect(r.x + 2, r.y + 7, r.w - 4, r.h - 12)
                    pygame.draw.rect(surface, wood, top, border_radius=2)
                    pygame.draw.rect(surface, outline, top, 1, border_radius=2)
                    pygame.draw.rect(surface, wood2, pygame.Rect(top.x + 1, top.y + 1, top.w - 2, 3))
                    # Table legs/frame (so it reads like real furniture).
                    floor_y = int(r.bottom - 3)
                    leg_y0 = int(top.bottom - 1)
                    leg_h = int(floor_y - leg_y0)
                    if leg_h > 0 and top.w >= 10:
                        leg_col = self._tint(wood2, add=(-10, -10, -10))
                        for lx in (int(top.x + 2), int(top.right - 4)):
                            leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                            surface.fill(leg_col, leg)
                            pygame.draw.rect(surface, outline, leg, 1)
                            surface.fill(leg_col, pygame.Rect(int(lx - 1), int(floor_y), 4, 1))
                    if (x + y) % 3 == 0:
                        mug = pygame.Rect(top.centerx - 2, top.y + 4, 4, 4)
                        pygame.draw.rect(surface, (230, 230, 240), mug, border_radius=1)
                        pygame.draw.rect(surface, outline, mug, 1, border_radius=1)
                    elif (x + y) % 3 == 1:
                        screen = pygame.Rect(top.centerx - 5, top.y + 2, 10, 6)
                        pygame.draw.rect(surface, (36, 38, 44), screen, border_radius=2)
                        pygame.draw.rect(surface, steel2, screen, 1, border_radius=2)
                    continue

                if ch == "K":
                    if (x, y) in k_done:
                        continue

                    bw = 1
                    while self._rv_int_char_at(int(x) + int(bw), int(y)) == "K":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._rv_int_char_at(int(x), int(ny)) != "K":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._rv_int_char_at(int(x) + int(dx), int(ny)) != "K":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            k_done.add((int(x) + int(dx), int(y) + int(dy)))

                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    obj = br.inflate(-6, -10)
                    sh = pygame.Surface((obj.w, obj.h), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 70), sh.get_rect(), border_radius=5)
                    surface.blit(sh, (obj.x + 2, obj.y + 3))

                    # Long counter: top (lighter) + front face (darker) to read as a continuous kitchen.
                    top_h = int(clamp(int(obj.h * 0.28), 7, 10))
                    top_r = pygame.Rect(obj.x, obj.y, obj.w, top_h)
                    front_r = pygame.Rect(obj.x, obj.y + top_h - 1, obj.w, obj.h - (top_h - 1))
                    pygame.draw.rect(surface, wood2, front_r, border_radius=6)
                    pygame.draw.rect(surface, outline, front_r, 1, border_radius=6)
                    pygame.draw.rect(surface, wood, top_r, border_radius=6)
                    pygame.draw.rect(surface, outline, top_r, 1, border_radius=6)
                    pygame.draw.line(surface, frame2, (top_r.x + 2, top_r.top + 1), (top_r.right - 3, top_r.top + 1), 1)
                    pygame.draw.line(surface, frame2, (top_r.x + 2, top_r.bottom - 2), (top_r.right - 3, top_r.bottom - 2), 1)

                    # Cabinet doors + handles on the front face (depth cues).
                    modules = int(max(2, int(bw)))
                    for i in range(1, modules):
                        xline = int(front_r.x + (front_r.w * i) / modules)
                        pygame.draw.line(surface, frame2, (xline, front_r.y + 4), (xline, front_r.bottom - 5), 2)
                        pygame.draw.line(surface, outline, (xline, front_r.y + 4), (xline, front_r.bottom - 5), 1)
                    for i in range(modules):
                        cx = int(front_r.x + (front_r.w * (i + 0.5)) / modules)
                        hrect = pygame.Rect(cx - 1, front_r.y + 8, 2, 7)
                        surface.fill((220, 220, 230), hrect)
                        pygame.draw.rect(surface, outline, hrect, 1)

                    # Sink + stove placed once across the whole block.
                    sink_w = int(clamp(int(top_r.w * 0.18), 12, 18))
                    sink_h = int(clamp(int(top_r.h - 3), 5, 7))
                    sink = pygame.Rect(top_r.x + int(top_r.w * 0.16), top_r.y + 2, sink_w, sink_h)
                    pygame.draw.rect(surface, steel, sink, border_radius=3)
                    pygame.draw.rect(surface, outline, sink, 1, border_radius=3)
                    pygame.draw.circle(surface, (60, 60, 70), (sink.right - 3, sink.y + 3), 1)
                    pygame.draw.line(surface, steel2, (sink.x + 2, sink.y + 1), (sink.x + 2, sink.y - 3), 1)
                    pygame.draw.line(surface, steel2, (sink.x + 2, sink.y - 3), (sink.x + 6, sink.y - 3), 1)

                    stove_w = int(clamp(int(top_r.w * 0.20), 12, 18))
                    stove_h = sink_h
                    stove = pygame.Rect(top_r.right - int(top_r.w * 0.18) - stove_w, top_r.y + 2, stove_w, stove_h)
                    pygame.draw.rect(surface, (40, 40, 50), stove, border_radius=3)
                    pygame.draw.rect(surface, outline, stove, 1, border_radius=3)
                    pygame.draw.circle(surface, (80, 80, 90), (stove.x + stove_w // 3, stove.centery), 2)
                    pygame.draw.circle(surface, (80, 80, 90), (stove.right - stove_w // 3, stove.centery), 2)

                    # Pots / bowls / plates on the countertop.
                    plate = pygame.Rect(top_r.right - 14, top_r.y + 2, 12, 5)
                    pygame.draw.ellipse(surface, (232, 232, 238), plate)
                    pygame.draw.ellipse(surface, outline, plate, 1)
                    bowl = pygame.Rect(top_r.x + 8, top_r.y + 2, 10, 5)
                    pygame.draw.ellipse(surface, (200, 210, 220), bowl)
                    pygame.draw.ellipse(surface, outline, bowl, 1)
                    pot = pygame.Rect(top_r.centerx - 8, top_r.y + 1, 16, 6)
                    pygame.draw.rect(surface, (40, 40, 50), pot, border_radius=3)
                    pygame.draw.rect(surface, outline, pot, 1, border_radius=3)
                    pygame.draw.line(surface, steel2, (pot.x + 2, pot.y + 2), (pot.right - 3, pot.y + 2), 1)
                    pygame.draw.line(surface, outline, (pot.x + 3, pot.y + 1), (pot.right - 4, pot.y + 1), 1)

                    # Small rack cue above the counter.
                    rack_y = int(top_r.y - 6)
                    if rack_y >= int(br.y) + 1:
                        pygame.draw.line(surface, outline, (top_r.x + 2, rack_y), (top_r.right - 3, rack_y), 1)
                        for ux in (top_r.x + 8, top_r.centerx, top_r.right - 10):
                            pygame.draw.line(surface, steel2, (int(ux), rack_y + 1), (int(ux), rack_y + 4), 1)
                    continue

                if ch == "H":
                    bench = pygame.Rect(r.x + 2, r.y + 7, r.w - 4, r.h - 11)
                    pygame.draw.rect(surface, wood2, bench, border_radius=2)
                    pygame.draw.rect(surface, outline, bench, 1, border_radius=2)
                    pygame.draw.rect(surface, wood, pygame.Rect(bench.x + 1, bench.y + 1, bench.w - 2, 3))
                    pygame.draw.line(surface, steel2, (bench.x + 2, bench.y), (bench.right - 3, bench.y + 5), 1)
                    pygame.draw.rect(surface, steel2, pygame.Rect(bench.x + 4, bench.y + 6, 5, 2), border_radius=1)
                    continue

                if ch == "R":
                    # Steering wheel + dashboard (cab).
                    wheel = (34, 34, 42)
                    wheel_hi = self._tint(wheel, add=(34, 34, 40))
                    wheel_lo = self._tint(wheel, add=(-18, -18, -18))

                    cx = int(r.centerx - 2)
                    cy = int(r.centery + 1)
                    outer = 7
                    try:
                        bg = surface.get_at((int(cx), int(cy)))[:3]
                    except Exception:
                        bg = (48, 46, 44)

                    pygame.draw.circle(surface, wheel, (cx, cy), int(outer))
                    pygame.draw.circle(surface, outline, (cx, cy), int(outer), 1)
                    pygame.draw.circle(surface, bg, (cx, cy), int(max(1, outer - 3)))

                    pygame.draw.line(surface, wheel_lo, (cx, cy), (cx, cy - outer + 2), 2)
                    pygame.draw.line(surface, wheel_lo, (cx, cy), (cx - outer + 2, cy + 1), 2)
                    pygame.draw.line(surface, wheel_lo, (cx, cy), (cx + outer - 2, cy + 1), 2)

                    hub = pygame.Rect(cx - 2, cy - 2, 5, 5)
                    pygame.draw.rect(surface, wheel_hi, hub, border_radius=2)
                    pygame.draw.rect(surface, outline, hub, 1, border_radius=2)

                    dash = pygame.Rect(r.right - 6, r.y + 6, 5, r.h - 12)
                    pygame.draw.rect(surface, (28, 28, 34), dash, border_radius=3)
                    pygame.draw.rect(surface, outline, dash, 1, border_radius=3)
                    pygame.draw.circle(surface, (180, 200, 220), (dash.centerx, dash.y + 4), 2)
                    pygame.draw.circle(surface, outline, (dash.centerx, dash.y + 4), 2, 1)
                    continue

                if ch == "C":
                    # Choose a facing direction so cabin seats read as facing the windshield / steering wheel.
                    facing = "down"
                    try:
                        if self._rv_int_char_at(int(x) + 1, int(y)) == "R":
                            facing = "right"
                        elif self._rv_int_char_at(int(x) - 1, int(y)) == "R":
                            facing = "left"
                        elif self._rv_int_char_at(int(x), int(y) - 1) == "R":
                            facing = "up"
                        elif self._rv_int_char_at(int(x), int(y) + 1) == "R":
                            facing = "down"
                        else:
                            if self._rv_int_char_at(int(x) + 1, int(y)) == "V":
                                facing = "right"
                            elif self._rv_int_char_at(int(x) - 1, int(y)) == "V":
                                facing = "left"
                            elif self._rv_int_char_at(int(x), int(y) - 1) == "V":
                                facing = "up"
                            elif self._rv_int_char_at(int(x), int(y) + 1) == "V":
                                facing = "down"
                    except Exception:
                        facing = "down"
                    # If still ambiguous, aim the seat toward the steering wheel (even if not adjacent).
                    if facing == "down":
                        try:
                            rpos = self._rv_int_find("R")
                        except Exception:
                            rpos = None
                        if isinstance(rpos, tuple) and len(rpos) == 2:
                            rx, ry = int(rpos[0]), int(rpos[1])
                            dx = int(rx) - int(x)
                            dy = int(ry) - int(y)
                            # Only affect seats reasonably close to the cockpit.
                            if abs(int(dx)) + abs(int(dy)) <= 8:
                                if abs(int(dx)) > abs(int(dy)):
                                    facing = "right" if int(dx) > 0 else "left"
                                else:
                                    facing = "down" if int(dy) > 0 else "up"

                    seat_surf = pygame.Surface((int(tile), int(tile)), pygame.SRCALPHA)
                    back = pygame.Rect(4, 5, int(tile) - 8, 7)
                    base = pygame.Rect(4, 11, int(tile) - 8, 6)
                    pygame.draw.rect(seat_surf, seat2, back, border_radius=3)
                    pygame.draw.rect(seat_surf, outline, back, 1, border_radius=3)
                    pygame.draw.rect(seat_surf, seat, base, border_radius=3)
                    pygame.draw.rect(seat_surf, outline, base, 1, border_radius=3)
                    pygame.draw.rect(
                        seat_surf,
                        self._tint(seat, add=(16, 16, 16)),
                        pygame.Rect(int(base.x + 1), int(base.y + 1), int(base.w - 2), 2),
                        border_radius=2,
                    )

                    arm_l = pygame.Rect(int(base.x - 1), int(base.y - 1), 3, 3)
                    arm_r = pygame.Rect(int(base.right - 2), int(base.y - 1), 3, 3)
                    pygame.draw.rect(seat_surf, seat2, arm_l, border_radius=2)
                    pygame.draw.rect(seat_surf, seat2, arm_r, border_radius=2)
                    pygame.draw.rect(seat_surf, outline, arm_l, 1, border_radius=2)
                    pygame.draw.rect(seat_surf, outline, arm_r, 1, border_radius=2)

                    head = pygame.Rect(int(back.centerx - 3), int(back.y - 3), 6, 3)
                    pygame.draw.rect(seat_surf, seat2, head, border_radius=2)
                    pygame.draw.rect(seat_surf, outline, head, 1, border_radius=2)

                    floor_y = int(tile - 3)
                    leg_y0 = int(base.bottom - 1)
                    leg_h = int(floor_y - leg_y0)
                    if leg_h > 0:
                        leg_col = self._tint(seat2, add=(-24, -24, -24))
                        for lx in (int(base.x + 2), int(base.right - 4)):
                            leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                            seat_surf.fill(leg_col, leg)
                            pygame.draw.rect(seat_surf, outline, leg, 1)

                    if facing == "up":
                        seat_surf = pygame.transform.rotate(seat_surf, 180)
                    elif facing == "left":
                        seat_surf = pygame.transform.rotate(seat_surf, 90)
                    elif facing == "right":
                        seat_surf = pygame.transform.rotate(seat_surf, -90)
                    surface.blit(seat_surf, r.topleft)
                    continue

        if getattr(self, "rv_edit_mode", False):
            blocks = getattr(self, "rv_edit_blocks", None)
            if isinstance(blocks, list) and blocks:
                sel_i = int(getattr(self, "rv_edit_index", 0)) % len(blocks)
                _ch, cells = blocks[sel_i]
                min_x = min(int(p[0]) for p in cells)
                max_x = max(int(p[0]) for p in cells)
                min_y = min(int(p[1]) for p in cells)
                max_y = max(int(p[1]) for p in cells)
                sel = pygame.Rect(
                    int(map_x + min_x * tile),
                    int(map_y + min_y * tile),
                    int((max_x - min_x + 1) * tile),
                    int((max_y - min_y + 1) * tile),
                )
                ov = pygame.Surface((sel.w, sel.h), pygame.SRCALPHA)
                ov.fill((255, 220, 140, 50))
                pygame.draw.rect(ov, (255, 220, 140, 120), ov.get_rect(), 2, border_radius=8)
                surface.blit(ov, sel.topleft)

        face = pygame.Vector2(self.rv_int_facing)
        if face.length_squared() <= 0.001:
            face = pygame.Vector2(0, 1)
        if abs(face.y) >= abs(face.x):
            d = "down" if face.y >= 0 else "up"
        else:
            d = "right" if face.x >= 0 else "left"
        pose = str(getattr(self, "player_pose", "")).strip()
        pose_space = str(getattr(self, "player_pose_space", "")).strip()
        pose_anchor = getattr(self, "player_pose_anchor", None)
        use_pose = bool(pose and pose_space == "rv" and pose_anchor is not None)
        if use_pose:
            p = pygame.Vector2(float(pose_anchor[0]), float(pose_anchor[1]))
            if pose == "sleep":
                frame = int(float(getattr(self, "player_pose_phase", 0.0)) * 2.0) % 2
                base = self._get_pose_sprite("sleep", frame=frame)
            else:
                base = self._get_pose_sprite("sit", direction=d, frame=0)
        else:
            p = pygame.Vector2(self.rv_int_pos)
            speed2 = float(self.rv_int_vel.length_squared())
            pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
            pf_run = getattr(self, "player_frames_run", None)
            is_run = bool(getattr(self, "player_sprinting", False))
            pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
            frames = pf.get(d, pf["down"])
            if speed2 <= 0.2 or len(frames) <= 1:
                base = frames[0]
            else:
                walk = frames[1:]
                phase = (float(self.rv_int_walk_phase) % math.tau) / math.tau
                idx = int(phase * len(walk)) % len(walk)
                base = walk[idx]

        scale = int(max(1, int(self._RV_INT_SPRITE_SCALE)))
        spr = pygame.transform.scale(base, (int(base.get_width()) * scale, int(base.get_height()) * scale))
        sx = int(round(map_x + p.x))
        sy = int(round(map_y + p.y))
        if use_pose and pose == "sleep":
            shadow = pygame.Rect(0, 0, 20, 8)
            shadow.center = (sx, sy + 4)
            sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
            pygame.draw.ellipse(sh, (0, 0, 0, 90), sh.get_rect())
            surface.blit(sh, shadow.topleft)
            rect = spr.get_rect(center=(sx, sy + 2))
            surface.blit(spr, rect)
            self._last_player_screen_rect = pygame.Rect(rect)
        elif use_pose and pose == "sit":
            shadow = pygame.Rect(0, 0, 16, 7)
            shadow.center = (sx, sy + 6)
            sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
            pygame.draw.ellipse(sh, (0, 0, 0, 110), sh.get_rect())
            surface.blit(sh, shadow.topleft)
            rect = spr.get_rect(center=(sx, sy + 4))
            surface.blit(spr, rect)
            self._last_player_screen_rect = pygame.Rect(rect)
        else:
            shadow = pygame.Rect(0, 0, 14, 6)
            shadow.center = (sx, sy + 8)
            sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
            pygame.draw.ellipse(sh, (0, 0, 0, 120), sh.get_rect())
            surface.blit(sh, shadow.topleft)
            rect = spr.get_rect()
            rect.midbottom = (sx, sy + 12)
            surface.blit(spr, rect)
            self._last_player_screen_rect = pygame.Rect(rect)

        # Hover: furniture details + outline.
        mouse = None
        if (
            not self.inv_open
            and not bool(getattr(self, "rv_ui_open", False))
            and not bool(getattr(self, "world_map_open", False))
        ):
            mouse = self.app.screen_to_internal(pygame.mouse.get_pos())
        if mouse is not None:
            mx, my = int(mouse[0]), int(mouse[1])
            if map_rect.collidepoint(mx, my):
                ix = int((mx - int(map_x)) // int(tile))
                iy = int((my - int(map_y)) // int(tile))
                ch = str(self._rv_int_char_at(ix, iy))[:1]
                movable = {"B", "S", "K", "H", "T", "C"}
                if ch in movable:
                    w = int(self._RV_INT_W)
                    h = int(self._RV_INT_H)
                    seen: set[tuple[int, int]] = set()
                    stack = [(int(ix), int(iy))]
                    cells: list[tuple[int, int]] = []
                    while stack:
                        cx, cy = stack.pop()
                        cx = int(cx)
                        cy = int(cy)
                        if (cx, cy) in seen:
                            continue
                        if not (0 <= cx < w and 0 <= cy < h):
                            continue
                        if str(self._rv_int_char_at(cx, cy))[:1] != ch:
                            continue
                        seen.add((cx, cy))
                        cells.append((cx, cy))
                        stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
                    if cells:
                        min_x = min(int(p[0]) for p in cells)
                        max_x = max(int(p[0]) for p in cells)
                        min_y = min(int(p[1]) for p in cells)
                        max_y = max(int(p[1]) for p in cells)
                        sel = pygame.Rect(
                            int(map_x + min_x * tile),
                            int(map_y + min_y * tile),
                            int((max_x - min_x + 1) * tile),
                            int((max_y - min_y + 1) * tile),
                        )
                        ov = pygame.Surface((sel.w, sel.h), pygame.SRCALPHA)
                        ov.fill((255, 220, 140, 20))
                        pygame.draw.rect(ov, (255, 220, 140, 150), ov.get_rect(), 2, border_radius=8)
                        surface.blit(ov, sel.topleft)

                        meta: dict[str, tuple[str, str]] = {
                            "B": ("", ""),
                            "S": ("", ""),
                            "T": ("", "/"),
                            "K": ("", "/"),
                            "H": ("", "/"),
                            "C": ("", ""),
                        }
                        name, desc = meta.get(ch, ("", ""))
                        if bool(getattr(self, "rv_edit_mode", False)):
                            hint = " |  | R "
                        else:
                            hint = "R  | "
                        self._hover_tooltip = ([str(name), str(desc), str(hint)], (mx, my))
        return

        floor_a = (64, 62, 58)
        floor_b = (58, 56, 52)
        wall = (22, 22, 26)
        wall_hi = (38, 38, 46)
        bed = (170, 150, 140)
        bed2 = (128, 108, 100)
        shelf = (92, 78, 62)
        shelf2 = (66, 56, 46)
        table = (88, 72, 54)
        table2 = (60, 50, 38)
        seat = (56, 72, 140)
        seat2 = (40, 52, 112)
        kitchen = (86, 78, 68)
        kitchen2 = (60, 54, 46)
        steel = (220, 220, 230)
        work = (96, 84, 66)
        work2 = (62, 54, 42)
        tool = (150, 150, 160)
        door = (240, 220, 140)

        # Window "outside view" cache (small stylized sky/ground) so the RV
        # interior feels like a real space with windows.
        daylight, tday = self._daylight_amount()
        season = self._season_index()
        wkind = str(getattr(self, "weather_kind", "clear"))
        inten = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))

        def _lerp(a: float, b: float, t: float) -> float:
            return float(a + (b - a) * t)

        def _lerp_c(a: tuple[int, int, int], b: tuple[int, int, int], t: float) -> tuple[int, int, int]:
            return (
                int(round(_lerp(float(a[0]), float(b[0]), t))),
                int(round(_lerp(float(a[1]), float(b[1]), t))),
                int(round(_lerp(float(a[2]), float(b[2]), t))),
            )

        def _mul_c(c: tuple[int, int, int], m: float) -> tuple[int, int, int]:
            return (
                int(clamp(int(round(float(c[0]) * m)), 0, 255)),
                int(clamp(int(round(float(c[1]) * m)), 0, 255)),
                int(clamp(int(round(float(c[2]) * m)), 0, 255)),
            )

        glass_w = max(4, int(tile - 6))
        glass_h = max(4, int(tile - 8))
        tbin = int(clamp(int(tday * 64.0), 0, 63))
        dbin = int(clamp(int(daylight * 16.0), 0, 16))
        ibin = int(clamp(int(inten * 10.0), 0, 10))
        wkey = (glass_w, glass_h, int(season), str(wkind), int(tbin), int(dbin), int(ibin))

        win_view: pygame.Surface | None = getattr(self, "_rv_win_view_cache", None)
        if (
            win_view is None
            or getattr(self, "_rv_win_view_cache_key", None) != wkey
            or win_view.get_width() != glass_w
            or win_view.get_height() != glass_h
        ):
            day_sky_top = (78, 146, 224)
            day_sky_bot = (166, 214, 252)
            night_sky_top = (8, 10, 18)
            night_sky_bot = (24, 28, 44)
            sky_top = _lerp_c(night_sky_top, day_sky_top, float(daylight))
            sky_bot = _lerp_c(night_sky_bot, day_sky_bot, float(daylight))

            gloom = 1.0
            if wkind == "cloudy":
                gloom = 1.0 - 0.22 * inten
            elif wkind == "rain":
                gloom = 1.0 - 0.30 * inten
            elif wkind == "storm":
                gloom = 1.0 - 0.44 * inten
            elif wkind == "snow":
                gloom = 1.0 - 0.18 * inten
            sky_top = _mul_c(sky_top, gloom)
            sky_bot = _mul_c(sky_bot, gloom)
            if wkind == "snow" and inten > 0.05:
                sky_top = _lerp_c(sky_top, (200, 210, 230), 0.18 * inten)
                sky_bot = _lerp_c(sky_bot, (230, 240, 250), 0.24 * inten)

            if season == 0:  # spring
                ground = (74, 150, 78)
            elif season == 1:  # summer
                ground = (58, 135, 66)
            elif season == 2:  # autumn
                ground = (122, 118, 70)
            else:  # winter
                ground = (160, 162, 176)
            ground = _mul_c(ground, 0.85 + 0.15 * daylight)
            if wkind == "snow" and inten > 0.15:
                ground = _lerp_c(ground, (210, 214, 224), 0.45 * inten)

            base = pygame.Surface((glass_w, glass_h))
            for yy in range(int(glass_h)):
                t = float(yy) / max(1.0, float(glass_h - 1))
                base.fill(_lerp_c(sky_top, sky_bot, t), pygame.Rect(0, int(yy), int(glass_w), 1))
            gh = max(3, int(glass_h // 3))
            base.fill(ground, pygame.Rect(0, int(glass_h - gh), int(glass_w), int(gh)))
            base.fill((16, 16, 22), pygame.Rect(0, int(glass_h - gh), int(glass_w), 1))

            # Dawn / dusk warm stripe near horizon.
            if 0.0 < daylight < 1.0:
                warm = (220, 150, 96) if tday < 0.5 else (226, 140, 86)
                warm_y = int(glass_h - gh - 2)
                if 0 <= warm_y < glass_h:
                    base.fill(_mul_c(warm, 0.65), pygame.Rect(0, warm_y, int(glass_w), 1))

            # Tiny silhouettes (reads as distant trees/buildings).
            if glass_w >= 10 and glass_h >= 8:
                base.fill((18, 18, 22), pygame.Rect(2, int(glass_h - gh - 3), 2, 3))
                base.fill((18, 18, 22), pygame.Rect(int(glass_w - 5), int(glass_h - gh - 4), 3, 4))

            win_view = pygame.Surface((glass_w, glass_h), pygame.SRCALPHA)
            win_view.blit(base, (0, 0))
            tint = pygame.Surface((glass_w, glass_h), pygame.SRCALPHA)
            tint.fill((60, 86, 120, 55))
            pygame.draw.line(tint, (240, 244, 255, 70), (1, 1), (int(glass_w - 2), 1), 1)
            pygame.draw.line(tint, (210, 220, 240, 45), (1, 2), (int(glass_w - 3), 2), 1)
            win_view.blit(tint, (0, 0))
            self._rv_win_view_cache = win_view
            self._rv_win_view_cache_key = wkey

        bed_done: set[tuple[int, int]] = set()
        for y, row in enumerate(self._RV_INT_LAYOUT):
            for x in range(int(self._RV_INT_W)):
                ch = row[x] if x < len(row) else "W"
                r = pygame.Rect(map_x + x * tile, map_y + y * tile, tile, tile)
                if ch in ("W", "V"):
                    pygame.draw.rect(surface, wall, r)
                    pygame.draw.rect(surface, wall_hi, pygame.Rect(r.x, r.y, r.w, 3))
                    pygame.draw.rect(surface, (0, 0, 0), r, 1)
                    if ch == "V":
                        glass = pygame.Rect(r.x + 3, r.y + 4, r.w - 6, r.h - 8)
                        if win_view is not None and glass.w > 0 and glass.h > 0:
                            wv = win_view
                            if wv.get_width() != glass.w or wv.get_height() != glass.h:
                                wv = pygame.transform.scale(wv, (int(glass.w), int(glass.h)))
                            surface.blit(wv, glass.topleft)
                        pygame.draw.rect(surface, (10, 10, 12), glass, 1)
                        pygame.draw.line(
                            surface,
                            (40, 40, 50),
                            (glass.centerx, glass.top + 1),
                            (glass.centerx, glass.bottom - 2),
                            1,
                        )
                    continue

                col = floor_a if ((x + y) % 2 == 0) else floor_b
                pygame.draw.rect(surface, col, r)
                pygame.draw.rect(surface, (0, 0, 0), r, 1)

                if ch == "D":
                    pygame.draw.rect(surface, door, pygame.Rect(r.right - 4, r.y + 3, 3, r.h - 6))
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.right - 4, r.y + 3, 3, r.h - 6), 1)
                elif ch == "B":
                    if (int(x), int(y)) in bed_done:
                        continue

                    # Find the full bed block (contiguous 'B's) and draw as one object
                    # so it reads clearly as a single bed.
                    bw = 1
                    while self._rv_int_char_at(int(x) + int(bw), int(y)) == "B":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._rv_int_char_at(int(x), int(ny)) != "B":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._rv_int_char_at(int(x) + int(dx), int(ny)) != "B":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1

                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            bed_done.add((int(x) + int(dx), int(y) + int(dy)))

                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    bed_r = pygame.Rect(br.x + 2, br.y + 3, br.w - 4, br.h - 6)
                    pygame.draw.rect(surface, bed, bed_r, border_radius=4)
                    pygame.draw.rect(surface, (10, 10, 12), bed_r, 1, border_radius=4)

                    # Pillow + blanket band.
                    pillow_w = int(clamp(int(bed_r.w // 3), 8, max(8, bed_r.w - 4)))
                    pillow = pygame.Rect(bed_r.x + 2, bed_r.y + 2, pillow_w, 6)
                    pygame.draw.rect(surface, (230, 230, 235), pillow, border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pillow, 1, border_radius=2)
                    pygame.draw.rect(surface, bed2, pygame.Rect(bed_r.x + 2, bed_r.y + 10, bed_r.w - 4, 6), border_radius=2)

                    for sx in range(bed_r.x + 6, bed_r.right - 4, 6):
                        pygame.draw.line(surface, (10, 10, 12), (sx, bed_r.y + 11), (sx, bed_r.y + 15), 1)
                    continue
                elif ch == "S":
                    pygame.draw.rect(surface, shelf, pygame.Rect(r.x + 3, r.y + 3, r.w - 6, r.h - 6), border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 3, r.y + 3, r.w - 6, r.h - 6), 1, border_radius=2)
                    pygame.draw.line(surface, shelf2, (r.x + 4, r.y + r.h // 2), (r.right - 5, r.y + r.h // 2), 2)
                elif ch == "T":
                    pygame.draw.rect(surface, table, pygame.Rect(r.x + 3, r.y + 6, r.w - 6, r.h - 10), border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 3, r.y + 6, r.w - 6, r.h - 10), 1, border_radius=2)
                    pygame.draw.rect(surface, table2, pygame.Rect(r.x + 4, r.y + 8, r.w - 8, 3))
                elif ch == "K":
                    pygame.draw.rect(surface, kitchen, pygame.Rect(r.x + 2, r.y + 5, r.w - 4, r.h - 8), border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 2, r.y + 5, r.w - 4, r.h - 8), 1, border_radius=2)
                    pygame.draw.rect(surface, kitchen2, pygame.Rect(r.x + 3, r.y + 7, r.w - 6, 3))
                    # Sink / stove hints.
                    if x % 2 == 0:
                        pygame.draw.rect(surface, steel, pygame.Rect(r.x + 6, r.y + 6, 6, 4), border_radius=1)
                        pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 6, r.y + 6, 6, 4), 1, border_radius=1)
                        pygame.draw.circle(surface, (40, 40, 50), (r.x + 9, r.y + 8), 1)
                    else:
                        pygame.draw.rect(surface, steel, pygame.Rect(r.x + 5, r.y + 6, 8, 4), border_radius=1)
                        pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 5, r.y + 6, 8, 4), 1, border_radius=1)
                        pygame.draw.circle(surface, (40, 40, 50), (r.x + 7, r.y + 8), 1)
                        pygame.draw.circle(surface, (40, 40, 50), (r.x + 11, r.y + 8), 1)
                elif ch == "H":
                    pygame.draw.rect(surface, work, pygame.Rect(r.x + 2, r.y + 6, r.w - 4, r.h - 9), border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 2, r.y + 6, r.w - 4, r.h - 9), 1, border_radius=2)
                    pygame.draw.rect(surface, work2, pygame.Rect(r.x + 3, r.y + 8, r.w - 6, 3))
                    # Tools.
                    pygame.draw.line(surface, tool, (r.x + 5, r.y + 6), (r.x + 12, r.y + 10), 1)
                    pygame.draw.line(surface, (10, 10, 12), (r.x + 5, r.y + 6), (r.x + 12, r.y + 10), 1)
                    pygame.draw.rect(surface, tool, pygame.Rect(r.x + 5, r.y + 11, 5, 2), border_radius=1)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 5, r.y + 11, 5, 2), 1, border_radius=1)
                elif ch == "C":
                    pygame.draw.rect(surface, seat, pygame.Rect(r.x + 4, r.y + 4, r.w - 8, r.h - 8), border_radius=3)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 4, r.y + 4, r.w - 8, r.h - 8), 1, border_radius=3)
                    pygame.draw.rect(surface, seat2, pygame.Rect(r.x + 6, r.y + 6, r.w - 12, 4))

        p = pygame.Vector2(self.rv_int_pos)
        speed2 = float(self.rv_int_vel.length_squared())
        face = pygame.Vector2(self.rv_int_facing)
        if face.length_squared() <= 0.001:
            face = pygame.Vector2(0, 1)
        if abs(face.y) >= abs(face.x):
            d = "down" if face.y >= 0 else "up"
        else:
            d = "right" if face.x >= 0 else "left"
        pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
        pf_run = getattr(self, "player_frames_run", None)
        is_run = bool(getattr(self, "player_sprinting", False))
        pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
        frames = pf.get(d, pf["down"])
        if speed2 <= 0.2 or len(frames) <= 1:
            base = frames[0]
        else:
            walk = frames[1:]
            phase = (float(self.rv_int_walk_phase) % math.tau) / math.tau
            idx = int(phase * len(walk)) % len(walk)
            base = walk[idx]

        scale = int(max(1, int(self._RV_INT_SPRITE_SCALE)))
        spr = pygame.transform.scale(base, (int(base.get_width()) * scale, int(base.get_height()) * scale))
        sx = int(round(map_x + p.x))
        sy = int(round(map_y + p.y))
        shadow = pygame.Rect(0, 0, 14, 6)
        shadow.center = (sx, sy + 8)
        pygame.draw.ellipse(surface, (0, 0, 0), shadow)
        rect = spr.get_rect()
        rect.midbottom = (sx, sy + 12)
        surface.blit(spr, rect)
        self._last_player_screen_rect = pygame.Rect(rect)
        self._last_player_screen_rect = pygame.Rect(rect)

    def _draw_house_interior_scene(self, surface: pygame.Surface) -> None:
        surface.fill((10, 10, 14))
        tile = int(self._HOUSE_INT_TILE_SIZE)
        map_w = int(self._HOUSE_INT_W) * tile
        map_h = int(self._HOUSE_INT_H) * tile
        map_x = (INTERNAL_W - map_w) // 2
        map_y = 38
        panel = pygame.Rect(map_x - 10, map_y - 10, map_w + 20, map_h + 20)
        # Panel (pixel style)
        pygame.draw.rect(surface, (70, 70, 86), panel.inflate(4, 4))
        pygame.draw.rect(surface, (18, 18, 22), panel)

        floor = int(getattr(self, "house_floor", 1))
        max_f = int(max(1, int(getattr(self, "house_max_floors", int(self._HOUSE_INT_MAX_FLOORS_DEFAULT)))))
        subtitle = f"{floor}F/{max_f}F" if max_f > 1 else f"{floor}F"
        draw_text(
            surface,
            self.app.font_s,
            f" - {subtitle}",
            (INTERNAL_W // 2, panel.top - 14),
            pygame.Color(240, 240, 240),
            anchor="center",
        )

        map_rect = pygame.Rect(map_x, map_y, map_w, map_h)
        surface.blit(self._interior_floor_surface(map_w, map_h, kind="home"), map_rect.topleft)

        wall = (26, 26, 32)
        wall_hi = (56, 56, 70)
        wall_edge = (12, 12, 16)
        frame = (88, 80, 70)
        outline = (10, 10, 12)

        wood = (98, 78, 56)
        wood2 = (74, 58, 42)
        steel = (216, 220, 228)
        steel2 = (134, 140, 152)

        bed_matt = (186, 170, 156)
        bed_blank = (142, 128, 170)
        pillow = (238, 238, 244)

        wkind = str(getattr(self, "weather_kind", "clear"))
        inten = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))
        win_view = self._window_view_surface(max(4, int(tile - 6)), max(4, int(tile - 8)))

        done: set[tuple[int, int]] = set()

        def block_size(x: int, y: int, ch: str) -> tuple[int, int]:
            bw = 1
            while self._house_int_char_at(int(x) + int(bw), int(y)) == ch:
                bw += 1
            bh = 1
            while True:
                ny = int(y) + int(bh)
                if self._house_int_char_at(int(x), int(ny)) != ch:
                    break
                ok = True
                for dx in range(int(bw)):
                    if self._house_int_char_at(int(x) + int(dx), int(ny)) != ch:
                        ok = False
                        break
                if not ok:
                    break
                bh += 1
            return int(bw), int(bh)

        for y in range(int(self._HOUSE_INT_H)):
            for x in range(int(self._HOUSE_INT_W)):
                ch = self._house_int_char_at(x, y)
                r = pygame.Rect(map_x + x * tile, map_y + y * tile, tile, tile)

                if ch in ("W", "V", "D"):
                    pygame.draw.rect(surface, wall, r)
                    pygame.draw.rect(surface, wall_hi, pygame.Rect(r.x, r.y, r.w, 4))
                    pygame.draw.rect(surface, wall_edge, r, 1)
                    pygame.draw.rect(surface, wood2, pygame.Rect(r.x, r.bottom - 4, r.w, 2))

                    if ch == "V":
                        glass = pygame.Rect(r.x + 3, r.y + 4, r.w - 6, r.h - 8)
                        wv = win_view
                        if wv.get_width() != glass.w or wv.get_height() != glass.h:
                            wv = pygame.transform.scale(wv, (int(glass.w), int(glass.h)))
                        surface.blit(wv, glass.topleft)
                        if wkind in ("rain", "storm", "snow"):
                            self._draw_window_precip(surface, glass, kind=wkind, intensity=inten)
                        # Window frame (pixel style)
                        pygame.draw.rect(surface, frame, glass.inflate(4, 4), 1)
                        pygame.draw.rect(surface, outline, glass, 1)
                        pygame.draw.line(surface, (40, 40, 50), (glass.centerx, glass.top + 1), (glass.centerx, glass.bottom - 2), 1)
                    elif ch == "D":
                        # Door (pixel style)
                        dr = pygame.Rect(r.x + 5, r.y + 4, r.w - 10, r.h - 8)
                        pygame.draw.rect(surface, outline, dr.inflate(2, 2))
                        pygame.draw.rect(surface, (240, 220, 140), dr)
                        pygame.draw.rect(surface, outline, pygame.Rect(dr.right - 6, dr.centery - 2, 4, 4))
                    continue

                if ch in ("^", "v"):
                    if (x, y) in done:
                        continue
                    bw, bh = block_size(x, y, ch)
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    inner = br.inflate(-4, -4)
                    # Stairs (pixel style)
                    pygame.draw.rect(surface, outline, inner.inflate(2, 2))
                    pygame.draw.rect(surface, steel, inner)
                    pygame.draw.rect(surface, steel2, pygame.Rect(inner.x + 3, inner.y + 3, inner.w - 6, 3))
                    cx = int(inner.centerx)
                    cy = int(inner.centery)
                    if ch == "^":
                        pts = [(cx, cy - 6), (cx - 6, cy + 4), (cx + 6, cy + 4)]
                    else:
                        pts = [(cx, cy + 6), (cx - 6, cy - 4), (cx + 6, cy - 4)]
                    pygame.draw.polygon(surface, (240, 220, 140), pts)
                    pygame.draw.polygon(surface, outline, pts, 1)
                    continue

                if ch in ("B", "S", "F", "K", "T") and (x, y) not in done:
                    bw, bh = block_size(x, y, ch)
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    er = br.inflate(-4, -4)

                    if ch == "B":
                        # Bed frame (pixel style)
                        pygame.draw.rect(surface, outline, er.inflate(2, 2))
                        pygame.draw.rect(surface, wood2, er)
                        matt = er.inflate(-4, -4)
                        pygame.draw.rect(surface, outline, matt.inflate(2, 2))
                        pygame.draw.rect(surface, bed_matt, matt)
                        blank = pygame.Rect(matt.x, matt.y + matt.h // 2, matt.w, matt.h // 2)
                        pygame.draw.rect(surface, outline, blank.inflate(2, 2))
                        pygame.draw.rect(surface, bed_blank, blank)
                        pil = pygame.Rect(matt.x + 2, matt.y + 2, 8, 6)
                        pygame.draw.rect(surface, outline, pil.inflate(2, 2))
                        pygame.draw.rect(surface, pillow, pil)
                    elif ch == "S":
                        # Sofa (pixel style)
                        pygame.draw.rect(surface, outline, er.inflate(2, 2))
                        pygame.draw.rect(surface, (72, 80, 108), er)
                        for yy in range(er.y + 6, er.bottom - 6, 6):
                            pygame.draw.line(surface, (40, 40, 50), (er.x + 2, yy), (er.right - 3, yy), 1)
                        handle = pygame.Rect(er.x + 3, er.y + 3, 4, 3)
                        pygame.draw.rect(surface, outline, handle.inflate(2, 2))
                        pygame.draw.rect(surface, (210, 180, 110), handle)
                    elif ch == "F":
                        # Fridge (pixel style)
                        pygame.draw.rect(surface, outline, er.inflate(2, 2))
                        pygame.draw.rect(surface, (236, 236, 242), er)
                        top_rect = pygame.Rect(er.x + 2, er.y + 2, er.w - 4, 4)
                        pygame.draw.rect(surface, (200, 200, 210), top_rect)
                        pygame.draw.rect(surface, outline, top_rect, 1)
                        pygame.draw.line(surface, outline, (er.x + 6, er.y + 6), (er.x + 6, er.bottom - 6), 1)
                    elif ch == "K":
                        # Kitchen (pixel style)
                        pygame.draw.rect(surface, outline, er.inflate(2, 2))
                        pygame.draw.rect(surface, (62, 66, 74), er)
                        top_rect = pygame.Rect(er.x + 2, er.y + 2, er.w - 4, 4)
                        pygame.draw.rect(surface, (96, 102, 112), top_rect)
                        pygame.draw.rect(surface, outline, top_rect, 1)
                        stove = pygame.Rect(er.x + 6, er.y + 6, 8, 6)
                        pygame.draw.rect(surface, outline, stove.inflate(2, 2))
                        pygame.draw.rect(surface, (18, 18, 22), stove)
                    else:  # T - Table
                        pygame.draw.rect(surface, outline, er.inflate(2, 2))
                        pygame.draw.rect(surface, wood, er)
                        top = pygame.Rect(er.x + 2, er.y + 2, er.w - 4, 4)
                        pygame.draw.rect(surface, wood2, top)
                        pygame.draw.rect(surface, outline, top, 1)
                        # Legs
                        pygame.draw.rect(surface, wood2, pygame.Rect(er.x + 3, er.bottom - 5, 2, 4))
                        pygame.draw.rect(surface, wood2, pygame.Rect(er.right - 5, er.bottom - 5, 2, 4))
                    continue

                # Bathroom door (small door to bathroom)
                if ch == "d":
                    # Draw wall background first
                    pygame.draw.rect(surface, wall, r)
                    pygame.draw.rect(surface, wall_hi, pygame.Rect(r.x, r.y, r.w, 4))
                    pygame.draw.rect(surface, wall_edge, r, 1)
                    # Door (pixel style)
                    dr = pygame.Rect(r.x + 4, r.y + 3, r.w - 8, r.h - 5)
                    pygame.draw.rect(surface, outline, dr.inflate(2, 2))
                    pygame.draw.rect(surface, (180, 160, 130), dr)
                    # Door handle
                    pygame.draw.rect(surface, outline, pygame.Rect(dr.right - 5, dr.centery - 1, 3, 3))
                    continue

                # Bathroom floor tile
                if ch == ",":
                    bath_floor = pygame.Rect(r.x + 1, r.y + 1, r.w - 2, r.h - 2)
                    pygame.draw.rect(surface, (180, 190, 200), bath_floor)
                    pygame.draw.rect(surface, outline, bath_floor, 1)
                    continue

                # Toilet
                if ch == "O":
                    # Bowl base (pixel style)
                    bowl = pygame.Rect(r.x + 4, r.y + 6, r.w - 8, r.h - 8)
                    pygame.draw.rect(surface, outline, bowl.inflate(2, 2))
                    pygame.draw.rect(surface, (240, 240, 245), bowl)
                    # Tank
                    tank = pygame.Rect(r.x + 6, r.y + 2, r.w - 12, 6)
                    pygame.draw.rect(surface, outline, tank.inflate(2, 2))
                    pygame.draw.rect(surface, (230, 230, 238), tank)
                    # Seat
                    seat = pygame.Rect(bowl.x + 2, bowl.y + 2, bowl.w - 4, bowl.h - 4)
                    pygame.draw.rect(surface, (200, 200, 210), seat)
                    continue

                # Shower
                if ch == "R":
                    # Shower base (pixel style)
                    base = pygame.Rect(r.x + 2, r.y + 2, r.w - 4, r.h - 4)
                    pygame.draw.rect(surface, outline, base.inflate(2, 2))
                    pygame.draw.rect(surface, (160, 170, 185), base)
                    # Drain
                    drain = pygame.Rect(base.centerx - 3, base.centery - 3, 6, 6)
                    pygame.draw.rect(surface, (80, 85, 95), drain)
                    pygame.draw.rect(surface, outline, drain, 1)
                    # Shower head indicator
                    head = pygame.Rect(base.x + 2, base.y + 2, 4, 4)
                    pygame.draw.rect(surface, steel, head)
                    continue

        p = pygame.Vector2(self.house_int_pos)
        speed2 = float(getattr(self, "house_int_vel", pygame.Vector2(0, 0)).length_squared())
        face = pygame.Vector2(self.house_int_facing)
        if face.length_squared() <= 0.001:
            face = pygame.Vector2(0, 1)
        if abs(face.y) >= abs(face.x):
            d = "down" if face.y >= 0 else "up"
        else:
            d = "right" if face.x >= 0 else "left"
        pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
        pf_run = getattr(self, "player_frames_run", None)
        is_run = bool(getattr(self, "player_sprinting", False))
        pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
        frames = pf.get(d, pf["down"])
        if speed2 <= 0.2 or len(frames) <= 1:
            base = frames[0]
        else:
            walk = frames[1:]
            phase = (float(self.house_int_walk_phase) % math.tau) / math.tau
            idx = int(phase * len(walk)) % len(walk)
            base = walk[idx]

        scale = int(max(1, int(self._HOUSE_INT_SPRITE_SCALE)))
        spr = pygame.transform.scale(base, (int(base.get_width()) * scale, int(base.get_height()) * scale))
        sx = int(round(map_x + p.x))
        sy = int(round(map_y + p.y))
        shadow = pygame.Rect(0, 0, 14, 6)
        shadow.center = (sx, sy + 8)
        pygame.draw.ellipse(surface, (0, 0, 0), shadow)
        rect = spr.get_rect()
        rect.midbottom = (sx, sy + 12)
        surface.blit(spr, rect)

    def _draw_sch_interior_scene(self, surface: pygame.Surface) -> None:
        surface.fill((10, 10, 14))
        tile = int(self._SCH_INT_TILE_SIZE)
        full_map_w = int(self._SCH_INT_W) * tile
        full_map_h = int(self._SCH_INT_H) * tile
        map_y0 = 38
        map_w = int(min(int(full_map_w), max(1, int(INTERNAL_W) - 20)))
        map_h = int(min(int(full_map_h), max(1, int(INTERNAL_H) - int(map_y0) - 10)))
        map_x0 = (INTERNAL_W - map_w) // 2
        map_y0 = int(map_y0)
        panel = pygame.Rect(map_x0 - 10, map_y0 - 10, map_w + 20, map_h + 20)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (70, 70, 86), panel, 2, border_radius=12)

        floor = int(getattr(self, "sch_floor", 1))
        subtitle = "" if floor <= 1 else f"{floor}F"
        draw_text(
            surface,
            self.app.font_s,
            f" - {subtitle}",
            (INTERNAL_W // 2, panel.top - 14),
            pygame.Color(240, 240, 240),
            anchor="center",
        )

        map_rect = pygame.Rect(map_x0, map_y0, map_w, map_h)

        # Camera within the interior so the school can be larger than the viewport.
        focus = pygame.Vector2(self.sch_int_pos)
        if int(full_map_w) <= int(map_w):
            cam_x = 0
        else:
            cam_x = int(clamp(float(focus.x) - float(map_w) / 2.0, 0.0, float(full_map_w - map_w)))
        if int(full_map_h) <= int(map_h):
            cam_y = 0
        else:
            cam_y = int(clamp(float(focus.y) - float(map_h) / 2.0, 0.0, float(full_map_h - map_h)))

        map_x = int(map_x0) - int(cam_x)
        map_y = int(map_y0) - int(cam_y)

        wall = (26, 26, 32)
        wall_hi = (54, 54, 68)
        edge = (12, 12, 16)
        locker = (78, 90, 96)
        locker_hi = (110, 128, 136)
        desk = (96, 78, 56)
        desk_hi = (140, 116, 86)
        elev = (62, 62, 72)
        elev_hi = (100, 100, 116)
        stairs = (56, 60, 74)
        stairs_hi = (92, 98, 120)
        door = (96, 70, 46)
        door_hi = (132, 100, 68)

        prev_clip = surface.get_clip()
        surface.set_clip(map_rect)
        try:
            surface.blit(
                self._interior_floor_surface(int(full_map_w), int(full_map_h), kind="school"),
                (int(map_x), int(map_y)),
            )

            for y in range(int(self._SCH_INT_H)):
                for x in range(int(self._SCH_INT_W)):
                    ch = self._sch_int_char_at(x, y)
                    r = pygame.Rect(map_x + x * tile, map_y + y * tile, tile, tile)
                    if ch == "W":
                        pygame.draw.rect(surface, wall, r)
                        pygame.draw.rect(surface, edge, r, 1)
                        pygame.draw.line(surface, wall_hi, (r.left + 1, r.top + 1), (r.right - 2, r.top + 1), 1)
                    elif ch == "V":
                        view = self._window_view_surface(tile - 6, tile - 6)
                        surface.blit(view, (r.x + 3, r.y + 3))
                        pygame.draw.rect(surface, (20, 20, 26), pygame.Rect(r.x + 2, r.y + 2, tile - 4, tile - 4), 1)
                        pygame.draw.rect(surface, (70, 70, 86), pygame.Rect(r.x + 1, r.y + 1, tile - 2, tile - 2), 1)
                    elif ch == "L":
                        pygame.draw.rect(surface, locker, pygame.Rect(r.x + 3, r.y + 2, tile - 6, tile - 4), border_radius=2)
                        pygame.draw.rect(surface, edge, pygame.Rect(r.x + 3, r.y + 2, tile - 6, tile - 4), 1, border_radius=2)
                        pygame.draw.rect(surface, locker_hi, pygame.Rect(r.x + 4, r.y + 4, tile - 8, 3))
                        pygame.draw.line(surface, edge, (r.x + tile // 2, r.y + 3), (r.x + tile // 2, r.y + tile - 3), 1)
                    elif ch == "T":
                        pygame.draw.rect(surface, desk, pygame.Rect(r.x + 2, r.y + 5, tile - 4, tile - 8), border_radius=2)
                        pygame.draw.rect(surface, edge, pygame.Rect(r.x + 2, r.y + 5, tile - 4, tile - 8), 1, border_radius=2)
                        pygame.draw.rect(surface, desk_hi, pygame.Rect(r.x + 3, r.y + 6, tile - 6, 3))
                    elif ch == "E":
                        pygame.draw.rect(surface, elev, pygame.Rect(r.x + 2, r.y + 2, tile - 4, tile - 4), border_radius=2)
                        pygame.draw.rect(surface, edge, pygame.Rect(r.x + 2, r.y + 2, tile - 4, tile - 4), 1, border_radius=2)
                        pygame.draw.rect(surface, elev_hi, pygame.Rect(r.x + 3, r.y + 4, tile - 6, 3))
                        pygame.draw.line(surface, edge, (r.x + tile // 2, r.y + 4), (r.x + tile // 2, r.y + tile - 4), 1)
                    elif ch in ("^", "v"):
                        pygame.draw.rect(surface, stairs, pygame.Rect(r.x + 2, r.y + 2, tile - 4, tile - 4), border_radius=2)
                        pygame.draw.rect(surface, edge, pygame.Rect(r.x + 2, r.y + 2, tile - 4, tile - 4), 1, border_radius=2)
                        pygame.draw.rect(surface, stairs_hi, pygame.Rect(r.x + 3, r.y + 4, tile - 6, 3))
                        cx = r.centerx
                        cy = r.centery + (1 if ch == "v" else -1)
                        if ch == "^":
                            pygame.draw.polygon(surface, (230, 230, 240), [(cx, cy - 4), (cx - 4, cy + 3), (cx + 4, cy + 3)])
                        else:
                            pygame.draw.polygon(surface, (230, 230, 240), [(cx, cy + 4), (cx - 4, cy - 3), (cx + 4, cy - 3)])
                    elif ch == "D":
                        pygame.draw.rect(surface, door, pygame.Rect(r.x + 2, r.y + 2, tile - 4, tile - 4), border_radius=2)
                        pygame.draw.rect(surface, edge, pygame.Rect(r.x + 2, r.y + 2, tile - 4, tile - 4), 1, border_radius=2)
                        pygame.draw.rect(surface, door_hi, pygame.Rect(r.x + 3, r.y + 4, tile - 6, 3))
                        pygame.draw.circle(surface, (30, 30, 34), (r.right - 6, r.centery), 1)

            p = pygame.Vector2(self.sch_int_pos)
            speed2 = float(self.sch_int_vel.length_squared())
            face = pygame.Vector2(self.sch_int_facing)
            if face.length_squared() <= 0.001:
                face = pygame.Vector2(0, 1)
            if abs(face.y) >= abs(face.x):
                d = "down" if face.y >= 0 else "up"
            else:
                d = "right" if face.x >= 0 else "left"

            pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
            frames = pf_walk.get(d, pf_walk["down"])
            if speed2 <= 0.2 or len(frames) <= 1:
                base = frames[0]
            else:
                walk = frames[1:]
                phase = (float(self.sch_int_walk_phase) % math.tau) / math.tau
                idx = int(phase * len(walk)) % len(walk)
                base = walk[idx]

            scale = int(max(1, int(self._SCH_INT_SPRITE_SCALE)))
            spr = pygame.transform.scale(base, (int(base.get_width()) * scale, int(base.get_height()) * scale))
            sx = int(round(map_x + p.x))
            sy = int(round(map_y + p.y))
            shadow = pygame.Rect(0, 0, 14, 6)
            shadow.center = (sx, sy + 8)
            pygame.draw.ellipse(surface, (0, 0, 0), shadow)
            rect = spr.get_rect()
            rect.midbottom = (sx, sy + 12)
            surface.blit(spr, rect)
        finally:
            surface.set_clip(prev_clip)

    def _carve_hr_lamps_from_dim_overlay(
        self,
        overlay: pygame.Surface,
        *,
        map_rect: pygame.Rect,
        map_x: int,
        map_y: int,
        tile: int,
        lamps: list[tuple[int, int]],
        dim_alpha: int,
    ) -> None:
        if not lamps:
            return
        tile = int(tile)
        if tile <= 0:
            return
        dim_alpha = int(dim_alpha)
        if dim_alpha <= 0:
            return

        cfg = getattr(self.app, "config", None)
        radius_tiles = int(getattr(cfg, "lamp_hr_radius_tiles", 5)) if cfg is not None else 5
        radius_tiles = int(clamp(int(radius_tiles), 2, 18))
        intensity = float(getattr(cfg, "lamp_hr_intensity", 1.0)) if cfg is not None else 1.0
        intensity = float(clamp(float(intensity), 0.0, 3.0))
        if intensity <= 0.01:
            return

        radius_px = int(tile * radius_tiles)
        max_sub_alpha = int(clamp(int(round(float(dim_alpha) * 0.92 * float(intensity))), 0, int(dim_alpha)))
        if max_sub_alpha <= 0:
            return

        hole_key = (int(radius_px), int(max_sub_alpha))
        cache: dict[tuple[int, int], pygame.Surface] = getattr(self, "_hr_lamp_hole_cache", {})
        hole = cache.get(hole_key)
        if hole is None:
            g = pygame.Surface((int(radius_px) * 2 + 1, int(radius_px) * 2 + 1), pygame.SRCALPHA)
            rings = 18
            for i in range(rings):
                t = float(i) / float(max(1, rings - 1))
                r = int(round(float(radius_px) * (1.0 - t)))
                if r <= 0:
                    continue
                a = int(round(float(max_sub_alpha) * ((1.0 - t) ** 2)))
                a = int(clamp(int(a), 0, 255))
                if a <= 0:
                    continue
                pygame.draw.circle(g, (0, 0, 0, int(a)), (int(radius_px), int(radius_px)), int(r))
            cache[hole_key] = g
            self._hr_lamp_hole_cache = cache
            hole = g

        blocks = {"W", "V", "D", "A", "H", "I"}
        w = int(self._HR_INT_W)
        h = int(self._HR_INT_H)

        map_x_local = int(map_x) - int(map_rect.x)
        map_y_local = int(map_y) - int(map_rect.y)

        for lx, ly in lamps:
            lx = int(lx)
            ly = int(ly)
            seen: set[tuple[int, int]] = set()
            lit: list[tuple[int, int]] = []
            stack = [(lx, ly)]
            r2 = int(radius_tiles) * int(radius_tiles)
            while stack and len(lit) < 2400:
                x, y = stack.pop()
                x = int(x)
                y = int(y)
                if (x, y) in seen:
                    continue
                seen.add((x, y))
                if not (0 <= x < w and 0 <= y < h):
                    continue
                dx = int(x - lx)
                dy = int(y - ly)
                if int(dx * dx + dy * dy) > int(r2):
                    continue
                ch = str(self._hr_int_char_at(int(x), int(y)))[:1]
                if ch in blocks:
                    continue
                lit.append((x, y))
                stack.extend(((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)))

            base_rect = pygame.Rect(int(map_x_local + lx * tile), int(map_y_local + ly * tile), int(tile), int(tile))
            cx, cy = int(base_rect.centerx), int(base_rect.centery)
            ox = int(cx - radius_px)
            oy = int(cy - radius_px)

            mask = pygame.Surface(hole.get_size(), pygame.SRCALPHA)
            mask.fill((0, 0, 0, 0))
            mask_bounds = mask.get_rect()
            for tx, ty in lit:
                r = pygame.Rect(
                    int(map_x_local + int(tx) * tile),
                    int(map_y_local + int(ty) * tile),
                    int(tile),
                    int(tile),
                )
                lr = r.move(-int(ox), -int(oy)).clip(mask_bounds)
                if lr.w > 0 and lr.h > 0:
                    mask.fill((255, 255, 255, 255), lr)

            tmp = hole.copy()
            tmp.blit(mask, (0, 0), special_flags=pygame.BLEND_RGBA_MULT)
            overlay.blit(tmp, (int(ox), int(oy)), special_flags=pygame.BLEND_RGBA_SUB)

    def _draw_hr_interior_lamp_bloom(
        self,
        surface: pygame.Surface,
        *,
        map_rect: pygame.Rect,
        map_x: int,
        map_y: int,
        tile: int,
        lamps: list[tuple[int, int]],
    ) -> None:
        if not lamps:
            return
        tile = int(tile)
        if tile <= 0:
            return

        daylight, _tday = self._daylight_amount()

        cfg = getattr(self.app, "config", None)
        radius_tiles = int(getattr(cfg, "lamp_hr_radius_tiles", 5)) if cfg is not None else 5
        radius_tiles = int(clamp(int(radius_tiles), 2, 18))
        intensity = float(getattr(cfg, "lamp_hr_intensity", 1.0)) if cfg is not None else 1.0
        intensity = float(clamp(float(intensity), 0.0, 3.0))
        halo = float(getattr(cfg, "lamp_hr_halo", 0.35)) if cfg is not None else 0.35
        halo = float(clamp(float(halo), 0.0, 1.5))

        day_factor = float(clamp(0.45 + 0.55 * (1.0 - float(daylight)), 0.45, 1.0))
        halo_strength = float(halo) * float(day_factor) * float(clamp(float(intensity), 0.0, 1.0))
        halo_strength = float(clamp(float(halo_strength), 0.0, 1.0))
        halo_alpha = int(clamp(int(round(255.0 * float(halo_strength))), 0, 255))
        if halo_alpha <= 0:
            return

        # Warm bloom (screen blend) with a real alpha control (doesn't change radius).
        radius_px = int(tile * radius_tiles)
        cache: dict[int, pygame.Surface] = getattr(self, "_hr_lamp_bloom_cache", {})
        glow = cache.get(int(radius_px))
        if glow is None:
            grad = self._radial_gray_gradient(int(radius_px))
            g = grad.copy()
            g.fill((90, 90, 90), special_flags=pygame.BLEND_RGB_MULT)
            g.fill((232, 220, 198), special_flags=pygame.BLEND_RGB_MULT)
            cache[int(radius_px)] = g
            self._hr_lamp_bloom_cache = cache
            glow = g

        blocks = {"W", "V", "D", "A", "H", "I"}
        w = int(self._HR_INT_W)
        h = int(self._HR_INT_H)

        map_x_local = int(map_x) - int(map_rect.x)
        map_y_local = int(map_y) - int(map_rect.y)

        for lx, ly in lamps:
            lx = int(lx)
            ly = int(ly)
            seen: set[tuple[int, int]] = set()
            lit: list[tuple[int, int]] = []
            stack = [(lx, ly)]
            r2 = int(radius_tiles) * int(radius_tiles)
            while stack and len(lit) < 2400:
                x, y = stack.pop()
                x = int(x)
                y = int(y)
                if (x, y) in seen:
                    continue
                seen.add((x, y))
                if not (0 <= x < w and 0 <= y < h):
                    continue
                dx = int(x - lx)
                dy = int(y - ly)
                if int(dx * dx + dy * dy) > int(r2):
                    continue
                ch = str(self._hr_int_char_at(int(x), int(y)))[:1]
                if ch in blocks:
                    continue
                lit.append((x, y))
                stack.extend(((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)))

            base_rect = pygame.Rect(int(map_x_local + lx * tile), int(map_y_local + ly * tile), int(tile), int(tile))
            cx, cy = int(base_rect.centerx), int(base_rect.centery)
            ox = int(cx - radius_px)
            oy = int(cy - radius_px)
            mask = pygame.Surface(glow.get_size()).convert()
            mask.fill((0, 0, 0))
            bounds = mask.get_rect()
            for tx, ty in lit:
                r = pygame.Rect(
                    int(map_x_local + int(tx) * tile),
                    int(map_y_local + int(ty) * tile),
                    int(tile),
                    int(tile),
                )
                lr = r.move(-int(ox), -int(oy)).clip(bounds)
                if lr.w > 0 and lr.h > 0:
                    mask.fill((255, 255, 255), lr)

            tmp = glow.copy()
            tmp.blit(mask, (0, 0), special_flags=pygame.BLEND_RGB_MULT)
            self._blit_screen(surface, tmp, pos=(int(map_rect.x + ox), int(map_rect.y + oy)), alpha=int(halo_alpha))

    def _draw_hr_interior_lighting(
        self,
        surface: pygame.Surface,
        *,
        map_rect: pygame.Rect,
        map_x: int,
        map_y: int,
        tile: int,
        lamps: list[tuple[int, int]],
        light_on: bool,
    ) -> None:
        if int(map_rect.w) <= 0 or int(map_rect.h) <= 0:
            return
        tile = int(tile)
        if tile <= 0:
            return

        daylight, _tday = self._daylight_amount()
        # Ambient indoor darkness: night is darker; lights-off adds extra dim.
        dim_alpha = int(round(110.0 * (1.0 - float(daylight))))
        if not bool(light_on):
            dim_alpha = int(clamp(int(dim_alpha) + 110, 0, 220))
        if dim_alpha > 0:
            dim = pygame.Surface((int(map_rect.w), int(map_rect.h)), pygame.SRCALPHA)
            dim.fill((12, 14, 30, int(dim_alpha)))
            if bool(light_on) and lamps:
                try:
                    self._carve_hr_lamps_from_dim_overlay(
                        dim,
                        map_rect=map_rect,
                        map_x=int(map_x),
                        map_y=int(map_y),
                        tile=int(tile),
                        lamps=lamps,
                        dim_alpha=int(dim_alpha),
                    )
                except Exception:
                    pass
            surface.blit(dim, map_rect.topleft)

        if bool(light_on) and lamps:
            try:
                self._draw_hr_interior_lamp_bloom(
                    surface,
                    map_rect=map_rect,
                    map_x=int(map_x),
                    map_y=int(map_y),
                    tile=int(tile),
                    lamps=lamps,
                )
            except Exception:
                pass

    def _draw_hr_interior_scene(self, surface: pygame.Surface) -> None:  
        surface.fill((10, 10, 14))
        tile = int(self._HR_INT_TILE_SIZE)
        full_map_w = int(self._HR_INT_W) * tile
        full_map_h = int(self._HR_INT_H) * tile
        map_y0 = 38
        map_w = int(min(int(full_map_w), max(1, int(INTERNAL_W) - 20)))
        map_h = int(min(int(full_map_h), max(1, int(INTERNAL_H) - int(map_y0) - 10)))
        map_x0 = (INTERNAL_W - map_w) // 2
        map_y0 = int(map_y0)
        panel = pygame.Rect(int(map_x0) - 10, int(map_y0) - 10, int(map_w) + 20, int(map_h) + 20)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (70, 70, 86), panel, 2, border_radius=12)

        # Cozier indoor rendering (wood floors, furniture detail, window view).
        mode = str(getattr(self, "hr_mode", "lobby"))
        floor = int(getattr(self, "hr_floor", 1))
        room_id = str(getattr(self, "hr_current_room", "")).strip()
        lights = getattr(self, "hr_room_lights", None)
        if not isinstance(lights, dict):
            lights = {}
            self.hr_room_lights = lights
        light_on = True
        if mode == "home" and room_id:
            light_on = bool(lights.get(str(room_id), True))

        tv_states = getattr(self, "hr_room_tvs", None)
        if not isinstance(tv_states, dict):
            tv_states = {}
            self.hr_room_tvs = tv_states
        tv_on = bool(tv_states.get(str(room_id), False)) if (mode == "home" and room_id) else False

        title = ""
        home_room = str(getattr(self, "home_highrise_room", "")).strip()
        cur_room = str(getattr(self, "hr_current_room", "")).strip()
        home_floor = int(getattr(self, "hr_home_floor", -1))
        if mode == "home":
            if cur_room and home_room and cur_room != home_room:
                subtitle = f" {cur_room}"
            else:
                subtitle = f" {home_room}" if home_room else ""
        elif floor <= 1:
            subtitle = ""
        else:
            subtitle = f"{floor} "
            if home_floor == floor:
                subtitle += f" {home_room}" if home_room else ""
        draw_text(
            surface,
            self.app.font_s,
            f"{title} - {subtitle}",
            (INTERNAL_W // 2, panel.top - 14),
            pygame.Color(240, 240, 240),
            anchor="center",
        )

        # Persistent home guidance (so the player always knows where the room is).
        info = ""
        if home_floor > 0:
            if home_room:
                info = f"{home_room}{home_floor}F"
            else:
                info = f"{home_floor}F"
            if mode == "hall":
                if floor == home_floor:
                    info += "  "
                else:
                    info += f"  {floor}F"
        if info:
            draw_text(
                surface,
                self.app.font_s,
                info,
                (panel.right - 8, panel.top + 6),
                pygame.Color(200, 200, 210),
                anchor="topright",
            )

        map_rect = pygame.Rect(int(map_x0), int(map_y0), int(map_w), int(map_h))
        self._hr_int_ui_buttons = []
        floor_kind = "home" if mode == "home" else "stone"
        # Camera within the interior so layouts can be larger than the viewport.
        pose = str(getattr(self, "player_pose", "")).strip()
        pose_space = str(getattr(self, "player_pose_space", "")).strip()
        pose_anchor = getattr(self, "player_pose_anchor", None)
        use_pose = bool(pose and pose_space == "hr" and pose_anchor is not None)
        if use_pose:
            focus = pygame.Vector2(float(pose_anchor[0]), float(pose_anchor[1]))
        else:
            focus = pygame.Vector2(self.hr_int_pos)
        if int(full_map_w) <= int(map_w):
            cam_x = 0
        else:
            cam_x = int(clamp(float(focus.x) - float(map_w) / 2.0, 0.0, float(full_map_w - map_w)))
        if int(full_map_h) <= int(map_h):
            cam_y = 0
        else:
            cam_y = int(clamp(float(focus.y) - float(map_h) / 2.0, 0.0, float(full_map_h - map_h)))
        self._hr_int_draw_rect = pygame.Rect(map_rect)
        self._hr_int_draw_cam = (int(cam_x), int(cam_y))
        self._hr_int_draw_origin = (int(map_x0), int(map_y0))

        # Shift the draw origin by the camera, but keep map_rect in screen space.
        map_x = int(map_x0) - int(cam_x)
        map_y = int(map_y0) - int(cam_y)

        prev_clip = surface.get_clip()
        surface.set_clip(map_rect)
        surface.blit(self._interior_floor_surface(int(full_map_w), int(full_map_h), kind=floor_kind), (int(map_x), int(map_y)))

        # "Back wall" band (front-view cue) for the player's home, per reference.
        if mode == "home":
            wall_h = int(tile * 2)
            wall_h = int(clamp(wall_h, 18, max(18, int(map_h) - 40)))
            wall_rect = pygame.Rect(int(map_rect.x), int(map_rect.y), int(map_rect.w), int(wall_h))
            wall_surf = pygame.Surface((wall_rect.w, wall_rect.h))
            wall_base = (188, 186, 182)
            wall_surf.fill(wall_base)
            # Subtle horizontal noise lines.
            for yy in range(2, wall_rect.h - 6, 6):
                col = (182, 180, 176) if ((yy // 6) % 2) == 0 else (190, 188, 184)
                wall_surf.fill(col, pygame.Rect(0, int(yy), wall_rect.w, 1))
            # Baseboard.
            base_y = int(max(0, wall_rect.h - 5))
            wall_surf.fill((74, 58, 42), pygame.Rect(0, base_y, wall_rect.w, 4))
            wall_surf.fill((12, 12, 16), pygame.Rect(0, base_y, wall_rect.w, 1))
            surface.blit(wall_surf, wall_rect.topleft)

        wall = (26, 26, 32)
        wall_hi = (56, 56, 70)
        wall_edge = (12, 12, 16)
        frame = (88, 80, 70)
        frame2 = (62, 56, 48)
        outline = (10, 10, 12)

        wood = (98, 78, 56)
        wood2 = (74, 58, 42)
        steel = (216, 220, 228)
        steel2 = (134, 140, 152)
        bed_matt = (186, 170, 156)
        bed_blank = (142, 128, 170)
        bed_blank2 = (120, 106, 144)
        pillow = (238, 238, 244)
        seat = (72, 86, 148)
        seat2 = (54, 64, 118)

        wkind = str(getattr(self, "weather_kind", "clear"))
        inten = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))
        glass_w = max(4, int(tile - 6))
        glass_h = max(4, int(tile - 8))
        win_view = self._window_view_surface(glass_w, glass_h)

        # Rug under the table block in "home" mode.
        if mode == "home":
            t_tiles: list[tuple[int, int]] = []
            for yy, row in enumerate(getattr(self, "hr_layout", [])):
                if not isinstance(row, str):
                    continue
                for xx in range(min(len(row), int(self._HR_INT_W))):
                    if row[xx] == "T":
                        t_tiles.append((int(xx), int(yy)))
            if t_tiles:
                min_tx = min(p[0] for p in t_tiles)
                max_tx = max(p[0] for p in t_tiles)
                min_ty = min(p[1] for p in t_tiles)
                max_ty = max(p[1] for p in t_tiles)
                rug = pygame.Rect(
                    map_x + min_tx * tile - 3,
                    map_y + min_ty * tile + 7,
                    (max_tx - min_tx + 1) * tile + 6,
                    (max_ty - min_ty + 1) * tile + 8,
                )
                rug.clamp_ip(map_rect.inflate(-6, -6))
                rug_s = pygame.Surface((rug.w, rug.h), pygame.SRCALPHA)
                rug_s.fill((132, 70, 82, 190))
                for y in range(2, rug.h, 5):
                    pygame.draw.line(rug_s, (210, 150, 150, 55), (2, y), (rug.w - 3, y), 1)
                pygame.draw.rect(rug_s, (40, 18, 20, 220), rug_s.get_rect(), 2, border_radius=4)
                surface.blit(rug_s, rug.topleft)

        bed_done: set[tuple[int, int]] = set()
        elev_done: set[tuple[int, int]] = set()
        s_done: set[tuple[int, int]] = set()
        f_done: set[tuple[int, int]] = set()
        k_done: set[tuple[int, int]] = set()
        t_done: set[tuple[int, int]] = set()
        c_done: set[tuple[int, int]] = set()
        p_done: set[tuple[int, int]] = set()
        x_done: set[tuple[int, int]] = set()
        r_done: set[tuple[int, int]] = set()
        lamp_tiles: list[tuple[int, int]] = []

        layout = getattr(self, "hr_layout", [])
        for y in range(int(self._HR_INT_H)):
            row = layout[y] if 0 <= y < len(layout) else ""
            for x in range(int(self._HR_INT_W)):
                ch = row[x] if x < len(row) else "W"
                r = pygame.Rect(map_x + x * tile, map_y + y * tile, tile, tile)

                if ch in ("W", "V", "D", "A", "a", "H", "I"):
                    pygame.draw.rect(surface, wall, r)
                    pygame.draw.rect(surface, wall_hi, pygame.Rect(r.x, r.y, r.w, 4))
                    pygame.draw.rect(surface, wall_edge, r, 1)
                    pygame.draw.rect(surface, frame2, pygame.Rect(r.x, r.bottom - 4, r.w, 2))

                    if ch == "V":
                        glass = pygame.Rect(r.x + 3, r.y + 4, r.w - 6, r.h - 8)
                        wv = win_view
                        if wv.get_width() != glass.w or wv.get_height() != glass.h:
                            wv = pygame.transform.scale(wv, (int(glass.w), int(glass.h)))
                        surface.blit(wv, glass.topleft)
                        if wkind in ("rain", "storm", "snow"):
                            self._draw_window_precip(surface, glass, kind=wkind, intensity=inten)
                        # Pixel-style window frame.
                        pygame.draw.rect(surface, frame, glass.inflate(4, 4), 1)
                        pygame.draw.rect(surface, outline, glass, 1)
                        pygame.draw.line(surface, (40, 40, 50), (glass.centerx, glass.top + 1), (glass.centerx, glass.bottom - 2), 1)
                    elif ch == "D":
                        # Pixel-style door.
                        dr = pygame.Rect(r.x + 5, r.y + 4, r.w - 10, r.h - 8)
                        pygame.draw.rect(surface, outline, dr.inflate(2, 2))
                        pygame.draw.rect(surface, (240, 220, 140), dr)
                        pygame.draw.circle(surface, outline, (dr.right - 5, dr.centery), 2)
                    elif ch in ("A", "a", "H"):
                        # Apartment doors: keep a solid wall frame, bottom aligned to the baseboard.
                        # Doors should be taller than one tile (player sprite is 2x inside). Pixel-style.
                        door_h = int(clamp(int(tile * 1.7), int(tile + 8), int(tile * 2 - 2)))
                        dr = pygame.Rect(r.x + 2, int(r.bottom - 2 - door_h), r.w - 4, door_h)
                        pygame.draw.rect(surface, outline, dr.inflate(2, 2))
                        pygame.draw.rect(surface, wood, dr)
                        pygame.draw.rect(surface, wood2, pygame.Rect(dr.x + 2, dr.y + 2, dr.w - 4, 4))
                        knob_y = int(dr.y + dr.h * 0.62)
                        pygame.draw.circle(surface, (240, 220, 140), (dr.right - 4, knob_y), 2)
                        if ch == "H":
                            pygame.draw.rect(surface, (120, 200, 140), pygame.Rect(dr.x + 2, dr.y + 2, dr.w - 4, 3))
                        if ch == "a":
                            # Broken door accent so players understand it's enterable.
                            pygame.draw.line(surface, outline, (dr.x + 3, dr.y + 6), (dr.right - 4, dr.bottom - 7), 2)
                            pygame.draw.line(surface, (40, 20, 20), (dr.x + 4, dr.bottom - 6), (dr.right - 5, dr.bottom - 6), 1)
                    elif ch == "I":
                        # Light switch on the wall (controls room lighting). Pixel-style.
                        plate = pygame.Rect(int(r.centerx - 4), int(r.centery - 6), 8, 12)
                        pygame.draw.rect(surface, outline, plate.inflate(2, 2))
                        pygame.draw.rect(surface, (214, 214, 222), plate)
                        knob_h = 4
                        knob = pygame.Rect(int(plate.x + 2), int(plate.y + (2 if light_on else plate.h - knob_h - 2)), int(plate.w - 4), int(knob_h))
                        pygame.draw.rect(surface, outline, knob.inflate(2, 2))
                        pygame.draw.rect(surface, (255, 220, 140) if light_on else (120, 120, 132), knob)
                    continue

                if ch in (",", "O", "U", "R"):
                    # Bathroom tile floor overlay (on top of the base floor texture).
                    tile_a = (86, 88, 96)
                    tile_b = (78, 80, 88)
                    grout = (28, 28, 34)
                    col = tile_a if ((int(x) + int(y)) % 2 == 0) else tile_b
                    surface.fill(col, r)
                    surface.fill(grout, pygame.Rect(r.x, r.y, r.w, 1))
                    surface.fill(grout, pygame.Rect(r.x, r.y, 1, r.h))

                # Objects over the floor texture.
                if ch in ("^", "v"):
                    step_r = r.inflate(-6, -6)
                    sh = pygame.Surface((step_r.w + 4, step_r.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 70), sh.get_rect())
                    surface.blit(sh, (step_r.x, step_r.y + 2))
                    # Pixel-style stairs.
                    pygame.draw.rect(surface, outline, step_r.inflate(2, 2))
                    pygame.draw.rect(surface, steel2, step_r)
                    for i in range(3):
                        yy = int(step_r.y + 4 + i * 5)
                        pygame.draw.line(surface, steel, (step_r.x + 3, yy), (step_r.right - 4, yy), 1)
                    if ch == "^":
                        arrow = [(step_r.centerx, step_r.y + 3), (step_r.centerx - 4, step_r.y + 10), (step_r.centerx + 4, step_r.y + 10)]
                    else:
                        arrow = [
                            (step_r.centerx, step_r.bottom - 3),
                            (step_r.centerx - 4, step_r.bottom - 10),
                            (step_r.centerx + 4, step_r.bottom - 10),
                        ]
                    pygame.draw.polygon(surface, (255, 220, 140), arrow)
                    pygame.draw.polygon(surface, outline, arrow, 1)
                    continue

                if ch == "L":
                    # Standing lamp (glow drawn later with wall occlusion).
                    bulb_col = (255, 230, 140) if light_on else (90, 90, 104)
                    if light_on:
                        lamp_tiles.append((int(x), int(y)))

                    base_y = int(r.bottom - 5)
                    pole_top = int(r.y + 6)
                    pygame.draw.line(surface, (90, 84, 76), (int(r.centerx), base_y), (int(r.centerx), pole_top), 2)
                    pygame.draw.circle(surface, outline, (int(r.centerx), base_y), 3, 1)
                    pygame.draw.ellipse(surface, (60, 54, 46), pygame.Rect(int(r.centerx - 5), int(base_y), 10, 4))

                    shade = pygame.Rect(int(r.centerx - 6), int(pole_top - 1), 12, 7)
                    pygame.draw.polygon(
                        surface,
                        (238, 230, 200),
                        [
                            (shade.left, shade.bottom),
                            (shade.centerx, shade.top),
                            (shade.right, shade.bottom),
                        ],
                    )
                    pygame.draw.polygon(
                        surface,
                        outline,
                        [
                            (shade.left, shade.bottom),
                            (shade.centerx, shade.top),
                            (shade.right, shade.bottom),
                        ],
                        1,
                    )
                    pygame.draw.circle(surface, bulb_col, (int(r.centerx), int(shade.bottom - 1)), 2)
                    continue

                if ch == "O":
                    # Toilet.
                    porcelain = (230, 232, 238)
                    porcelain2 = (206, 210, 220)
                    bowl = pygame.Rect(r.x + 4, r.y + 6, r.w - 8, r.h - 10)
                    tank = pygame.Rect(r.x + 6, r.y + 2, r.w - 12, 5)
                    base = pygame.Rect(r.x + 5, r.bottom - 6, r.w - 10, 4)
                    sh = pygame.Surface((bowl.w, bowl.h), pygame.SRCALPHA)
                    pygame.draw.ellipse(sh, (0, 0, 0, 80), sh.get_rect())
                    surface.blit(sh, (bowl.x + 1, bowl.y + 2))
                    pygame.draw.ellipse(surface, porcelain, bowl)
                    pygame.draw.ellipse(surface, outline, bowl, 1)
                    # Pixel-style toilet parts.
                    pygame.draw.rect(surface, outline, tank.inflate(2, 2))
                    pygame.draw.rect(surface, porcelain2, tank)
                    pygame.draw.rect(surface, steel2, pygame.Rect(tank.right - 3, tank.y + 1, 2, 2))
                    pygame.draw.rect(surface, outline, base.inflate(2, 2))
                    pygame.draw.rect(surface, porcelain2, base)
                    hole = bowl.inflate(-6, -6)
                    pygame.draw.ellipse(surface, (30, 30, 36), hole)
                    water = hole.inflate(-4, -4)
                    if water.w > 2 and water.h > 2:
                        pygame.draw.ellipse(surface, (64, 126, 190), water)
                        hl = pygame.Rect(water.x + 1, water.y + 1, max(1, water.w - 2), max(1, water.h // 2))
                        pygame.draw.ellipse(surface, (120, 184, 220), hl, 1)
                    pygame.draw.ellipse(surface, outline, hole, 1)
                    continue

                if ch == "E":
                    if (x, y) in elev_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "E":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "E":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "E":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            elev_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    er = br.inflate(-4, -4)
                    sh = pygame.Surface((er.w + 4, er.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 80), sh.get_rect())
                    surface.blit(sh, (er.x, er.y + 2))
                    # Pixel-style elevator.
                    pygame.draw.rect(surface, outline, er.inflate(2, 2))
                    pygame.draw.rect(surface, steel, er)
                    pygame.draw.rect(surface, steel2, pygame.Rect(er.x + 3, er.y + 3, er.w - 6, 3))
                    pygame.draw.line(surface, outline, (er.centerx, er.y + 4), (er.centerx, er.bottom - 5), 1)
                    pygame.draw.rect(surface, (255, 220, 140), pygame.Rect(er.right - 9, er.y + 10, 3, 5))
                    continue

                if ch == "B":
                    if (int(x), int(y)) in bed_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "B":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "B":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "B":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            bed_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    bed_r = br.inflate(-4, -8)
                    # Pixel-style outline: draw outline first, then fill.
                    sh = pygame.Surface((bed_r.w + 4, bed_r.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 90), sh.get_rect())
                    surface.blit(sh, (bed_r.x + 1, bed_r.y + 2))
                    pygame.draw.rect(surface, outline, bed_r.inflate(2, 2))
                    pygame.draw.rect(surface, bed_matt, bed_r)
                    hb = pygame.Rect(bed_r.x, bed_r.y, 8, bed_r.h)
                    pygame.draw.rect(surface, outline, hb.inflate(2, 2))
                    pygame.draw.rect(surface, wood2, hb)
                    p1 = pygame.Rect(bed_r.x + 10, bed_r.y + 4, max(10, bed_r.w // 5), 7)
                    p2 = pygame.Rect(p1.x, p1.y + 10, p1.w, 7)
                    pygame.draw.rect(surface, outline, p1.inflate(2, 2))
                    pygame.draw.rect(surface, pillow, p1)
                    pygame.draw.rect(surface, outline, p2.inflate(2, 2))
                    pygame.draw.rect(surface, pillow, p2)
                    bl = pygame.Rect(bed_r.x + 10, bed_r.y + 20, bed_r.w - 14, max(10, bed_r.h - 24))
                    pygame.draw.rect(surface, outline, bl.inflate(2, 2))
                    pygame.draw.rect(surface, bed_blank, bl)
                    for sx in range(bl.x + 6, bl.right - 4, 10):
                        pygame.draw.line(surface, bed_blank2, (sx, bl.y + 2), (sx, bl.bottom - 3), 1)
                    # Bed legs/frame (so it doesn't look like it floats).
                    floor_y = int(br.bottom - 3)
                    leg_y0 = int(bed_r.bottom - 2)
                    leg_h = int(floor_y - leg_y0)
                    if leg_h > 0:
                        leg_col = self._tint(wood2, add=(-12, -12, -12))
                        for lx in (int(bed_r.x + 6), int(bed_r.right - 8)):
                            leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                            surface.fill(leg_col, leg)
                            pygame.draw.rect(surface, outline, leg, 1)
                            surface.fill(leg_col, pygame.Rect(int(lx - 1), int(floor_y), 4, 1))
                    continue

                if ch == "K":
                    if (x, y) in k_done:
                        continue

                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "K":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "K":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "K":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            k_done.add((int(x) + int(dx), int(y) + int(dy)))

                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    # Less inset so the countertop reads flush to the block edges.
                    obj = br.inflate(-2, -6)
                    # Pixel-style outline.
                    sh = pygame.Surface((obj.w + 4, obj.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 70), sh.get_rect())
                    surface.blit(sh, (obj.x + 1, obj.y + 2))

                    # Marble countertop (big visible top, thin front face).
                    top_h = int(clamp(int(obj.h * 0.58), 12, 18))
                    top_r = pygame.Rect(obj.x, obj.y, obj.w, top_h)
                    front_r = pygame.Rect(obj.x, obj.y + top_h - 1, obj.w, obj.h - (top_h - 1))

                    stone_face = (170, 172, 178)
                    stone_face2 = (150, 152, 160)
                    marble_base = (228, 230, 236)

                    # Pixel-style outline for front face.
                    pygame.draw.rect(surface, outline, front_r.inflate(2, 2))
                    pygame.draw.rect(surface, stone_face, front_r)
                    pygame.draw.rect(surface, stone_face2, pygame.Rect(front_r.x + 1, front_r.y + 2, front_r.w - 2, 3))

                    marble = self._marble_surface(
                        int(top_r.w),
                        int(top_r.h),
                        seed=int(getattr(self, "seed", 0)) ^ (int(x) * 65537) ^ (int(y) * 9719) ^ 0x51F15EED,
                        base=marble_base,
                    )
                    # Pixel-style outline for marble top.
                    pygame.draw.rect(surface, outline, top_r.inflate(2, 2))
                    surface.blit(marble, top_r.topleft)
                    pygame.draw.line(surface, outline, (top_r.x + 2, top_r.bottom - 1), (top_r.right - 3, top_r.bottom - 1), 1)

                    # Cabinet seams / handles on the front face (stone drawers).
                    modules = int(max(2, int(bw)))
                    for i in range(1, modules):
                        xline = int(front_r.x + (front_r.w * i) / modules)
                        pygame.draw.line(surface, stone_face2, (xline, front_r.y + 5), (xline, front_r.bottom - 5), 2)
                        pygame.draw.line(surface, outline, (xline, front_r.y + 5), (xline, front_r.bottom - 5), 1)
                    for i in range(modules):
                        cx = int(front_r.x + (front_r.w * (i + 0.5)) / modules)
                        hy = int(front_r.y + front_r.h * 0.55)
                        hrect = pygame.Rect(cx - 2, hy - 1, 4, 2)
                        surface.fill((80, 82, 90), hrect)
                        pygame.draw.rect(surface, outline, hrect, 1)

                    # Sink + stove on the top.
                    sink_w = int(clamp(int(top_r.w * 0.20), 14, 22))
                    sink_h = int(clamp(int(top_r.h - 5), 6, 10))
                    sink = pygame.Rect(top_r.x + int(top_r.w * 0.18), top_r.y + 3, sink_w, sink_h)
                    # Pixel-style sink.
                    pygame.draw.rect(surface, outline, sink.inflate(2, 2))
                    pygame.draw.rect(surface, steel, sink)
                    pygame.draw.circle(surface, (60, 60, 70), (sink.right - 3, sink.y + 3), 1)
                    pygame.draw.line(surface, steel2, (sink.x + 2, sink.y + 1), (sink.x + 2, sink.y - 3), 1)
                    pygame.draw.line(surface, steel2, (sink.x + 2, sink.y - 3), (sink.x + 7, sink.y - 3), 1)

                    stove_w = int(clamp(int(top_r.w * 0.20), 14, 22))
                    stove_h = sink_h
                    stove = pygame.Rect(top_r.right - int(top_r.w * 0.16) - stove_w, top_r.y + 3, stove_w, stove_h)
                    # Pixel-style stove.
                    pygame.draw.rect(surface, outline, stove.inflate(2, 2))
                    pygame.draw.rect(surface, (40, 40, 50), stove)
                    pygame.draw.circle(surface, (80, 80, 90), (stove.x + stove_w // 3, stove.centery), 2)
                    pygame.draw.circle(surface, (80, 80, 90), (stove.right - stove_w // 3, stove.centery), 2)

                    # Small items so it reads as a real kitchen.
                    plate = pygame.Rect(top_r.right - 15, top_r.y + 3, 12, 5)
                    pygame.draw.ellipse(surface, (238, 238, 244), plate)
                    pygame.draw.ellipse(surface, outline, plate, 1)
                    bowl = pygame.Rect(top_r.x + 8, top_r.y + 3, 10, 5)
                    pygame.draw.ellipse(surface, (205, 214, 224), bowl)
                    pygame.draw.ellipse(surface, outline, bowl, 1)
                    pot = pygame.Rect(top_r.centerx - 8, top_r.y + 2, 16, 6)
                    # Pixel-style pot.
                    pygame.draw.rect(surface, outline, pot.inflate(2, 2))
                    pygame.draw.rect(surface, (40, 40, 50), pot)
                    pygame.draw.line(surface, steel2, (pot.x + 2, pot.y + 2), (pot.right - 3, pot.y + 2), 1)

                    # Subtle shelf/rack cue above the counter.
                    rack_y = int(top_r.y - 7)
                    if rack_y >= int(br.y) + 1:
                        pygame.draw.line(surface, outline, (top_r.x + 2, rack_y), (top_r.right - 3, rack_y), 1)
                        for ux in (top_r.x + 10, top_r.centerx, top_r.right - 12):
                            pygame.draw.line(surface, steel2, (int(ux), rack_y + 1), (int(ux), rack_y + 4), 1)
                    continue

                if ch == "T":
                    if (x, y) in t_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "T":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "T":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "T":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            t_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    top = br.inflate(-6, -10)
                    # Pixel-style outline.
                    sh = pygame.Surface((top.w + 4, top.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 70), sh.get_rect())
                    surface.blit(sh, (top.x + 1, top.y + 2))
                    pygame.draw.rect(surface, outline, top.inflate(2, 2))
                    pygame.draw.rect(surface, wood, top)
                    pygame.draw.rect(surface, wood2, pygame.Rect(top.x + 1, top.y + 1, top.w - 2, 4))
                    # Small TV / radio-like decoration.
                    screen = pygame.Rect(top.centerx - 10, top.y + 5, 20, 10)
                    pygame.draw.rect(surface, outline, screen.inflate(2, 2))
                    pygame.draw.rect(surface, (36, 38, 44), screen)
                    pygame.draw.rect(surface, steel2, screen, 1)
                    pygame.draw.rect(surface, (120, 200, 240), pygame.Rect(screen.x + 3, screen.y + 3, 7, 4))
                    # Table legs (front-view cue).
                    floor_y = int(br.bottom - 3)
                    leg_y0 = int(top.bottom - 1)
                    leg_h = int(floor_y - leg_y0)
                    if leg_h > 0 and top.w >= 12:
                        leg_col = self._tint(wood2, add=(-10, -10, -10))
                        for lx in (int(top.x + 4), int(top.right - 6)):
                            leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                            surface.fill(leg_col, leg)
                            pygame.draw.rect(surface, outline, leg, 1)
                        # Simple crossbar.
                        if leg_h >= 4:
                            yb = int(floor_y - 2)
                            surface.fill(leg_col, pygame.Rect(int(top.x + 4), yb, int(max(1, top.w - 8)), 1))
                    continue

                if ch == "S":
                    if (x, y) in s_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "S":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "S":  
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "S":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            s_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    # Keep cabinets tall enough even when the block is only 1 tile high (e.g., the bottom-left cabinet).
                    obj = br.inflate(-6, -4)
                    # Pixel-style outline.
                    sh = pygame.Surface((obj.w + 4, obj.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 70), sh.get_rect())
                    surface.blit(sh, (obj.x + 1, obj.y + 2))
                    # Wardrobe / cabinet: draw top + front face (two visible planes).
                    cab_top = self._tint(wood, add=(14, 12, 10))
                    cab_front = self._tint(wood2, add=(2, 2, 2))
                    cab_front2 = self._tint(cab_front, add=(-16, -14, -12))
                    hi = self._tint(cab_top, add=(22, 22, 22))
                    lo = self._tint(cab_front, add=(-26, -24, -22))

                    top_h = int(clamp(int(obj.h * 0.34), 8, 12))
                    top_r = pygame.Rect(obj.x, obj.y, obj.w, top_h)
                    front_r = pygame.Rect(obj.x, obj.y + top_h - 1, obj.w, obj.h - (top_h - 1))

                    # Pixel-style outline for front face.
                    pygame.draw.rect(surface, outline, front_r.inflate(2, 2))
                    pygame.draw.rect(surface, cab_front, front_r)
                    pygame.draw.rect(surface, cab_front2, pygame.Rect(front_r.x + 1, front_r.y + 2, front_r.w - 2, 3))

                    # Pixel-style outline for top.
                    pygame.draw.rect(surface, outline, top_r.inflate(2, 2))
                    pygame.draw.rect(surface, cab_top, top_r)
                    pygame.draw.line(surface, hi, (top_r.x + 2, top_r.y + 1), (top_r.right - 3, top_r.y + 1), 1)
                    pygame.draw.line(surface, outline, (top_r.x + 2, top_r.bottom - 1), (top_r.right - 3, top_r.bottom - 1), 1)

                    # Inset doors live on the front face (keeps the top readable).
                    door_area = front_r.inflate(-4, -6)
                    if door_area.w > 6 and door_area.h > 8:
                        pygame.draw.rect(surface, outline, door_area.inflate(2, 2))
                        pygame.draw.rect(surface, self._tint(cab_front, add=(-8, -6, -4)), door_area)
                    else:
                        door_area = pygame.Rect(front_r)

                    # Tiny feet so it doesn't look like it floats.
                    floor_y = int(br.bottom - 3)
                    leg_y0 = int(front_r.bottom - 2)
                    leg_h = int(floor_y - leg_y0)
                    if leg_h > 0:
                        leg_col = self._tint(cab_front2, add=(-16, -16, -16))
                        for lx in (int(front_r.x + 6), int(front_r.right - 8)):
                            leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                            surface.fill(leg_col, leg)
                            pygame.draw.rect(surface, outline, leg, 1)

                    open_block = getattr(self, "home_ui_open_block", None)
                    is_open = bool(getattr(self, "home_ui_open", False)) and open_block == (
                        int(x),
                        int(y),
                        int(x) + int(bw) - 1,
                        int(y) + int(bh) - 1,
                    )
                    if is_open:
                        inner = door_area.inflate(-10, -10)
                        if inner.w > 4 and inner.h > 4:
                            # Pixel-style cabinet interior.
                            pygame.draw.rect(surface, outline, inner.inflate(2, 2))
                            pygame.draw.rect(surface, (20, 20, 24), inner)
                            # Inside top surface + shelves.
                            pygame.draw.line(surface, self._tint(cab_front2, add=(18, 18, 18)), (inner.x + 2, inner.y + 2), (inner.right - 3, inner.y + 2), 1)
                            step = max(6, int(inner.h // 3))
                            for sy in range(inner.y + step, inner.bottom - 2, step):
                                pygame.draw.line(surface, cab_front2, (inner.x + 2, sy), (inner.right - 3, sy), 2)
                                pygame.draw.line(surface, outline, (inner.x + 2, sy), (inner.right - 3, sy), 1)
                            # Small visible supplies.
                            can = pygame.Rect(inner.x + 4, inner.y + 5, 5, 7)
                            surface.fill((180, 60, 70), can)
                            pygame.draw.rect(surface, outline, can, 1)
                            jar = pygame.Rect(inner.right - 10, inner.y + 6, 7, 6)
                            surface.fill((90, 140, 190), jar)
                            pygame.draw.rect(surface, outline, jar, 1)

                        # Doors "slid open" to sides. Pixel-style.
                        door_w = max(6, int(door_area.w // 5))
                        ld = pygame.Rect(door_area.x + 1, door_area.y + 3, door_w, door_area.h - 6)
                        rd = pygame.Rect(door_area.right - door_w - 1, door_area.y + 3, door_w, door_area.h - 6)
                        for d in (ld, rd):
                            pygame.draw.rect(surface, outline, d.inflate(2, 2))
                            pygame.draw.rect(surface, cab_front, d)
                            inset = d.inflate(-2, -4)
                            if inset.w > 2 and inset.h > 2:
                                pygame.draw.rect(surface, outline, inset.inflate(2, 2))
                                pygame.draw.rect(surface, self._tint(cab_front, add=(-8, -8, -8)), inset)
                                pygame.draw.line(surface, hi, (inset.x + 1, inset.y + 1), (inset.right - 2, inset.y + 1), 1)
                        for d in (ld, rd):
                            hy = int(d.y + d.h * 0.55)
                            hrect = pygame.Rect(d.centerx - 1, hy - 3, 2, 6)
                            surface.fill((220, 220, 230), hrect)
                            pygame.draw.rect(surface, outline, hrect, 1)
                    else:
                        # Closed doors + handles.
                        doors = max(2, int(door_area.w // 24))
                        doors = int(clamp(doors, 2, 4))
                        y_top = int(door_area.y + 2)
                        y_bot = int(door_area.bottom - 3)
                        for i in range(1, doors):
                            xline = int(door_area.x + (door_area.w * i) / doors)
                            pygame.draw.line(surface, cab_front2, (xline, y_top), (xline, y_bot), 2)
                            pygame.draw.line(surface, outline, (xline, y_top), (xline, y_bot), 1)
                        for i in range(doors):
                            x0 = int(door_area.x + (door_area.w * i) / doors)
                            x1 = int(door_area.x + (door_area.w * (i + 1)) / doors)
                            panel = pygame.Rect(x0 + 2, y_top + 1, (x1 - x0) - 4, max(2, int(y_bot - y_top - 2)))
                            if panel.w > 3 and panel.h > 3:
                                # Pixel-style cabinet panel.
                                pygame.draw.rect(surface, outline, panel.inflate(2, 2))
                                pygame.draw.rect(surface, self._tint(cab_front, add=(-6, -6, -6)), panel)
                                pygame.draw.line(surface, hi, (panel.x + 1, panel.y + 1), (panel.right - 2, panel.y + 1), 1)

                            hx = int(door_area.x + (door_area.w * (i + 0.5)) / doors)
                            hy = int(door_area.y + door_area.h * 0.55)
                            hrect = pygame.Rect(hx - 1, hy - 3, 2, 6)
                            surface.fill((220, 220, 230), hrect)
                            pygame.draw.rect(surface, outline, hrect, 1)
                    continue

                if ch == "F":
                    if (x, y) in f_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "F":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "F":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "F":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            f_done.add((int(x) + int(dx), int(y) + int(dy)))

                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    obj = br.inflate(-4, -4)
                    # Pixel-style outline.
                    sh = pygame.Surface((obj.w + 4, obj.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 70), sh.get_rect())
                    surface.blit(sh, (obj.x + 1, obj.y + 2))

                    fridge_top = (238, 240, 246)
                    fridge_front = (210, 214, 224)
                    fridge_front2 = (178, 182, 194)
                    hi = (248, 248, 252)

                    top_h = int(clamp(int(obj.h * 0.34), 8, 12))
                    top_r = pygame.Rect(obj.x, obj.y, obj.w, top_h)
                    front_r = pygame.Rect(obj.x, obj.y + top_h - 1, obj.w, obj.h - (top_h - 1))

                    # Pixel-style outline for fridge.
                    pygame.draw.rect(surface, outline, front_r.inflate(2, 2))
                    pygame.draw.rect(surface, fridge_front, front_r)
                    pygame.draw.rect(surface, fridge_front2, pygame.Rect(front_r.x + 1, front_r.y + 2, front_r.w - 2, 3))

                    pygame.draw.rect(surface, outline, top_r.inflate(2, 2))
                    pygame.draw.rect(surface, fridge_top, top_r)
                    pygame.draw.line(surface, hi, (top_r.x + 2, top_r.y + 1), (top_r.right - 3, top_r.y + 1), 1)
                    pygame.draw.line(surface, outline, (top_r.x + 2, top_r.bottom - 1), (top_r.right - 3, top_r.bottom - 1), 1)

                    door_area = front_r.inflate(-4, -6)
                    if door_area.w <= 6 or door_area.h <= 8:
                        door_area = pygame.Rect(front_r)

                    open_block = getattr(self, "home_ui_open_block", None)
                    is_open = bool(getattr(self, "home_ui_open", False)) and open_block == (
                        int(x),
                        int(y),
                        int(x) + int(bw) - 1,
                        int(y) + int(bh) - 1,
                    )
                    if is_open:
                        inner = door_area.inflate(-8, -8)
                        if inner.w > 4 and inner.h > 4:
                            # Pixel-style fridge interior.
                            pygame.draw.rect(surface, outline, inner.inflate(2, 2))
                            pygame.draw.rect(surface, (20, 20, 24), inner)
                            for sy in range(inner.y + 4, inner.bottom - 2, 6):
                                pygame.draw.line(surface, (44, 44, 52), (inner.x + 2, sy), (inner.right - 3, sy), 1)
                            bottle = pygame.Rect(inner.x + 3, inner.bottom - 9, 4, 7)
                            surface.fill((120, 170, 230), bottle)
                            pygame.draw.rect(surface, outline, bottle, 1)
                            can = pygame.Rect(inner.right - 8, inner.bottom - 8, 5, 6)
                            surface.fill((220, 70, 80), can)
                            pygame.draw.rect(surface, outline, can, 1)

                        # Doors slid to sides. Pixel-style.
                        door_w = max(6, int(door_area.w // 5))
                        ld = pygame.Rect(door_area.x + 1, door_area.y + 3, door_w, door_area.h - 6)
                        rd = pygame.Rect(door_area.right - door_w - 1, door_area.y + 3, door_w, door_area.h - 6)
                        for d in (ld, rd):
                            pygame.draw.rect(surface, outline, d.inflate(2, 2))
                            pygame.draw.rect(surface, fridge_front, d)
                            inset = d.inflate(-2, -4)
                            if inset.w > 2 and inset.h > 2:
                                pygame.draw.rect(surface, outline, inset.inflate(2, 2))
                                pygame.draw.rect(surface, self._tint(fridge_front, add=(-8, -8, -8)), inset)
                                pygame.draw.line(surface, hi, (inset.x + 1, inset.y + 1), (inset.right - 2, inset.y + 1), 1)
                    else:
                        # Freezer split line + handle + magnets.
                        split_y = int(door_area.y + door_area.h * 0.38)
                        pygame.draw.line(surface, fridge_front2, (door_area.x + 2, split_y), (door_area.right - 3, split_y), 2)
                        pygame.draw.line(surface, outline, (door_area.x + 2, split_y), (door_area.right - 3, split_y), 1)
                        handle = pygame.Rect(door_area.right - 5, door_area.y + 4, 2, max(6, door_area.h - 8))
                        surface.fill(steel2, handle)
                        pygame.draw.rect(surface, outline, handle, 1)
                        for mx, my, col in (
                            (door_area.x + 3, door_area.y + 4, (240, 120, 120)),
                            (door_area.x + 6, door_area.y + 7, (120, 200, 140)),
                            (door_area.x + 4, door_area.y + 10, (240, 220, 140)),
                        ):
                            mr = pygame.Rect(int(mx), int(my), 3, 3)
                            surface.fill(col, mr)
                            pygame.draw.rect(surface, outline, mr, 1)

                    # Tiny feet so it doesn't look like it floats.
                    floor_y = int(br.bottom - 3)
                    leg_y0 = int(front_r.bottom - 2)
                    leg_h = int(floor_y - leg_y0)
                    if leg_h > 0:
                        leg_col = self._tint(fridge_front2, add=(-16, -16, -16))
                        for lx in (int(front_r.x + 6), int(front_r.right - 8)):
                            leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                            surface.fill(leg_col, leg)
                            pygame.draw.rect(surface, outline, leg, 1)
                    continue

                if ch == "X":
                    if (x, y) in x_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "X":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "X":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "X":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            x_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    obj = br.inflate(-6, -10)
                    if obj.w <= 0 or obj.h <= 0:
                        continue
                    # Pixel-style outline.
                    sh = pygame.Surface((obj.w + 4, obj.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 60), sh.get_rect())
                    surface.blit(sh, (obj.x + 1, obj.y + 2))

                    stand_h = int(clamp(int(obj.h * 0.36), 6, 12))
                    stand = pygame.Rect(int(obj.x + 2), int(obj.bottom - stand_h), int(obj.w - 4), int(stand_h))
                    pygame.draw.rect(surface, outline, stand.inflate(2, 2))
                    pygame.draw.rect(surface, wood2, stand)
                    pygame.draw.rect(surface, self._tint(wood2, add=(18, 18, 18)), pygame.Rect(stand.x + 2, stand.y + 2, max(1, stand.w - 4), 3))

                    tv_w = int(clamp(int(obj.w * 0.72), 20, max(20, obj.w - 2)))
                    tv_h = int(clamp(int(obj.h * 0.58), 12, 22))
                    tv = pygame.Rect(0, 0, tv_w, tv_h)
                    tv.midtop = (obj.centerx, obj.y + 1)
                    frame = tv.inflate(4, 4)
                    # Pixel-style outline for TV.
                    pygame.draw.rect(surface, outline, frame.inflate(2, 2))
                    pygame.draw.rect(surface, (34, 36, 44), frame)
                    screen = tv.inflate(-2, -2)
                    pygame.draw.rect(surface, outline, screen.inflate(2, 2))
                    pygame.draw.rect(surface, (14, 14, 18), screen)
                    pygame.draw.rect(surface, steel2, screen, 1)
                    if tv_on:
                        # Simple animated "show" on the TV.
                        surface.fill((18, 20, 28), screen)
                        for iy in range(screen.y + 2, screen.bottom - 2, 4):
                            col = (28, 32, 44) if ((iy // 4) % 2) == 0 else (22, 26, 36)
                            surface.fill(col, pygame.Rect(screen.x + 2, iy, screen.w - 4, 1))
                        phase = int(float(self.world_time_s) * 3.0)
                        span = max(1, int(screen.w - 8))
                        px = int(screen.x + 4 + (phase * 2) % span)
                        py = int(screen.y + screen.h // 2 - 2)
                        pygame.draw.rect(surface, (200, 220, 240), pygame.Rect(px, py, 2, 2))
                        pygame.draw.rect(surface, (170, 190, 210), pygame.Rect(px, py + 2, 2, 3))
                        pygame.draw.rect(surface, (140, 160, 190), pygame.Rect(px - 1, py + 5, 4, 1))
                    else:
                        glow = pygame.Rect(screen.x + 4, screen.y + 4, max(5, int(screen.w * 0.25)), max(4, int(screen.h * 0.22)))
                        pygame.draw.rect(surface, (120, 200, 240), glow)
                    pygame.draw.line(surface, steel2, (screen.x + 2, screen.bottom - 3), (screen.right - 3, screen.bottom - 3), 1)
                    # Game console / set-top box. Pixel-style.
                    box = pygame.Rect(int(stand.centerx - 10), int(stand.y + 3), 20, 6)
                    pygame.draw.rect(surface, outline, box.inflate(2, 2))
                    pygame.draw.rect(surface, (26, 26, 32), box)
                    pygame.draw.circle(surface, (120, 200, 140), (box.right - 4, box.centery), 1)
                    continue

                if ch == "P":
                    if (x, y) in p_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "P":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "P":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "P":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            p_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    obj = br.inflate(-6, -10)
                    if obj.w <= 0 or obj.h <= 0:
                        continue
                    # Pixel-style outline.
                    sh = pygame.Surface((obj.w + 4, obj.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 70), sh.get_rect())
                    surface.blit(sh, (obj.x + 1, obj.y + 2))

                    top_h = int(clamp(int(obj.h * 0.36), 10, 18))
                    top = pygame.Rect(int(obj.x), int(obj.y), int(obj.w), int(top_h))
                    front = pygame.Rect(int(obj.x), int(obj.y + top_h - 1), int(obj.w), int(obj.h - (top_h - 1)))
                    desk_top = self._tint(wood, add=(10, 8, 6))
                    desk_front = self._tint(wood2, add=(6, 4, 2))
                    # Pixel-style outline for desk.
                    pygame.draw.rect(surface, outline, front.inflate(2, 2))
                    pygame.draw.rect(surface, desk_front, front)
                    pygame.draw.rect(surface, outline, top.inflate(2, 2))
                    pygame.draw.rect(surface, desk_top, top)
                    pygame.draw.line(surface, self._tint(desk_top, add=(26, 26, 26)), (top.x + 2, top.y + 1), (top.right - 3, top.y + 1), 1)

                    # Monitor + keyboard. Pixel-style.
                    mon_w = int(clamp(int(top.w * 0.42), 14, 30))
                    mon_h = int(clamp(int(top.h * 0.70), 10, 16))
                    mon = pygame.Rect(0, 0, mon_w, mon_h)
                    mon.center = (int(top.centerx - top.w * 0.12), int(top.centery + 1))
                    pygame.draw.rect(surface, outline, mon.inflate(2, 2))
                    pygame.draw.rect(surface, (32, 34, 40), mon)
                    # Give the monitor a tiny "thickness" so it reads 3D.
                    side = pygame.Rect(mon.right - 1, mon.y + 1, 2, max(1, mon.h - 2))
                    pygame.draw.rect(surface, (22, 22, 28), side)
                    pygame.draw.line(surface, outline, (side.x, side.y + 1), (side.x, side.bottom - 2), 1)
                    scr = mon.inflate(-3, -3)
                    pygame.draw.rect(surface, (14, 14, 18), scr)
                    pygame.draw.rect(surface, (120, 200, 240), pygame.Rect(scr.x + 2, scr.y + 2, max(3, scr.w // 3), max(3, scr.h // 3)))
                    kb = pygame.Rect(int(mon.right + 3), int(top.bottom - 6), max(12, int(top.w * 0.30)), 4)
                    pygame.draw.rect(surface, outline, kb.inflate(2, 2))
                    pygame.draw.rect(surface, (36, 36, 44), kb)
                    for xx in range(int(kb.x + 2), int(kb.right - 2), 3):
                        surface.fill((60, 60, 72), pygame.Rect(int(xx), int(kb.y + 1), 1, 1))

                    # PC tower. Pixel-style.
                    tower = pygame.Rect(int(top.right - 10), int(front.y + 4), 8, max(10, int(front.h - 8)))
                    pygame.draw.rect(surface, outline, tower.inflate(2, 2))
                    pygame.draw.rect(surface, (28, 28, 34), tower)
                    surface.fill((18, 18, 22), pygame.Rect(tower.right - 2, tower.y + 1, 1, max(1, tower.h - 2)))
                    surface.fill((56, 56, 66), pygame.Rect(tower.x + 1, tower.y + 2, max(1, tower.w - 3), 1))
                    pygame.draw.circle(surface, (120, 200, 140), (tower.centerx, tower.y + 5), 1)
                    continue

                if ch == "R":
                    if (x, y) in r_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "R":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "R":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "R":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            r_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    obj = br.inflate(-6, -10)
                    if obj.w <= 0 or obj.h <= 0:
                        continue
                    # Pixel-style outline.
                    sh = pygame.Surface((obj.w + 4, obj.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 60), sh.get_rect())
                    surface.blit(sh, (obj.x + 1, obj.y + 2))

                    tray = obj.inflate(-2, -2)
                    tray_col = (214, 216, 222)
                    tray_hi = (232, 232, 238)
                    pygame.draw.rect(surface, outline, tray.inflate(2, 2))
                    pygame.draw.rect(surface, tray_col, tray)
                    pygame.draw.rect(surface, tray_hi, pygame.Rect(tray.x + 2, tray.y + 2, tray.w - 4, 3), border_radius=3)
                    drain = pygame.Rect(tray.centerx + 4, tray.centery + 3, 4, 4)
                    pygame.draw.ellipse(surface, (40, 40, 48), drain)
                    pygame.draw.ellipse(surface, outline, drain, 1)

                    glass = tray.inflate(-6, -10)
                    if glass.w > 6 and glass.h > 6:
                        gs = pygame.Surface((glass.w, glass.h), pygame.SRCALPHA)
                        gs.fill((90, 140, 190, 55))
                        # Pixel-style glass frame.
                        pygame.draw.rect(gs, (210, 220, 235, 80), gs.get_rect(), 1)
                        surface.blit(gs, glass.topleft)
                        pygame.draw.line(surface, outline, (glass.centerx, glass.y + 2), (glass.centerx, glass.bottom - 3), 1)
                    # Showerhead hint.
                    pygame.draw.line(surface, steel2, (tray.x + 6, tray.y + 4), (tray.x + 12, tray.y + 4), 1)
                    pygame.draw.circle(surface, steel2, (tray.x + 12, tray.y + 4), 2, 1)
                    continue

                if ch == "U":
                    base = r.inflate(-6, -8)
                    if base.w > 0 and base.h > 0:
                        # Pixel-style bathroom vanity.
                        cab = pygame.Rect(base.x, base.y + 4, base.w, max(6, base.h - 4))
                        pygame.draw.rect(surface, outline, cab.inflate(2, 2))
                        pygame.draw.rect(surface, wood2, cab)
                        basin = pygame.Rect(base.x + 2, base.y + 1, base.w - 4, 6)
                        pygame.draw.rect(surface, outline, basin.inflate(2, 2))
                        pygame.draw.rect(surface, (238, 238, 244), basin)
                        pygame.draw.circle(surface, steel2, (basin.right - 4, basin.y + 2), 1)
                        pygame.draw.line(surface, steel2, (basin.right - 4, basin.y + 2), (basin.right - 4, basin.y + 5), 1)
                    continue

                if ch == "O":
                    # Pixel-style toilet (second rendering path).
                    bowl = pygame.Rect(r.x + 6, r.y + 9, r.w - 12, r.h - 10)
                    tank = pygame.Rect(r.centerx - 5, r.y + 5, 10, 6)
                    pygame.draw.ellipse(surface, (238, 238, 244), bowl)
                    pygame.draw.ellipse(surface, outline, bowl, 1)
                    pygame.draw.rect(surface, outline, tank.inflate(2, 2))
                    pygame.draw.rect(surface, (238, 238, 244), tank)
                    seat = bowl.inflate(-4, -4)
                    pygame.draw.ellipse(surface, (210, 210, 218), seat)
                    pygame.draw.ellipse(surface, outline, seat, 1)
                    continue

                if ch == "C":
                    if (x, y) in c_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "C":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "C":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "C":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            c_done.add((int(x) + int(dx), int(y) + int(dy)))

                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    obj = br.inflate(-6, -10)
                    # Pixel-style outline.
                    sh = pygame.Surface((obj.w + 4, obj.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 60), sh.get_rect())
                    surface.blit(sh, (obj.x + 1, obj.y + 2))

                    is_sofa = bool(mode == "home" and (int(bw) >= 3 or int(bh) >= 2))
                    if is_sofa:
                        back_h = int(clamp(int(obj.h // 3), 7, 12))
                        back = pygame.Rect(obj.x + 1, obj.y + 1, obj.w - 2, back_h)
                        seat_r = pygame.Rect(obj.x, obj.y + back_h - 1, obj.w, obj.h - back_h + 1)
                        # Pixel-style outline for sofa.
                        pygame.draw.rect(surface, outline, seat_r.inflate(2, 2))
                        pygame.draw.rect(surface, seat, seat_r)
                        pygame.draw.rect(surface, outline, back.inflate(2, 2))
                        pygame.draw.rect(surface, seat2, back)
                        arm_w = int(clamp(int(obj.w // 10), 4, 8))
                        arm_l = pygame.Rect(seat_r.x, back.bottom - 2, arm_w, seat_r.h - 2)
                        arm_r = pygame.Rect(seat_r.right - arm_w, back.bottom - 2, arm_w, seat_r.h - 2)
                        pygame.draw.rect(surface, outline, arm_l.inflate(2, 2))
                        pygame.draw.rect(surface, seat2, arm_l)
                        pygame.draw.rect(surface, outline, arm_r.inflate(2, 2))
                        pygame.draw.rect(surface, seat2, arm_r)
                        for i in (1, 2):
                            xline = int(seat_r.x + (seat_r.w * i) / 3)
                            pygame.draw.line(surface, outline, (xline, seat_r.y + 3), (xline, seat_r.bottom - 4), 1)
                        if back.w >= 24:
                            # Pixel-style sofa cushions.
                            p_w = int(clamp(int(back.w // 3), 10, 18))
                            for px in (back.x + 6, back.right - p_w - 6):
                                p = pygame.Rect(int(px), back.y + 3, int(p_w), max(4, int(back.h - 5)))
                                pygame.draw.rect(surface, outline, p.inflate(2, 2))
                                pygame.draw.rect(surface, self._tint(seat, add=(18, 18, 18)), p)
                        floor_y = int(br.bottom - 3)
                        leg_y0 = int(seat_r.bottom - 1)
                        leg_h = int(floor_y - leg_y0)
                        if leg_h > 0:
                            leg_col = self._tint(seat2, add=(-22, -22, -22))
                            for lx in (int(seat_r.x + 6), int(seat_r.right - 8)):
                                leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                                surface.fill(leg_col, leg)
                                pygame.draw.rect(surface, outline, leg, 1)
                    else:
                        # Pixel-style outline for chair.
                        pygame.draw.rect(surface, outline, obj.inflate(2, 2))
                        pygame.draw.rect(surface, seat, obj)
                        back = pygame.Rect(obj.x + 2, obj.y + 2, obj.w - 4, int(clamp(int(obj.h * 0.45), 5, 10)))
                        pygame.draw.rect(surface, outline, back.inflate(2, 2))
                        pygame.draw.rect(surface, seat2, back)
                        seat_r = pygame.Rect(obj.x + 2, back.bottom - 1, obj.w - 4, obj.bottom - (back.bottom - 1))
                        pygame.draw.rect(surface, outline, seat_r.inflate(2, 2))
                        pygame.draw.rect(surface, self._tint(seat, add=(12, 12, 12)), seat_r)
                        floor_y = int(br.bottom - 3)
                        leg_y0 = int(seat_r.bottom - 1)
                        leg_h = int(floor_y - leg_y0)
                        if leg_h > 0:
                            leg_col = self._tint(seat2, add=(-18, -18, -18))
                            for lx in (int(seat_r.x + 2), int(seat_r.right - 4)):
                                leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                                surface.fill(leg_col, leg)
                                pygame.draw.rect(surface, outline, leg, 1)
                    continue

                if False and ch == "C":
                    sr = pygame.Rect(r.x + 4, r.y + 4, r.w - 8, r.h - 8)
                    sh = pygame.Surface((sr.w, sr.h), pygame.SRCALPHA)  
                    pygame.draw.rect(sh, (0, 0, 0, 60), sh.get_rect(), border_radius=4)
                    surface.blit(sh, (sr.x + 1, sr.y + 2))
                    pygame.draw.rect(surface, seat, sr, border_radius=4)
                    pygame.draw.rect(surface, outline, sr, 1, border_radius=4)
                    pygame.draw.rect(surface, seat2, pygame.Rect(sr.x + 2, sr.y + 2, sr.w - 4, 4), border_radius=2)
                    # Legs (gives the chair more readable structure).
                    leg_y0 = int(sr.bottom - 1)
                    leg_y1 = int(r.bottom - 3)
                    leg_h = int(leg_y1 - leg_y0)
                    if leg_h > 0:
                        leg_col = self._tint(seat2, add=(-18, -18, -18))        
                        for lx in (int(sr.x + 3), int(sr.right - 5)):
                            leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                            surface.fill(leg_col, leg)
                            pygame.draw.rect(surface, outline, leg, 1)
                    continue

        # Apartment floor loot + proximity outlines.
        if mode == "home":
            items = getattr(self, "hr_floor_items", None)
            near_i: int | None = None
            near_d2 = float("inf")
            if isinstance(items, list) and items:
                focus = pygame.Vector2(self.hr_int_pos)
                for i, it in enumerate(items):
                    if not isinstance(it, HardcoreSurvivalState._WorldItem):
                        continue
                    d2 = float((pygame.Vector2(it.pos) - focus).length_squared())
                    if d2 < near_d2:
                        near_d2 = d2
                        near_i = int(i)

                for i, it in enumerate(items):
                    if not isinstance(it, HardcoreSurvivalState._WorldItem):
                        continue
                    spr = self._ITEM_SPRITES_WORLD.get(it.item_id) or self._ITEM_SPRITES.get(it.item_id)
                    if spr is None:
                        continue
                    ix = int(round(map_x + float(it.pos.x) - float(spr.get_width()) / 2.0))
                    iy = int(round(map_y + float(it.pos.y) - float(spr.get_height()) / 2.0))
                    surface.blit(spr, (ix, iy))
                    if near_i is not None and int(i) == int(near_i) and near_d2 <= (22.0 * 22.0):
                        pygame.draw.rect(
                            surface,
                            (0, 220, 80),
                            pygame.Rect(ix - 2, iy - 2, spr.get_width() + 4, spr.get_height() + 4),
                            2,
                            border_radius=3,
                        )

            tx, ty = self._hr_int_player_tile()
            candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
            interact = {"D", "B", "S", "F", "C", "O", "L"}
            pose = str(getattr(self, "player_pose", "")).strip()
            pose_space = str(getattr(self, "player_pose_space", "")).strip()
            in_pose = bool(pose_space == "hr" and pose in ("sleep", "sit"))

            def _draw_cells_outline(
                cells: list[tuple[int, int]],
                *,
                rgb: tuple[int, int, int],
                fill_alpha: int = 0,
                edge_alpha: int = 200,
            ) -> None:
                if not cells:
                    return
                min_x = min(int(p[0]) for p in cells)
                max_x = max(int(p[0]) for p in cells)
                min_y = min(int(p[1]) for p in cells)
                max_y = max(int(p[1]) for p in cells)
                w_tiles = int(max_x - min_x + 1)
                h_tiles = int(max_y - min_y + 1)
                ov = pygame.Surface((int(w_tiles) * int(tile), int(h_tiles) * int(tile)), pygame.SRCALPHA)
                cell_set = {(int(x), int(y)) for (x, y) in cells}
                if int(fill_alpha) > 0:
                    fill_col = (int(rgb[0]), int(rgb[1]), int(rgb[2]), int(clamp(int(fill_alpha), 0, 255)))
                    for cx, cy in cell_set:
                        rr = pygame.Rect(int((cx - min_x) * tile), int((cy - min_y) * tile), int(tile), int(tile))
                        ov.fill(fill_col, rr)
                edge_col = (int(rgb[0]), int(rgb[1]), int(rgb[2]), int(clamp(int(edge_alpha), 0, 255)))
                for cx, cy in cell_set:
                    rx = int((cx - min_x) * tile)
                    ry = int((cy - min_y) * tile)
                    left = int(rx)
                    right = int(rx + tile - 1)
                    top = int(ry)
                    bottom = int(ry + tile - 1)
                    if (int(cx) - 1, int(cy)) not in cell_set:
                        pygame.draw.line(ov, edge_col, (left, top), (left, bottom), 1)
                    if (int(cx) + 1, int(cy)) not in cell_set:
                        pygame.draw.line(ov, edge_col, (right, top), (right, bottom), 1)
                    if (int(cx), int(cy) - 1) not in cell_set:
                        pygame.draw.line(ov, edge_col, (left, top), (right, top), 1)
                    if (int(cx), int(cy) + 1) not in cell_set:
                        pygame.draw.line(ov, edge_col, (left, bottom), (right, bottom), 1)
                surface.blit(ov, (int(map_x + min_x * tile), int(map_y + min_y * tile)))

            near_lamp: tuple[int, int] | None = None
            for cx, cy in candidates:
                if str(self._hr_int_char_at(int(cx), int(cy)))[:1] == "L":
                    near_lamp = (int(cx), int(cy))
                    break

            chosen_ch = ""
            for cx, cy in candidates:
                ch = self._hr_int_char_at(cx, cy)
                if ch not in interact:
                    continue
                w = int(self._HR_INT_W)
                h = int(self._HR_INT_H)
                seen: set[tuple[int, int]] = set()
                stack = [(int(cx), int(cy))]
                cells: list[tuple[int, int]] = []
                while stack:
                    sx, sy = stack.pop()
                    if (int(sx), int(sy)) in seen:
                        continue
                    if not (0 <= int(sx) < int(w) and 0 <= int(sy) < int(h)):
                        continue
                    if str(self._hr_int_char_at(int(sx), int(sy)))[:1] != str(ch)[:1]:
                        continue
                    seen.add((int(sx), int(sy)))
                    cells.append((int(sx), int(sy)))
                    stack.extend([(int(sx) + 1, int(sy)), (int(sx) - 1, int(sy)), (int(sx), int(sy) + 1), (int(sx), int(sy) - 1)])
                _draw_cells_outline(cells, rgb=(0, 220, 80), fill_alpha=0, edge_alpha=220)
                chosen_ch = str(ch)[:1]
                break

            if (
                near_lamp is not None
                and not bool(in_pose)
                and str(getattr(self, "hr_mode", "lobby")) == "home"
                and str(room_id).strip()
                and not bool(getattr(self, "inv_open", False))
                and not bool(getattr(self, "home_ui_open", False))
                and not bool(getattr(self, "hr_elevator_ui_open", False))
                and not bool(getattr(self, "world_map_open", False))
                and not bool(getattr(self, "hr_edit_mode", False))
            ):
                lx, ly = int(near_lamp[0]), int(near_lamp[1])
                if str(chosen_ch) != "L":
                    _draw_cells_outline([(int(lx), int(ly))], rgb=(0, 220, 80), fill_alpha=0, edge_alpha=220)

                label_toggle = "" if bool(light_on) else ""
                label_move = ""
                font = self.app.font_s
                btn_h = int(font.get_height()) + 4
                btn_w = int(max(30, int(max(font.size(str(label_toggle))[0], font.size(str(label_move))[0])) + 12))
                gap = 4
                opts: list[tuple[str, str, tuple[int, int] | None]] = [
                    (str(label_toggle), "toggle_lamp", None),
                    (str(label_move), "hr_move", (int(lx), int(ly))),
                ]

                panel_w = int(len(opts) * btn_w + max(0, len(opts) - 1) * gap + 10)
                panel_h = int(btn_h + 10)
                lr = pygame.Rect(int(map_x + int(lx) * tile), int(map_y + int(ly) * tile), int(tile), int(tile))
                px = int(lr.centerx - panel_w // 2)
                py = int(lr.top - panel_h - 6)
                if py < int(map_rect.top + 2):
                    py = int(lr.bottom + 6)
                panel = pygame.Rect(int(px), int(py), int(panel_w), int(panel_h))
                panel.clamp_ip(map_rect.inflate(-2, -2))
                # Pixel-style panel (no border_radius).
                pygame.draw.rect(surface, (90, 90, 110), panel.inflate(2, 2))
                pygame.draw.rect(surface, (18, 18, 22), panel)

                x0 = int(panel.x + 5)
                y0 = int(panel.y + 5)
                for i, (label, action, payload) in enumerate(opts):
                    br = pygame.Rect(int(x0 + i * (btn_w + gap)), int(y0), int(btn_w), int(btn_h))
                    # Pixel-style button (no border_radius).
                    pygame.draw.rect(surface, (160, 160, 180), br.inflate(2, 2))
                    pygame.draw.rect(surface, (28, 28, 34), br)
                    draw_text(surface, font, str(label), (br.centerx, br.centery - 1), pygame.Color(230, 230, 240), anchor="center")
                    self._hr_int_ui_buttons.append((str(action), str(room_id), pygame.Rect(br), payload))

        if str(getattr(self, "hr_mode", "lobby")) == "home" and bool(getattr(self, "hr_edit_mode", False)):
            blocks = getattr(self, "hr_edit_blocks", None)
            if isinstance(blocks, list) and blocks:
                sel_i = int(getattr(self, "hr_edit_index", 0)) % len(blocks)
                _ch, cells = blocks[sel_i]
                _draw_cells_outline([(int(p[0]), int(p[1])) for p in cells], rgb=(255, 220, 140), fill_alpha=50, edge_alpha=180)

        # Draw player on top of the interior.
        face = pygame.Vector2(self.hr_int_facing)
        if face.length_squared() <= 0.001:
            face = pygame.Vector2(0, 1)
        if abs(face.y) >= abs(face.x):
            d = "down" if face.y >= 0 else "up"
        else:
            d = "right" if face.x >= 0 else "left"
        pose = str(getattr(self, "player_pose", "")).strip()
        pose_space = str(getattr(self, "player_pose_space", "")).strip()
        pose_anchor = getattr(self, "player_pose_anchor", None)
        use_pose = bool(pose and pose_space == "hr" and pose_anchor is not None)
        if use_pose:
            p = pygame.Vector2(float(pose_anchor[0]), float(pose_anchor[1]))
            if pose == "sleep":
                frame = int(float(getattr(self, "player_pose_phase", 0.0)) * 2.0) % 2
                base = self._get_pose_sprite("sleep", frame=frame)
            else:
                base = self._get_pose_sprite("sit", direction=d, frame=0)
        else:
            p = pygame.Vector2(self.hr_int_pos)
            speed2 = float(self.hr_int_vel.length_squared())
            pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
            pf_run = getattr(self, "player_frames_run", None)
            is_run = bool(getattr(self, "player_sprinting", False))
            pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
            frames = pf.get(d, pf["down"])
            if speed2 <= 0.2 or len(frames) <= 1:
                base = frames[0]
            else:
                walk = frames[1:]
                phase = (float(self.hr_int_walk_phase) % math.tau) / math.tau
                idx = int(phase * len(walk)) % len(walk)
                base = walk[idx]

        scale = int(max(1, int(self._HR_INT_SPRITE_SCALE)))
        spr = pygame.transform.scale(base, (int(base.get_width()) * scale, int(base.get_height()) * scale))
        sx = int(round(map_x + p.x))
        sy = int(round(map_y + p.y))
        if use_pose and pose == "sleep":
            shadow = pygame.Rect(0, 0, 20, 8)
            shadow.center = (sx, sy + 4)
            sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
            pygame.draw.ellipse(sh, (0, 0, 0, 90), sh.get_rect())
            surface.blit(sh, shadow.topleft)
            rect = spr.get_rect(center=(sx, sy + 2))
            surface.blit(spr, rect)
        elif use_pose and pose == "sit":
            shadow = pygame.Rect(0, 0, 16, 7)
            shadow.center = (sx, sy + 8)
            sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
            pygame.draw.ellipse(sh, (0, 0, 0, 110), sh.get_rect())
            surface.blit(sh, shadow.topleft)
            rect = spr.get_rect(center=(sx, sy + 6))
            surface.blit(spr, rect)
        else:
            shadow = pygame.Rect(0, 0, 14, 6)
            shadow.center = (sx, sy + 8)
            sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
            pygame.draw.ellipse(sh, (0, 0, 0, 120), sh.get_rect())
            surface.blit(sh, shadow.topleft)
            rect = spr.get_rect()
            rect.midbottom = (sx, sy + 12)
            surface.blit(spr, rect)

        if mode == "home":
            self._draw_hr_interior_lighting(
                surface,
                map_rect=map_rect,
                map_x=int(map_x),
                map_y=int(map_y),
                tile=int(tile),
                lamps=lamp_tiles,
                light_on=bool(light_on),
            )

        # Hover: furniture details + outline (home only).
        if str(getattr(self, "hr_mode", "lobby")) == "home":
            mouse = None
            if (
                not self.inv_open
                and not bool(getattr(self, "hr_elevator_ui_open", False))
                and not bool(getattr(self, "home_ui_open", False))
                and not bool(getattr(self, "world_map_open", False))
            ):
                mouse = self.app.screen_to_internal(pygame.mouse.get_pos())
            if mouse is not None:
                mx, my = int(mouse[0]), int(mouse[1])
                if map_rect.collidepoint(mx, my):
                    ix = int((mx - int(map_x)) // int(tile))
                    iy = int((my - int(map_y)) // int(tile))
                    ch = str(self._hr_int_char_at(ix, iy))[:1]
                    movable = {"B", "S", "F", "K", "T", "C", "P", "X"}
                    if ch in movable:
                        w = int(self._HR_INT_W)
                        h = int(self._HR_INT_H)
                        seen: set[tuple[int, int]] = set()
                        stack = [(int(ix), int(iy))]
                        cells: list[tuple[int, int]] = []
                        while stack:
                            cx, cy = stack.pop()
                            cx = int(cx)
                            cy = int(cy)
                            if (cx, cy) in seen:
                                continue
                            if not (0 <= cx < w and 0 <= cy < h):
                                continue
                            if str(self._hr_int_char_at(cx, cy))[:1] != ch:
                                continue
                            seen.add((cx, cy))
                            cells.append((cx, cy))
                            stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
                        if cells:
                            _draw_cells_outline(cells, rgb=(255, 220, 140), fill_alpha=18, edge_alpha=220)

                            min_x = min(int(p[0]) for p in cells)
                            max_x = max(int(p[0]) for p in cells)
                            min_y = min(int(p[1]) for p in cells)
                            max_y = max(int(p[1]) for p in cells)
                            bw = int(max_x - min_x + 1)
                            bh = int(max_y - min_y + 1)
                            name = ""
                            desc = ""
                            if ch == "B":
                                name, desc = ("", "")
                            elif ch == "S":
                                name, desc = ("", "")
                            elif ch == "F":
                                name, desc = ("", "/")
                            elif ch == "T":
                                name, desc = ("", "/")
                            elif ch == "K":
                                name, desc = ("", "/")
                            elif ch == "C":
                                if bw >= 3 or bh >= 2:
                                    name, desc = ("", "")
                                else:
                                    name, desc = ("", "")
                            if bool(getattr(self, "hr_edit_mode", False)):
                                hint = " |  | R "
                            else:
                                hint = "R  | "
                            self._hover_tooltip = ([str(name), str(desc), str(hint)], (mx, my))
        surface.set_clip(prev_clip)
        return

        floor_a = (64, 62, 58)
        floor_b = (58, 56, 52)
        wall = (22, 22, 26)
        wall_hi = (38, 38, 46)
        door_col = (240, 220, 140)
        apt_door = (120, 92, 64)
        apt_door2 = (90, 68, 46)
        elev = (110, 112, 120)
        elev2 = (74, 76, 86)
        glass = (90, 140, 190)
        seat = (56, 72, 140)
        seat2 = (40, 52, 112)
        shelf = (92, 78, 62)
        shelf2 = (66, 56, 46)
        table = (88, 72, 54)
        table2 = (60, 50, 38)
        kitchen = (86, 78, 68)
        kitchen2 = (60, 54, 46)
        steel = (220, 220, 230)
        bed = (170, 150, 140)
        bed2 = (128, 108, 100)

        title = ""
        mode = str(getattr(self, "hr_mode", "lobby"))
        floor = int(getattr(self, "hr_floor", 0))
        if mode == "home":
            subtitle = ""
        elif floor <= 0:
            subtitle = ""
        else:
            subtitle = f"{floor} "
            if int(getattr(self, "hr_home_floor", -1)) == floor:
                subtitle += ""
        draw_text(surface, self.app.font_s, f"{title} - {subtitle}", (INTERNAL_W // 2, panel.top - 14), pygame.Color(240, 240, 240), anchor="center")

        bed_done: set[tuple[int, int]] = set()
        elev_done: set[tuple[int, int]] = set()
        for y in range(int(self._HR_INT_H)):
            row = self.hr_layout[y] if 0 <= y < len(self.hr_layout) else ""
            for x in range(int(self._HR_INT_W)):
                ch = row[x] if x < len(row) else "W"
                r = pygame.Rect(map_x + x * tile, map_y + y * tile, tile, tile)

                if ch in ("W", "V", "D", "A", "H"):
                    pygame.draw.rect(surface, wall, r)
                    pygame.draw.rect(surface, wall_hi, pygame.Rect(r.x, r.y, r.w, 3))
                    pygame.draw.rect(surface, (0, 0, 0), r, 1)
                    if ch == "V":
                        g = pygame.Rect(r.x + 3, r.y + 4, r.w - 6, r.h - 8)
                        pygame.draw.rect(surface, glass, g, border_radius=2)
                        pygame.draw.rect(surface, (10, 10, 12), g, 1, border_radius=2)
                        pygame.draw.line(surface, (180, 210, 240), (g.left + 1, g.top + 1), (g.right - 2, g.top + 1), 1)
                        pygame.draw.line(surface, (40, 40, 50), (g.centerx, g.top + 1), (g.centerx, g.bottom - 2), 1)
                    elif ch == "D":
                        dr = pygame.Rect(r.x + 5, r.y + 4, r.w - 10, r.h - 8)
                        pygame.draw.rect(surface, door_col, dr, border_radius=2)
                        pygame.draw.rect(surface, (10, 10, 12), dr, 1, border_radius=2)
                        pygame.draw.circle(surface, (10, 10, 12), (dr.right - 5, dr.centery), 2)
                    elif ch in ("A", "H"):
                        dr = pygame.Rect(r.x + 4, r.y + 5, r.w - 8, r.h - 10)
                        pygame.draw.rect(surface, apt_door, dr, border_radius=2)
                        pygame.draw.rect(surface, (10, 10, 12), dr, 1, border_radius=2)
                        pygame.draw.rect(surface, apt_door2, pygame.Rect(dr.x + 2, dr.y + 2, dr.w - 4, 3))
                        pygame.draw.circle(surface, (240, 220, 140), (dr.right - 4, dr.centery), 2)
                        if ch == "H":
                            pygame.draw.rect(surface, (120, 200, 140), pygame.Rect(dr.x + 2, dr.y - 2, dr.w - 4, 3), border_radius=1)
                    continue

                col = floor_a if ((x + y) % 2 == 0) else floor_b
                pygame.draw.rect(surface, col, r)
                pygame.draw.rect(surface, (0, 0, 0), r, 1)

                if ch == "E":
                    if (x, y) in elev_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "E":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "E":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "E":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            elev_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    er = pygame.Rect(br.x + 2, br.y + 2, br.w - 4, br.h - 4)
                    pygame.draw.rect(surface, elev, er, border_radius=3)
                    pygame.draw.rect(surface, (10, 10, 12), er, 1, border_radius=3)
                    pygame.draw.rect(surface, elev2, pygame.Rect(er.x + 3, er.y + 3, er.w - 6, 3))
                    pygame.draw.line(surface, (10, 10, 12), (er.centerx, er.y + 4), (er.centerx, er.bottom - 5), 1)
                    continue
                if ch == "C":
                    pygame.draw.rect(surface, seat, pygame.Rect(r.x + 4, r.y + 4, r.w - 8, r.h - 8), border_radius=3)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 4, r.y + 4, r.w - 8, r.h - 8), 1, border_radius=3)
                    pygame.draw.rect(surface, seat2, pygame.Rect(r.x + 6, r.y + 6, r.w - 12, 4))
                elif ch == "T":
                    pygame.draw.rect(surface, table, pygame.Rect(r.x + 3, r.y + 6, r.w - 6, r.h - 10), border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 3, r.y + 6, r.w - 6, r.h - 10), 1, border_radius=2)
                    pygame.draw.rect(surface, table2, pygame.Rect(r.x + 4, r.y + 8, r.w - 8, 3))
                elif ch == "K":
                    pygame.draw.rect(surface, kitchen, pygame.Rect(r.x + 2, r.y + 5, r.w - 4, r.h - 8), border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 2, r.y + 5, r.w - 4, r.h - 8), 1, border_radius=2)
                    pygame.draw.rect(surface, kitchen2, pygame.Rect(r.x + 3, r.y + 7, r.w - 6, 3))
                    pygame.draw.rect(surface, steel, pygame.Rect(r.x + 6, r.y + 6, 6, 4), border_radius=1)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 6, r.y + 6, 6, 4), 1, border_radius=1)
                elif ch == "B":
                    if (int(x), int(y)) in bed_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "B":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "B":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "B":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            bed_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    bed_r = pygame.Rect(br.x + 2, br.y + 3, br.w - 4, br.h - 6)
                    pygame.draw.rect(surface, bed, bed_r, border_radius=4)
                    pygame.draw.rect(surface, (10, 10, 12), bed_r, 1, border_radius=4)
                    pillow_w = int(clamp(int(bed_r.w // 3), 8, max(8, bed_r.w - 4)))
                    pillow = pygame.Rect(bed_r.x + 2, bed_r.y + 2, pillow_w, 6)
                    pygame.draw.rect(surface, (230, 230, 235), pillow, border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pillow, 1, border_radius=2)
                    pygame.draw.rect(surface, bed2, pygame.Rect(bed_r.x + 2, bed_r.y + 10, bed_r.w - 4, 6), border_radius=2)
                    continue
                elif ch == "S":
                    pygame.draw.rect(surface, shelf, pygame.Rect(r.x + 3, r.y + 3, r.w - 6, r.h - 6), border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 3, r.y + 3, r.w - 6, r.h - 6), 1, border_radius=2)
                    pygame.draw.line(surface, shelf2, (r.x + 4, r.y + r.h // 2), (r.right - 5, r.y + r.h // 2), 2)

        p = pygame.Vector2(self.hr_int_pos)
        speed2 = float(self.hr_int_vel.length_squared())
        face = pygame.Vector2(self.hr_int_facing)
        if face.length_squared() <= 0.001:
            face = pygame.Vector2(0, 1)
        if abs(face.y) >= abs(face.x):
            d = "down" if face.y >= 0 else "up"
        else:
            d = "right" if face.x >= 0 else "left"
        pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
        pf_run = getattr(self, "player_frames_run", None)
        is_run = bool(getattr(self, "player_sprinting", False))
        pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
        frames = pf.get(d, pf["down"])
        if speed2 <= 0.2 or len(frames) <= 1:
            base = frames[0]
        else:
            walk = frames[1:]
            phase = (float(self.hr_int_walk_phase) % math.tau) / math.tau
            idx = int(phase * len(walk)) % len(walk)
            base = walk[idx]

        scale = int(max(1, int(self._HR_INT_SPRITE_SCALE)))
        spr = pygame.transform.scale(base, (int(base.get_width()) * scale, int(base.get_height()) * scale))
        sx = int(round(map_x + p.x))
        sy = int(round(map_y + p.y))
        shadow = pygame.Rect(0, 0, 14, 6)
        shadow.center = (sx, sy + 8)
        pygame.draw.ellipse(surface, (0, 0, 0), shadow)
        rect = spr.get_rect()
        rect.midbottom = (sx, sy + 12)
        surface.blit(spr, rect)

    def _draw_sch_elevator_ui(self, surface: pygame.Surface) -> None:
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 200))
        surface.blit(overlay, (0, 0))

        options: list[int] = list(getattr(self, "sch_elevator_options", []))
        if not options:
            options = [1]
            self.sch_elevator_options = options
        cols = max(1, int(getattr(self, "sch_elevator_cols", 4)))
        rows_per_page = 4
        n = len(options)
        page_size = max(1, cols * rows_per_page)
        sel_i = int(getattr(self, "sch_elevator_sel", 0)) % max(1, n)
        page = int(sel_i // page_size)
        page_count = int(max(1, int(math.ceil(float(n) / float(page_size)))))
        start = int(page * page_size)
        end = int(min(int(n), int(start + page_size)))
        page_opts = list(options[start:end])
        rows = int(max(1, int(math.ceil(float(len(page_opts)) / float(cols)))))

        btn_w = 56
        btn_h = 28
        gap = 8
        grid_w = cols * btn_w + (cols - 1) * gap
        grid_h = rows * btn_h + (rows - 1) * gap
        panel = pygame.Rect(0, 0, grid_w + 40, grid_h + 98)
        panel.center = (INTERNAL_W // 2, INTERNAL_H // 2)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (90, 90, 110), panel, 2, border_radius=12)

        draw_text(surface, self.app.font_m, "", (panel.centerx, panel.top + 16), pygame.Color(240, 240, 240), anchor="center")
        draw_text(
            surface,
            self.app.font_s,
            f"{int(page) + 1}/{int(page_count)}",
            (panel.centerx, panel.top + 36),
            pygame.Color(180, 180, 195),
            anchor="center",
        )
        typed = str(getattr(self, "sch_elevator_input", "")).strip()
        draw_text(
            surface,
            self.app.font_s,
            f": {typed if typed else ''}",
            (panel.centerx, panel.top + 52),
            pygame.Color(200, 200, 215),
            anchor="center",
        )

        x0 = panel.centerx - grid_w // 2
        y0 = panel.top + 66
        cur_floor = int(getattr(self, "sch_floor", 1))

        for local_i, f in enumerate(page_opts):
            i = int(start) + int(local_i)
            r = int(local_i) // cols
            c = int(local_i) % cols
            x = x0 + c * (btn_w + gap)
            y = y0 + r * (btn_h + gap)
            br = pygame.Rect(x, y, btn_w, btn_h)
            selected = int(i) == int(sel_i)
            is_cur = int(f) == cur_floor
            bg = (44, 44, 52) if selected else (26, 26, 32)
            border = (240, 240, 255) if selected else (90, 90, 110)
            if is_cur and not selected:
                border = (255, 220, 140)
            pygame.draw.rect(surface, bg, br, border_radius=8)
            pygame.draw.rect(surface, border, br, 2, border_radius=8)
            label = f"{int(f)}F"
            draw_text(surface, self.app.font_s, label, (br.centerx, br.centery), pygame.Color(230, 230, 240), anchor="center")

        draw_text(
            surface,
            self.app.font_s,
            " | PgUp/PgDn |  | Enter | Esc",
            (panel.centerx, panel.bottom - 14),
            pygame.Color(160, 160, 175),
            anchor="center",
        )

    def _draw_world_elevator_ui(self, surface: pygame.Surface) -> None:
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 200))
        surface.blit(overlay, (0, 0))

        options: list[int] = list(getattr(self, "world_elevator_options", []))
        if not options:
            options = [1]
            self.world_elevator_options = options
        cols = max(1, int(getattr(self, "world_elevator_cols", 4)))
        rows_per_page = 4
        n = len(options)
        page_size = max(1, cols * rows_per_page)
        sel_i = int(getattr(self, "world_elevator_sel", 0)) % max(1, n)
        page = int(sel_i // page_size)
        page_count = int(max(1, int(math.ceil(float(n) / float(page_size)))))
        start = int(page * page_size)
        end = int(min(int(n), int(start + page_size)))
        page_opts = list(options[start:end])
        rows = int(max(1, int(math.ceil(float(len(page_opts)) / float(cols)))))

        btn_w = 56
        btn_h = 28
        gap = 8
        grid_w = cols * btn_w + (cols - 1) * gap
        grid_h = rows * btn_h + (rows - 1) * gap
        panel = pygame.Rect(0, 0, grid_w + 40, grid_h + 98)
        panel.center = (INTERNAL_W // 2, INTERNAL_H // 2)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (90, 90, 110), panel, 2, border_radius=12)

        draw_text(surface, self.app.font_m, "", (panel.centerx, panel.top + 16), pygame.Color(240, 240, 240), anchor="center")
        draw_text(
            surface,
            self.app.font_s,
            f"{int(page) + 1}/{int(page_count)}",
            (panel.centerx, panel.top + 36),
            pygame.Color(180, 180, 195),
            anchor="center",
        )
        typed = str(getattr(self, "world_elevator_input", "")).strip()
        draw_text(
            surface,
            self.app.font_s,
            f": {typed if typed else ''}",
            (panel.centerx, panel.top + 52),
            pygame.Color(200, 200, 215),
            anchor="center",
        )

        x0 = panel.centerx - grid_w // 2
        y0 = panel.top + 66
        mh = getattr(self, "world_elevator_mh", None)
        cur_floor = int(getattr(mh, "cur_floor", 1)) if mh is not None else 1

        for local_i, f in enumerate(page_opts):
            i = int(start) + int(local_i)
            r = int(local_i) // cols
            c = int(local_i) % cols
            x = x0 + c * (btn_w + gap)
            y = y0 + r * (btn_h + gap)
            br = pygame.Rect(x, y, btn_w, btn_h)
            selected = int(i) == int(sel_i)
            is_cur = int(f) == cur_floor
            bg = (44, 44, 52) if selected else (26, 26, 32)
            border = (240, 240, 255) if selected else (90, 90, 110)
            if is_cur and not selected:
                border = (255, 220, 140)
            pygame.draw.rect(surface, bg, br, border_radius=8)
            pygame.draw.rect(surface, border, br, 2, border_radius=8)
            label = f"{int(f)}F"
            draw_text(surface, self.app.font_s, label, (br.centerx, br.centery), pygame.Color(230, 230, 240), anchor="center")

        draw_text(
            surface,
            self.app.font_s,
            " | PgUp/PgDn |  | Enter | Esc",
            (panel.centerx, panel.bottom - 14),
            pygame.Color(160, 160, 175),
            anchor="center",
        )

    def _draw_hr_elevator_ui(self, surface: pygame.Surface) -> None:     
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 200))
        surface.blit(overlay, (0, 0))

        options: list[int] = list(getattr(self, "hr_elevator_options", []))
        if not options:
            options = [0]
        cols = max(1, int(getattr(self, "hr_elevator_cols", 4)))
        rows_per_page = 4
        n = len(options)
        page_size = max(1, cols * rows_per_page)
        sel_i = int(getattr(self, "hr_elevator_sel", 0)) % max(1, n)
        page = int(sel_i // page_size)
        page_count = int(max(1, int(math.ceil(float(n) / float(page_size)))))
        start = int(page * page_size)
        end = int(min(int(n), int(start + page_size)))
        page_opts = list(options[start:end])
        rows = int(max(1, int(math.ceil(float(len(page_opts)) / float(cols)))))

        btn_w = 56
        btn_h = 28
        gap = 8
        grid_w = cols * btn_w + (cols - 1) * gap
        grid_h = rows * btn_h + (rows - 1) * gap
        panel = pygame.Rect(0, 0, grid_w + 40, grid_h + 98)
        panel.center = (INTERNAL_W // 2, INTERNAL_H // 2)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (90, 90, 110), panel, 2, border_radius=12)

        draw_text(surface, self.app.font_m, "", (panel.centerx, panel.top + 16), pygame.Color(240, 240, 240), anchor="center")
        draw_text(
            surface,
            self.app.font_s,
            f"{int(page) + 1}/{int(page_count)}",
            (panel.centerx, panel.top + 36),
            pygame.Color(180, 180, 195),
            anchor="center",
        )
        typed = str(getattr(self, "hr_elevator_input", "")).strip()
        draw_text(
            surface,
            self.app.font_s,
            f": {typed if typed else ''}",
            (panel.centerx, panel.top + 52),
            pygame.Color(200, 200, 215),
            anchor="center",
        )

        x0 = panel.centerx - grid_w // 2
        y0 = panel.top + 66
        cur_floor = int(getattr(self, "hr_floor", 1))
        home_floor = int(getattr(self, "hr_home_floor", -1))

        for local_i, f in enumerate(page_opts):
            i = int(start) + int(local_i)
            r = int(local_i) // cols
            c = int(local_i) % cols
            x = x0 + c * (btn_w + gap)
            y = y0 + r * (btn_h + gap)
            br = pygame.Rect(x, y, btn_w, btn_h)
            selected = int(i) == int(sel_i)
            is_cur = int(f) == cur_floor
            bg = (44, 44, 52) if selected else (26, 26, 32)
            border = (240, 240, 255) if selected else (90, 90, 110)     
            if is_cur and not selected:
                border = (255, 220, 140)
            if int(f) == int(home_floor) and int(home_floor) > 0 and not selected and not is_cur:
                border = (120, 200, 140)
            pygame.draw.rect(surface, bg, br, border_radius=8)
            pygame.draw.rect(surface, border, br, 2, border_radius=8)   
            label = str(int(f))
            draw_text(surface, self.app.font_s, label, (br.centerx, br.centery), pygame.Color(230, 230, 240), anchor="center")
            if int(f) == int(home_floor) and int(home_floor) > 0:
                pygame.draw.circle(surface, (120, 200, 140), (br.right - 10, br.y + 8), 3)

        draw_text(
            surface,
            self.app.font_s,
            " | PgUp/PgDn |  | Enter | Esc",
            (panel.centerx, panel.bottom - 14),
            pygame.Color(160, 160, 175),
            anchor="center",
        )

    def _draw_hr_travel_ui(self, surface: pygame.Surface) -> None:
        if not bool(getattr(self, "hr_travel_active", False)):
            return
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 210))
        surface.blit(overlay, (0, 0))

        kind = str(getattr(self, "hr_travel_kind", "elevator"))
        title = "" if kind == "elevator" else ""
        draw_text(surface, self.app.font_m, title, (INTERNAL_W // 2, INTERNAL_H // 2 - 58), pygame.Color(240, 240, 240), anchor="center")

        f0 = int(getattr(self, "hr_travel_from", int(getattr(self, "hr_floor", 1))))
        f1 = int(getattr(self, "hr_travel_to", f0))
        cur = int(getattr(self, "hr_travel_display", f0))
        direction = 1 if int(f1) >= int(f0) else -1
        floors = list(range(int(f0), int(f1) + int(direction), int(direction)))
        if not floors:
            floors = [int(cur)]

        big_font = getattr(self.app, "font_l", self.app.font_m)
        draw_text(surface, big_font, str(int(cur)), (INTERNAL_W // 2, INTERNAL_H // 2 - 18), pygame.Color(255, 220, 140), anchor="center")

        font = self.app.font_s
        labels = [str(int(f)) for f in floors]
        widths = [int(font.size(lbl)[0]) for lbl in labels]
        gap = 10
        total_w = int(sum(widths) + max(0, len(widths) - 1) * gap)
        x = int(INTERNAL_W // 2 - total_w // 2)
        y = int(INTERNAL_H // 2 + 18)
        for f, lbl, w in zip(floors, labels, widths):
            passed = (direction > 0 and int(f) < int(cur)) or (direction < 0 and int(f) > int(cur))
            if int(f) == int(cur):
                col = pygame.Color(255, 220, 140)
            elif passed:
                col = pygame.Color(220, 220, 232)
            else:
                col = pygame.Color(140, 140, 155)
            draw_text(surface, font, lbl, (int(x + w // 2), int(y)), col, anchor="center")
            x += int(w + gap)

        hint = "..." if kind == "elevator" else "..."
        draw_text(surface, self.app.font_s, hint, (INTERNAL_W // 2, INTERNAL_H // 2 + 44), pygame.Color(160, 160, 175), anchor="center")

    def _home_ui_storage_kind_norm(self) -> str:
        kind = str(getattr(self, "home_ui_storage_kind", "cabinet")).strip().lower()
        return "fridge" if kind == "fridge" else "cabinet"

    def _home_ui_storage_inv(self) -> HardcoreSurvivalState._Inventory:
        if self._home_ui_storage_kind_norm() == "fridge":
            inv = getattr(self, "fridge_storage", None)
            if inv is not None:
                return inv
        return self.home_storage

    def _home_ui_storage_label(self) -> str:
        return "" if self._home_ui_storage_kind_norm() == "fridge" else ""

    def _home_ui_storage_title(self) -> str:
        return "" if self._home_ui_storage_kind_norm() == "fridge" else ""

    def _home_ui_open(
        self,
        *,
        open_block: tuple[int, int, int, int] | None = None,
        storage_kind: str = "cabinet",
    ) -> None:
        if bool(getattr(self, "hr_interior", False)) and str(getattr(self, "hr_mode", "lobby")) != "home":
            return
        self.inv_open = False
        self.rv_ui_open = False
        self._gallery_open = False
        self.home_ui_open = True
        self.home_ui_focus = "storage"
        self.home_ui_storage_kind = "fridge" if str(storage_kind).strip().lower() == "fridge" else "cabinet"
        self.home_ui_open_block = open_block
        self.home_ui_player_index = int(
            clamp(int(getattr(self, "home_ui_player_index", 0)), 0, len(self.inventory.slots) - 1)
        )
        storage = self._home_ui_storage_inv()
        self.home_ui_storage_index = int(
            clamp(int(getattr(self, "home_ui_storage_index", 0)), 0, len(storage.slots) - 1)
        )
        title = "" if self._home_ui_storage_kind_norm() == "fridge" else ""
        target = self._home_ui_storage_label()
        self._set_home_ui_status(
            f"{title}Tab  /{target} | Enter  | Esc ",
            seconds=2.0,
        )

    def _home_ui_close(self) -> None:
        self.home_ui_open = False
        self.home_ui_focus = "storage"
        self.home_ui_open_block = None

    def _home_ui_cycle_focus(self) -> None:
        cur = str(getattr(self, "home_ui_focus", "storage"))
        self.home_ui_focus = "player" if cur != "player" else "storage"

    def _home_ui_transfer(self, *, from_player: bool) -> None:
        storage = self._home_ui_storage_inv()
        if from_player:
            src = self.inventory
            dst = storage
            idx = int(getattr(self, "home_ui_player_index", 0))
        else:
            src = storage
            dst = self.inventory
            idx = int(getattr(self, "home_ui_storage_index", 0))

        if not (0 <= idx < len(src.slots)):
            self._set_home_ui_status("", seconds=1.2)
            return
        st = src.slots[idx]
        if st is None:
            self._set_home_ui_status("", seconds=1.0)
            return

        idef = self._ITEMS.get(st.item_id)
        name = idef.name if idef is not None else st.item_id

        before = int(st.qty)

        # Small tools (e.g. cup) are more usable when transferred directly into the hand.
        take_hand = 0
        if not from_player and idef is not None and self.gun is None and str(getattr(idef, "kind", "")) == "tool":
            if getattr(self, "held_item", None) is None and int(before) > 0:
                take_hand = 1

        moved_inv = 0
        left = int(before)
        if int(before - take_hand) > 0:
            left_after = int(dst.add(st.item_id, int(before - take_hand), self._ITEMS))
            moved_inv = int((before - take_hand) - left_after)
            left = int(left_after)
        else:
            left = int(before - take_hand)

        moved = int(before - left)
        if moved <= 0:
            self._set_home_ui_status("", seconds=1.2)
            return

        if take_hand > 0:
            hmeta: dict[str, object] = dict(getattr(st, "meta", {})) if isinstance(getattr(st, "meta", None), dict) else {}
            if str(getattr(st, "item_id", "")) == "flashlight" and "charge" not in hmeta:
                hmeta["charge"] = 1.0
            self.held_item = HardcoreSurvivalState._ItemStack(item_id=str(st.item_id), qty=1, meta=hmeta)
            if str(getattr(st, "item_id", "")) == "flashlight":
                self.flashlight_on = False

        if left <= 0:
            src.slots[idx] = None
        else:
            st.qty = int(left)

        if take_hand > 0 and moved_inv <= 0:
            self._set_home_ui_status(f": {name}", seconds=1.2)
        else:
            self._set_home_ui_status(f": {name} x{moved}", seconds=1.6)

    def _handle_home_ui_key(self, key: int) -> None:
        if key in (pygame.K_ESCAPE,):
            self._home_ui_close()
            return
        if key in (pygame.K_TAB,):
            self._home_ui_cycle_focus()
            return
        if key in (pygame.K_RETURN, pygame.K_SPACE):
            focus = str(getattr(self, "home_ui_focus", "storage"))
            if focus == "player":
                self._home_ui_transfer(from_player=True)
            else:
                self._home_ui_transfer(from_player=False)
            return

        move: tuple[int, int] | None = None
        if key in (pygame.K_LEFT, pygame.K_a):
            move = (-1, 0)
        elif key in (pygame.K_RIGHT, pygame.K_d):
            move = (1, 0)
        elif key in (pygame.K_UP, pygame.K_w):
            move = (0, -1)
        elif key in (pygame.K_DOWN, pygame.K_s):
            move = (0, 1)
        if move is None:
            return

        focus = str(getattr(self, "home_ui_focus", "storage"))
        dx, dy = int(move[0]), int(move[1])
        if focus == "player":
            cols = max(1, int(self.inventory.cols))
            if dx != 0:
                self.home_ui_player_index = (int(self.home_ui_player_index) + dx) % len(self.inventory.slots)
            else:
                self.home_ui_player_index = (int(self.home_ui_player_index) + dy * cols) % len(self.inventory.slots)
            return

        storage = self._home_ui_storage_inv()
        cols = max(1, int(storage.cols))
        if dx != 0:
            self.home_ui_storage_index = (int(self.home_ui_storage_index) + dx) % len(storage.slots)
        else:
            self.home_ui_storage_index = (int(self.home_ui_storage_index) + dy * cols) % len(storage.slots)

    def _handle_home_ui_mouse(self, event: pygame.event.Event) -> None:
        if not getattr(self, "home_ui_open", False):
            return
        if event.type not in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION):
            return
        if not hasattr(event, "pos"):
            return
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return
        mx, my = int(internal[0]), int(internal[1])

        # Mirror the layout math in _draw_home_storage_ui() so hit-testing matches.
        panel = pygame.Rect(16, 14, INTERNAL_W - 32, INTERNAL_H - 28)
        slot = 22
        gap = 4

        storage = self._home_ui_storage_inv()
        storage_label = self._home_ui_storage_label()

        pcols = max(1, int(self.inventory.cols))
        prows = int(math.ceil(len(self.inventory.slots) / pcols))
        pgrid_w = pcols * slot + (pcols - 1) * gap
        pgrid_h = prows * slot + (prows - 1) * gap

        scols = max(1, int(storage.cols))
        srows = int(math.ceil(len(storage.slots) / scols))
        sgrid_w = scols * slot + (scols - 1) * gap
        sgrid_h = srows * slot + (srows - 1) * gap

        inv_y = panel.top + 46
        left_x = panel.left + 14
        right_x = panel.right - 14 - sgrid_w

        content_h = max(pgrid_h, sgrid_h) + 20
        inv_y = int(clamp(inv_y, panel.top + 42, panel.bottom - 52 - content_h))

        pgrid = pygame.Rect(int(left_x), int(inv_y), int(pgrid_w), int(pgrid_h))
        sgrid = pygame.Rect(int(right_x), int(inv_y), int(sgrid_w), int(sgrid_h))

        # Clickable "tabs" (the labels above each grid).
        lab_y = int(inv_y - 14)
        bw, bh = self.app.font_s.size("")
        sw, sh = self.app.font_s.size(storage_label)
        tab_player = pygame.Rect(int(left_x), int(lab_y), int(bw), int(bh))
        tab_storage = pygame.Rect(int(right_x), int(lab_y), int(sw), int(sh))

        def hit_grid(
            *,
            grid: pygame.Rect,
            cols: int,
            count: int,
            x0: int,
            y0: int,
        ) -> int | None:
            if not grid.collidepoint(mx, my):
                return None
            lx = int(mx - int(x0))
            ly = int(my - int(y0))
            cell = int(slot + gap)
            if cell <= 0:
                return None
            cx = int(lx // cell)
            cy = int(ly // cell)
            if cx < 0 or cy < 0:
                return None
            if cx >= int(cols):
                return None
            # Ignore clicks on the gap area.
            if int(lx % cell) >= int(slot) or int(ly % cell) >= int(slot):
                return None
            idx = int(cy * int(cols) + cx)
            if not (0 <= idx < int(count)):
                return None
            return int(idx)

        if event.type == pygame.MOUSEBUTTONDOWN:
            btn = int(getattr(event, "button", 0))
            if btn == 1:
                if tab_player.collidepoint(mx, my):
                    self.home_ui_focus = "player"
                    return
                if tab_storage.collidepoint(mx, my):
                    self.home_ui_focus = "storage"
                    return
                idx = hit_grid(grid=pgrid, cols=pcols, count=len(self.inventory.slots), x0=left_x, y0=inv_y)
                if idx is not None:
                    self.home_ui_focus = "player"
                    self.home_ui_player_index = int(idx)
                    return
                idx = hit_grid(grid=sgrid, cols=scols, count=len(storage.slots), x0=right_x, y0=inv_y)
                if idx is not None:
                    self.home_ui_focus = "storage"
                    self.home_ui_storage_index = int(idx)
                    return
            # Right-click transfers for mouse-only usability.
            if btn == 3:
                idx = hit_grid(grid=pgrid, cols=pcols, count=len(self.inventory.slots), x0=left_x, y0=inv_y)
                if idx is not None:
                    self.home_ui_focus = "player"
                    self.home_ui_player_index = int(idx)
                    self._home_ui_transfer(from_player=True)
                    return
                idx = hit_grid(grid=sgrid, cols=scols, count=len(storage.slots), x0=right_x, y0=inv_y)
                if idx is not None:
                    self.home_ui_focus = "storage"
                    self.home_ui_storage_index = int(idx)
                    self._home_ui_transfer(from_player=False)
                    return

    def _tile_solid(self, tile_id: int) -> bool:
        t = self._TILES.get(int(tile_id))
        return bool(t.solid) if t is not None else False

    def _tile_slow(self, tile_id: int) -> float:
        t = self._TILES.get(int(tile_id))
        return float(t.slow) if t is not None else 1.0

    def _collide_rect_world(self, rect: pygame.Rect) -> list[pygame.Rect]:
        left = int(math.floor(rect.left / self.TILE_SIZE))
        right = int(math.floor((rect.right - 1) / self.TILE_SIZE))       
        top = int(math.floor(rect.top / self.TILE_SIZE))
        bottom = int(math.floor((rect.bottom - 1) / self.TILE_SIZE))

        # RV world-interior: ignore outside props/parked vehicles that fall inside the stamped RV room,
        # otherwise things like a sidewalk streetlamp can appear/collide "inside" the RV.
        rv_hide: tuple[int, int, int, int] | None = None
        if bool(getattr(self, "rv_world_interior", False)):
            key = getattr(self, "_rv_world_int_active_key", None)
            if isinstance(key, tuple) and len(key) == 4:
                try:
                    rv_hide = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
                except Exception:
                    rv_hide = None
        ts = int(self.TILE_SIZE)

        hits: list[pygame.Rect] = []
        for ty in range(top, bottom + 1):
            for tx in range(left, right + 1):
                tile = int(self.world.get_tile(tx, ty))
                solid = bool(self._tile_solid(tile))
                if tile == int(self.T_DOOR):
                    # Prevent stepping "onto" portal/sealed doors (e.g. high-rises),
                    # which makes it look like the player can walk on the facade.
                    leads_to_floor = False
                    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        if int(self.world.get_tile(int(tx + dx), int(ty + dy))) == int(self.T_FLOOR):
                            leads_to_floor = True
                            break
                    if not leads_to_floor:
                        solid = True
                if not solid:
                    continue
                tile_rect = pygame.Rect(tx * self.TILE_SIZE, ty * self.TILE_SIZE, self.TILE_SIZE, self.TILE_SIZE)
                if rect.colliderect(tile_rect):
                    hits.append(tile_rect)

        # Solid world props (signs/toys/etc).
        start_cx = left // self.CHUNK_SIZE
        end_cx = right // self.CHUNK_SIZE
        start_cy = top // self.CHUNK_SIZE
        end_cy = bottom // self.CHUNK_SIZE
        for cy in range(int(start_cy), int(end_cy) + 1):
            for cx in range(int(start_cx), int(end_cx) + 1):
                chunk = self.world.get_chunk(int(cx), int(cy))
                for pr in getattr(chunk, "props", []):
                    if rv_hide is not None and ts > 0:
                        try:
                            px = float(getattr(getattr(pr, "pos", pygame.Vector2(0, 0)), "x", 0.0))
                            py = float(getattr(getattr(pr, "pos", pygame.Vector2(0, 0)), "y", 0.0))
                            tx = int(math.floor(px / float(ts)))
                            ty = int(math.floor(py / float(ts)))
                            rx0, ry0, rw, rh = rv_hide
                            if int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh):
                                continue
                        except Exception:
                            pass
                    pdef = self._PROP_DEFS.get(str(getattr(pr, "prop_id", "")))
                    if pdef is None or not bool(getattr(pdef, "solid", False)):
                        continue
                    w, h = getattr(pdef, "collider", (10, 10))
                    w = max(2, int(w))
                    h = max(2, int(h))
                    prect = pygame.Rect(
                        int(round(float(pr.pos.x) - w / 2)),
                        int(round(float(pr.pos.y) - h / 2)),
                        int(w),
                        int(h),
                    )
                    if rect.colliderect(prect):
                        hits.append(prect)

                # Parked vehicles (cars + bikes) are solid in the world.
                for car in getattr(chunk, "cars", []):
                    if rv_hide is not None and ts > 0:
                        try:
                            cpos = pygame.Vector2(getattr(car, "pos", pygame.Vector2(0, 0)))
                            tx = int(math.floor(float(cpos.x) / float(ts)))
                            ty = int(math.floor(float(cpos.y) / float(ts)))
                            rx0, ry0, rw, rh = rv_hide
                            if int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh):
                                continue
                        except Exception:
                            pass
                    mid = str(getattr(car, "model_id", "rv"))
                    model = self._CAR_MODELS.get(mid) or self._CAR_MODELS.get("rv")
                    if model is None:
                        continue
                    cw, ch = int(model.collider[0]), int(model.collider[1])
                    if cw <= 0 or ch <= 0:
                        continue
                    cpos = pygame.Vector2(getattr(car, "pos", pygame.Vector2(0, 0)))
                    chead = float(getattr(car, "heading", 0.0))
                    c = abs(math.cos(float(chead)))
                    s = abs(math.sin(float(chead)))
                    ww = float(cw) * c + float(ch) * s
                    hh = float(cw) * s + float(ch) * c
                    w = int(max(2, int(round(float(ww)))))
                    h = int(max(2, int(round(float(hh)))))
                    crect = pygame.Rect(
                        int(round(float(cpos.x) - float(w) / 2.0)),
                        int(round(float(cpos.y) - float(h) / 2.0)),
                        int(w),
                        int(h),
                    )
                    if rect.colliderect(crect):
                        hits.append(crect)

                for b in getattr(chunk, "bikes", []):
                    if rv_hide is not None and ts > 0:
                        try:
                            bpos = pygame.Vector2(getattr(b, "pos", pygame.Vector2(0, 0)))
                            tx = int(math.floor(float(bpos.x) / float(ts)))
                            ty = int(math.floor(float(bpos.y) / float(ts)))
                            rx0, ry0, rw, rh = rv_hide
                            if int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh):
                                continue
                        except Exception:
                            pass
                    mid = str(getattr(b, "model_id", "bike"))
                    bw, bh = self._two_wheel_collider_px(mid)
                    d = str(getattr(b, "dir", "right"))
                    if d in ("up", "down"):
                        bw, bh = int(bh), int(bw)
                    bw = max(2, int(bw))
                    bh = max(2, int(bh))
                    bpos = pygame.Vector2(getattr(b, "pos", pygame.Vector2(0, 0)))
                    brect = pygame.Rect(
                        int(round(float(bpos.x) - float(bw) / 2.0)),
                        int(round(float(bpos.y) - float(bh) / 2.0)),
                        int(bw),
                        int(bh),
                    )
                    if rect.colliderect(brect):
                        hits.append(brect)

        # Player-owned vehicles are also solid when on foot.
        # Exception: when inside the RV world-interior, allow walking within the RV footprint.
        if self.mount != "rv" and not bool(getattr(self, "rv_world_interior", False)):
            try:
                vrect = self._rv_collider_rect_at()
                if rect.colliderect(vrect):
                    hits.append(vrect)
            except Exception:
                pass
        if self.mount != "bike":
            try:
                bw, bh = int(getattr(self.bike, "w", 0)), int(getattr(self.bike, "h", 0))
                if bw > 0 and bh > 0:
                    bpos = pygame.Vector2(getattr(self.bike, "pos", pygame.Vector2(0, 0)))
                    brect = pygame.Rect(
                        int(round(float(bpos.x) - float(bw) / 2.0)),
                        int(round(float(bpos.y) - float(bh) / 2.0)),
                        int(bw),
                        int(bh),
                    )
                    if rect.colliderect(brect):
                        hits.append(brect)
            except Exception:
                pass

        # RV world-interior: add thin boundary colliders so the stamped floor area stays enclosed,
        # without spending a full 1-tile wall border (which makes small RVs feel tiny).
        if bool(getattr(self, "rv_world_interior", False)):
            key = getattr(self, "_rv_world_int_active_key", None)
            if isinstance(key, tuple) and len(key) == 4:
                try:
                    rx0, ry0, rw, rh = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
                    pw = int(rw * int(self.TILE_SIZE))
                    ph = int(rh * int(self.TILE_SIZE))
                    if pw > 0 and ph > 0:
                        px0 = int(rx0 * int(self.TILE_SIZE))
                        py0 = int(ry0 * int(self.TILE_SIZE))
                        # Use OUTSIDE thick boundary strips. The previous 1px inside lines could
                        # "push" the player out of the RV (and can be tunneled on low FPS).
                        ts = int(max(1, int(self.TILE_SIZE)))
                        th = int(ts)
                        walls = [
                            # top / bottom
                            pygame.Rect(int(px0 - th), int(py0 - th), int(pw + 2 * th), int(th)),
                            pygame.Rect(int(px0 - th), int(py0 + ph), int(pw + 2 * th), int(th)),
                            # left / right
                            pygame.Rect(int(px0 - th), int(py0 - th), int(th), int(ph + 2 * th)),
                            pygame.Rect(int(px0 + pw), int(py0 - th), int(th), int(ph + 2 * th)),
                        ]
                        for wrect in walls:
                            if rect.colliderect(wrect):
                                hits.append(wrect)
                except Exception:
                    pass
        return hits

    def _collide_rect_world_vehicle(self, rect: pygame.Rect) -> list[pygame.Rect]:
        left = int(math.floor(rect.left / self.TILE_SIZE))
        right = int(math.floor((rect.right - 1) / self.TILE_SIZE))
        top = int(math.floor(rect.top / self.TILE_SIZE))
        bottom = int(math.floor((rect.bottom - 1) / self.TILE_SIZE))

        hits: list[pygame.Rect] = []
        for ty in range(top, bottom + 1):
            for tx in range(left, right + 1):
                tile = int(self.world.get_tile(tx, ty))
                # Vehicles must not enter buildings: treat interior floor/doors as solid.
                if tile in (
                    int(self.T_FLOOR),
                    int(self.T_DOOR),
                    int(self.T_DOOR_HOME),
                    int(self.T_DOOR_LOCKED),
                    int(self.T_DOOR_HOME_LOCKED),
                    int(self.T_DOOR_BROKEN),
                    int(self.T_ELEVATOR),
                    int(self.T_STAIRS_UP),
                    int(self.T_STAIRS_DOWN),
                ):
                    solid = True
                else:
                    solid = bool(self._tile_solid(tile))
                if not solid:
                    continue
                tile_rect = pygame.Rect(
                    int(tx * self.TILE_SIZE),
                    int(ty * self.TILE_SIZE),
                    int(self.TILE_SIZE),
                    int(self.TILE_SIZE),
                )
                if rect.colliderect(tile_rect):
                    hits.append(tile_rect)

        # Building roofs/facades: block vehicles from entering building footprints.
        try:
            ts = int(self.TILE_SIZE)
            if ts > 0:
                # If the current vehicle is using a smaller "driving" collider (e.g. RV),
                # inflate building footprints so the *visual* vehicle can't clip into walls.
                inflate_x = 0
                inflate_y = 0
                try:
                    if self.mount == "rv":
                        mid = str(getattr(self.rv, "model_id", "rv"))
                        model = self._CAR_MODELS.get(mid) or self._CAR_MODELS.get("rv")
                        if model is not None:
                            fw, fh = int(model.collider[0]), int(model.collider[1])
                            # Match the same axis-orientation that driving uses (swap when near-vertical).
                            axis = int(getattr(self, "_rv_drive_axis", 0))
                            if axis == 1:
                                fw, fh = int(fh), int(fw)
                            inflate_x = max(0, (int(fw) - int(rect.w)) // 2)
                            inflate_y = max(0, (int(fh) - int(rect.h)) // 2)
                            # Keep it bounded; we only want to compensate for drive_collider.
                            inflate_x = int(clamp(int(inflate_x), 0, int(ts) * 3))
                            inflate_y = int(clamp(int(inflate_y), 0, int(ts) * 3))
                except Exception:
                    inflate_x = 0
                    inflate_y = 0

                start_cx = left // self.CHUNK_SIZE
                end_cx = right // self.CHUNK_SIZE
                start_cy = top // self.CHUNK_SIZE
                end_cy = bottom // self.CHUNK_SIZE
                seen_buildings: set[tuple[int, int, int, int]] = set()
                for cy in range(int(start_cy) - 1, int(end_cy) + 2):
                    for cx in range(int(start_cx) - 1, int(end_cx) + 2):
                        chunk = self.world.get_chunk(int(cx), int(cy))
                        for b in getattr(chunk, "buildings", []):
                            bx0, by0, bw, bh = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                            key = (int(bx0), int(by0), int(bw), int(bh))
                            if key in seen_buildings:
                                continue
                            seen_buildings.add(key)
                            brect = pygame.Rect(int(bx0 * ts), int(by0 * ts), int(bw * ts), int(bh * ts))
                            if inflate_x > 0 or inflate_y > 0:
                                brect = brect.inflate(int(inflate_x) * 2, int(inflate_y) * 2)
                            if rect.colliderect(brect):
                                hits.append(brect)
        except Exception:
            pass

        # Solid world props (signs/toys/etc) still block vehicles.
        start_cx = left // self.CHUNK_SIZE
        end_cx = right // self.CHUNK_SIZE
        start_cy = top // self.CHUNK_SIZE
        end_cy = bottom // self.CHUNK_SIZE
        for cy in range(int(start_cy), int(end_cy) + 1):
            for cx in range(int(start_cx), int(end_cx) + 1):
                chunk = self.world.get_chunk(int(cx), int(cy))
                for pr in getattr(chunk, "props", []):
                    pdef = self._PROP_DEFS.get(str(getattr(pr, "prop_id", "")))
                    if pdef is None or not bool(getattr(pdef, "solid", False)):
                        continue
                    w, h = getattr(pdef, "collider", (10, 10))
                    w = max(2, int(w))
                    h = max(2, int(h))
                    prect = pygame.Rect(
                        int(round(float(pr.pos.x) - w / 2)),
                        int(round(float(pr.pos.y) - h / 2)),
                        int(w),
                        int(h),
                    )
                    if rect.colliderect(prect):
                        hits.append(prect)

                # Parked vehicles block drivable vehicles too.
                for car in getattr(chunk, "cars", []):
                    mid = str(getattr(car, "model_id", "rv"))
                    model = self._CAR_MODELS.get(mid) or self._CAR_MODELS.get("rv")
                    if model is None:
                        continue
                    cw, ch = int(model.collider[0]), int(model.collider[1])
                    if cw <= 0 or ch <= 0:
                        continue
                    cpos = pygame.Vector2(getattr(car, "pos", pygame.Vector2(0, 0)))
                    chead = float(getattr(car, "heading", 0.0))
                    c = abs(math.cos(float(chead)))
                    s = abs(math.sin(float(chead)))
                    ww = float(cw) * c + float(ch) * s
                    hh = float(cw) * s + float(ch) * c
                    w = int(max(2, int(round(float(ww)))))
                    h = int(max(2, int(round(float(hh)))))
                    crect = pygame.Rect(
                        int(round(float(cpos.x) - float(w) / 2.0)),
                        int(round(float(cpos.y) - float(h) / 2.0)),
                        int(w),
                        int(h),
                    )
                    if rect.colliderect(crect):
                        hits.append(crect)

                for b in getattr(chunk, "bikes", []):
                    mid = str(getattr(b, "model_id", "bike"))
                    bw, bh = self._two_wheel_collider_px(mid)
                    d = str(getattr(b, "dir", "right"))
                    if d in ("up", "down"):
                        bw, bh = int(bh), int(bw)
                    bw = max(2, int(bw))
                    bh = max(2, int(bh))
                    bpos = pygame.Vector2(getattr(b, "pos", pygame.Vector2(0, 0)))
                    brect = pygame.Rect(
                        int(round(float(bpos.x) - float(bw) / 2.0)),
                        int(round(float(bpos.y) - float(bh) / 2.0)),
                        int(bw),
                        int(bh),
                    )
                    if rect.colliderect(brect):
                        hits.append(brect)

        # Player-owned vehicles block other vehicles (but never collide with themselves).
        if self.mount != "rv":
            try:
                vrect = self._rv_collider_rect_at()
                if rect.colliderect(vrect):
                    hits.append(vrect)
            except Exception:
                pass
        if self.mount != "bike":
            try:
                bw, bh = int(getattr(self.bike, "w", 0)), int(getattr(self.bike, "h", 0))
                if bw > 0 and bh > 0:
                    bpos = pygame.Vector2(getattr(self.bike, "pos", pygame.Vector2(0, 0)))
                    brect = pygame.Rect(
                        int(round(float(bpos.x) - float(bw) / 2.0)),
                        int(round(float(bpos.y) - float(bh) / 2.0)),
                        int(bw),
                        int(bh),
                    )
                    if rect.colliderect(brect):
                        hits.append(brect)
            except Exception:
                pass

        # Prelude traffic/NPCs should also block drivable vehicles so cars/bikes
        # don't clip through people during the "normal town" phase.
        try:
            if (
                bool(getattr(self, "story_enabled", False))
                and bool(self._story_is_pre_apocalypse())
                and not (
                    bool(getattr(self, "hr_interior", False))
                    or bool(getattr(self, "house_interior", False))
                    or bool(getattr(self, "sch_interior", False))
                )
            ):
                npcs = getattr(self, "npcs", None)
                if isinstance(npcs, list) and npcs:
                    npc_w, npc_h = self._story_npc_collider_wh()
                    for npc in npcs:
                        if not isinstance(npc, dict):
                            continue
                        try:
                            pos = pygame.Vector2(npc.get("pos", pygame.Vector2(0, 0)))
                        except Exception:
                            continue
                        nrect = pygame.Rect(
                            iround(float(pos.x) - float(npc_w) / 2.0),
                            iround(float(pos.y) - float(npc_h) / 2.0),
                            int(npc_w),
                            int(npc_h),
                        )
                        if rect.colliderect(nrect):
                            hits.append(nrect)

                traffic = getattr(self, "story_traffic", None)
                if isinstance(traffic, list) and traffic:
                    for a in traffic:
                        if not isinstance(a, dict):
                            continue
                        trect = self._story_traffic_rect_for_actor(a)
                        if isinstance(trect, pygame.Rect) and rect.colliderect(trect):
                            hits.append(trect)
        except Exception:
            pass
        return hits

    def _collide_rect_world_story_npc(self, rect: pygame.Rect) -> list[pygame.Rect]:
        # Story NPCs should not walk "into" cutaway-roof buildings: those tiles are
        # often non-solid floors that get rendered as walls when the player is outside,
        # which looks like NPCs are climbing facades.
        hits = list(self._collide_rect_world(rect))
        try:
            left = int(math.floor(rect.left / self.TILE_SIZE))
            right = int(math.floor((rect.right - 1) / self.TILE_SIZE))
            top = int(math.floor(rect.top / self.TILE_SIZE))
            bottom = int(math.floor((rect.bottom - 1) / self.TILE_SIZE))
            for ty in range(int(top), int(bottom) + 1):
                for tx in range(int(left), int(right) + 1):
                    try:
                        if self._peek_building_at_tile(int(tx), int(ty)) is None:
                            continue
                    except Exception:
                        continue
                    # Avoid duplicates for already-solid tiles.
                    try:
                        tid = int(self.world.peek_tile(int(tx), int(ty)))
                        if bool(self._tile_solid(int(tid))):
                            continue
                    except Exception:
                        pass
                    tile_rect = pygame.Rect(int(tx) * int(self.TILE_SIZE), int(ty) * int(self.TILE_SIZE), int(self.TILE_SIZE), int(self.TILE_SIZE))
                    if rect.colliderect(tile_rect):
                        hits.append(tile_rect)
        except Exception:
            pass

        # Prevent NPCs from overlapping the player (on-foot).
        if getattr(self, "mount", None) is None:
            try:
                prect = self.player.rect_at()
                if rect.colliderect(prect):
                    hits.append(prect)
            except Exception:
                pass

        # Story traffic (moving vehicles) blocks NPCs too.
        try:
            traffic = getattr(self, "story_traffic", None)
            if isinstance(traffic, list):
                for a in traffic:
                    if not isinstance(a, dict):
                        continue
                    trect = self._story_traffic_rect_for_actor(a)
                    if isinstance(trect, pygame.Rect) and rect.colliderect(trect):
                        hits.append(trect)
        except Exception:
            pass
        return hits

    def _story_npc_is_indoor_tile(self, tx: int, ty: int) -> bool:
        tx = int(tx)
        ty = int(ty)
        try:
            hit = self._peek_building_at_tile(int(tx), int(ty))
        except Exception:
            hit = None
        if hit is None:
            return False
        try:
            btx0, bty0, bw, bh = int(hit[0]), int(hit[1]), int(hit[2]), int(hit[3])
            # Treat outer border/wall belt as not-indoor for pathing guards.
            if int(tx) in (int(btx0), int(btx0) + int(bw) - 1) or int(ty) in (int(bty0), int(bty0) + int(bh) - 1):
                return False
        except Exception:
            pass
        return True

    def _story_npc_collider_wh(self) -> tuple[int, int]:
        # Keep story NPC collision volume aligned with the player's footprint so
        # crowds/brawls feel solid (avoid "ghosting" through NPCs).
        try:
            w = int(getattr(self.player, "w", 10))
        except Exception:
            w = 10
        try:
            h = int(getattr(self.player, "collider_h", 10))
        except Exception:
            h = 10
        w = int(clamp(int(w), 8, 12))
        h = int(clamp(int(h), 8, 14))
        return int(w), int(h)

    def _collide_rect_world_player(self, rect: pygame.Rect) -> list[pygame.Rect]:
        # Player collision in the world: includes static world + story NPCs + story traffic.
        hits = list(self._collide_rect_world(rect))
        if not bool(getattr(self, "story_enabled", False)):
            return hits
        if not bool(self._story_is_pre_apocalypse()):
            return hits
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return hits

        # Story NPC collision volume.
        npcs = getattr(self, "npcs", None)
        if isinstance(npcs, list) and npcs:
            npc_w, npc_h = self._story_npc_collider_wh()
            for npc in npcs:
                if not isinstance(npc, dict):
                    continue
                try:
                    pos = pygame.Vector2(npc.get("pos", pygame.Vector2(0, 0)))
                except Exception:
                    continue
                nrect = pygame.Rect(
                    iround(float(pos.x) - float(npc_w) / 2.0),
                    iround(float(pos.y) - float(npc_h) / 2.0),
                    int(npc_w),
                    int(npc_h),
                )
                if rect.colliderect(nrect):
                    hits.append(nrect)

        # Story traffic collision volume.
        try:
            traffic = getattr(self, "story_traffic", None)
            if isinstance(traffic, list):
                for a in traffic:
                    if not isinstance(a, dict):
                        continue
                    trect = self._story_traffic_rect_for_actor(a)
                    if isinstance(trect, pygame.Rect) and rect.colliderect(trect):
                        hits.append(trect)
        except Exception:
            pass
        return hits

    def _move_with_collisions(self, pos: pygame.Vector2, vel: pygame.Vector2, dt: float) -> pygame.Vector2:
        rect = self.player.rect_at(pos)
        dx = float(vel.x * dt)
        dy = float(vel.y * dt)

        if dx != 0.0:
            rect.x += int(round(dx))
            for hit in self._collide_rect_world(rect):
                if dx > 0:
                    rect.right = hit.left
                else:
                    rect.left = hit.right

        if dy != 0.0:
            rect.y += int(round(dy))
            for hit in self._collide_rect_world(rect):
                if dy > 0:
                    rect.bottom = hit.top
                else:
                    rect.top = hit.bottom

        return pygame.Vector2(rect.centerx, rect.centery)

    def _move_box(
        self,
        pos: pygame.Vector2,
        vel: pygame.Vector2,
        dt: float,
        *,
        w: int,
        h: int,
        collide_fn: Callable[[pygame.Rect], list[pygame.Rect]] | None = None,
    ) -> pygame.Vector2:
        # Use float movement (sub-pixel accumulation) then resolve collisions
        # with an int rect. This keeps pixel-art rendering crisp while allowing
        # slow entities (e.g., zombies) to actually move.
        collide: Callable[[pygame.Rect], list[pygame.Rect]]
        collide = collide_fn if callable(collide_fn) else self._collide_rect_world

        w = int(w)
        h = int(h)
        p = pygame.Vector2(pos)
        dt = float(dt)
        if dt > 0.25:
            dt = 0.25
        dx_total = float(vel.x) * dt
        dy_total = float(vel.y) * dt

        def rect_at(px: float, py: float) -> pygame.Rect:
            return pygame.Rect(
                iround(float(px) - float(w) / 2.0),
                iround(float(py) - float(h) / 2.0),
                int(w),
                int(h),
            )

        def depenetrate(r: pygame.Rect, *, prefer_axis: str | None = None) -> pygame.Rect:
            prefer_axis = None if prefer_axis is None else str(prefer_axis)
            r = pygame.Rect(r)
            axis_penalty = int(clamp(int(self.TILE_SIZE) // 5, 1, 3))
            for _ in range(10):
                hits = collide(r)
                if not hits:
                    break
                best: tuple[int, int, int, int, int] | None = None  # score, absd, prio, ox, oy
                for hit in hits:
                    if not r.colliderect(hit):
                        continue
                    dx_l = int(hit.left - r.right)
                    dx_r = int(hit.right - r.left)
                    dy_u = int(hit.top - r.bottom)
                    dy_d = int(hit.bottom - r.top)
                    for absd, ox, oy in (
                        (abs(dx_l), dx_l, 0),
                        (abs(dx_r), dx_r, 0),
                        (abs(dy_u), 0, dy_u),
                        (abs(dy_d), 0, dy_d),
                    ):
                        if absd <= 0:
                            continue
                        axis = "x" if int(ox) != 0 else "y"
                        prio = 0 if (prefer_axis is not None and axis == prefer_axis) else 1
                        score = int(absd) + (0 if prefer_axis is None or axis == prefer_axis else int(axis_penalty))
                        if best is None or (score, prio, int(absd)) < (best[0], best[2], best[1]):
                            best = (int(score), int(absd), int(prio), int(ox), int(oy))
                if best is None:
                    break
                _score, _absd, _prio, ox, oy = best
                r.move_ip(int(ox), int(oy))
            return r

        def depenetrate_axis(r: pygame.Rect, *, axis: str) -> pygame.Rect:
            axis = str(axis)
            r = pygame.Rect(r)
            for _ in range(10):
                hits = collide(r)
                if not hits:
                    break
                best: tuple[int, int] | None = None
                for hit in hits:
                    if not r.colliderect(hit):
                        continue
                    if axis == "x":
                        dx_l = int(hit.left - r.right)
                        dx_r = int(hit.right - r.left)
                        for absd, ox in ((abs(dx_l), dx_l), (abs(dx_r), dx_r)):
                            if absd <= 0:
                                continue
                            if best is None or absd < best[0]:
                                best = (int(absd), int(ox))
                    else:
                        dy_u = int(hit.top - r.bottom)
                        dy_d = int(hit.bottom - r.top)
                        for absd, oy in ((abs(dy_u), dy_u), (abs(dy_d), dy_d)):
                            if absd <= 0:
                                continue
                            if best is None or absd < best[0]:
                                best = (int(absd), int(oy))
                if best is None:
                    break
                _absd, o = best
                if axis == "x":
                    r.move_ip(int(o), 0)
                else:
                    r.move_ip(0, int(o))
            return r

        def filter_hits_axis(hits: list[pygame.Rect], r: pygame.Rect, *, axis: str) -> list[pygame.Rect]:
            axis = str(axis)
            # "Skin" lets the player slide along horizontal/vertical walls without
            # getting caught on 1px corner overlaps (fixes right->left sticking).
            skin = int(clamp(int(self.TILE_SIZE) // 6, 1, 2))
            kept: list[pygame.Rect] = []
            for h in hits:
                if not r.colliderect(h):
                    continue
                inter = r.clip(h)
                if int(inter.w) <= 0 or int(inter.h) <= 0:
                    continue
                # Ignore tiny 1-2px corner overlaps; treating them as "blocking"
                # causes visible jitter when sliding along walls (esp. while sprinting).
                if int(inter.w) <= int(skin) and int(inter.h) <= int(skin):
                    continue
                # For horizontal movement, only keep hits that are "mostly side walls"
                # (penetration in X smaller than in Y, plus a small skin). Otherwise,
                # treat the hit as a top/bottom scrape and resolve via a small
                # orthogonal depenetration. This also avoids getting stuck on
                # outside corners where inter.w ~= inter.h.
                if axis == "x":
                    if int(inter.w) <= int(inter.h) + int(skin):
                        kept.append(h)
                else:
                    if int(inter.h) <= int(inter.w) + int(skin):
                        kept.append(h)
            return kept

        # If we ever end up slightly inside a wall (rounding edge-case), push out
        # in the shortest direction. This prevents large "snap" corrections later.
        cur = rect_at(float(p.x), float(p.y))
        if collide(cur):
            pref = None
            try:
                if abs(float(vel.x)) >= abs(float(vel.y)) and abs(float(vel.x)) > 1e-6:
                    pref = "y"
                elif abs(float(vel.y)) > 1e-6:
                    pref = "x"
            except Exception:
                pref = None
            if pref in ("x", "y"):
                cur2 = depenetrate_axis(cur, axis=str(pref))
                cur = cur2 if not collide(cur2) else depenetrate(cur, prefer_axis=pref)
            else:
                cur = depenetrate(cur, prefer_axis=pref)
            p.update(float(cur.centerx), float(cur.centery))

        # Prevent tunneling through thin walls/doorways on hitches by moving
        # in small sub-steps (still using a crisp int rect for collisions).
        max_step = max(1.0, float(self.TILE_SIZE) / 2.0)
        steps = int(max(1, math.ceil(max(abs(dx_total), abs(dy_total)) / max_step)))
        dx = float(dx_total) / float(steps)
        dy = float(dy_total) / float(steps)
        nudge_max = int(clamp(int(self.TILE_SIZE) // 2, 1, 4))

        for _ in range(int(steps)):
            step_prev = pygame.Vector2(p)
            if dx != 0.0:
                prev = rect_at(float(p.x), float(p.y))
                p.x += float(dx)
                rect = rect_at(float(p.x), float(p.y))
                hits = collide(rect)
                if hits:
                    hits_block = filter_hits_axis(hits, rect, axis="x")
                    if not hits_block:
                        rect2 = depenetrate_axis(rect, axis="y")
                        if not collide(rect2):
                            rect = rect2
                            p.y = float(rect.centery)
                        p.x = float(rect.centerx)
                        continue
                    hits = hits_block
                    # Corner correction: when moving purely horizontally, a tiny Y nudge
                    # makes 1-tile corridors/doorways feel smooth instead of "pixel perfect".
                    corrected = False
                    depen_fixed = False
                    if abs(float(vel.y)) < 1e-6:
                        prefer = 0
                        try:
                            avg = sum(int(hh.centery) for hh in hits) / float(max(1, len(hits)))
                            if float(avg) < float(rect.centery):
                                prefer = 1  # obstacles above -> move down first
                            elif float(avg) > float(rect.centery):
                                prefer = -1  # obstacles below -> move up first
                        except Exception:
                            prefer = 0

                        base = pygame.Rect(rect)
                        for n in range(1, int(nudge_max) + 1):
                            if prefer > 0:
                                cands = (n, -n)
                            elif prefer < 0:
                                cands = (-n, n)
                            else:
                                cands = (-n, n)
                            for sy in cands:
                                test = pygame.Rect(base)
                                test.y += int(sy)
                                if not collide(test):
                                    rect = test
                                    corrected = True
                                    break
                            if corrected:
                                break
                    if not corrected and abs(float(vel.y)) < 1e-6:
                        # If this collision can be fixed by a tiny vertical push (common when
                        # sliding along the top/bottom walls), prefer that so horizontal motion
                        # doesn't get cancelled at 1px corner overlaps.
                        rect2 = depenetrate_axis(rect, axis="y")
                        if abs(int(rect2.y) - int(rect.y)) <= int(nudge_max) and not collide(rect2):
                            rect = rect2
                            corrected = True
                            depen_fixed = True
                    if corrected:
                        # Accept the corrected position and skip the blocking clamp for X.
                        p.x = float(rect.centerx)
                        p.y = float(rect.centery)
                    else:
                        if dx > 0.0:
                            blocks = [int(r.left) for r in hits if int(prev.right) <= int(r.left)]
                            if blocks:
                                rect.right = int(min(blocks))
                            else:
                                # If we can't find a proper blocking face, do NOT depenetrate in X
                                # (that can push several pixels and trigger the teleport-guard,
                                # which feels like getting stuck). Prefer a tiny Y depenetration;
                                # if that can't fix it, cancel this X step.
                                rect2 = depenetrate_axis(rect, axis="y")
                                if (
                                    abs(float(vel.y)) < 1e-6
                                    and abs(int(rect2.y) - int(rect.y)) <= int(nudge_max)
                                    and rect2.topleft != rect.topleft
                                    and not collide(rect2)
                                ):
                                    rect = rect2
                                    depen_fixed = True
                                else:
                                    rect = pygame.Rect(prev)
                        else:
                            blocks = [int(r.right) for r in hits if int(prev.left) >= int(r.right)]
                            if blocks:
                                rect.left = int(max(blocks))
                            else:
                                rect2 = depenetrate_axis(rect, axis="y")
                                if (
                                    abs(float(vel.y)) < 1e-6
                                    and abs(int(rect2.y) - int(rect.y)) <= int(nudge_max)
                                    and rect2.topleft != rect.topleft
                                    and not collide(rect2)
                                ):
                                    rect = rect2
                                    depen_fixed = True
                                else:
                                    rect = pygame.Rect(prev)
                        if collide(rect):
                            rect2 = depenetrate_axis(rect, axis="y")
                            if abs(int(rect2.y) - int(rect.y)) <= int(nudge_max) and rect2.topleft != rect.topleft:
                                rect = rect2
                                depen_fixed = True
                        # Keep wall sliding stable: avoid large cross-axis corrections here.
                        # We only apply tiny axis depenetration when we're still overlapping.
                        p.x = float(rect.centerx)
                        if depen_fixed:
                            p.y = float(rect.centery)

            if dy != 0.0:
                prev = rect_at(float(p.x), float(p.y))
                p.y += float(dy)
                rect = rect_at(float(p.x), float(p.y))
                hits = collide(rect)
                if hits:
                    hits_block = filter_hits_axis(hits, rect, axis="y")
                    if not hits_block:
                        rect2 = depenetrate_axis(rect, axis="x")
                        if not collide(rect2):
                            rect = rect2
                            p.x = float(rect.centerx)
                        p.y = float(rect.centery)
                        continue
                    hits = hits_block
                    corrected = False
                    depen_fixed = False
                    if abs(float(vel.x)) < 1e-6:
                        prefer = 0
                        try:
                            avg = sum(int(hh.centerx) for hh in hits) / float(max(1, len(hits)))
                            if float(avg) < float(rect.centerx):
                                prefer = 1  # obstacles left -> move right first
                            elif float(avg) > float(rect.centerx):
                                prefer = -1  # obstacles right -> move left first
                        except Exception:
                            prefer = 0

                        base = pygame.Rect(rect)
                        for n in range(1, int(nudge_max) + 1):
                            if prefer > 0:
                                cands = (n, -n)
                            elif prefer < 0:
                                cands = (-n, n)
                            else:
                                cands = (-n, n)
                            for sx in cands:
                                test = pygame.Rect(base)
                                test.x += int(sx)
                                if not collide(test):
                                    rect = test
                                    corrected = True
                                    break
                            if corrected:
                                break
                    if corrected:
                        p.x = float(rect.centerx)
                        p.y = float(rect.centery)
                        continue
                    if not corrected and abs(float(vel.x)) < 1e-6:
                        # Mirror of the horizontal case: if we can clear the collision by
                        # nudging in X, do so to avoid 1px corner lockups.
                        rect2 = depenetrate_axis(rect, axis="x")
                        if abs(int(rect2.x) - int(rect.x)) <= int(nudge_max) and not collide(rect2):
                            rect = rect2
                            corrected = True
                            depen_fixed = True
                            p.x = float(rect.centerx)
                            p.y = float(rect.centery)
                            continue
                    if dy > 0.0:
                        blocks = [int(r.top) for r in hits if int(prev.bottom) <= int(r.top)]
                        if blocks:
                            rect.bottom = int(min(blocks))
                        else:
                            rect2 = depenetrate_axis(rect, axis="x")
                            if (
                                abs(float(vel.x)) < 1e-6
                                and abs(int(rect2.x) - int(rect.x)) <= int(nudge_max)
                                and rect2.topleft != rect.topleft
                                and not collide(rect2)
                            ):
                                rect = rect2
                                depen_fixed = True
                            else:
                                rect = pygame.Rect(prev)
                    else:
                        blocks = [int(r.bottom) for r in hits if int(prev.top) >= int(r.bottom)]
                        if blocks:
                            rect.top = int(max(blocks))
                        else:
                            rect2 = depenetrate_axis(rect, axis="x")
                            if (
                                abs(float(vel.x)) < 1e-6
                                and abs(int(rect2.x) - int(rect.x)) <= int(nudge_max)
                                and rect2.topleft != rect.topleft
                                and not collide(rect2)
                            ):
                                rect = rect2
                                depen_fixed = True
                            else:
                                rect = pygame.Rect(prev)
                    if collide(rect):
                        rect2 = depenetrate_axis(rect, axis="x")
                        if abs(int(rect2.x) - int(rect.x)) <= int(nudge_max) and rect2.topleft != rect.topleft:
                            rect = rect2
                            depen_fixed = True
                    # Same idea as X: only clamp along Y to preserve wall sliding.
                    p.y = float(rect.centery)
                    if depen_fixed:
                        p.x = float(rect.centerx)

            # Final safety: never return a penetrated position (prevents "").
            final = rect_at(float(p.x), float(p.y))
            if collide(final):
                # Avoid large depenetration "snaps" at outside corners: only allow
                # tiny corrective pushes. Otherwise, revert this sub-step.
                max_fix = int(max(1, int(nudge_max)))
                fixed: pygame.Rect | None = None

                if abs(float(vel.y)) < 1e-6 and abs(float(vel.x)) > 1e-6:
                    cand = depenetrate_axis(final, axis="y")
                    if abs(int(cand.y) - int(final.y)) <= max_fix and not collide(cand):
                        fixed = cand
                elif abs(float(vel.x)) < 1e-6 and abs(float(vel.y)) > 1e-6:
                    cand = depenetrate_axis(final, axis="x")
                    if abs(int(cand.x) - int(final.x)) <= max_fix and not collide(cand):
                        fixed = cand
                else:
                    cand = depenetrate_axis(final, axis="x")
                    if abs(int(cand.x) - int(final.x)) <= max_fix and not collide(cand):
                        fixed = cand
                    else:
                        cand = depenetrate_axis(final, axis="y")
                        if abs(int(cand.y) - int(final.y)) <= max_fix and not collide(cand):
                            fixed = cand

                if fixed is not None:
                    p.update(float(fixed.centerx), float(fixed.centery))
                else:
                    p.update(float(step_prev.x), float(step_prev.y))

        return p

    def _move_box_vehicle(
        self,
        pos: pygame.Vector2,
        vel: pygame.Vector2,
        dt: float,
        *,
        w: int,
        h: int,
        max_dist: float | None = None,
    ) -> pygame.Vector2:
        # Sub-stepped movement to avoid tunneling through 1-tile walls when dt spikes.
        w = int(w)
        h = int(h)
        dt = float(dt)
        if dt > 0.25:
            dt = 0.25

        p = pygame.Vector2(pos)
        rect = pygame.Rect(
            iround(float(p.x) - float(w) / 2.0),
            iround(float(p.y) - float(h) / 2.0),
            int(w),
            int(h),
        )

        def _rect_at_center(center: pygame.Vector2) -> pygame.Rect:
            return pygame.Rect(
                iround(float(center.x) - float(w) / 2.0),
                iround(float(center.y) - float(h) / 2.0),
                int(w),
                int(h),
            )

        def _resolve_vehicle_overlap(r: pygame.Rect, *, iters: int = 14) -> pygame.Rect:
            r = pygame.Rect(r)
            for _ in range(int(iters)):
                try:
                    hits2 = self._collide_rect_world_vehicle(r)
                except Exception:
                    hits2 = []
                if not hits2:
                    break
                best: tuple[float, str, pygame.Rect] | None = None
                for hit in hits2:
                    if not r.colliderect(hit):
                        continue
                    dl = float(r.right - hit.left)
                    dr = float(hit.right - r.left)
                    du = float(r.bottom - hit.top)
                    dd = float(hit.bottom - r.top)
                    for d, axis in ((dl, "L"), (dr, "R"), (du, "U"), (dd, "D")):
                        if d <= 0.0:
                            continue
                        if best is None or float(d) < float(best[0]):
                            best = (float(d), str(axis), hit)
                if best is None:
                    break
                _d, axis, hit = best
                if axis == "L":
                    r.right = int(hit.left)
                elif axis == "R":
                    r.left = int(hit.right)
                elif axis == "U":
                    r.bottom = int(hit.top)
                else:
                    r.top = int(hit.bottom)
            return r

        # If the vehicle starts overlapped (e.g., after a collision snap), depenetrate
        # so it doesn't become permanently stuck with zero velocity.
        try:
            init_hits = self._collide_rect_world_vehicle(rect)
        except Exception:
            init_hits = []
        if init_hits:
            # Prefer snapping back to a known-safe position if we have one.
            last_safe_global = None
            if self.mount == "rv":
                last_safe_global = getattr(self, "_rv_last_safe_pos", None)
            elif self.mount == "bike":
                last_safe_global = getattr(self, "_bike_last_safe_pos", None)
            if isinstance(last_safe_global, pygame.Vector2):
                cand = _rect_at_center(pygame.Vector2(last_safe_global))
                try:
                    if not self._collide_rect_world_vehicle(cand):
                        rect = cand
                        p.update(float(rect.centerx), float(rect.centery))
                        init_hits = []
                except Exception:
                    pass

            if init_hits:
                rect = _resolve_vehicle_overlap(rect, iters=18)
                p.update(float(rect.centerx), float(rect.centery))
                try:
                    init_hits = self._collide_rect_world_vehicle(rect)
                except Exception:
                    init_hits = []

            if init_hits:
                # Final fallback: small radial search for any nearby free spot.
                step = int(max(1, int(self.TILE_SIZE) // 2))
                max_r = int(self.TILE_SIZE) * 4
                found = False
                for r in range(int(step), int(max_r) + 1, int(step)):
                    for ox, oy in (
                        (r, 0),
                        (-r, 0),
                        (0, r),
                        (0, -r),
                        (r, r),
                        (r, -r),
                        (-r, r),
                        (-r, -r),
                    ):
                        cand_pos = pygame.Vector2(float(p.x) + float(ox), float(p.y) + float(oy))
                        cand_rect = _rect_at_center(cand_pos)
                        try:
                            if not self._collide_rect_world_vehicle(cand_rect):
                                rect = cand_rect
                                p.update(float(rect.centerx), float(rect.centery))
                                found = True
                                break
                        except Exception:
                            continue
                    if found:
                        break

        dx_total = float(vel.x) * dt
        dy_total = float(vel.y) * dt
        # If the vehicle is running out of fuel mid-frame, cap the travel distance so it
        # stops exactly when fuel reaches 0 (instead of gliding for the rest of the frame).
        if max_dist is not None:
            try:
                md = float(max_dist)
            except Exception:
                md = None
            if md is not None:
                if md <= 0.0:
                    dx_total = 0.0
                    dy_total = 0.0
                else:
                    dlen = float(math.hypot(float(dx_total), float(dy_total)))
                    if dlen > md and dlen > 1e-9:
                        s = float(md) / float(dlen)
                        dx_total *= float(s)
                        dy_total *= float(s)
        if abs(dx_total) < 1e-6 and abs(dy_total) < 1e-6:
            # Persist a safe position for un-sticking.
            try:
                if not self._collide_rect_world_vehicle(rect):
                    if self.mount == "rv":
                        self._rv_last_safe_pos = pygame.Vector2(float(rect.centerx), float(rect.centery))
                    elif self.mount == "bike":
                        self._bike_last_safe_pos = pygame.Vector2(float(rect.centerx), float(rect.centery))
            except Exception:
                pass
            return pygame.Vector2(p)

        # Keep per-step movement small (px) so collisions can't be skipped.
        max_step = 2.0
        steps = int(max(1, math.ceil(max(abs(dx_total), abs(dy_total)) / max_step)))
        steps = int(clamp(int(steps), 1, 80))
        step_dx = float(dx_total) / float(steps)
        step_dy = float(dy_total) / float(steps)

        last_safe: pygame.Vector2 | None = None
        try:
            if not self._collide_rect_world_vehicle(rect):
                last_safe = pygame.Vector2(p)
        except Exception:
            last_safe = pygame.Vector2(p)

        skin = int(clamp(int(self.TILE_SIZE) // 6, 1, 2))
        max_jump = max(float(self.TILE_SIZE) * 2.0, float(max_step) * 8.0)

        for _ in range(int(steps)):
            step_prev = pygame.Vector2(p)
            prev_rect = pygame.Rect(rect)
            had_hit = False

            if abs(step_dx) > 1e-9:
                prev_x = pygame.Rect(rect)
                p.x += float(step_dx)
                rect.x = iround(float(p.x) - float(w) / 2.0)
                hits = self._collide_rect_world_vehicle(rect)
                if hits:
                    had_hit = True
                    # First clamp along X as usual.
                    if step_dx > 0.0:
                        blocks = [int(hit.left) for hit in hits if int(prev_x.right) <= int(hit.left) + int(skin)]
                        limit = int(min(blocks)) if blocks else int(min(int(hit.left) for hit in hits))
                        rect.right = int(limit)
                    else:
                        blocks = [int(hit.right) for hit in hits if int(prev_x.left) >= int(hit.right) - int(skin)]
                        limit = int(max(blocks)) if blocks else int(max(int(hit.right) for hit in hits))
                        rect.left = int(limit)

                # Preserve sub-pixel remainder so shallow headings don't "snap" to axis movement.
                try:
                    fx = float(clamp(float(p.x) - float(rect.centerx), -0.49, 0.49))
                except Exception:
                    fx = 0.0
                p.x = float(rect.centerx) + float(fx)

            if abs(step_dy) > 1e-9:
                prev_y = pygame.Rect(rect)
                p.y += float(step_dy)
                rect.y = iround(float(p.y) - float(h) / 2.0)
                hits = self._collide_rect_world_vehicle(rect)
                if hits:
                    had_hit = True
                    # First clamp along Y as usual.
                    if step_dy > 0.0:
                        blocks = [int(hit.top) for hit in hits if int(prev_y.bottom) <= int(hit.top) + int(skin)]
                        limit = int(min(blocks)) if blocks else int(min(int(hit.top) for hit in hits))
                        rect.bottom = int(limit)
                    else:
                        blocks = [int(hit.bottom) for hit in hits if int(prev_y.top) >= int(hit.bottom) - int(skin)]
                        limit = int(max(blocks)) if blocks else int(max(int(hit.bottom) for hit in hits))
                        rect.top = int(limit)

                try:
                    fy = float(clamp(float(p.y) - float(rect.centery), -0.49, 0.49))
                except Exception:
                    fy = 0.0
                p.y = float(rect.centery) + float(fy)

            # If we still overlap after resolution (e.g., due to large colliders like
            # whole-building rects), depenetrate a bit; otherwise revert to the last
            # known safe position to prevent visible "teleport" snaps.
            if had_hit:
                try:
                    post_hits = self._collide_rect_world_vehicle(rect)
                except Exception:
                    post_hits = []
                if post_hits:
                    r = pygame.Rect(rect)
                    for _j in range(10):
                        try:
                            hits2 = self._collide_rect_world_vehicle(r)
                        except Exception:
                            hits2 = []
                        if not hits2:
                            break
                        best: tuple[float, str, pygame.Rect] | None = None
                        for hit in hits2:
                            if not r.colliderect(hit):
                                continue
                            dl = float(r.right - hit.left)
                            dr = float(hit.right - r.left)
                            du = float(r.bottom - hit.top)
                            dd = float(hit.bottom - r.top)
                            for d, axis in ((dl, "L"), (dr, "R"), (du, "U"), (dd, "D")):
                                if d <= 0.0:
                                    continue
                                if best is None or d < best[0]:
                                    best = (float(d), str(axis), hit)
                        if best is None:
                            break
                        _d, axis, hit = best
                        if axis == "L":
                            r.right = int(hit.left)
                        elif axis == "R":
                            r.left = int(hit.right)
                        elif axis == "U":
                            r.bottom = int(hit.top)
                        else:
                            r.top = int(hit.bottom)
                    rect = r
                    p.update(float(rect.centerx), float(rect.centery))

                    try:
                        post_hits = self._collide_rect_world_vehicle(rect)
                    except Exception:
                        post_hits = []
                    if post_hits:
                        if last_safe is not None:
                            rect.x = iround(float(last_safe.x) - float(w) / 2.0)
                            rect.y = iround(float(last_safe.y) - float(h) / 2.0)
                            p.update(float(last_safe.x), float(last_safe.y))
                        else:
                            rect = prev_rect
                            p.update(float(step_prev.x), float(step_prev.y))
                        break

            # Anti-teleport guard: collision resolution should never move a vehicle
            # multiple tiles in a single sub-step. If it does, snap back.
            try:
                step_jump = float((pygame.Vector2(float(rect.centerx), float(rect.centery)) - step_prev).length())
            except Exception:
                step_jump = 0.0
            allowed_jump = float(max_jump) if last_safe is not None else float(max(float(self.TILE_SIZE) * 6.0, float(max_jump)))
            if float(step_jump) > float(allowed_jump):
                if last_safe is not None:
                    rect.x = iround(float(last_safe.x) - float(w) / 2.0)
                    rect.y = iround(float(last_safe.y) - float(h) / 2.0)
                    p.update(float(last_safe.x), float(last_safe.y))
                else:
                    rect = prev_rect
                    p.update(float(step_prev.x), float(step_prev.y))
                break

            # Record a "safe" (non-overlapping) position for fallback.
            if not had_hit:
                last_safe = pygame.Vector2(p)
            else:
                try:
                    if not self._collide_rect_world_vehicle(rect):
                        last_safe = pygame.Vector2(p)
                except Exception:
                    last_safe = pygame.Vector2(p)

        # Persist a safe position for un-sticking.
        if last_safe is not None:
            if self.mount == "rv":
                self._rv_last_safe_pos = pygame.Vector2(last_safe)
            elif self.mount == "bike":
                self._bike_last_safe_pos = pygame.Vector2(last_safe)

        return pygame.Vector2(p)

    def _update_world_door_open_anim(self, dt: float) -> None:
        # Visual-only door open/close animation for world-map doors.
        if bool(getattr(self, "hr_interior", False)) or bool(getattr(self, "house_interior", False)) or bool(getattr(self, "sch_interior", False)):
            return
        anim = getattr(self, "_door_open_anim", None)
        if not isinstance(anim, dict):
            anim = {}
            self._door_open_anim = anim
        tx, ty = self._player_tile()
        openable = {int(self.T_DOOR), int(self.T_DOOR_HOME), int(self.T_DOOR_BROKEN)}
        want: set[tuple[int, int]] = set()
        for yy in range(int(ty) - 2, int(ty) + 3):
            for xx in range(int(tx) - 2, int(tx) + 3):
                tid = int(self.world.peek_tile(int(xx), int(yy), default=int(self.T_GRASS)))
                if int(tid) not in openable:
                    continue
                if abs(int(xx) - int(tx)) <= 1 and abs(int(yy) - int(ty)) <= 1:
                    want.add((int(xx), int(yy)))

        open_speed = 10.0
        close_speed = 8.0
        for pos in set(anim.keys()) | want:
            cur = float(anim.get(pos, 0.0))
            if pos in want:
                cur = min(1.0, cur + float(dt) * float(open_speed))
            else:
                cur = max(0.0, cur - float(dt) * float(close_speed))
            if cur <= 0.001 and pos not in want:
                anim.pop(pos, None)
            else:
                anim[pos] = float(cur)

    def update(self, dt: float) -> None:
        if self.hint_left > 0.0:
            self.hint_left = max(0.0, float(self.hint_left) - dt)
            if self.hint_left <= 0.0:
                self.hint_text = ""

        self._dialog_update(float(dt))
        self._conv_update(float(dt))
        if float(getattr(self, "speech_left", 0.0)) > 0.0:
            self.speech_left = max(0.0, float(getattr(self, "speech_left", 0.0)) - dt)
            if float(self.speech_left) <= 0.0:
                self.speech_text = ""

        if float(getattr(self, "world_ctx_cooldown_left", 0.0)) > 0.0:
            self.world_ctx_cooldown_left = max(0.0, float(getattr(self, "world_ctx_cooldown_left", 0.0)) - dt)

        if bool(getattr(self, "pause_open", False)):
            return

        # Auto-dismiss the in-world context bubble if it stays up without clicks.
        try:
            if bool(getattr(self, "world_ctx_open", False)) and isinstance(getattr(self, "world_ctx_target", None), tuple):
                tgt = tuple(getattr(self, "world_ctx_target"))
                if tgt == getattr(self, "world_ctx_idle_target", None):
                    self.world_ctx_idle_s = float(getattr(self, "world_ctx_idle_s", 0.0)) + float(dt)
                else:
                    self.world_ctx_idle_target = tgt
                    self.world_ctx_idle_s = 0.0
            else:
                self.world_ctx_idle_target = None
                self.world_ctx_idle_s = 0.0

            if float(getattr(self, "world_ctx_idle_s", 0.0)) >= 4.0:
                ptx, pty = self._player_tile()
                self.world_ctx_suppressed = {"target": tuple(getattr(self, "world_ctx_target", ())), "player_tile": (int(ptx), int(pty))}
                self.world_ctx_idle_s = 0.0
                self.world_ctx_idle_target = None
                self.world_ctx_open = False
                self.world_ctx_target = None
                self.world_ctx_rects = []
                self.world_ctx_cooldown_left = max(float(getattr(self, "world_ctx_cooldown_left", 0.0)), 0.8)
        except Exception:
            pass

        if getattr(self, "rv_ui_status_left", 0.0) > 0.0:
            self.rv_ui_status_left = max(0.0, float(self.rv_ui_status_left) - dt)
            if self.rv_ui_status_left <= 0.0:
                self.rv_ui_status = ""

        if getattr(self, "home_ui_status_left", 0.0) > 0.0:
            self.home_ui_status_left = max(0.0, float(self.home_ui_status_left) - dt)
            if self.home_ui_status_left <= 0.0:
                self.home_ui_status = ""

        if getattr(self, "muzzle_flash_left", 0.0) > 0.0:
            self.muzzle_flash_left = max(0.0, float(self.muzzle_flash_left) - dt)

        if self.player.hp <= 0:
            if self.dead_left <= 0.0:
                self.dead_left = 2.0
                self._set_hint(" 2", seconds=2.0)
            else:
                self.dead_left = max(0.0, float(self.dead_left) - dt)
                if self.dead_left <= 0.0:
                    self.app.set_state(MainMenuState(self.app))
            return

        if self.inv_open or getattr(self, "rv_ui_open", False) or getattr(self, "home_ui_open", False) or getattr(self, "hr_elevator_ui_open", False) or getattr(self, "world_elevator_ui_open", False) or getattr(self, "sch_elevator_ui_open", False) or getattr(self, "_gallery_open", False) or getattr(self, "world_map_open", False) or getattr(self, "conv_open", False):
            self.player.vel.update(0, 0)
            self.player.walk_phase *= 0.85
            self.rv.vel.update(0, 0)
            self.bike.vel.update(0, 0)
            return

        self._update_flashlight(float(dt))

        dt_time = float(dt)
        if str(getattr(self, "player_pose", "")) == "sleep" and str(getattr(self, "player_pose_space", "")) == "world":
            # Sleep at night fast-forwards time; the fuller you are, the faster it goes.
            tday = (float(self.world_time_s) % float(self.DAY_LENGTH_S)) / float(self.DAY_LENGTH_S)
            if tday >= (20.0 / 24.0) or tday <= (6.0 / 24.0):
                full = float(clamp(float(self.player.hunger) / 100.0, 0.0, 1.0))
                dt_time = float(dt) * float(8.0 + 16.0 * full)
        dt_time = float(clamp(float(dt_time), 0.0, 0.45))

        self.world_time_s += dt_time
        self._update_weather(dt_time)
        self._story_update(dt_time)
        self._crime_update(dt_time)
        self._story_update_npcs(dt_time)
        self._story_update_traffic(dt_time)

        if getattr(self, "noise_left", 0.0) > 0.0:
            self.noise_left = max(0.0, float(self.noise_left) - dt_time)
            if self.noise_left <= 0.0:
                self.noise_radius = 0.0

        # Survival stats (prototype tuning).
        self.player.hunger = float(clamp(self.player.hunger - dt_time * 0.10, 0.0, 100.0))
        self.player.thirst = float(clamp(self.player.thirst - dt_time * 0.16, 0.0, 100.0))

        focus = pygame.Vector2(self.player.pos)
        nearest = 99999.0
        for z in self.zombies:
            nearest = min(nearest, float((z.pos - focus).length()))

        stress = 0.0
        if self.player.hunger < 25.0:
            stress += (25.0 - self.player.hunger) / 25.0
        if self.player.thirst < 25.0:
            stress += 1.2 * (25.0 - self.player.thirst) / 25.0
        if self.player.hp < 40:
            stress += (40.0 - float(self.player.hp)) / 40.0
        if nearest < 90.0:
            stress += (90.0 - nearest) / 90.0 * 1.4

        morale_decay = 0.010 + 0.035 * stress
        self.player.morale = float(clamp(self.player.morale - dt_time * morale_decay * 20.0, 0.0, 100.0))

        cond_down = 0.0
        if self.player.hunger <= 0.0:
            cond_down += 0.10
        if self.player.thirst <= 0.0:
            cond_down += 0.14
        if self.player.hp < 60:
            cond_down += 0.06
        cond_up = 0.0
        if self.mount == "rv" and self.rv.vel.length_squared() <= 0.1 and nearest > 140.0:
            cond_up += 0.08
            if self.player.hunger > 50.0 and self.player.thirst > 50.0:
                cond_up += 0.05
        self.player.condition = float(clamp(self.player.condition + dt_time * (cond_up - cond_down) * 10.0, 0.0, 100.0))

        # Starvation / dehydration damage.
        dmg_rate = 0.0
        if self.player.hunger <= 0.0:
            dmg_rate += 0.55
        if self.player.thirst <= 0.0:
            dmg_rate += 0.85
        if dmg_rate > 0.0:
            self.starve_accum += dmg_rate * dt_time
            while self.starve_accum >= 1.0:
                self.starve_accum -= 1.0
                self.player.hp = max(0, int(self.player.hp) - 1)        

        # Bleeding damage (from zombie scratches/bites).
        self._apply_bleed(dt_time)

        keys = pygame.key.get_pressed()
        move = pygame.Vector2(0, 0)
        if keys[pygame.K_w] or keys[pygame.K_UP]:
            move.y -= 1
        if keys[pygame.K_s] or keys[pygame.K_DOWN]:
            move.y += 1
        if keys[pygame.K_a] or keys[pygame.K_LEFT]:
            move.x -= 1
        if keys[pygame.K_d] or keys[pygame.K_RIGHT]:
            move.x += 1

        # In-world furniture moving mode freezes the player; the cursor is moved via key events.
        if bool(getattr(self, "home_move_mode", False)):
            move = pygame.Vector2(0, 0)

        # Sit/Sleep pose locks movement inside interiors.
        pose = getattr(self, "player_pose", None)
        if pose:
            cur_space = "world"
            if getattr(self, "house_interior", False):
                cur_space = "house"
            elif getattr(self, "sch_interior", False):
                cur_space = "sch"
            elif getattr(self, "hr_interior", False):
                cur_space = "hr"
            if str(getattr(self, "player_pose_space", "")) != cur_space:
                self._clear_player_pose()
            else:
                self.player_pose_phase = float(getattr(self, "player_pose_phase", 0.0)) + dt
                left = float(getattr(self, "player_pose_left", 0.0))
                if left > 0.0:
                    self.player_pose_left = max(0.0, left - dt)
                    if self.player_pose_left <= 0.0:
                        self._clear_player_pose()
                if getattr(self, "player_pose", None) is not None:
                    if move.length_squared() > 0.001:
                        self._clear_player_pose()
                    else:
                        move = pygame.Vector2(0, 0)

        # Timed world actions (e.g. toilet) that rely on the sit pose.
        self._update_toilet_task(float(dt))
        self._update_work_task(float(dt))

        move_raw = pygame.Vector2(move)
        if move.length_squared() > 0.001:
            move = move.normalize()
            if self.mount != "rv":
                self.player.facing = pygame.Vector2(move.x, move.y)

        if getattr(self, "sch_interior", False):
            base_speed = 60.0
            self.sch_int_vel = move * base_speed
            self.player_sprinting = False
            if self.sch_int_vel.length_squared() > 0.1:
                self.sch_int_facing = pygame.Vector2(self.sch_int_vel).normalize()
                self.sch_int_walk_phase += dt * 10.0 * (self.sch_int_vel.length() / base_speed)
            else:
                self.sch_int_walk_phase *= 0.90
            self.sch_int_pos = self._sch_int_move_box(
                self.sch_int_pos,
                self.sch_int_vel,
                dt,
                w=int(getattr(self, "int_player_w", 10)),
                h=int(getattr(self, "int_player_h", 14)),
            )
            self.player.vel.update(0, 0)
            self.rv.vel.update(0, 0)
            self.bike.vel.update(0, 0)
            self._update_gun_timers(dt, allow_fire=False)
            return

        if getattr(self, "house_interior", False):
            base_speed = 60.0
            self.house_int_vel = move * base_speed
            self.player_sprinting = False
            if self.house_int_vel.length_squared() > 0.1:
                self.house_int_facing = pygame.Vector2(self.house_int_vel).normalize()
                self.house_int_walk_phase += dt * 10.0 * (self.house_int_vel.length() / base_speed)
            else:
                self.house_int_walk_phase *= 0.90
            self.house_int_pos = self._house_int_move_box(
                self.house_int_pos,
                self.house_int_vel,
                dt,
                w=int(getattr(self, "int_player_w", 10)),
                h=int(getattr(self, "int_player_h", 14)),
            )
            self.player.vel.update(0, 0)
            self.rv.vel.update(0, 0)
            self.bike.vel.update(0, 0)
            self._update_gun_timers(dt, allow_fire=False)
            return

        if getattr(self, "hr_interior", False):
            base_speed = 60.0
            if bool(getattr(self, "hr_travel_active", False)):
                self.player_sprinting = False
                self.hr_int_vel = pygame.Vector2(0, 0)
                self.hr_int_walk_phase *= 0.90
                self._hr_travel_update(dt)
                self.player.vel.update(0, 0)
                self.rv.vel.update(0, 0)
                self.bike.vel.update(0, 0)
                self._update_gun_timers(dt, allow_fire=False)
                return

            # "Walk into the lobby then to the elevator" feel on entry.
            if bool(getattr(self, "hr_auto_walk_to_elevator", False)):  
                # Allow player input to cancel the auto-walk.
                if move.length_squared() > 0.001:
                    self.hr_auto_walk_to_elevator = False
                else:
                    delay = float(getattr(self, "hr_auto_walk_delay", 0.0))
                    if delay > 0.0:
                        self.hr_auto_walk_delay = max(0.0, delay - dt)
                        move = pygame.Vector2(0, 0)
                    elif str(getattr(self, "hr_mode", "lobby")) == "lobby":
                        elev = self._hr_int_find("E")
                        if elev is None:
                            self.hr_auto_walk_to_elevator = False
                        else:
                            ex, ey = elev
                            tile = int(self._HR_INT_TILE_SIZE)
                            target = pygame.Vector2((ex + 0.5) * tile, (ey + 0.5) * tile)
                            diff = target - pygame.Vector2(self.hr_int_pos)
                            d2 = float(diff.length_squared())
                            if d2 <= 3.0 * 3.0:
                                self.hr_auto_walk_to_elevator = False
                                move = pygame.Vector2(0, 0)
                                if not bool(getattr(self, "hr_elevator_ui_open", False)):
                                    self._hr_elevator_open()
                            else:
                                if diff.length_squared() > 0.001:
                                    move = diff.normalize()
                                    base_speed = 56.0

            self.hr_int_vel = move * base_speed
            self.player_sprinting = False
            if self.hr_int_vel.length_squared() > 0.1:
                self.hr_int_facing = pygame.Vector2(self.hr_int_vel).normalize()
                self.hr_int_walk_phase += dt * 10.0 * (self.hr_int_vel.length() / base_speed)
            else:
                self.hr_int_walk_phase *= 0.90
            self.hr_int_pos = self._hr_int_move_box(
                self.hr_int_pos,
                self.hr_int_vel,
                dt,
                w=int(getattr(self, "int_player_w", 10)),
                h=int(getattr(self, "int_player_h", 14)),
            )
            self.player.vel.update(0, 0)
            self.rv.vel.update(0, 0)
            self.bike.vel.update(0, 0)
            self._update_gun_timers(dt, allow_fire=False)
            return

        if self.mount == "rv":
            mid = getattr(self.rv, "model_id", "rv")
            model = self._CAR_MODELS.get(str(mid))
            if model is None:
                model = self._CAR_MODELS.get("rv") or next(iter(self._CAR_MODELS.values()))

            want_fwd = bool(keys[pygame.K_w] or keys[pygame.K_UP])
            want_rev = bool(keys[pygame.K_s] or keys[pygame.K_DOWN])
            throttle = (1.0 if want_fwd else 0.0) + (-1.0 if want_rev else 0.0)
            steer_in = 0.0
            if keys[pygame.K_a] or keys[pygame.K_LEFT]:
                steer_in -= 1.0
            if keys[pygame.K_d] or keys[pygame.K_RIGHT]:
                steer_in += 1.0

            tx = int(math.floor(self.rv.pos.x / self.TILE_SIZE))        
            ty = int(math.floor(self.rv.pos.y / self.TILE_SIZE))        
            tile_under = self.world.get_tile(tx, ty)
            traction = float(self._tile_slow(tile_under))

            fuel = float(getattr(self.rv, "fuel", 0.0))
            fuel_empty = fuel <= 0.01
            boost = 1.15 if (keys[pygame.K_LSHIFT] or keys[pygame.K_RSHIFT]) else 1.0
            if fuel_empty:
                boost = 1.0
                if abs(float(throttle)) > 0.1 and not bool(getattr(self, "_rv_no_fuel_warned", False)):
                    self._set_hint("", seconds=1.0)
                    self._rv_no_fuel_warned = True
            else:
                self._rv_no_fuel_warned = False

            # Out of fuel: engine stops (no acceleration), but the vehicle can still coast
            # due to inertia and slow down via drag/braking (hardcore simulation feel).
            accel_mult = 0.0 if fuel_empty else boost

            max_fwd = float(model.max_fwd) * traction * float(boost)
            max_rev = float(model.max_rev) * traction
            accel = float(model.accel) * traction * float(accel_mult)
            brake = float(model.brake) * traction
            drag = 1.8 + (1.0 - traction) * 2.2

            max_steer = float(getattr(model, "steer_max", 0.62))  # radians
            # Faster return-to-center reduces "drift" when releasing A/D.
            steer_resp = 16.0
            target_steer = float(clamp(steer_in, -1.0, 1.0)) * max_steer        
            self.rv.steer = float(self.rv.steer + (target_steer - float(self.rv.steer)) * clamp(dt * steer_resp, 0.0, 1.0))
            # Snap small residual steer to zero so straight driving stays straight.
            if abs(float(steer_in)) < 1e-6 and abs(float(self.rv.steer)) < 0.0035:
                self.rv.steer = 0.0

            speed = float(self.rv.speed)
            if fuel_empty:
                # Engine off: W does nothing; S is braking. Otherwise coast with drag.
                if throttle < 0.0:
                    if speed > 0.5:
                        speed = max(0.0, speed - brake * dt)
                    elif speed < -0.5:
                        speed = min(0.0, speed + brake * dt)
                    else:
                        speed = 0.0
                else:
                    speed *= max(0.0, 1.0 - drag * dt)
                self._rv_reverse_hold = 0.0
            else:
                # W = accelerate forward, S = brake (and reverse only after stopping).
                if throttle > 0.0:
                    if speed < -0.5:
                        # Braking while reversing.
                        speed = min(0.0, speed + brake * dt)
                    else:
                        speed += accel * dt
                    self._rv_reverse_hold = 0.0
                elif throttle < 0.0:
                    if speed > 0.5:
                        # Braking while moving forward.
                        speed = max(0.0, speed - brake * dt)
                        self._rv_reverse_hold = 0.0
                    else:
                        # Reverse is gated: hold S briefly after stopping.
                        hold = float(getattr(self, "_rv_reverse_hold", 0.0)) + float(dt)
                        self._rv_reverse_hold = float(hold)
                        if float(hold) >= 0.25:
                            speed -= (accel * 0.75) * dt
                        else:
                            speed = 0.0
                else:
                    speed *= max(0.0, 1.0 - drag * dt)
                    self._rv_reverse_hold = 0.0

            speed = float(clamp(speed, -max_rev, max_fwd))
            self.rv.speed = speed

            wheelbase = float(max(8.0, getattr(model, "wheelbase", 20.0)))
            heading0 = float(getattr(self.rv, "heading", 0.0))
            forward0 = pygame.Vector2(math.cos(heading0), math.sin(heading0))
            if forward0.length_squared() <= 0.001:
                forward0 = pygame.Vector2(1, 0)
            else:
                forward0 = forward0.normalize()

            turn = 0.0
            if abs(speed) > 0.5 and abs(float(self.rv.steer)) > 1e-6:
                turn = (speed / wheelbase) * math.tan(float(self.rv.steer))
            heading1 = float((heading0 + turn * dt) % math.tau)
            self.rv.heading = float(heading1)

            forward1 = pygame.Vector2(math.cos(float(heading1)), math.sin(float(heading1)))
            if forward1.length_squared() <= 0.001:
                forward1 = pygame.Vector2(1, 0)
            else:
                forward1 = forward1.normalize()

            # Move the vehicle as if steering is applied at the front axle (rear-axle anchored),
            # so it doesn't feel like turning around its center.
            length_px = float(max(int(getattr(self.rv, "w", 0)), int(getattr(self.rv, "h", 0))))
            half_len = float(length_px * 0.5) if length_px > 0.0 else float(wheelbase * 0.5)
            rear_ref = float(max(6.0, float(wheelbase * 0.5)))
            if half_len > 0.0:
                rear_ref = float(max(rear_ref, half_len - 6.0))
                rear_ref = float(min(rear_ref, max(6.0, half_len - 2.0)))

            rear0 = pygame.Vector2(self.rv.pos) - forward0 * float(rear_ref)
            # Midpoint integration so the RV doesn't "slide" sideways while turning.
            heading_mid = float(heading0 + turn * dt * 0.5)
            forward_mid = pygame.Vector2(math.cos(float(heading_mid)), math.sin(float(heading_mid)))
            if forward_mid.length_squared() <= 0.001:
                forward_mid = forward0
            else:
                forward_mid = forward_mid.normalize()
            rear1 = rear0 + forward_mid * speed * dt
            center1 = rear1 + forward1 * float(rear_ref)
            if dt > 0.0:
                self.rv.vel = (center1 - pygame.Vector2(self.rv.pos)) / float(dt)
            else:
                self.rv.vel = pygame.Vector2(0, 0)

            if abs(speed) > 4.0:
                self.rv_anim += dt * (2.0 + abs(speed) * 0.06)
            else:
                self.rv_anim *= 0.85

            before = pygame.Vector2(self.rv.pos)
            desired_vel = pygame.Vector2(self.rv.vel)
            try:
                desired_step = float((pygame.Vector2(desired_vel) * float(dt)).length())
            except Exception:
                desired_step = 0.0
            # Driving collision: use a stable axis-aligned collider (swap on near-vertical)
            # instead of the rotated AABB, which becomes overly conservative at ~45 and
            # makes vehicles feel like they hit buildings too early.
            try:
                cw = int(max(2, int(getattr(self.rv, "w", 0))))
                ch = int(max(2, int(getattr(self.rv, "h", 0))))
                # Allow per-model driving collider (e.g. RV uses a smaller box to avoid
                # feeling blocked by dense city building facades while keeping a big footprint
                # for its interior stamping).
                try:
                    dc = getattr(model, "drive_collider", None)
                    if isinstance(dc, tuple) and len(dc) == 2:
                        dcw, dch = int(dc[0]), int(dc[1])
                        if dcw > 0 and dch > 0:
                            cw = int(max(2, min(int(cw), int(dcw))))
                            ch = int(max(2, min(int(ch), int(dch))))
                except Exception:
                    pass
                heading = float(getattr(self.rv, "heading", 0.0))
                c = abs(float(math.cos(float(heading))))
                s = abs(float(math.sin(float(heading))))
                ratio = float(s / max(1e-6, c))
                axis = int(getattr(self, "_rv_drive_axis", 0))  # 0=horiz, 1=vert
                if axis == 0:
                    if ratio > 1.18:
                        axis = 1
                else:
                    if ratio < 0.85:
                        axis = 0
                self._rv_drive_axis = int(axis)
                if axis == 1:
                    vw, vh = int(ch), int(cw)
                else:
                    vw, vh = int(cw), int(ch)
            except Exception:
                vw = int(max(2, int(getattr(self.rv, "w", 0))))
                vh = int(max(2, int(getattr(self.rv, "h", 0))))
            self.rv.pos = self._move_box_vehicle(self.rv.pos, self.rv.vel, dt, w=vw, h=vh)
            moved = pygame.Vector2(self.rv.pos) - before
            dist = float(moved.length())
            if dt > 0.0:
                self.rv.vel = moved / float(dt)
                # If we hit something, the kinematic model will keep "pushing" unless we
                # sync the signed speed to the *actual* movement. This prevents the
                # spin-in-place exploit that can creep vehicles through walls/buildings.
                # BUT: vehicle movement is quantized to pixels for crisp rendering. If we always
                # sync speed to the quantized movement, braking/accel will feel "steppy" and
                # can even get stuck at exactly 60px/s (1px per frame). Only sync when we were
                # meaningfully blocked (i.e., forward progress is much less than intended).
                try:
                    desired_fwd_step = float(abs(float(speed)) * float(dt))
                    actual_fwd_step = float(abs(float(moved.dot(forward1))))
                except Exception:
                    desired_fwd_step = float(desired_step)
                    actual_fwd_step = float(dist)
                if float(desired_fwd_step) >= 0.51 and (float(actual_fwd_step) + 0.15) < float(desired_fwd_step):
                    try:
                        self.rv.speed = float(clamp(float(self.rv.vel.dot(forward1)), -max_rev, max_fwd))
                    except Exception:
                        pass
            if dist > 0.001:
                self.rv.fuel = max(0.0, float(self.rv.fuel) - dist * float(getattr(model, "fuel_per_px", 0.0125)))
            self.player.pos.update(self.rv.pos)
            self.player.vel.update(self.rv.vel)
            self.player.walk_phase *= 0.85
            self.player_sprinting = False

            # If the player is clearly trying to move but the RV doesn't translate for a while,
            # auto-unstuck to a nearby road-like tile so the vehicle never feels permanently dead.
            try:
                stuck_t = float(getattr(self, "_rv_stuck_t", 0.0))
                trying = abs(float(throttle)) > 0.10
                # Consider it "stuck" when the player intends meaningful movement this frame,
                # but the quantized movement stays near-zero.
                want_move = bool(trying and float(desired_step) >= 0.35)
                if want_move and float(dist) <= 0.05:
                    stuck_t += float(dt)
                else:
                    stuck_t = max(0.0, float(stuck_t) - float(dt) * 2.5)
                if stuck_t >= 0.85:
                    if self._rv_try_unstuck_nearby():
                        self._set_hint("", seconds=0.9)
                    stuck_t = 0.0
                self._rv_stuck_t = float(stuck_t)
            except Exception:
                pass
        elif self.mount == "bike":
            base_speed = float(self._bike_base_speed())
            tx = int(math.floor(self.bike.pos.x / self.TILE_SIZE))       
            ty = int(math.floor(self.bike.pos.y / self.TILE_SIZE))        
            tile_under = self.world.get_tile(tx, ty)
            speed = base_speed * self._tile_slow(tile_under)
            speed *= self._weather_move_mult()

            mid = str(getattr(self.bike, "model_id", "bike"))
            uses_fuel = bool(mid.startswith("moto"))
            fuel = float(getattr(self.bike, "fuel", 0.0))
            if uses_fuel and fuel > 0.05:
                self._bike_no_fuel_warned = False

            want_sprint = bool(keys[pygame.K_LSHIFT] or keys[pygame.K_RSHIFT])
            moving_now = move.length_squared() > 0.001
            fuel_empty = bool(uses_fuel and fuel <= 0.01)
            if fuel_empty:
                if moving_now and not bool(getattr(self, "_bike_no_fuel_warned", False)):
                    self._set_hint("", seconds=1.0)
                    self._bike_no_fuel_warned = True
                # Engine off: keep coasting with friction; no input thrust.
                try:
                    drag = 5.0
                    self.bike.vel *= max(0.0, 1.0 - float(drag) * float(dt))
                    if self.bike.vel.length_squared() < 0.15:
                        self.bike.vel.update(0, 0)
                except Exception:
                    self.bike.vel.update(0, 0)
                want_sprint = False
            elif self._bike_uses_stamina():
                stamina = float(self.player.stamina)
                can_sprint = bool(want_sprint and moving_now and stamina > 10.0)
                if can_sprint:
                    speed *= 1.25
                    self.player.stamina = float(clamp(stamina - dt * 18.0, 0.0, 100.0))
                else:
                    self.player.stamina = float(clamp(stamina + dt * 10.0, 0.0, 100.0))
            else:
                # Motorized two-wheelers: shift is throttle, stamina should recover.
                if want_sprint and moving_now:
                    speed *= 1.35
                self.player.stamina = float(clamp(float(self.player.stamina) + dt * 14.0, 0.0, 100.0))

            if not fuel_empty:
                self.bike.vel = move * speed
            if self.bike.vel.length_squared() > 0.1:
                # Stabilize 4-dir bike facing on diagonals (avoid rapid left/up flips).
                vx = float(self.bike.vel.x)
                vy = float(self.bike.vel.y)
                ratio = abs(vy) / max(1e-6, abs(vx))
                axis = int(getattr(self, "_bike_dir_axis", 0))  # 0=horiz, 1=vert
                if axis == 0:
                    if ratio > 1.18:
                        axis = 1
                else:
                    if ratio < 0.85:
                        axis = 0
                self._bike_dir_axis = int(axis)
                if axis == 1:
                    self.bike_dir = "down" if vy >= 0.0 else "up"
                else:
                    self.bike_dir = "right" if vx >= 0.0 else "left"
                self.bike_anim += dt * 10.0
            else:
                self.bike_anim *= 0.85

            before = pygame.Vector2(self.bike.pos)
            self.bike.pos = self._move_box_vehicle(self.bike.pos, self.bike.vel, dt, w=self.bike.w, h=self.bike.h)
            dist = float((self.bike.pos - before).length())
            if uses_fuel and dist > 0.001:
                fuel_per_px = {
                    "moto": 0.0024,
                    "moto_lux": 0.0022,
                    "moto_long": 0.0026,
                }.get(mid, 0.0024)
                before_fuel = float(getattr(self.bike, "fuel", 0.0))
                self.bike.fuel = float(clamp(before_fuel - dist * float(fuel_per_px), 0.0, 100.0))
                if before_fuel > 0.01 and float(self.bike.fuel) <= 0.01:
                    self._set_hint("", seconds=1.0)
                    self._bike_no_fuel_warned = True
            self.player.pos.update(self.bike.pos)
            self.player.vel.update(self.bike.vel)
            self.player.walk_phase *= 0.85
            self.player_sprinting = False
        else:
            base_speed = 60.0
            tx = int(math.floor(self.player.pos.x / self.TILE_SIZE))
            ty = int(math.floor(self.player.pos.y / self.TILE_SIZE))
            tile_under = self.world.get_tile(tx, ty)
            speed = base_speed * self._tile_slow(tile_under)
            speed *= 0.80 + 0.20 * (float(self.player.condition) / 100.0)
            speed *= self._weather_move_mult()

            carrying_furniture = bool(self._world_furniture_carry_active())
            if carrying_furniture:
                speed *= 0.62
            want_sprint = bool(keys[pygame.K_LSHIFT] or keys[pygame.K_RSHIFT]) and not bool(carrying_furniture)
            moving_now = move_raw.length_squared() > 0.001
            sprint_intent = bool(want_sprint and moving_now)
            stamina = float(self.player.stamina)

            # Sprint gating with hysteresis: once stamina is depleted, the
            # player must recover some stamina before sprinting again. This
            # prevents tiny "bursts" of sprint when stamina hovers near zero.
            sprint_start_need = 25.0
            sprint_stop_need = 8.0
            was_sprinting = bool(getattr(self, "player_sprinting", False))
            if sprint_intent:
                can_sprint = stamina > (sprint_stop_need if was_sprinting else sprint_start_need)
            else:
                can_sprint = False

            if can_sprint: 
                # Sprint speed multiplier (diagonal sprint is normalized below). 
                speed *= 1.25 
                self.player.stamina = float(clamp(stamina - dt * 28.0, 0.0, 100.0)) 
            else: 
                regen_mod = 0.50 + 0.50 * (min(self.player.hunger, self.player.thirst) / 100.0) 
                regen_mod *= 0.55 + 0.45 * (self.player.morale / 100.0) 
                self.player.stamina = float(clamp(stamina + dt * 16.0 * regen_mod, 0.0, 100.0)) 
            self.player_sprinting = bool(can_sprint) 
            # Keep raw 8-way input (no normalization) so cardinal walking stays 
            # pixel-perfect, but normalize diagonal movement so 
            move_vel = pygame.Vector2(move_raw) 
            if abs(float(move_raw.x)) > 1e-6 and abs(float(move_raw.y)) > 1e-6: 
                move_vel = pygame.Vector2(move) 
            self.player.vel = move_vel * speed 

            if self.player.vel.length_squared() > 0.1:
                self.player.walk_phase += dt * 10.0 * (self.player.vel.length() / base_speed)
            else:
                self.player.walk_phase *= 0.92

            # Walk-into-door: special buildings (highrise/school) are portals.
            if self._try_walk_into_special_door(move, dt):
                return

            prev_pos = pygame.Vector2(self.player.pos)
            new_pos = self._move_box(
                self.player.pos,
                self.player.vel,
                dt,
                w=self.player.w,
                h=int(getattr(self.player, "collider_h", self.player.h)),
                collide_fn=self._collide_rect_world_player,
            )
            # Anti-jitter: if we started from a non-penetrating position, never let
            # collision resolution move the player *opposite* their intended axis
            # direction (this can look like camera shake when pushing on walls).
            try:
                if not self._collide_rect_world(self.player.rect_at(prev_pos)):
                    dx = float(new_pos.x) - float(prev_pos.x)
                    dy = float(new_pos.y) - float(prev_pos.y)
                    vx = float(getattr(self.player.vel, "x", 0.0))
                    vy = float(getattr(self.player.vel, "y", 0.0))
                    if vx > 1e-6 and dx < -1e-6:
                        new_pos.x = float(prev_pos.x)
                    elif vx < -1e-6 and dx > 1e-6:
                        new_pos.x = float(prev_pos.x)
                    if vy > 1e-6 and dy < -1e-6:
                        new_pos.y = float(prev_pos.y)
                    elif vy < -1e-6 and dy > 1e-6:
                        new_pos.y = float(prev_pos.y)
            except Exception:
                pass
            # Safety net: if collision resolution ever produces a multi-tile jump,
            # keep the old position (prevents visible "").
            max_ok = max(float(self.player.vel.length()) * float(dt) + 2.0, float(self.TILE_SIZE) * 0.95)
            if float((new_pos - prev_pos).length_squared()) > float(max_ok * max_ok):
                try:
                    with open("__teleport.log", "a", encoding="utf-8") as f:
                        f.write(
                            f"world_tp_guard pos=({prev_pos.x:.2f},{prev_pos.y:.2f}) new=({float(new_pos.x):.2f},{float(new_pos.y):.2f}) "
                            f"vel=({float(self.player.vel.x):.2f},{float(self.player.vel.y):.2f}) dt={float(dt):.4f} "
                            f"hr_interior={int(bool(getattr(self,'hr_interior',False)))} house_interior={int(bool(getattr(self,'house_interior',False)))}\\n"
                        )
                except Exception:
                    pass
                self.player.pos.update(prev_pos)
            else:
                self.player.pos.update(new_pos)

        self._update_world_door_open_anim(float(dt))
        self._maybe_show_home_highrise_dialog()

        # Pixel-locked camera follow: track the player's integer world position.
        # Direction-aware rounding avoids visible 1-frame stalls on diagonals.
        fx, fy = self._compute_player_pixel_lock_world_xy()
        self._player_pixel_lock_world_xy = (int(fx), int(fy))
        self.cam_x = int(fx - int(INTERNAL_W // 2))
        self.cam_y = int(fy - int(INTERNAL_H // 2))
        self.cam_fx = float(self.cam_x)
        self.cam_fy = float(self.cam_y)

        self._stream_world_chunks()

        if self.gun is not None and float(self.gun.reload_left) > 0.0 and getattr(self, "_reload_lock_dir", None) is not None:
            lock = pygame.Vector2(self._reload_lock_dir)
            if lock.length_squared() > 0.001:
                self.aim_dir = lock.normalize()
            else:
                self.aim_dir = pygame.Vector2(1, 0)
        else:
            self.aim_dir = self._compute_aim_dir()

        block_fire = bool(getattr(self, "world_ctx_open", False)) or bool(getattr(self, "home_move_mode", False)) or self._world_furniture_carry_active()
        self._update_gun_timers(dt, allow_fire=not bool(block_fire))

        self._update_punch(dt)
        self._update_zombies(dt)
        self._update_bullets(dt)
        self._update_thrown_furniture(dt)
        self._update_hit_fx(dt)

    def _set_hint(self, text: str, *, seconds: float = 1.2) -> None:    
        self.hint_text = str(text)
        self.hint_left = float(seconds)

    def _pause_open_menu(self) -> None:
        self.pause_open = True
        self.pause_rects = []
        self.inv_open = False
        self._inv_clear_ui_state()
        self.world_map_open = False
        self.rv_ui_open = False
        self.home_ui_open = False
        self.world_elevator_ui_open = False
        self.hr_elevator_ui_open = False
        self.sch_elevator_ui_open = False
        self._gallery_open = False
        self.lamp_cfg_open = False
        self.lamp_cfg_target = None
        self.lamp_cfg_rects = []
        # Close any world context bubble so it doesn't overlap the menu.
        self.world_ctx_open = False
        self.world_ctx_target = None
        self.world_ctx_rects = []

    def _pause_close_menu(self) -> None:
        self.pause_open = False
        self.pause_rects = []

    def _pause_activate(self, action: str) -> None:
        action = str(action)
        if action == "resume":
            self._pause_close_menu()
            return
        if action == "menu":
            self._pause_close_menu()
            self.app.set_state(MainMenuState(self.app))
            return
        if action == "quit":
            self._pause_close_menu()
            try:
                pygame.event.post(pygame.event.Event(pygame.QUIT))
            except Exception:
                pass
            return

    def _handle_pause_menu_mouse(self, event: pygame.event.Event) -> bool:
        if not bool(getattr(self, "pause_open", False)):
            return False
        if not hasattr(event, "pos"):
            return False
        mp = self.app.screen_to_internal(event.pos)
        if mp is None:
            return False
        mx, my = int(mp[0]), int(mp[1])
        for r, act in list(getattr(self, "pause_rects", []) or []):
            if isinstance(r, pygame.Rect) and r.collidepoint(mx, my):
                self._pause_activate(str(act))
                return True
        return True

    def _draw_pause_menu(self, surface: pygame.Surface) -> None:
        if not bool(getattr(self, "pause_open", False)):
            return

        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 170))
        surface.blit(overlay, (0, 0))

        panel_w = 240
        panel_h = 140
        panel = pygame.Rect(0, 0, panel_w, panel_h)
        panel.center = (INTERNAL_W // 2, INTERNAL_H // 2)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=10)
        pygame.draw.rect(surface, (90, 90, 110), panel, 2, border_radius=10)

        draw_text(surface, self.app.font_m, "", (panel.centerx, panel.top + 18), pygame.Color(240, 240, 240), anchor="center")

        buttons = [("", "resume"), ("", "menu"), ("", "quit")]
        btn_w = panel.w - 40
        btn_h = 22
        gap = 8
        x0 = panel.x + 20
        y0 = panel.y + 38

        rects: list[tuple[pygame.Rect, str]] = []
        for i, (label, act) in enumerate(buttons):
            br = pygame.Rect(int(x0), int(y0 + i * (btn_h + gap)), int(btn_w), int(btn_h))
            pygame.draw.rect(surface, (28, 28, 34), br, border_radius=8)
            pygame.draw.rect(surface, (160, 160, 180), br, 1, border_radius=8)
            draw_text(surface, self.app.font_s, label, (br.centerx, br.centery - 1), pygame.Color(230, 230, 240), anchor="center")
            rects.append((br, str(act)))
        self.pause_rects = rects

    def _lamp_cfg_close(self) -> None:
        self.lamp_cfg_open = False
        self.lamp_cfg_target = None
        self.lamp_cfg_rects = []

    def _lamp_cfg_activate(self, action: str) -> None:
        action = str(action)
        if action == "close":
            self._lamp_cfg_close()
            return
        cfg = getattr(self.app, "config", None)
        if not isinstance(cfg, GameConfig):
            return

        if action in ("r-", "r+"):
            delta = -1 if action == "r-" else 1
            cur = int(getattr(cfg, "lamp_world_radius_tiles", 3))
            cur = int(clamp(int(cur) + int(delta), 2, 18))
            cfg.lamp_world_radius_tiles = int(cur)
            cfg.save()
            self._set_hint(f": {cur}", seconds=0.8)
            return
        if action in ("i-", "i+"):
            delta = -0.1 if action == "i-" else 0.1
            cur = float(getattr(cfg, "lamp_world_intensity", 1.0))
            cur = float(clamp(float(cur) + float(delta), 0.0, 3.0))
            cur = float(round(cur, 2))
            cfg.lamp_world_intensity = float(cur)
            cfg.save()
            self._set_hint(f": {cur:.2f}", seconds=0.8)
            return
        if action in ("h-", "h+"):
            delta = -0.05 if action == "h-" else 0.05
            cur = float(getattr(cfg, "lamp_world_halo", 0.35))
            cur = float(clamp(float(cur) + float(delta), 0.0, 1.5))
            cur = float(round(cur, 2))
            cfg.lamp_world_halo = float(cur)
            cfg.save()
            self._set_hint(f": {cur:.2f}", seconds=0.8)
            return

    def _handle_lamp_cfg_mouse(self, event: pygame.event.Event) -> bool:
        if not bool(getattr(self, "lamp_cfg_open", False)):
            return False
        if not hasattr(event, "pos"):
            return False
        mp = self.app.screen_to_internal(event.pos)
        if mp is None:
            return False
        mx, my = int(mp[0]), int(mp[1])
        rects = list(getattr(self, "lamp_cfg_rects", []) or [])
        for r, act in rects:
            if isinstance(r, pygame.Rect) and r.collidepoint(mx, my):
                self._lamp_cfg_activate(str(act))
                return True
        # Click outside closes it.
        self._lamp_cfg_close()
        return True

    def _draw_lamp_cfg_ui(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        if not bool(getattr(self, "lamp_cfg_open", False)):
            return
        if bool(getattr(self, "pause_open", False)):
            return
        tgt = getattr(self, "lamp_cfg_target", None)
        if not (isinstance(tgt, tuple) and len(tgt) == 2):
            return
        cfg = getattr(self.app, "config", None)
        if not isinstance(cfg, GameConfig):
            return

        tx, ty = int(tgt[0]), int(tgt[1])
        tile_rect = self._world_tile_screen_rect(int(tx), int(ty), int(cam_x), int(cam_y))

        panel_w = 220
        panel_h = 96
        px = int(tile_rect.centerx - panel_w // 2)
        py = int(tile_rect.top - panel_h - 8)
        if py < 4:
            py = int(tile_rect.bottom + 8)
        px = int(clamp(int(px), 4, int(INTERNAL_W - 4 - panel_w)))
        py = int(clamp(int(py), 4, int(INTERNAL_H - 4 - panel_h)))
        panel = pygame.Rect(px, py, panel_w, panel_h)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=10)
        pygame.draw.rect(surface, (90, 90, 110), panel, 1, border_radius=10)

        draw_text(surface, self.app.font_s, "", (panel.centerx, panel.y + 10), pygame.Color(230, 230, 240), anchor="center")

        rows = [
            ("", int(getattr(cfg, "lamp_world_radius_tiles", 3)), "r-", "r+"),
            ("", float(getattr(cfg, "lamp_world_intensity", 1.0)), "i-", "i+"),
            ("", float(getattr(cfg, "lamp_world_halo", 0.35)), "h-", "h+"),
        ]
        rects: list[tuple[pygame.Rect, str]] = []
        y = panel.y + 24
        for name, val, a_dec, a_inc in rows:
            draw_text(surface, self.app.font_s, f"{name}: {val}", (panel.x + 10, y + 8), pygame.Color(200, 200, 210), anchor="midleft")
            bw = 26
            bh = 18
            dec = pygame.Rect(panel.right - 10 - bw * 2 - 6, y, bw, bh)
            inc = pygame.Rect(panel.right - 10 - bw, y, bw, bh)
            for br, lbl, act in ((dec, "-", a_dec), (inc, "+", a_inc)):
                pygame.draw.rect(surface, (28, 28, 34), br, border_radius=6)
                pygame.draw.rect(surface, (160, 160, 180), br, 1, border_radius=6)
                draw_text(surface, self.app.font_s, lbl, (br.centerx, br.centery - 1), pygame.Color(230, 230, 240), anchor="center")
                rects.append((br, str(act)))
            y += 24

        close = pygame.Rect(panel.right - 28, panel.y + 6, 20, 16)
        pygame.draw.rect(surface, (28, 28, 34), close, border_radius=6)
        pygame.draw.rect(surface, (160, 160, 180), close, 1, border_radius=6)
        draw_text(surface, self.app.font_s, "x", (close.centerx, close.centery - 1), pygame.Color(230, 230, 240), anchor="center")
        rects.append((close, "close"))

        self.lamp_cfg_rects = rects

    def _adjust_lamp_settings_key(self, key: int) -> bool:
        cfg = getattr(self.app, "config", None)
        if not isinstance(cfg, GameConfig):
            return False

        key = int(key)
        in_hr = bool(getattr(self, "hr_interior", False))
        if in_hr:
            radius_name = "lamp_hr_radius_tiles"
            inten_name = "lamp_hr_intensity"
            halo_name = "lamp_hr_halo"
        else:
            radius_name = "lamp_world_radius_tiles"
            inten_name = "lamp_world_intensity"
            halo_name = "lamp_world_halo"

        # New lighting controls (override legacy hint strings).
        if key in (pygame.K_F7, pygame.K_F8):
            delta = -1 if key == pygame.K_F7 else 1
            cur = int(getattr(cfg, radius_name, 5))
            cur = int(clamp(int(cur) + int(delta), 2, 18))
            setattr(cfg, radius_name, int(cur))
            cfg.save()
            self._set_hint(f" {cur}", seconds=0.9)
            return True

        if key in (pygame.K_F9, pygame.K_F10):
            delta = -0.1 if key == pygame.K_F9 else 0.1
            cur = float(getattr(cfg, inten_name, 1.0))
            cur = float(clamp(float(cur) + float(delta), 0.0, 3.0))
            cur = float(round(cur, 2))
            setattr(cfg, inten_name, float(cur))
            cfg.save()
            self._set_hint(f" {cur:.2f}", seconds=0.9)
            return True

        if key in (pygame.K_F11, pygame.K_F12, pygame.K_LEFTBRACKET, pygame.K_RIGHTBRACKET):
            delta = -0.1 if key in (pygame.K_F11, pygame.K_LEFTBRACKET) else 0.1
            cur = float(getattr(cfg, halo_name, 0.35))
            cur = float(clamp(float(cur) + float(delta), 0.0, 1.5))
            cur = float(round(cur, 2))
            setattr(cfg, halo_name, float(cur))
            cfg.save()
            self._set_hint(f" {cur:.2f}", seconds=0.9)
            return True

        if key in (pygame.K_F7, pygame.K_F8):
            delta = -1 if key == pygame.K_F7 else 1
            cur = int(getattr(cfg, radius_name, 5))
            cur = int(clamp(int(cur) + int(delta), 2, 18))
            setattr(cfg, radius_name, int(cur))
            cfg.save()
            self._set_hint(f" {cur}", seconds=0.9)
            return True

        if key in (pygame.K_F9, pygame.K_F10):
            delta = -0.1 if key == pygame.K_F9 else 0.1
            cur = float(getattr(cfg, inten_name, 1.0))
            cur = float(clamp(float(cur) + float(delta), 0.0, 3.0))
            cur = float(round(cur, 2))
            setattr(cfg, inten_name, float(cur))
            cfg.save()
            self._set_hint(f" {cur:.2f}", seconds=0.9)
            return True

        if key in (pygame.K_F11, pygame.K_F12):
            delta = -0.1 if key == pygame.K_F11 else 0.1
            cur = float(getattr(cfg, inten_name, 1.0))
            cur = float(clamp(float(cur) + float(delta), 0.0, 3.0))
            cur = float(round(cur, 2))
            setattr(cfg, inten_name, float(cur))
            cfg.save()
            self._set_hint(f" {cur:.2f}", seconds=0.9)
            return True

        if key in (pygame.K_LEFTBRACKET, pygame.K_RIGHTBRACKET):
            delta = -0.1 if key == pygame.K_LEFTBRACKET else 0.1
            cur = float(getattr(cfg, halo_name, 0.35))
            cur = float(clamp(float(cur) + float(delta), 0.0, 1.5))
            cur = float(round(cur, 2))
            setattr(cfg, halo_name, float(cur))
            cfg.save()
            self._set_hint(f" {cur:.2f}", seconds=0.9)
            return True

        return False

    def _dialog_start(self, title: str, lines: list[str], *, speed: float = 42.0) -> None:
        title = str(title).strip()
        if not title:
            title = ""
        self.dialog_open = True
        self.dialog_title = title
        self.dialog_text_full = "\n".join(str(s) for s in (lines or [])).strip()
        self.dialog_reveal = 0.0
        self.dialog_speed = float(clamp(float(speed), 10.0, 120.0))
        self.dialog_blink = 0.0

    def _dialog_close(self) -> None:
        self.dialog_open = False
        self.dialog_title = ""
        self.dialog_text_full = ""
        self.dialog_reveal = 0.0
        self.dialog_blink = 0.0

    def _dialog_finished(self) -> bool:
        full = str(getattr(self, "dialog_text_full", ""))
        return int(max(0.0, float(getattr(self, "dialog_reveal", 0.0)))) >= len(full)

    def _dialog_finish(self) -> None:
        full = str(getattr(self, "dialog_text_full", ""))
        self.dialog_reveal = float(len(full))

    def _dialog_update(self, dt: float) -> None:
        if not bool(getattr(self, "dialog_open", False)):
            return
        full = str(getattr(self, "dialog_text_full", ""))
        if not full:
            self.dialog_reveal = 0.0
            return
        self.dialog_blink = float(getattr(self, "dialog_blink", 0.0)) + float(dt)
        if self._dialog_finished():
            return
        speed = float(getattr(self, "dialog_speed", 42.0))
        self.dialog_reveal = float(min(float(len(full)), float(getattr(self, "dialog_reveal", 0.0)) + speed * float(dt)))

    def _wrap_text_lines(self, text: str, font: pygame.font.Font, max_w: int) -> list[str]:
        max_w = int(max(1, max_w))
        out: list[str] = []
        for para in str(text).split("\n"):
            cur = ""
            for ch in str(para):
                test = cur + ch
                if cur and font.size(test)[0] > max_w:
                    out.append(cur)
                    cur = ch
                else:
                    cur = test
            out.append(cur)
        while len(out) > 1 and not str(out[-1]).strip():
            out.pop()
        return out

    def _conv_close(self) -> None:
        self.conv_open = False
        self.conv_script = ""
        self.conv_node = ""
        self.conv_ctx = {}
        self.conv_speaker = ""
        self.conv_text_full = ""
        self.conv_options = []
        self.conv_reveal = 0.0
        self.conv_blink = 0.0
        self.conv_choice = 0
        self.conv_option_rects = []

    def _conv_finished(self) -> bool:
        full = str(getattr(self, "conv_text_full", ""))
        return int(max(0.0, float(getattr(self, "conv_reveal", 0.0)))) >= len(full)

    def _conv_finish(self) -> None:
        full = str(getattr(self, "conv_text_full", ""))
        self.conv_reveal = float(len(full))

    def _conv_update(self, dt: float) -> None:
        if not bool(getattr(self, "conv_open", False)):
            return
        full = str(getattr(self, "conv_text_full", ""))
        if not full:
            self.conv_reveal = 0.0
            return
        self.conv_blink = float(getattr(self, "conv_blink", 0.0)) + float(dt)
        if self._conv_finished():
            return
        speed = float(getattr(self, "conv_speed", 60.0))
        self.conv_reveal = float(min(float(len(full)), float(getattr(self, "conv_reveal", 0.0)) + speed * float(dt)))

    def _conv_format(self, text: str) -> str:
        text = str(text)
        try:
            text = text.replace("{PLAYER_NAME}", str(getattr(self, "player_name", "")))
        except Exception:
            pass
        return text

    def _conv_open_node(
        self,
        *,
        speaker: str,
        text: str,
        options: list[dict[str, object]] | None = None,
        script: str = "",
        node: str = "",
        ctx: dict[str, object] | None = None,
        speed: float = 60.0,
    ) -> None:
        self.conv_open = True
        self.conv_script = str(script)
        self.conv_node = str(node)
        self.conv_ctx = dict(ctx) if isinstance(ctx, dict) else {}
        self.conv_speaker = str(speaker)
        self.conv_text_full = self._conv_format(str(text))
        self.conv_options = list(options) if isinstance(options, list) else []
        self.conv_reveal = 0.0
        self.conv_speed = float(clamp(float(speed), 10.0, 180.0))
        self.conv_blink = 0.0
        self.conv_choice = 0
        self.conv_option_rects = []

    def _conv_open_script(self, script_id: str, *, node: str = "start", ctx: dict[str, object] | None = None) -> None:
        scripts = getattr(self, "_CONV_SCRIPTS", None)
        if not isinstance(scripts, dict):
            self._conv_open_node(speaker="", text="", options=[{"label": "", "action": "close"}])
            return
        script = scripts.get(str(script_id))
        if not isinstance(script, dict):
            self._conv_open_node(speaker="", text="", options=[{"label": "", "action": "close"}])
            return
        nd = script.get(str(node))
        if not isinstance(nd, dict):
            self._conv_open_node(speaker="", text="", options=[{"label": "", "action": "close"}])
            return
        speaker = str(nd.get("speaker", "") or script.get("speaker", "") or "???")
        text = str(nd.get("text", "") or "")
        options = nd.get("options", [])
        self._conv_open_node(
            speaker=speaker,
            text=text,
            options=[dict(o) for o in options] if isinstance(options, list) else [],
            script=str(script_id),
            node=str(node),
            ctx=ctx,
            speed=float(nd.get("speed", 60.0) if isinstance(nd.get("speed", 60.0), (int, float)) else 60.0),
        )

    def _conv_dispatch_action(self, action: str, opt: dict[str, object]) -> bool:
        action = str(action).strip()
        if not action or action == "close":
            self._conv_close()
            return True
        if action.startswith("hint:"):
            msg = action.split(":", 1)[1].strip()
            if msg:
                self._set_hint(msg, seconds=1.4)
            return True
        if action.startswith("set_flag:"):
            flag = action.split(":", 1)[1].strip()
            flags = getattr(self, "story_flags", None)
            if not isinstance(flags, set):
                flags = set()
                self.story_flags = flags
            if flag:
                flags.add(flag)
            return True
        if action.startswith("clear_flag:"):
            flag = action.split(":", 1)[1].strip()
            flags = getattr(self, "story_flags", None)
            if isinstance(flags, set) and flag:
                flags.discard(flag)
            return True
        if action.startswith("trust:"):
            # trust:<npc_id>:<delta>
            parts = action.split(":")
            if len(parts) >= 3:
                npc_id = str(parts[1]).strip()
                try:
                    delta = float(parts[2])
                except Exception:
                    delta = 0.0
                if npc_id:
                    trust = getattr(self, "npc_trust", None)
                    if not isinstance(trust, dict):
                        trust = {}
                        self.npc_trust = trust
                    trust[npc_id] = float(trust.get(npc_id, 50.0)) + float(delta)
            return True
        if action.startswith("give_item:"):
            # give_item:<item_id>:<qty>
            parts = action.split(":")
            if len(parts) >= 3:
                item_id = str(parts[1]).strip()
                try:
                    qty = int(float(parts[2]))
                except Exception:
                    qty = 1
                if item_id and qty > 0 and isinstance(getattr(self, "inventory", None), HardcoreSurvivalState._Inventory):
                    self.inventory.add(item_id, int(qty), self._ITEMS)
            return True
        if action.startswith("start_fight"):
            # start_fight[:<npc_id>[:<seconds>]]
            parts = action.split(":")
            npc_id = ""
            seconds = 10.0
            if len(parts) >= 2 and str(parts[1]).strip():
                npc_id = str(parts[1]).strip()
            else:
                ctx = getattr(self, "conv_ctx", None)
                if isinstance(ctx, dict):
                    npc_id = str(ctx.get("npc_id", "")).strip()
            if len(parts) >= 3:
                try:
                    seconds = float(parts[2])
                except Exception:
                    seconds = 10.0
            if npc_id:
                try:
                    self._story_set_npc_hostile(str(npc_id), seconds=float(seconds))
                except Exception:
                    pass
                self._set_hint("", seconds=1.4)
            self._conv_close()
            return True
        if action == "knock_open":
            # A brutal "you opened the door" story fail.
            try:
                self.player.hp = 0
            except Exception:
                pass
            self._set_hint("", seconds=2.0)
            self._conv_close()
            return True
        return False

    def _conv_choose(self, idx: int) -> None:
        if not bool(getattr(self, "conv_open", False)):
            return
        if not self._conv_finished():
            self._conv_finish()
            return
        opts = getattr(self, "conv_options", None)
        if not isinstance(opts, list) or not opts:
            self._conv_close()
            return
        idx = int(idx)
        if not (0 <= idx < len(opts)):
            return
        opt = opts[idx]
        if not isinstance(opt, dict):
            self._conv_close()
            return

        act = opt.get("action")
        if isinstance(act, str) and act:
            self._conv_dispatch_action(str(act), opt)
            if not bool(getattr(self, "conv_open", False)):
                return

        nxt = opt.get("next")
        if isinstance(nxt, str) and nxt:
            self._conv_open_script(str(getattr(self, "conv_script", "")), node=str(nxt), ctx=dict(getattr(self, "conv_ctx", {}) or {}))
            return

        if not bool(opt.get("stay", False)):
            self._conv_close()

    def _conv_handle_key(self, key: int) -> None:
        key = int(key)
        if key in (pygame.K_ESCAPE,):
            self._conv_close()
            return
        if key in (pygame.K_SPACE, pygame.K_RETURN, pygame.K_KP_ENTER, pygame.K_e):
            self._conv_choose(int(getattr(self, "conv_choice", 0)))
            return
        opts = getattr(self, "conv_options", None)
        n = len(opts) if isinstance(opts, list) else 0
        if n <= 0:
            return
        if key in (pygame.K_UP, pygame.K_w):
            self.conv_choice = (int(getattr(self, "conv_choice", 0)) - 1) % n
            return
        if key in (pygame.K_DOWN, pygame.K_s):
            self.conv_choice = (int(getattr(self, "conv_choice", 0)) + 1) % n
            return
        if pygame.K_1 <= key <= pygame.K_9:
            i = int(key - pygame.K_1)
            if 0 <= i < n:
                self.conv_choice = int(i)
                self._conv_choose(int(i))
            return

    def _conv_handle_mouse(self, event: pygame.event.Event) -> None:
        if not hasattr(event, "pos"):
            return
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return
        mx, my = int(internal[0]), int(internal[1])
        rects = getattr(self, "conv_option_rects", None)
        if not isinstance(rects, list):
            return
        for r, idx in rects:
            if not isinstance(r, pygame.Rect):
                continue
            if r.collidepoint(mx, my):
                self.conv_choice = int(idx)
                if event.type == pygame.MOUSEBUTTONDOWN and int(getattr(event, "button", 0)) == 1:
                    self._conv_choose(int(idx))
                return

    def _draw_conversation(self, surface: pygame.Surface) -> None:
        if not bool(getattr(self, "conv_open", False)):
            return
        speaker = str(getattr(self, "conv_speaker", "")).strip() or "???"
        full = str(getattr(self, "conv_text_full", ""))
        shown = full[: int(max(0.0, float(getattr(self, "conv_reveal", 0.0))))]
        opts = getattr(self, "conv_options", None)
        options = opts if isinstance(opts, list) else []

        pad_x = 12
        pad_y = 10
        panel_w = int(INTERNAL_W - pad_x * 2)
        font_t = self.app.font_m
        font = self.app.font_s

        def ellipsize(text: str, font: pygame.font.Font, max_w: int) -> str:
            text = str(text)
            max_w = int(max_w)
            if max_w <= 0 or font.size(text)[0] <= max_w:
                return text
            suffix = ""
            lo = 0
            hi = len(text)
            while lo < hi:
                mid = (lo + hi) // 2
                cand = text[:mid].rstrip() + suffix
                if font.size(cand)[0] <= max_w:
                    lo = mid + 1
                else:
                    hi = mid
            return text[: max(0, lo - 1)].rstrip() + suffix

        # Wrap first so we can size the panel to avoid overflow.
        max_w = int(max(1, panel_w - 20))
        lines = self._wrap_text_lines(shown, font, max_w)
        lines = lines[:4]

        # Dynamic height: keep everything inside the panel.
        btn_h = int(font.get_height() + 8)
        gap = 4
        max_opts = int(min(6, len(options)))
        opts_h = int(max_opts * btn_h + max(0, max_opts - 1) * gap) if max_opts > 0 else 0
        text_h = int(len(lines) * (int(font.get_height()) + 2))
        need_h = int(30 + text_h + (opts_h + 18 if max_opts > 0 else 18))
        panel_h = int(clamp(int(need_h), 96, 170))
        panel = pygame.Rect(pad_x, INTERNAL_H - int(panel_h) - pad_y, int(panel_w), int(panel_h))
        if panel.y < 6:
            panel.y = 6

        ui = pygame.Surface((panel.w, panel.h), pygame.SRCALPHA)
        ui.fill((0, 0, 0, 190))
        pygame.draw.rect(ui, (240, 220, 140, 26), ui.get_rect(), border_radius=10)
        pygame.draw.rect(ui, (220, 220, 235, 160), ui.get_rect(), 2, border_radius=10)
        surface.blit(ui, panel.topleft)

        tx = panel.x + 10
        ty = panel.y + 30
        text_bottom = int(ty + len(lines) * (int(font.get_height()) + 2))

        # Always clip to the panel so long glyphs/options never bleed outside.
        prev_clip0 = surface.get_clip()
        surface.set_clip(panel)
        try:
            surface.blit(
                font_t.render(ellipsize(speaker, font_t, int(panel.w - 20)), False, pygame.Color(240, 240, 240)),
                (panel.x + 10, panel.y + 8),
            )
            ty_draw = int(ty)
            for ln in lines:
                surface.blit(font.render(str(ln), False, pygame.Color(230, 230, 240)), (tx, ty_draw))
                ty_draw += int(font.get_height() + 2)

            # Cursor while typing.
            if not self._conv_finished() and (int(float(getattr(self, "conv_blink", 0.0)) * 3.0) % 2 == 0):
                last_ln = str(lines[-1]) if lines else ""
                cx = tx + max(0, int(font.size(last_ln)[0]))
                cy = int(ty_draw) - int(font.get_height() + 2)
                surface.blit(font.render("|", False, pygame.Color(240, 220, 140)), (cx, cy))
        finally:
            surface.set_clip(prev_clip0)

        # Options (buttons).
        self.conv_option_rects = []
        if options:
            avail_h = int(panel.bottom - 8 - (text_bottom + 6))
            max_fit = int((int(avail_h) + int(gap)) // int(btn_h + gap)) if int(btn_h + gap) > 0 else 0
            show_n = int(min(6, len(options), max_fit)) if int(max_fit) > 0 else 0

            if show_n > 0:
                total_h = int(show_n * btn_h + max(0, show_n - 1) * gap)
                by = int(panel.bottom - 8 - total_h)
                by = int(max(by, int(text_bottom + 6)))
                bx = int(panel.x + 10)
                bw = int(panel.w - 20)

                mouse = self.app.screen_to_internal(pygame.mouse.get_pos())
                mx, my = (int(mouse[0]), int(mouse[1])) if mouse is not None else (-999, -999)

                for i, opt in enumerate(options[: int(show_n)]):
                    label = str(opt.get("label", f"{i+1}")) if isinstance(opt, dict) else f"{i+1}"
                    r = pygame.Rect(int(bx), int(by + i * (btn_h + gap)), int(bw), int(btn_h))
                    hot = r.collidepoint(mx, my)
                    selected = int(getattr(self, "conv_choice", 0)) == int(i)
                    bg = (55, 55, 70) if hot or selected else (30, 30, 38)
                    border = (235, 210, 90) if selected else (140, 140, 160)
                    pygame.draw.rect(surface, bg, r, border_radius=6)
                    pygame.draw.rect(surface, border, r, 2 if selected else 1, border_radius=6)
                    tip = f"{i+1}. {label}" if len(options) <= 9 else str(label)
                    tip = ellipsize(tip, font, int(r.w - 16))
                    prev_clip = surface.get_clip()
                    surface.set_clip(r.inflate(-6, 0))
                    try:
                        # Vertically center inside the button bar.
                        y = int(r.y + (int(r.h) - int(font.get_height())) // 2)
                        draw_text(surface, font, tip, (int(r.left + 8), int(y)), pygame.Color(240, 240, 240), anchor="topleft")
                    finally:
                        surface.set_clip(prev_clip)
                    self.conv_option_rects.append((r, int(i)))

    def _story_world_day(self) -> int:
        return int(self.world_time_s / max(1e-6, float(self.DAY_LENGTH_S))) + 1

    def _story_day_offset(self) -> int:
        # World day 1 == D-3, world day 4 == D0.
        day0 = int(getattr(self, "story_day0_world_day", 4))
        return int(self._story_world_day()) - int(day0)

    def _story_is_pre_apocalypse(self) -> bool:
        day = int(self._story_world_day())
        day0 = int(getattr(self, "story_day0_world_day", 4))
        t = float(self._time_of_day())
        outbreak_t = float(getattr(self, "story_outbreak_time", 6.0 / 24.0))
        if day < day0:
            return True
        if day == day0 and t < outbreak_t:
            return True
        return False

    def _story_add_marker(self, tx: int, ty: int, label: str, *, color: tuple[int, int, int] = (255, 220, 140)) -> None:
        markers = getattr(self, "world_map_markers", None)
        if not isinstance(markers, list):
            self.world_map_markers = []
            markers = self.world_map_markers
        tx = int(tx)
        ty = int(ty)
        label = str(label)
        color = (int(color[0]), int(color[1]), int(color[2]))
        # De-dupe by label.
        self.world_map_markers = [m for m in markers if str(getattr(m, "label", "")) != label]
        self.world_map_markers.append(HardcoreSurvivalState._MapMarker(tx=tx, ty=ty, label=label, color=color))

    def _story_init(self) -> None:
        # Enables the "" prelude. This is a content system: it can be
        # extended without changing core combat/survival.
        self.story_enabled = True
        self.story_day0_world_day = 4
        self.story_outbreak_time = 6.0 / 24.0  # ~06:00
        self.story_flags: set[str] = set()
        self.story_events_done: set[str] = set()
        self.npc_trust: dict[str, float] = {}

        # Ensure story items exist (kept here to avoid touching the bulk-item generator).
        try:
            if "home_peephole_kit" not in self._ITEMS:
                self._ITEMS["home_peephole_kit"] = HardcoreSurvivalState._ItemDef(
                    id="home_peephole_kit",
                    name="",
                    stack=1,
                    color=(170, 170, 190),
                    kind="home_upgrade",
                    desc="",
                )
            if "home_door_chain" not in self._ITEMS:
                self._ITEMS["home_door_chain"] = HardcoreSurvivalState._ItemDef(
                    id="home_door_chain",
                    name="",
                    stack=1,
                    color=(170, 150, 120),
                    kind="home_upgrade",
                    desc="",
                )
        except Exception:
            pass

        # Home upgrades (door vision / partial open).
        self.home_has_peephole = False
        self.home_has_chain = False

        # Key POIs for the prelude (simple, deterministic positions near spawn).
        stx, sty = self._player_tile()
        self.story_origin_tile = (int(stx), int(sty))

        def find_open_tile_near(
            tx: int,
            ty: int,
            *,
            max_r: int = 8,
            avoid_tiles: set[tuple[int, int]] | None = None,
        ) -> tuple[int, int]:
            tx = int(tx)
            ty = int(ty)
            max_r = int(max(0, max_r))
            avoid = avoid_tiles if isinstance(avoid_tiles, set) else None
            for avoid_roads in (True, False):
                for r in range(0, max_r + 1):
                    for dy in range(-r, r + 1):
                        for dx in range(-r, r + 1):
                            nx = int(tx + dx)
                            ny = int(ty + dy)
                            if avoid is not None and (int(nx), int(ny)) in avoid:
                                continue
                            # Keep story NPCs/POIs outdoors (avoid being "on the facade").
                            try:
                                if self._peek_building_at_tile(int(nx), int(ny)) is not None:
                                    continue
                            except Exception:
                                pass
                            tid = int(self.world.peek_tile(int(nx), int(ny)))
                            if bool(avoid_roads) and int(tid) in (int(self.T_ROAD), int(self.T_HIGHWAY)):
                                continue
                            if not bool(self._tile_solid(int(tid))):
                                return int(nx), int(ny)
            return int(tx), int(ty)

        # Keep these close so players will immediately see story NPCs on a fresh start.
        # But: keep "work/company" in the city (avoid randomly landing inside the residential compound).
        try:
            gate_x0 = int(getattr(self.world, "compound_gate_x0", 0))
            gate_x1 = int(getattr(self.world, "compound_gate_x1", 0))
            gate_y = int(getattr(self.world, "compound_ty1", 0))
            work_seed_tx = int((gate_x0 + gate_x1) // 2) + 36
            work_seed_ty = int(gate_y) + 22
        except Exception:
            work_seed_tx = int(stx + 24)
            work_seed_ty = int(sty + 8)

        self.story_work_tile = find_open_tile_near(int(work_seed_tx), int(work_seed_ty), max_r=72)
        self.story_hardware_tile = find_open_tile_near(int(stx + 4), int(sty + 1), max_r=12)
        self.story_cafe_tile = find_open_tile_near(int(stx - 2), int(sty + 1), max_r=12)
        self.story_gym_tile = find_open_tile_near(int(stx - 5), int(sty + 3), max_r=14)

        # Guarantee a real, enterable office building at the work marker.
        try:
            # A larger, more "modern" footprint so it doesn't read like a small house.
            office_w = 18
            office_h = 14

            door_tids = {
                int(self.T_DOOR),
                int(self.T_DOOR_BROKEN),
                int(self.T_DOOR_LOCKED),
            }

            clear_furn_tids = {
                int(self.T_TABLE),
                int(self.T_SHELF),
                int(self.T_BED),
                int(self.T_SOFA),
                int(self.T_FRIDGE),
                int(self.T_TV),
                int(self.T_CHAIR),
                int(self.T_PC),
                int(self.T_TOILET),
                int(self.T_SINK),
                int(self.T_BARRICADE),
                int(self.T_GAS_PUMP),
            }

            def set_world_tile(tx: int, ty: int, tid2: int) -> None:
                tx = int(tx)
                ty = int(ty)
                cx2 = int(tx) // int(self.CHUNK_SIZE)
                cy2 = int(ty) // int(self.CHUNK_SIZE)
                ch2 = self.world.get_chunk(int(cx2), int(cy2))
                lx2 = int(tx) - int(cx2) * int(self.CHUNK_SIZE)
                ly2 = int(ty) - int(cy2) * int(self.CHUNK_SIZE)
                if 0 <= lx2 < int(self.CHUNK_SIZE) and 0 <= ly2 < int(self.CHUNK_SIZE):
                    ch2.tiles[int(ly2) * int(self.CHUNK_SIZE) + int(lx2)] = int(tid2)

            def stamp_office_layout(*, btx0: int, bty0: int, bw: int, bh: int, door: tuple[int, int] | None = None) -> None:
                btx0 = int(btx0)
                bty0 = int(bty0)
                bw = int(bw)
                bh = int(bh)
                if bw <= 3 or bh <= 3:
                    return
                ix0 = int(btx0 + 1)
                iy0 = int(bty0 + 1)
                ix1 = int(btx0 + bw - 2)
                iy1 = int(bty0 + bh - 2)

                def in_int(xx: int, yy: int) -> bool:
                    return int(ix0) <= int(xx) <= int(ix1) and int(iy0) <= int(yy) <= int(iy1)

                def place(tid2: int, xx: int, yy: int) -> None:
                    if in_int(int(xx), int(yy)):
                        set_world_tile(int(xx), int(yy), int(tid2))

                # Clear the interior so the office is never "empty" or blocked by random furniture.
                for yy in range(int(iy0), int(iy1) + 1):
                    for xx in range(int(ix0), int(ix1) + 1):
                        tid = int(self.world.get_tile(int(xx), int(yy)))
                        if int(tid) in clear_furn_tids:
                            set_world_tile(int(xx), int(yy), int(self.T_FLOOR))

                # Ensure a clear entry step inside the door.
                if isinstance(door, tuple) and len(door) == 2:
                    dx, dy = int(door[0]), int(door[1])
                    for ox, oy in ((0, -1), (0, 1), (-1, 0), (1, 0)):
                        nx = int(dx + ox)
                        ny = int(dy + oy)
                        if in_int(int(nx), int(ny)):
                            set_world_tile(int(nx), int(ny), int(self.T_FLOOR))

                # Desk coordinates (adapt to building size).
                # Each desk is 2 tiles wide: PC at (x,y) and (x+1,y).
                def clamp_i(v: int, lo: int, hi: int) -> int:
                    return int(max(int(lo), min(int(hi), int(v))))

                def pc_desk(x0: int, y0: int) -> None:
                    x0 = int(x0)
                    y0 = int(y0)
                    x0 = clamp_i(int(x0), int(ix0), int(ix1 - 1))
                    y0 = clamp_i(int(y0), int(iy0), int(iy1))
                    place(int(self.T_PC), int(x0), int(y0))
                    place(int(self.T_PC), int(x0 + 1), int(y0))
                    # Chair tries to go "below" the left PC tile; fall back above if needed.
                    cy = int(y0 + 1)
                    if not in_int(int(x0), int(cy)):
                        cy = int(y0 - 1)
                    place(int(self.T_CHAIR), int(x0), int(cy))

                # Layout: lobby/corridor + open-plan desks.
                mid_x = int((ix0 + ix1) // 2)
                corridor_x0 = int(mid_x - 1)
                corridor_x1 = int(mid_x + 1)

                # Boss (top-right corner-ish).
                boss_x0 = int(ix1 - 3)
                boss_y0 = int(iy0 + 2)
                pc_desk(int(boss_x0), int(boss_y0))

                # Secretary / reception near the entrance (bottom-left).
                sec_x0 = int(ix0 + 2)
                sec_y0 = int(max(int(iy0 + 2), int(iy1 - 3)))
                pc_desk(int(sec_x0), int(sec_y0))

                # Player workstation near the middle (left of corridor).
                player_x0 = int(max(int(ix0 + 3), int(mid_x - 4)))
                player_y0 = int(max(int(iy0 + 4), int((iy0 + iy1) // 2)))
                pc_desk(int(player_x0), int(player_y0))

                # Record the player's workstation so we can guide + require clock-in from that PC.
                try:
                    self.story_office_player_pc_tiles = {(int(player_x0), int(player_y0)), (int(player_x0 + 1), int(player_y0))}
                except Exception:
                    self.story_office_player_pc_tiles = set()

                # Prefer a walkable adjacent tile as the "workstation marker".
                self.story_workstation_tile = None
                try:
                    for px, py in ((player_x0, player_y0), (player_x0 + 1, player_y0)):
                        for ox, oy in ((0, -1), (-1, 0), (1, 0), (0, 1)):
                            ax = int(px + ox)
                            ay = int(py + oy)
                            if not in_int(int(ax), int(ay)):
                                continue
                            tid = int(self.world.get_tile(int(ax), int(ay)))
                            if not bool(self._tile_solid(int(tid))):
                                self.story_workstation_tile = (int(ax), int(ay))
                                raise StopIteration
                except StopIteration:
                    pass
                except Exception:
                    self.story_workstation_tile = None

                # Employee desks (fill left/right areas, keep a corridor).
                for yy in range(int(iy0 + 4), int(iy1 - 1), 3):
                    # Left side
                    for xx in range(int(ix0 + 2), int(corridor_x0 - 3), 4):
                        pc_desk(int(xx), int(yy))
                    # Right side
                    for xx in range(int(corridor_x1 + 2), int(ix1 - 2), 4):
                        pc_desk(int(xx), int(yy))

                # Filing shelves on the left wall.
                place(int(self.T_SHELF), int(ix0), int(iy0 + 1))
                place(int(self.T_SHELF), int(ix0), int(iy0 + 2))
                # Small pantry corner (bottom-right): fridge + sink.
                place(int(self.T_FRIDGE), int(ix1), int(max(int(iy0 + 2), int(iy1 - 2))))
                place(int(self.T_SINK), int(ix1), int(max(int(iy0 + 2), int(iy1 - 3))))

            # Always place a dedicated office building so it won't end up as a random house.
            claimed = False

            def rects_overlap(ax0: int, ay0: int, aw: int, ah: int, bx0: int, by0: int, bw: int, bh: int) -> bool:
                return int(ax0) < int(bx0 + bw) and int(ax0 + aw) > int(bx0) and int(ay0) < int(by0 + bh) and int(ay0 + ah) > int(by0)

            def can_place_office_at_door(door_tx: int, door_ty: int) -> tuple[int, int, int, int] | None:
                door_tx = int(door_tx)
                door_ty = int(door_ty)
                tx0 = int(door_tx - int(office_w // 2))
                ty0 = int(door_ty - int(office_h - 1))
                tx1 = int(tx0 + int(office_w) - 1)
                ty1 = int(ty0 + int(office_h) - 1)
                cx0 = int(tx0) // int(self.CHUNK_SIZE)
                cy0 = int(ty0) // int(self.CHUNK_SIZE)
                if int(tx1) // int(self.CHUNK_SIZE) != int(cx0) or int(ty1) // int(self.CHUNK_SIZE) != int(cy0):
                    return None
                # Don't place the office inside the residential compound.
                try:
                    if bool(self.world._is_compound_chunk(int(cx0), int(cy0))):
                        return None
                except Exception:
                    pass

                # Force-generate the chunk so we don't place the office onto "future" buildings.
                ch = self.world.get_chunk(int(cx0), int(cy0))
                existing_buildings = getattr(ch, "buildings", None)
                if isinstance(existing_buildings, list):
                    for b in existing_buildings:
                        if not (isinstance(b, tuple) and len(b) >= 4):
                            continue
                        bx0, by0, bw, bh = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                        if rects_overlap(int(tx0), int(ty0), int(office_w), int(office_h), int(bx0), int(by0), int(bw), int(bh)):
                            return None
                existing_special = getattr(ch, "special_buildings", None)
                if isinstance(existing_special, list):
                    for sb in existing_special:
                        try:
                            bx0, by0, bw, bh = int(getattr(sb, "tx0", 0)), int(getattr(sb, "ty0", 0)), int(getattr(sb, "w", 0)), int(getattr(sb, "h", 0))
                        except Exception:
                            continue
                        if bw <= 0 or bh <= 0:
                            continue
                        if rects_overlap(int(tx0), int(ty0), int(office_w), int(office_h), int(bx0), int(by0), int(bw), int(bh)):
                            return None

                # Don't place on highways/water with the office footprint.
                for yy in range(int(ty0), int(ty0 + office_h)):
                    for xx in range(int(tx0), int(tx0 + office_w)):
                        tid = int(self.world.get_tile(int(xx), int(yy)))
                        if int(tid) in (int(self.T_HIGHWAY), int(self.T_WATER)):
                            return None

                # Require a walkable tile just outside the door.
                out_tx = int(door_tx)
                out_ty = int(door_ty + 1)
                try:
                    if self._peek_building_at_tile(int(out_tx), int(out_ty)) is not None:
                        return None
                except Exception:
                    pass
                tid_out = int(self.world.get_tile(int(out_tx), int(out_ty)))
                if bool(self._tile_solid(int(tid_out))):
                    return None
                # Don't open directly onto roads/highways (traffic can block the door).
                if int(tid_out) in (int(self.T_ROAD), int(self.T_HIGHWAY)):
                    return None

                return (int(tx0), int(ty0), int(office_w), int(office_h))

            # Find a good door tile near the initial work tile.
            door_tx, door_ty = int(self.story_work_tile[0]), int(self.story_work_tile[1])
            best = can_place_office_at_door(int(door_tx), int(door_ty)) if not bool(claimed) else None
            if (not bool(claimed)) and best is None:
                found = None
                max_r = 72
                for city_only in (True, False):
                    for avoid_roads in (True, False):
                        for r in range(0, int(max_r) + 1):
                            if found is not None:
                                break
                            for dy in range(-r, r + 1):
                                if found is not None:
                                    break
                                for dx in range(-r, r + 1):
                                    nx = int(door_tx + dx)
                                    ny = int(door_ty + dy)
                                    try:
                                        if self._peek_building_at_tile(int(nx), int(ny)) is not None:
                                            continue
                                    except Exception:
                                        pass
                                    # Prefer placing the company in a city chunk.
                                    try:
                                        ccx = int(nx) // int(self.CHUNK_SIZE)
                                        ccy = int(ny) // int(self.CHUNK_SIZE)
                                        if bool(self.world._is_compound_chunk(int(ccx), int(ccy))):
                                            continue
                                        if bool(city_only) and not bool(self.world._is_city_chunk(int(ccx), int(ccy))):
                                            continue
                                    except Exception:
                                        if bool(city_only):
                                            continue

                                    tid = int(self.world.get_tile(int(nx), int(ny)))
                                    if bool(avoid_roads) and int(tid) in (int(self.T_ROAD), int(self.T_HIGHWAY)):
                                        continue
                                    if bool(self._tile_solid(int(tid))):
                                        continue
                                    cand = can_place_office_at_door(int(nx), int(ny))
                                    if cand is not None:
                                        found = (int(nx), int(ny), cand)
                                        break
                        if found is not None:
                            break
                    if found is not None:
                        break
                if found is not None:
                    door_tx, door_ty, best = int(found[0]), int(found[1]), found[2]

            # Last-resort fallback: try deterministic placements in nearby chunks so the office
            # never ends up "missing" (e.g. when the initial tile is near chunk borders).
            if (not bool(claimed)) and best is None:
                try:
                    scx = int(stx) // int(self.CHUNK_SIZE)
                    scy = int(sty) // int(self.CHUNK_SIZE)
                    # Door local coordinates inside a chunk (keep some space below for a small plaza).
                    door_locals = [(16, 27), (12, 27), (20, 27), (16, 28), (10, 27), (22, 27)]
                    placed = None
                    max_chunk_r = 6
                    for cr in range(0, int(max_chunk_r) + 1):
                        if placed is not None:
                            break
                        for dy in range(-cr, cr + 1):
                            if placed is not None:
                                break
                            for dx in range(-cr, cr + 1):
                                if max(abs(int(dx)), abs(int(dy))) != int(cr):
                                    continue
                                ccx = int(scx + dx)
                                ccy = int(scy + dy)
                                base_tx2 = int(ccx) * int(self.CHUNK_SIZE)
                                base_ty2 = int(ccy) * int(self.CHUNK_SIZE)
                                for lx, ly in door_locals:
                                    cand_tx = int(base_tx2 + int(lx))
                                    cand_ty = int(base_ty2 + int(ly))
                                    cand = can_place_office_at_door(int(cand_tx), int(cand_ty))
                                    if cand is not None:
                                        placed = (int(cand_tx), int(cand_ty), cand)
                                        break
                    if placed is not None:
                        door_tx, door_ty, best = int(placed[0]), int(placed[1]), placed[2]
                except Exception:
                    pass

            if best is not None:
                tx0, ty0, bw, bh = (int(best[0]), int(best[1]), int(best[2]), int(best[3]))
                door_tx, door_ty = int(door_tx), int(door_ty)
                self.story_work_tile = (int(door_tx), int(door_ty))
                self.story_office_key = (int(tx0), int(ty0), int(bw), int(bh))

                cx = int(tx0) // int(self.CHUNK_SIZE)
                cy = int(ty0) // int(self.CHUNK_SIZE)
                ch = self.world.get_chunk(int(cx), int(cy))
                base_tx = int(cx) * int(self.CHUNK_SIZE)
                base_ty = int(cy) * int(self.CHUNK_SIZE)

                def set_t(xx: int, yy: int, tid2: int) -> None:
                    lx = int(xx) - int(base_tx)
                    ly = int(yy) - int(base_ty)
                    if 0 <= lx < int(self.CHUNK_SIZE) and 0 <= ly < int(self.CHUNK_SIZE):
                        ch.tiles[int(ly) * int(self.CHUNK_SIZE) + int(lx)] = int(tid2)

                # Clear items/vehicles inside the office footprint to avoid "floating" clutter.
                try:
                    if isinstance(getattr(ch, "items", None), list) and ch.items:
                        ch.items[:] = [
                            it
                            for it in ch.items
                            if not (
                                isinstance(it, HardcoreSurvivalState._WorldItem)
                                and int(tx0) <= int(math.floor(float(it.pos.x) / float(self.TILE_SIZE))) <= int(tx0 + bw - 1)
                                and int(ty0) <= int(math.floor(float(it.pos.y) / float(self.TILE_SIZE))) <= int(ty0 + bh - 1)
                            )
                        ]
                except Exception:
                    pass
                try:
                    if isinstance(getattr(ch, "cars", None), list) and ch.cars:
                        ch.cars[:] = [
                            v
                            for v in ch.cars
                            if not (
                                int(tx0) <= int(math.floor(float(getattr(v, "pos", pygame.Vector2(0, 0)).x) / float(self.TILE_SIZE))) <= int(tx0 + bw - 1)
                                and int(ty0) <= int(math.floor(float(getattr(v, "pos", pygame.Vector2(0, 0)).y) / float(self.TILE_SIZE))) <= int(ty0 + bh - 1)
                            )
                        ]
                except Exception:
                    pass
                try:
                    if isinstance(getattr(ch, "bikes", None), list) and ch.bikes:
                        ch.bikes[:] = [
                            v
                            for v in ch.bikes
                            if not (
                                int(tx0) <= int(math.floor(float(getattr(v, "pos", pygame.Vector2(0, 0)).x) / float(self.TILE_SIZE))) <= int(tx0 + bw - 1)
                                and int(ty0) <= int(math.floor(float(getattr(v, "pos", pygame.Vector2(0, 0)).y) / float(self.TILE_SIZE))) <= int(ty0 + bh - 1)
                            )
                        ]
                except Exception:
                    pass

                # Stamp walls/floors.
                for yy in range(int(ty0), int(ty0 + bh)):
                    for xx in range(int(tx0), int(tx0 + bw)):
                        border = (int(xx) == int(tx0) or int(xx) == int(tx0 + bw - 1) or int(yy) == int(ty0) or int(yy) == int(ty0 + bh - 1))
                        set_t(int(xx), int(yy), int(self.T_WALL) if border else int(self.T_FLOOR))

                # Door on the south wall (walk-in).
                set_t(int(door_tx), int(door_ty), int(self.T_DOOR))
                set_t(int(door_tx), int(door_ty - 1), int(self.T_FLOOR))
                # Small plaza/approach outside the door (avoid feeling like a residential entrance).
                for oy in range(1, 5):
                    out_ty = int(door_ty + oy)
                    if bool(self._tile_solid(int(self.world.get_tile(int(door_tx), int(out_ty))))):
                        break
                    for ox in range(-3, 4):
                        out_tx = int(door_tx + ox)
                        tid_out = int(self.world.get_tile(int(out_tx), int(out_ty)))
                        if int(tid_out) in (int(self.T_ROAD), int(self.T_HIGHWAY), int(self.T_WATER), int(self.T_WALL)):
                            continue
                        try:
                            set_world_tile(int(out_tx), int(out_ty), int(self.T_PAVEMENT if oy <= 2 else self.T_SIDEWALK))
                        except Exception:
                            pass

                # Office furniture layout (desks/chairs/shelves). Also sets workstation info.
                stamp_office_layout(btx0=int(tx0), bty0=int(ty0), bw=int(bw), bh=int(bh), door=(int(door_tx), int(door_ty)))

                # Keep the office entrance clear: no parked vehicles (and don't allow story NPCs
                # to spawn right on the doorstep).
                try:
                    clear_tiles: set[tuple[int, int]] = set()
                    for oy in range(-1, 7):
                        for ox in range(-3, 4):
                            clear_tiles.add((int(door_tx) + int(ox), int(door_ty) + int(oy)))
                    self.story_office_entrance_clear = set(clear_tiles)

                    # Remove parked vehicles whose anchor tile is in the clear zone.
                    by_chunk: dict[tuple[int, int], set[tuple[int, int]]] = {}
                    for txc, tyc in clear_tiles:
                        ccx = int(txc) // int(self.CHUNK_SIZE)
                        ccy = int(tyc) // int(self.CHUNK_SIZE)
                        by_chunk.setdefault((int(ccx), int(ccy)), set()).add((int(txc), int(tyc)))

                    ts = float(self.TILE_SIZE)

                    def anchor_tile(pos: object) -> tuple[int, int]:
                        try:
                            p = pygame.Vector2(pos)
                        except Exception:
                            p = pygame.Vector2(0, 0)
                        return int(math.floor(float(p.x) / ts)), int(math.floor(float(p.y) / ts))

                    for (ccx, ccy), tiles_set in by_chunk.items():
                        cch = self.world.get_chunk(int(ccx), int(ccy))
                        try:
                            if isinstance(getattr(cch, "cars", None), list) and cch.cars:
                                cch.cars[:] = [v for v in cch.cars if anchor_tile(getattr(v, "pos", pygame.Vector2(0, 0))) not in tiles_set]
                        except Exception:
                            pass
                        try:
                            if isinstance(getattr(cch, "bikes", None), list) and cch.bikes:
                                cch.bikes[:] = [v for v in cch.bikes if anchor_tile(getattr(v, "pos", pygame.Vector2(0, 0))) not in tiles_set]
                        except Exception:
                            pass

                    # Coworker anchor tile near the office (but not at the entrance).
                    try:
                        seed_tx = int(door_tx) + 6
                        seed_ty = int(door_ty) + 5
                        self.story_work_meet_tile = find_open_tile_near(int(seed_tx), int(seed_ty), max_r=18, avoid_tiles=clear_tiles)
                    except Exception:
                        self.story_work_meet_tile = None
                except Exception:
                    self.story_office_entrance_clear = set()
                    self.story_work_meet_tile = None

                # Add the building record so roof/cutaway works.
                try:
                    roof_var = int((int(tx0) * 31 + int(ty0) * 17 + int(getattr(self, "seed", 0))) & 0xFF)
                    roof_kind = (2 << 8) | int(roof_var)
                    if not isinstance(getattr(ch, "buildings", None), list):
                        ch.buildings = []
                    ch.buildings.append((int(tx0), int(ty0), int(bw), int(bh), int(roof_kind), 1))
                except Exception:
                    pass
            else:
                self.story_office_key = None
                self.story_workstation_tile = None
                self.story_office_player_pc_tiles = set()
                self.story_office_entrance_clear = set()
                self.story_work_meet_tile = None
        except Exception:
            self.story_office_key = None
            self.story_workstation_tile = None
            self.story_office_player_pc_tiles = set()
            self.story_office_entrance_clear = set()
            self.story_work_meet_tile = None

        try:
            gate_x0 = int(getattr(self.world, "compound_gate_x0", 0))
            gate_x1 = int(getattr(self.world, "compound_gate_x1", 0))
            gate_y = int(getattr(self.world, "compound_ty1", 0))
            self.story_gate_tile = (int((gate_x0 + gate_x1) // 2), int(gate_y))
        except Exception:
            self.story_gate_tile = (int(stx), int(sty))

        self._story_add_marker(int(self.story_gate_tile[0]), int(self.story_gate_tile[1]), "", color=(255, 220, 140))
        self._story_add_marker(int(self.story_work_tile[0]), int(self.story_work_tile[1]), "", color=(160, 220, 255))
        try:
            ws = getattr(self, "story_workstation_tile", None)
            if isinstance(ws, tuple) and len(ws) == 2:
                self._story_add_marker(int(ws[0]), int(ws[1]), "", color=(255, 245, 190))
        except Exception:
            pass
        self._story_add_marker(int(self.story_hardware_tile[0]), int(self.story_hardware_tile[1]), "", color=(200, 200, 210))
        self._story_add_marker(int(self.story_cafe_tile[0]), int(self.story_cafe_tile[1]), "", color=(240, 200, 140))
        self._story_add_marker(int(self.story_gym_tile[0]), int(self.story_gym_tile[1]), "", color=(210, 170, 255))

        # Place an office sign prop so "" is visually obvious in-world.
        try:
            wtx, wty = int(self.story_work_tile[0]), int(self.story_work_tile[1])
            wx = (float(wtx) + 0.5) * float(self.TILE_SIZE)
            wy = (float(wty) + 0.5) * float(self.TILE_SIZE)
            chunk = self.world.get_chunk(int(wtx) // int(self.CHUNK_SIZE), int(wty) // int(self.CHUNK_SIZE))
            if chunk is not None:
                props = getattr(chunk, "props", None)
                if not isinstance(props, list):
                    chunk.props = []
                    props = chunk.props
                props[:] = [
                    pr
                    for pr in props
                    if str(getattr(pr, "prop_id", "")) != "sign_office"
                    or (pygame.Vector2(getattr(pr, "pos", pygame.Vector2(0, 0))) - pygame.Vector2(wx, wy)).length_squared() > 9.0
                ]
                props.append(HardcoreSurvivalState._WorldProp(pos=pygame.Vector2(wx, wy), prop_id="sign_office", variant=0, dir="down"))
        except Exception:
            pass

        # Place a small gym sign prop so the POI is visually obvious in-world.
        try:
            gtx, gty = int(self.story_gym_tile[0]), int(self.story_gym_tile[1])
            gx = (float(gtx) + 0.5) * float(self.TILE_SIZE)
            gy = (float(gty) + 0.5) * float(self.TILE_SIZE)
            chunk = self.world.get_chunk(int(gtx) // int(self.CHUNK_SIZE), int(gty) // int(self.CHUNK_SIZE))
            if chunk is not None:
                props = getattr(chunk, "props", None)
                if not isinstance(props, list):
                    chunk.props = []
                    props = chunk.props
                # De-dupe nearby same prop_id.
                props[:] = [
                    pr
                    for pr in props
                    if str(getattr(pr, "prop_id", "")) != "sign_gym"
                    or (pygame.Vector2(getattr(pr, "pos", pygame.Vector2(0, 0))) - pygame.Vector2(gx, gy)).length_squared() > 9.0
                ]
                props.append(HardcoreSurvivalState._WorldProp(pos=pygame.Vector2(gx, gy), prop_id="sign_gym", variant=0, dir="down"))
        except Exception:
            pass

        # Story NPCs (lightweight pedestrians for the prelude).
        self.npcs: list[dict[str, object]] = []
        # Facility staff (shop/hospital clerks etc) spawned lazily per building/sign.
        self.story_staff_spawned: set[tuple[int, int, str]] = set()
        self.story_staff_scan_left = 0.0
        # Prelude ambient traffic (decorative): cars/bikes moving on roads.
        self.story_traffic_enabled = True
        self.story_traffic: list[dict[str, object]] = []
        self.story_traffic_max = 10
        self.story_traffic_rng = random.Random(int(self.seed) ^ 0x54B3_9C21)

        def npc_pos_from_tile(tx: int, ty: int) -> pygame.Vector2:
            return pygame.Vector2((float(tx) + 0.5) * float(self.TILE_SIZE), (float(ty) + 0.5) * float(self.TILE_SIZE))

        def make_avatar(*, gender: int, outfit: int) -> SurvivalAvatar:
            g = int(gender)
            av = SurvivalAvatar(
                gender=int(g),
                height=random.choice([0, 1, 1, 2]),
                face=random.randrange(0, 3),
                eyes=random.randrange(0, 4),
                hair=random.randrange(0, len(SURVIVAL_HAIR_OPTIONS)),
                nose=random.randrange(0, 3),
                skin=random.randrange(0, len(SURVIVAL_SKIN_OPTIONS)),
                hair_color=random.randrange(0, len(SURVIVAL_HAIR_COLOR_OPTIONS)),
                eye_color=random.randrange(0, len(SURVIVAL_EYE_COLOR_OPTIONS)),
                mouth=random.randrange(0, len(SURVIVAL_MOUTH_OPTIONS)),
                beard=(random.choice([0, 0, 1, 1, 2, 3]) if g == 0 else 0),
                makeup=(random.choice([0, 1, 2]) if g != 0 else 0),
                accessory=(random.choice([0, 0, 1, 2, 3]) if g != 0 else random.choice([0, 0, 1])),
                outfit=int(outfit),
            )
            av.clamp_all()
            return av

        def add_npc(
            npc_id: str,
            name: str,
            *,
            tile: tuple[int, int],
            home: tuple[int, int] | None = None,
            work: tuple[int, int] | None = None,
            gender: int = 0,
            outfit: int = 0,
            speed: float = 28.0,
            script: str = "",
        ) -> None:
            # Clamp to walkable tiles so NPCs don't spawn/anchor inside walls/furniture.
            avoid = getattr(self, "story_office_entrance_clear", None)
            avoid = avoid if isinstance(avoid, set) else None
            try:
                tile = find_open_tile_near(int(tile[0]), int(tile[1]), max_r=10, avoid_tiles=avoid)
            except Exception:
                pass
            if isinstance(home, tuple) and len(home) == 2:
                try:
                    home = find_open_tile_near(int(home[0]), int(home[1]), max_r=10, avoid_tiles=avoid)
                except Exception:
                    pass
            if isinstance(work, tuple) and len(work) == 2:
                try:
                    work = find_open_tile_near(int(work[0]), int(work[1]), max_r=10, avoid_tiles=avoid)
                except Exception:
                    pass

            av = make_avatar(gender=int(gender), outfit=int(outfit))
            frames = HardcoreSurvivalState.build_avatar_player_frames(av, run=False)
            tx, ty = int(tile[0]), int(tile[1])
            # Per-NPC rng (stable enough for wandering).
            seed = 0
            for ch in str(npc_id):
                seed = (seed * 131 + ord(ch)) & 0xFFFFFFFF
            rng = random.Random(int(seed) ^ int(self.seed) ^ 0x4C6E6B51)
            self.npcs.append(
                {
                    "id": str(npc_id),
                    "name": str(name),
                    "pos": npc_pos_from_tile(int(tx), int(ty)),
                    "dir": "down",
                    "walk_phase": float(random.random() * math.tau),
                    "vel": pygame.Vector2(0, 0),
                    "goal": npc_pos_from_tile(int(tx), int(ty)),
                    "goal_left": 0.0,
                    "axis": 0,
                    "stuck": 0.0,
                    "rng": rng,
                    "speed": float(speed),
                    "home": tuple(home) if isinstance(home, tuple) and len(home) == 2 else (int(tx), int(ty)),
                     "work": tuple(work) if isinstance(work, tuple) and len(work) == 2 else (int(tx), int(ty)),
                     "frames": frames,
                     "script": str(script),
                     "avatar": av,
                     "action": "",
                     "pose_phase": float(random.random() * math.tau),
                     "stay_left": 0.0,
                     "pose_cache": {},
                 }
             )
            try:
                self.npcs[-1]['spawn_fade_left'] = 0.24
                self.npcs[-1]['spawn_fade_total'] = 0.24
            except Exception:
                pass

        # Key NPCs around the core POIs.
        gate_tx, gate_ty = tuple(getattr(self, "story_gate_tile", (stx, sty)))
        work_tx, work_ty = tuple(getattr(self, "story_work_tile", (stx, sty)))
        cafe_tx, cafe_ty = tuple(getattr(self, "story_cafe_tile", (stx, sty)))
        gym_tx, gym_ty = tuple(getattr(self, "story_gym_tile", (stx, sty)))
        home_door = getattr(self, "home_highrise_door", None)
        home_tx, home_ty = (int(home_door[0]), int(home_door[1])) if isinstance(home_door, tuple) and len(home_door) == 2 else (int(stx), int(sty))

        add_npc("zhou_guard", "", tile=(int(gate_tx), int(gate_ty) - 1), home=(int(gate_tx), int(gate_ty) - 1), work=(int(gate_tx), int(gate_ty) - 1), gender=0, outfit=1, speed=0.0, script="npc_guard_zhou")
        meet = getattr(self, "story_work_meet_tile", None)
        if not (isinstance(meet, tuple) and len(meet) == 2):
            meet = (int(work_tx) + 6, int(work_ty) + 5)
        add_npc(
            "lin_coworker",
            "",
            tile=(int(meet[0]), int(meet[1])),
            home=(int(home_tx), int(home_ty) - 2),
            work=(int(meet[0]), int(meet[1])),
            gender=0,
            outfit=1,
            script="npc_coworker_lin",
        )
        add_npc("qiao_white", "", tile=(int(cafe_tx), int(cafe_ty)), home=(int(home_tx) + 2, int(home_ty) - 2), work=(int(cafe_tx), int(cafe_ty)), gender=1, outfit=0, script="npc_aqiao")
        add_npc("nana_influencer", "", tile=(int(cafe_tx) + 2, int(cafe_ty) + 1), home=(int(home_tx) - 2, int(home_ty) - 2), work=(int(cafe_tx) + 2, int(cafe_ty) + 1), gender=1, outfit=6, script="npc_nana")
        add_npc("green_tea", "", tile=(int(home_tx) - 1, int(home_ty) - 1), home=(int(home_tx) - 1, int(home_ty) - 1), work=(int(cafe_tx) - 2, int(cafe_ty) + 2), gender=1, outfit=6, script="npc_green_tea")
        add_npc("muscle_guy", "", tile=(int(gym_tx), int(gym_ty)), home=(int(home_tx) - 2, int(home_ty) - 1), work=(int(gym_tx), int(gym_ty)), gender=0, outfit=2, script="npc_muscle_guy")
        add_npc("street_thug", "", tile=(int(gate_tx) + 4, int(gate_ty) + 1), home=(int(gate_tx) + 4, int(gate_ty) + 1), work=(int(gate_tx) + 4, int(gate_ty) + 1), gender=0, outfit=6, speed=32.0, script="npc_hooligan")

        # Conversation scripts for story NPCs.
        self._CONV_SCRIPTS = {
            "npc_guard_zhou": {
                "start": {
                    "speaker": "",
                    "text": " {PLAYER_NAME}",
                    "options": [
                        {"label": "", "action": "hint:", "next": "news"},
                        {"label": "/", "action": "hint:", "next": "fortify"},
                        {"label": "", "action": "close"},
                    ],
                },
                "news": {
                    "speaker": "",
                    "text": "",
                    "options": [{"label": "", "action": "set_flag:ZHOU_WARNED", "next": "start"}],
                },
                "fortify": {
                    "speaker": "",
                    "text": "",
                    "options": [{"label": "", "action": "set_flag:KNOWS_FORTIFY", "action2": "", "next": "start"}],
                },
            },
            "npc_coworker_lin": {
                "start": {
                    "speaker": "",
                    "text": "{PLAYER_NAME}",
                    "options": [
                        {"label": "", "action": "set_flag:RUMOR_BITE", "next": "rumor"},
                        {"label": "", "action": "set_flag:WORK_CLOCKED", "next": "clocked"},
                        {"label": "", "action": "close"},
                    ],
                },
                "rumor": {
                    "speaker": "",
                    "text": "",
                    "options": [{"label": "", "action": "close"}],
                },
                "clocked": {
                    "speaker": "",
                    "text": "",
                    "options": [{"label": "", "action": "hint:", "action2": "", "stay": False}],
                },
            },
            "npc_aqiao": {
                "start": {
                    "speaker": "",
                    "text": "",
                    "options": [
                        {"label": "", "action": "hint:", "next": "warn"},
                        {"label": "", "action": "set_flag:AQIAO_BOND", "next": "task"},
                        {"label": "", "action": "close"},
                    ],
                },
                "warn": {
                    "speaker": "",
                    "text": "",
                    "options": [{"label": "", "action": "close"}],
                },
                "task": {
                    "speaker": "",
                    "text": "",
                    "options": [{"label": "", "action": "close"}],
                },
            },
            "npc_nana": {
                "start": {
                    "speaker": "",
                    "text": "",
                    "options": [
                        {"label": "", "action": "set_flag:NANA_WARNED", "next": "stop"},
                        {"label": "", "action": "hint:", "next": "rumor"},
                        {"label": "", "action": "close"},
                    ],
                },
                "stop": {"speaker": "", "text": "", "options": [{"label": "", "action": "close"}]},
                "rumor": {"speaker": "", "text": "", "options": [{"label": "", "action": "close"}]},
            },
            "npc_green_tea": {
                "start": {
                    "speaker": "",
                    "text": "{PLAYER_NAME}",
                    "options": [
                        {"label": "", "action": "set_flag:GREEN_TEA_KNOWS_NAME", "next": "name"},
                        {"label": "", "action": "hint:", "next": "start"},
                        {"label": "", "action": "close"},
                    ],
                },
                "name": {
                    "speaker": "",
                    "text": "",
                    "options": [{"label": "", "action": "close"}],
                },
            },
            "npc_muscle_guy": {
                "start": {
                    "speaker": "",
                    "text": "",
                    "options": [
                        {"label": "", "action": "close"},
                        {"label": "", "action": "hint:", "next": "start"},
                        {"label": "", "action": "start_fight:muscle_guy:8"},
                    ],
                }
            },
            "npc_hooligan": {
                "start": {
                    "speaker": "",
                    "text": "{PLAYER_NAME}",
                    "options": [
                        {"label": "", "action": "start_fight:street_thug:10"},
                        {"label": "", "action": "hint:", "next": "start"},
                        {"label": "", "action": "close"},
                    ],
                }
            },
        }

        # Bootstrap traffic so the town feels alive immediately.
        try:
            self._story_bootstrap_traffic()
        except Exception:
            pass

        # Prelude starts with no zombies; outbreak will enable them.
        self.zombie_cap = 0

        # One-time intro.
        try:
            if "PRELUDE_INTRO" not in self.story_events_done:
                self.story_events_done.add("PRELUDE_INTRO")
                self._dialog_start(
                    "",
                    [
                        f"{str(getattr(self, 'player_name', ''))}",
                        "",
                        " 3  NPC",
                        " NPC E  M ",
                    ],
                    speed=52.0,
                )
        except Exception:
            pass

    def _story_update_npcs(self, dt_time: float) -> None:
        if not bool(getattr(self, "story_enabled", False)):
            return
        if not bool(self._story_is_pre_apocalypse()):
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return

        npcs = getattr(self, "npcs", None)
        if not isinstance(npcs, list) or not npcs:
            return

        dt_time = float(max(0.0, dt_time))
        if dt_time <= 1e-6:
            return

        tday = float(self._time_of_day())
        at_work = 0.34 <= tday <= 0.72

        def tile_center(tx: int, ty: int) -> pygame.Vector2:
            return pygame.Vector2(
                (float(tx) + 0.5) * float(self.TILE_SIZE),
                (float(ty) + 0.5) * float(self.TILE_SIZE),
            )

        def is_road_tid(tid: int) -> bool:
            return int(tid) in (int(self.T_ROAD), int(self.T_HIGHWAY))

        def find_open_tile_near(
            tx: int,
            ty: int,
            *,
            max_r: int = 6,
            avoid_roads: bool = False,
            allow_inside: bool = False,
        ) -> tuple[int, int]:
            tx = int(tx)
            ty = int(ty)
            max_r = int(max(0, max_r))
            for r in range(0, max_r + 1):
                for dy in range(-r, r + 1):
                    for dx in range(-r, r + 1):
                        nx = int(tx + dx)
                        ny = int(ty + dy)
                        if not bool(allow_inside):
                            try:
                                if bool(self._story_npc_is_indoor_tile(int(nx), int(ny))):
                                    continue
                            except Exception:
                                pass
                        tid = int(self.world.peek_tile(int(nx), int(ny)))
                        if bool(avoid_roads) and bool(is_road_tid(int(tid))):
                            continue
                        if not bool(self._tile_solid(int(tid))):
                            return int(nx), int(ny)
            if bool(avoid_roads):
                return find_open_tile_near(int(tx), int(ty), max_r=int(max_r), avoid_roads=False, allow_inside=bool(allow_inside))
            return int(tx), int(ty)

        def is_open_outdoor_tile(tx: int, ty: int) -> bool:
            tx = int(tx)
            ty = int(ty)
            try:
                if bool(self._story_npc_is_indoor_tile(int(tx), int(ty))):
                    return False
            except Exception:
                pass
            try:
                tid = int(self.world.peek_tile(int(tx), int(ty)))
                if bool(self._tile_solid(int(tid))):
                    return False
            except Exception:
                pass
            return True

        road_x = getattr(self.world, "_is_road_x", None)
        road_y = getattr(self.world, "_is_road_y", None)

        def find_road_tile_near(tx: int, ty: int, *, axis: str | None = None, max_r: int = 18) -> tuple[int, int]:
            tx = int(tx)
            ty = int(ty)
            axis = None if axis is None else str(axis)
            max_r = int(max(0, max_r))
            for r in range(0, max_r + 1):
                for dy in range(-r, r + 1):
                    for dx in range(-r, r + 1):
                        nx = int(tx + dx)
                        ny = int(ty + dy)
                        if axis == "v" and callable(road_x):
                            try:
                                if not bool(road_x(int(nx))):
                                    continue
                            except Exception:
                                continue
                        elif axis == "h" and callable(road_y):
                            try:
                                if not bool(road_y(int(ny))):
                                    continue
                            except Exception:
                                continue
                        else:
                            try:
                                if not bool(self.world.is_road(int(nx), int(ny))):
                                    continue
                            except Exception:
                                continue
                        if is_open_outdoor_tile(int(nx), int(ny)):
                            return int(nx), int(ny)
            # Fallback: at least keep it walkable.
            return find_open_tile_near(int(tx), int(ty), max_r=8)

        def nudge_off_road_tile(tx: int, ty: int) -> tuple[int, int]:
            tx = int(tx)
            ty = int(ty)
            try:
                tid = int(self.world.peek_tile(int(tx), int(ty)))
            except Exception:
                return int(tx), int(ty)
            if not bool(is_road_tid(int(tid))):
                return int(tx), int(ty)

            on_x = False
            on_y = False
            try:
                on_x = bool(road_x(int(tx))) if callable(road_x) else False
            except Exception:
                on_x = False
            try:
                on_y = bool(road_y(int(ty))) if callable(road_y) else False
            except Exception:
                on_y = False

            # Prefer stepping onto sidewalk/pavement beside the road axis.
            if on_y and not on_x:
                candidates = [(tx, ty - 1), (tx, ty + 1)]
            elif on_x and not on_y:
                candidates = [(tx - 1, ty), (tx + 1, ty)]
            else:
                candidates = [(tx, ty - 1), (tx, ty + 1), (tx - 1, ty), (tx + 1, ty)]

            for nx, ny in candidates:
                nx = int(nx)
                ny = int(ny)
                try:
                    if bool(self._story_npc_is_indoor_tile(int(nx), int(ny))):
                        continue
                except Exception:
                    pass
                try:
                    tid2 = int(self.world.peek_tile(int(nx), int(ny)))
                    if bool(self._tile_solid(int(tid2))):
                        continue
                    if bool(is_road_tid(int(tid2))):
                        continue
                except Exception:
                    continue
                return int(nx), int(ny)

            return find_open_tile_near(int(tx), int(ty), max_r=3, avoid_roads=True)

        def plan_commute_points(
            start_tile: tuple[int, int],
            dest_tile: tuple[int, int],
            *,
            rng: random.Random,
        ) -> list[pygame.Vector2]:
            # Simple "town commute": walk to the nearest road, follow road grid, then walk off-road.
            sx, sy = int(start_tile[0]), int(start_tile[1])
            dx, dy = int(dest_tile[0]), int(dest_tile[1])
            if (sx, sy) == (dx, dy):
                return []

            # Two candidates: enter road via vertical then exit via horizontal, or the opposite.
            sv = find_road_tile_near(int(sx), int(sy), axis="v", max_r=20)
            sh = find_road_tile_near(int(sx), int(sy), axis="h", max_r=20)
            dv = find_road_tile_near(int(dx), int(dy), axis="v", max_r=20)
            dh = find_road_tile_near(int(dx), int(dy), axis="h", max_r=20)

            def build(points: list[tuple[int, int]]) -> list[pygame.Vector2]:
                out_tiles: list[tuple[int, int]] = []
                last = None
                for tx, ty in points:
                    tx, ty = int(tx), int(ty)
                    if not is_open_outdoor_tile(int(tx), int(ty)):
                        tx, ty = find_open_tile_near(int(tx), int(ty), max_r=8, avoid_roads=True)
                    tx, ty = nudge_off_road_tile(int(tx), int(ty))
                    cur = (int(tx), int(ty))
                    if last is None or cur != last:
                        out_tiles.append(cur)
                        last = cur
                # Drop the first point (current tile) so the NPC won't "stall" on it.
                out_tiles = out_tiles[1:] if len(out_tiles) > 1 else []
                return [tile_center(int(tx), int(ty)) for tx, ty in out_tiles]

            cand_a = [(sx, sy), sv, (int(sv[0]), int(dh[1])), dh, (dx, dy)]
            cand_b = [(sx, sy), sh, (int(dv[0]), int(sh[1])), dv, (dx, dy)]
            pa = build(cand_a)
            pb = build(cand_b)
            # Choose the shorter (slightly randomized so NPCs don't look cloned).
            if not pb:
                return pa
            if not pa:
                return pb
            la = abs(int(sv[0]) - int(dx)) + abs(int(dh[1]) - int(sy))
            lb = abs(int(sh[1]) - int(dy)) + abs(int(dv[0]) - int(sx))
            if la == lb and float(rng.random()) < 0.35:
                return pb
            return pa if la <= lb else pb

        npc_w, npc_h = self._story_npc_collider_wh()
        base_speed = 60.0
        npc_beh: dict[str, dict[str, object]] = {
            # Office staff (spawned dynamically via sign_office).
            "npc_staff_office_boss": {
                "work_action": "guard_scan",
                "home_action": "guard_scan",
                "pose_rate": 2.0,
                "stay_work": (999.0, 999.0),
                "stay_home": (999.0, 999.0),
                "stay_chance": 1.0,
                "wander_work": 0,
                "wander_home": 0,
                "face": "scan",
            },
            "npc_staff_office_secretary": {
                "work_action": "type",
                "home_action": "type",
                "pose_rate": 3.0,
                "stay_work": (999.0, 999.0),
                "stay_home": (999.0, 999.0),
                "stay_chance": 1.0,
                "wander_work": 0,
                "wander_home": 0,
                "face": "down",
            },
            "npc_staff_office_employee": {
                "work_action": "type",
                "home_action": "type",
                "pose_rate": 3.0,
                "stay_work": (999.0, 999.0),
                "stay_home": (999.0, 999.0),
                "stay_chance": 1.0,
                "wander_work": 0,
                "wander_home": 0,
                "face": "down",
            },
            # Each story NPC gets a tiny "slice of life" action so they don't all look identical.
            "npc_guard_zhou": {
                "work_action": "guard_scan",
                "home_action": "guard_scan",
                "pose_rate": 1.6,
                "stay_work": (999.0, 999.0),
                "stay_home": (999.0, 999.0),
                "stay_chance": 1.0,
                "wander_work": 0,
                "wander_home": 0,
                "face": "scan",
            },
            "npc_coworker_lin": {
                "work_action": "type",
                "home_action": "",
                "pose_rate": 3.2,
                "stay_work": (2.2, 4.8),
                "stay_home": (0.0, 0.0),
                "stay_chance": 0.75,
                "wander_work": 0,
                "wander_home": 3,
                "face": "down",
            },
            "npc_aqiao": {
                "work_action": "coffee",
                "home_action": "",
                "pose_rate": 2.0,
                "stay_work": (1.6, 3.6),
                "stay_home": (0.0, 0.0),
                "stay_chance": 0.55,
                "wander_work": 1,
                "wander_home": 3,
                "face": "player",
            },
            "npc_nana": {
                "work_action": "selfie",
                "home_action": "",
                "pose_rate": 2.6,
                "stay_work": (2.0, 4.2),
                "stay_home": (0.0, 0.0),
                "stay_chance": 0.7,
                "wander_work": 1,
                "wander_home": 3,
                "face": "right",
            },
            "npc_green_tea": {
                "work_action": "wave",
                "home_action": "wave",
                "pose_rate": 2.8,
                "stay_work": (1.4, 3.0),
                "stay_home": (1.4, 2.8),
                "stay_chance": 0.55,
                "wander_work": 1,
                "wander_home": 2,
                "face": "player",
            },
            "npc_muscle_guy": {
                "work_action": "flex",
                "home_action": "pushup",
                "pose_rate": 3.0,
                "stay_work": (1.6, 3.0),
                "stay_home": (2.8, 5.0),
                "stay_chance": 0.7,
                "wander_work": 1,
                "wander_home": 1,
                "face": "flex",
            },
            "npc_hooligan": {
                "work_action": "guard_scan",
                "home_action": "guard_scan",
                "pose_rate": 2.4,
                "stay_work": (1.0, 2.4),
                "stay_home": (1.0, 2.2),
                "stay_chance": 0.45,
                "wander_work": 2,
                "wander_home": 2,
                "face": "player",
            },
            # Facility staff (spawned dynamically via sign props).
            "npc_staff_shop_clerk": {
                "work_action": "type",
                "home_action": "type",
                "pose_rate": 3.0,
                "stay_work": (999.0, 999.0),
                "stay_home": (999.0, 999.0),
                "stay_chance": 1.0,
                "wander_work": 0,
                "wander_home": 0,
                "face": "down",
            },
            "npc_staff_shop_stocker": {
                "work_action": "guard_scan",
                "home_action": "guard_scan",
                "pose_rate": 2.2,
                "stay_work": (999.0, 999.0),
                "stay_home": (999.0, 999.0),
                "stay_chance": 1.0,
                "wander_work": 0,
                "wander_home": 0,
                "face": "right",
            },
            "npc_staff_bookstore_clerk": {
                "work_action": "type",
                "home_action": "type",
                "pose_rate": 3.0,
                "stay_work": (999.0, 999.0),
                "stay_home": (999.0, 999.0),
                "stay_chance": 1.0,
                "wander_work": 0,
                "wander_home": 0,
                "face": "down",
            },
            "npc_staff_gunshop_clerk": {
                "work_action": "guard_scan",
                "home_action": "guard_scan",
                "pose_rate": 2.2,
                "stay_work": (999.0, 999.0),
                "stay_home": (999.0, 999.0),
                "stay_chance": 1.0,
                "wander_work": 0,
                "wander_home": 0,
                "face": "scan",
            },
            "npc_staff_hospital_doctor": {
                "work_action": "type",
                "home_action": "type",
                "pose_rate": 3.2,
                "stay_work": (999.0, 999.0),
                "stay_home": (999.0, 999.0),
                "stay_chance": 1.0,
                "wander_work": 0,
                "wander_home": 0,
                "face": "down",
            },
            "npc_staff_hospital_nurse": {
                "work_action": "coffee",
                "home_action": "coffee",
                "pose_rate": 2.0,
                "stay_work": (999.0, 999.0),
                "stay_home": (999.0, 999.0),
                "stay_chance": 1.0,
                "wander_work": 0,
                "wander_home": 0,
                "face": "right",
            },
            "npc_staff_restaurant_waiter": {
                "work_action": "wave",
                "home_action": "wave",
                "pose_rate": 2.8,
                "stay_work": (999.0, 999.0),
                "stay_home": (999.0, 999.0),
                "stay_chance": 1.0,
                "wander_work": 0,
                "wander_home": 0,
                "face": "player",
            },
            "npc_staff_restaurant_chef": {
                "work_action": "type",
                "home_action": "type",
                "pose_rate": 3.0,
                "stay_work": (999.0, 999.0),
                "stay_home": (999.0, 999.0),
                "stay_chance": 1.0,
                "wander_work": 0,
                "wander_home": 0,
                "face": "down",
            },
        }

        for npc in npcs:
            if not isinstance(npc, dict):
                continue
            try:
                pos = pygame.Vector2(npc.get("pos", pygame.Vector2(0, 0)))
            except Exception:
                pos = pygame.Vector2(0, 0)

            npc_id = str(npc.get("id", "") or "")
            speed = float(npc.get("speed", 28.0))
            stuck_t = float(npc.get("stuck", 0.0))

            fade_left = 0.0
            try:
                fade_left = float(npc.get('spawn_fade_left', 0.0) or 0.0)
            except Exception:
                fade_left = 0.0
            if fade_left > 0.0:
                npc['spawn_fade_left'] = float(max(0.0, float(fade_left) - float(dt_time)))

            # Stable per-NPC RNG.
            rng = npc.get("rng", None)
            if not isinstance(rng, random.Random):
                rng = random.Random(int(self.seed) ^ 0x1234)
                npc["rng"] = rng

            script_id = str(npc.get("script", "") or "")
            allow_inside = str(script_id).startswith("npc_staff_")
            beh = npc_beh.get(str(script_id), {})
            work_action = str(beh.get("work_action", "") or "")
            home_action = str(beh.get("home_action", "") or "")
            action_target = work_action if bool(at_work) else home_action
            face_mode = str(beh.get("face", "player") or "player")
            pose_rate = float(beh.get("pose_rate", 2.2))
            stay_pair = beh.get("stay_work" if bool(at_work) else "stay_home", (0.0, 0.0))
            stay_min = 0.0
            stay_max = 0.0
            if isinstance(stay_pair, tuple) and len(stay_pair) == 2:
                try:
                    stay_min = float(stay_pair[0])
                    stay_max = float(stay_pair[1])
                except Exception:
                    stay_min = 0.0
                    stay_max = 0.0
            stay_chance = float(beh.get("stay_chance", 0.55))
            wander_base = int(beh.get("wander_work" if bool(at_work) else "wander_home", (2 if at_work else 3)))

            home = npc.get("home", (0, 0))
            work = npc.get("work", (0, 0))
            if not (isinstance(home, tuple) and len(home) == 2):
                home = (0, 0)
            if not (isinstance(work, tuple) and len(work) == 2):
                work = (0, 0)
            # Ensure anchors are on walkable tiles.
            if not bool(allow_inside):
                hx, hy = find_open_tile_near(int(home[0]), int(home[1]), max_r=8, avoid_roads=True)
                wx, wy = find_open_tile_near(int(work[0]), int(work[1]), max_r=8, avoid_roads=True)
            else:
                hx, hy = find_open_tile_near(int(home[0]), int(home[1]), max_r=8, avoid_roads=True, allow_inside=True)
                wx, wy = find_open_tile_near(int(work[0]), int(work[1]), max_r=8, avoid_roads=True, allow_inside=True)
            home = (int(hx), int(hy))
            work = (int(wx), int(wy))
            npc["home"] = home
            npc["work"] = work

            anchor_tile = work if bool(at_work) else home
            ax, ay = int(anchor_tile[0]), int(anchor_tile[1])
            anchor = tile_center(int(ax), int(ay))

            # Hostile mode (story fights): temporarily chase the player instead of commuting.
            try:
                hostile_left = float(npc.get("hostile_left", 0.0))
            except Exception:
                hostile_left = 0.0
            if hostile_left > 0.0:
                hostile_left = float(max(0.0, float(hostile_left) - float(dt_time)))
                npc["hostile_left"] = float(hostile_left)
            else:
                hostile_left = 0.0
                npc["hostile_left"] = 0.0
            hostile = float(hostile_left) > 0.0
            if hostile:
                # Cancel commute/wander actions while hostile.
                npc["path_pts"] = []
                npc["path_i"] = 0
                npc["stay_left"] = 0.0
                action_target = ""
                wander_base = 0
                speed = max(float(speed), 76.0)
                try:
                    ptx, pty = self._player_tile()
                except Exception:
                    ptx, pty = int(ax), int(ay)
                ax, ay = int(ptx), int(pty)
                anchor = pygame.Vector2(self.player.pos)

            # Commute path (home <-> work): only recompute when schedule flips.
            if not bool(hostile):
                dest_kind = "work" if bool(at_work) else "home"
                prev_kind = str(npc.get("schedule_dest", "") or "")
                if prev_kind != str(dest_kind):
                    npc["schedule_dest"] = str(dest_kind)
                    try:
                        ptx = int(math.floor(float(pos.x) / float(self.TILE_SIZE)))
                        pty = int(math.floor(float(pos.y) / float(self.TILE_SIZE)))
                    except Exception:
                        ptx, pty = int(ax), int(ay)
                    try:
                        npc["path_pts"] = plan_commute_points((int(ptx), int(pty)), (int(ax), int(ay)), rng=rng)
                        npc["path_i"] = 0
                    except Exception:
                        npc["path_pts"] = []
                        npc["path_i"] = 0
                    npc["goal_left"] = 0.0
                    npc["stay_left"] = 0.0
            else:
                npc["schedule_dest"] = "hostile"

            path_pts = npc.get("path_pts", None)
            try:
                path_i = int(npc.get("path_i", 0))
            except Exception:
                path_i = 0
            commuting = (not bool(hostile)) and isinstance(path_pts, list) and 0 <= int(path_i) < len(path_pts)
            if commuting:
                # No "posing" while commuting; just walk the route.
                action_target = ""

            def _face_to_player() -> str:
                try:
                    v = pygame.Vector2(self.player.pos) - pygame.Vector2(pos)
                except Exception:
                    v = pygame.Vector2(0, 1)
                if v.length_squared() <= 0.001:
                    return str(npc.get("dir", "down") or "down")
                ax2 = abs(float(v.x))
                ay2 = abs(float(v.y))
                if ay2 >= ax2:
                    return "down" if float(v.y) >= 0.0 else "up"
                return "right" if float(v.x) >= 0.0 else "left"

            def _apply_action_facing(action: str, *, phase: float) -> None:
                action = str(action)
                phase = float(phase)
                if action == "guard_scan":
                    cyc = int(phase * 0.7) % 4
                    npc["dir"] = ("left", "down", "right", "down")[int(cyc)]
                    return
                if action == "flex":
                    npc["dir"] = "right" if (int(phase * 0.8) % 2 == 0) else "left"
                    return
                if action in ("type", "pushup", "coffee"):
                    npc["dir"] = "down"
                    return
                if action == "selfie":
                    npc["dir"] = "right" if (int(phase * 0.7) % 2 == 0) else "down"
                    return
                if action == "wave":
                    npc["dir"] = _face_to_player()
                    return
                # Fallback: use the configured face mode.
                if str(face_mode) == "down":
                    npc["dir"] = "down"
                elif str(face_mode) == "right":
                    npc["dir"] = "right"
                elif str(face_mode) == "scan":
                    cyc = int(phase * 0.7) % 4
                    npc["dir"] = ("left", "down", "right", "down")[int(cyc)]
                else:
                    npc["dir"] = _face_to_player()

            # Stay/pose logic so story NPCs have distinct day-to-day actions.
            near_anchor = (not bool(commuting)) and float((pos - anchor).length_squared()) <= float((self.TILE_SIZE * 1.60) ** 2)
            stay_left = float(npc.get("stay_left", 0.0))
            if not bool(near_anchor):
                stay_left = 0.0
                npc["stay_left"] = 0.0

            # Stationary story NPCs (e.g. guard) still animate their actions.
            if float(speed) <= 0.1:
                # Safety: if ever displaced into a facade tile, snap back.
                if not bool(allow_inside):
                    try:
                        ntx = int(math.floor(float(pos.x) / float(self.TILE_SIZE)))
                        nty = int(math.floor(float(pos.y) / float(self.TILE_SIZE)))
                        if bool(self._story_npc_is_indoor_tile(int(ntx), int(nty))):
                            sx, sy = find_open_tile_near(int(ax), int(ay), max_r=18, avoid_roads=True)
                            pos = tile_center(int(sx), int(sy))
                            npc["pos"] = pygame.Vector2(pos)
                    except Exception:
                        pass

                npc["vel"] = pygame.Vector2(0, 0)
                npc["walk_phase"] = float(npc.get("walk_phase", 0.0)) * 0.92
                if action_target:
                    npc["action"] = str(action_target)
                    pp = float(npc.get("pose_phase", 0.0)) + float(dt_time) * float(pose_rate)
                    npc["pose_phase"] = float(pp)
                    _apply_action_facing(str(action_target), phase=float(pp))
                else:
                    npc["action"] = ""
                continue

            # If currently staying, keep the NPC still and play the action.
            if float(stay_left) > 0.0 and action_target:
                stay_left = float(max(0.0, float(stay_left) - float(dt_time)))
                npc["stay_left"] = float(stay_left)
                npc["vel"] = pygame.Vector2(0, 0)
                npc["walk_phase"] = float(npc.get("walk_phase", 0.0)) * 0.92
                npc["goal"] = pygame.Vector2(pos)
                npc["goal_left"] = 0.0
                npc["stuck"] = 0.0
                npc["action"] = str(action_target)
                pp = float(npc.get("pose_phase", 0.0)) + float(dt_time) * float(pose_rate)
                npc["pose_phase"] = float(pp)
                _apply_action_facing(str(action_target), phase=float(pp))
                if float(stay_left) > 0.0:
                    continue

            goal_left = float(npc.get("goal_left", 0.0))
            try:
                goal = pygame.Vector2(npc.get("goal", anchor))
            except Exception:
                goal = pygame.Vector2(anchor)

            # Follow commute waypoints if present.
            if commuting and isinstance(path_pts, list):
                try:
                    while int(path_i) < len(path_pts) and float((pygame.Vector2(path_pts[int(path_i)]) - pos).length_squared()) <= 4.0:
                        path_i = int(path_i) + 1
                    npc["path_i"] = int(path_i)
                    if int(path_i) >= len(path_pts):
                        npc["path_pts"] = []
                        commuting = False
                    else:
                        goal = pygame.Vector2(path_pts[int(path_i)])
                        goal_left = max(float(goal_left), 1.4)
                except Exception:
                    npc["path_pts"] = []
                    npc["path_i"] = 0
                    commuting = False

            # If the NPC ever gets displaced too far, snap its "intent" back.
            if (not bool(commuting)) and float((pos - anchor).length_squared()) > float((self.TILE_SIZE * 6) ** 2):
                goal_left = 0.0
                goal = pygame.Vector2(anchor)

            goal_left = max(0.0, float(goal_left) - float(dt_time))
            if float(stuck_t) > 0.60:
                goal_left = 0.0

            if goal_left <= 0.0 or float((goal - pos).length_squared()) <= 4.0:
                if bool(commuting):
                    # Keep walking along the route; avoid falling into "wander" selection.
                    goal_left = float(max(float(goal_left), 1.0))
                else:
                    # If we're near the anchor, sometimes pause and do an "action" instead
                    # of immediately picking a new wander target.
                    if action_target and bool(near_anchor) and float(stay_max) > 0.01:
                        on_road = False
                        try:
                            ntx = int(math.floor(float(pos.x) / float(self.TILE_SIZE)))
                            nty = int(math.floor(float(pos.y) / float(self.TILE_SIZE)))
                            on_road = bool(is_road_tid(int(self.world.peek_tile(int(ntx), int(nty)))))
                        except Exception:
                            on_road = False
                        if (not bool(on_road)) and float(rng.random()) < float(stay_chance):
                            hold = float(rng.uniform(float(stay_min), float(stay_max)))
                            npc["stay_left"] = float(hold)
                            npc["vel"] = pygame.Vector2(0, 0)
                            npc["goal"] = pygame.Vector2(pos)
                            npc["goal_left"] = 0.0
                            npc["stuck"] = 0.0
                            npc["action"] = str(action_target)
                            pp = float(npc.get("pose_phase", 0.0)) + float(dt_time) * float(pose_rate)
                            npc["pose_phase"] = float(pp)
                            _apply_action_facing(str(action_target), phase=float(pp))
                            continue

                    radius = int(wander_base) + (1 if float(stuck_t) > 0.60 else 0)
                    radius = int(clamp(int(radius), 0, 5))

                    # Pick a reachable walkable tile near the anchor so NPCs don't
                    # keep pushing into walls/corners.
                    try:
                        ptx = int(math.floor(float(pos.x) / float(self.TILE_SIZE)))
                        pty = int(math.floor(float(pos.y) / float(self.TILE_SIZE)))
                    except Exception:
                        ptx, pty = int(ax), int(ay)

                    seen: set[tuple[int, int]] = set()
                    stack: list[tuple[int, int]] = [(int(ax), int(ay))]
                    cands: list[tuple[int, int]] = []
                    limit = 120
                    while stack and len(seen) < limit:
                        tx, ty = stack.pop()
                        tx = int(tx)
                        ty = int(ty)
                        if (tx, ty) in seen:
                            continue
                        if abs(int(tx) - int(ax)) > int(radius) or abs(int(ty) - int(ay)) > int(radius):
                            continue
                        if not bool(allow_inside):
                            try:
                                if bool(self._story_npc_is_indoor_tile(int(tx), int(ty))):
                                    continue
                            except Exception:
                                pass
                        tid = int(self.world.peek_tile(int(tx), int(ty)))
                        if bool(self._tile_solid(int(tid))):
                            continue
                        seen.add((tx, ty))
                        # Don't let NPCs choose road/highway tiles as "idle" goals.
                        if not bool(is_road_tid(int(tid))):
                            cands.append((tx, ty))
                        stack.extend([(tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)])

                    best_tile = (int(ax), int(ay))
                    if cands:
                        rng.shuffle(cands)
                        for tx, ty in cands:
                            if (int(tx), int(ty)) == (int(ptx), int(pty)):
                                continue
                            best_tile = (int(tx), int(ty))
                            break

                    goal = tile_center(int(best_tile[0]), int(best_tile[1]))
                    goal_left = float(rng.uniform(0.9, 2.2))

            d = pygame.Vector2(goal) - pygame.Vector2(pos)
            vel = pygame.Vector2(0, 0)
            if d.length_squared() > 1.0:
                try:
                    # Match player: speed is affected by terrain + weather.
                    try:
                        tx_u = int(math.floor(float(pos.x) / float(self.TILE_SIZE)))
                        ty_u = int(math.floor(float(pos.y) / float(self.TILE_SIZE)))
                        tile_under = self.world.get_tile(int(tx_u), int(ty_u))
                        sp = float(speed) * float(self._tile_slow(tile_under)) * float(self._weather_move_mult())
                    except Exception:
                        sp = float(speed)
                    vel = d.normalize() * float(sp)
                except Exception:
                    vel = pygame.Vector2(0, 0)

            prev_pos = pygame.Vector2(pos)
            new_pos = self._move_box(
                pygame.Vector2(pos),
                pygame.Vector2(vel),
                float(dt_time),
                w=int(npc_w),
                h=int(npc_h),
                collide_fn=self._collide_rect_world_story_npc,
            )

            # Anti-jitter like the player: don't let collision resolution move the NPC
            # opposite to its intended axis direction (prevents "stuck shaking").
            try:
                prev_rect = pygame.Rect(
                    iround(float(prev_pos.x) - float(npc_w) / 2.0),
                    iround(float(prev_pos.y) - float(npc_h) / 2.0),
                    int(npc_w),
                    int(npc_h),
                )
                if not self._collide_rect_world_story_npc(prev_rect):
                    dx = float(new_pos.x) - float(prev_pos.x)
                    dy = float(new_pos.y) - float(prev_pos.y)
                    vx = float(getattr(vel, "x", 0.0))
                    vy = float(getattr(vel, "y", 0.0))
                    if vx > 1e-6 and dx < -1e-6:
                        new_pos.x = float(prev_pos.x)
                    elif vx < -1e-6 and dx > 1e-6:
                        new_pos.x = float(prev_pos.x)
                    if vy > 1e-6 and dy < -1e-6:
                        new_pos.y = float(prev_pos.y)
                    elif vy < -1e-6 and dy > 1e-6:
                        new_pos.y = float(prev_pos.y)
            except Exception:
                pass

            moved = pygame.Vector2(new_pos) - pygame.Vector2(prev_pos)
            npc_vel = moved / float(dt_time) if dt_time > 0.0 else pygame.Vector2(0, 0)

            # Safety: pedestrians shouldn't end up inside building footprints (facades).
            # Staff NPCs (clerks/doctors/office) are intentionally placed indoors.
            try:
                if not bool(allow_inside):
                    ntx = int(math.floor(float(new_pos.x) / float(self.TILE_SIZE)))
                    nty = int(math.floor(float(new_pos.y) / float(self.TILE_SIZE)))
                    if bool(self._story_npc_is_indoor_tile(int(ntx), int(nty))):
                        sx, sy = find_open_tile_near(int(ax), int(ay), max_r=18, avoid_roads=True)
                        new_pos = tile_center(int(sx), int(sy))
                        moved = pygame.Vector2(0, 0)
                        npc_vel = pygame.Vector2(0, 0)
                        goal = pygame.Vector2(new_pos)
                        goal_left = 0.0
                        stuck_t = 0.0
            except Exception:
                pass

            # Stuck detection: if we're trying to move but can't, re-roll goals faster.
            want_move = float(d.length_squared()) > float((self.TILE_SIZE * 0.65) ** 2)
            barely = float(moved.length_squared()) < 0.20
            if bool(want_move and barely):
                stuck_t = float(stuck_t) + float(dt_time)
            else:
                stuck_t = max(0.0, float(stuck_t) - float(dt_time) * 1.8)
            # Don't let NPCs remain stuck on road tiles (looks like "standing in traffic").
            if float(stuck_t) > 0.45:
                try:
                    ntx = int(math.floor(float(new_pos.x) / float(self.TILE_SIZE)))
                    nty = int(math.floor(float(new_pos.y) / float(self.TILE_SIZE)))
                    tid = int(self.world.peek_tile(int(ntx), int(nty)))
                    if bool(is_road_tid(int(tid))):
                        sx, sy = find_open_tile_near(int(ntx), int(nty), max_r=10, avoid_roads=True)
                        new_pos = tile_center(int(sx), int(sy))
                        moved = pygame.Vector2(0, 0)
                        npc_vel = pygame.Vector2(0, 0)
                        goal = pygame.Vector2(new_pos)
                        goal_left = 0.0
                        stuck_t = 0.0
                except Exception:
                    pass
            if float(stuck_t) > 2.40:
                # Hard recovery: if an NPC gets wedged, snap it back to its anchor area.
                sx, sy = find_open_tile_near(int(ax), int(ay), max_r=18, avoid_roads=True)
                new_pos = tile_center(int(sx), int(sy))
                moved = pygame.Vector2(0, 0)
                npc_vel = pygame.Vector2(0, 0)
                goal = pygame.Vector2(new_pos)
                goal_left = 0.0
                stuck_t = 0.0
            if float(stuck_t) > 1.20:
                goal_left = 0.0

            npc["pos"] = pygame.Vector2(new_pos)
            # Match the player: animate using intended velocity, not just the post-collision delta.
            npc["vel"] = pygame.Vector2(vel)
            npc["goal"] = pygame.Vector2(goal)
            npc["goal_left"] = float(goal_left)
            npc["stuck"] = float(stuck_t)

            # Story fight: hostile NPCs can punch the player (pre-apocalypse brawls).
            if bool(hostile) and getattr(self, "mount", None) is None:
                # Visible attack pose () for the street thug.
                try:
                    atk_anim = float(npc.get("attack_anim_left", 0.0))
                except Exception:
                    atk_anim = 0.0
                atk_anim = float(max(0.0, float(atk_anim) - float(dt_time)))
                npc["attack_anim_left"] = float(atk_anim)
                if npc_id == "street_thug":
                    npc["action"] = "bruce_punch" if float(atk_anim) > 0.0 else "bruce_guard"
                    npc["pose_phase"] = float(npc.get("pose_phase", 0.0)) + float(dt_time) * (7.5 if float(atk_anim) > 0.0 else 4.0)
                elif npc_id == "muscle_guy":
                    npc["action"] = "muscle_punch" if float(atk_anim) > 0.0 else "muscle_guard"
                    npc["pose_phase"] = float(npc.get("pose_phase", 0.0)) + float(dt_time) * (6.5 if float(atk_anim) > 0.0 else 3.6)
                else:
                    role = str(npc.get("role", "") or "")
                    if role in ("police", "swat"):
                        npc["action"] = "bruce_punch" if float(atk_anim) > 0.0 else "bruce_guard"
                        rate = 8.2 if role == "swat" else 7.6
                        npc["pose_phase"] = float(npc.get("pose_phase", 0.0)) + float(dt_time) * (rate if float(atk_anim) > 0.0 else 4.2)

                try:
                    atk_left = float(npc.get("attack_left", 0.0))
                except Exception:
                    atk_left = 0.0
                atk_left = float(max(0.0, float(atk_left) - float(dt_time)))
                npc["attack_left"] = float(atk_left)
                if float(atk_left) <= 0.0:
                    try:
                        to_p = pygame.Vector2(self.player.pos) - pygame.Vector2(new_pos)
                        d2p = float(to_p.length_squared())
                    except Exception:
                        to_p = pygame.Vector2(0, 0)
                        d2p = 1e18
                    dmg = 8
                    cd = 0.85
                    atk_range = 11.0
                    if npc_id == "muscle_guy":
                        dmg = 14
                        cd = 1.05
                        atk_range = 12.5
                    elif npc_id == "street_thug":
                        dmg = 9
                        cd = 0.78
                        atk_range = 13.0
                    else:
                        role = str(npc.get("role", "") or "")
                        if role == "police":
                            dmg = 10
                            cd = 0.70
                            atk_range = 13.2
                        elif role == "swat":
                            dmg = 16
                            cd = 0.62
                            atk_range = 13.6
                    if d2p <= float(atk_range) * float(atk_range):
                        npc["attack_left"] = float(cd)
                        if npc_id == "street_thug":
                            npc["attack_anim_left"] = float(max(float(npc.get("attack_anim_left", 0.0) or 0.0), 0.40))
                            npc["action"] = "bruce_punch"
                        elif npc_id == "muscle_guy":
                            npc["attack_anim_left"] = float(max(float(npc.get("attack_anim_left", 0.0) or 0.0), 0.45))
                            npc["action"] = "muscle_punch"
                        else:
                            role = str(npc.get("role", "") or "")
                            if role in ("police", "swat"):
                                npc["attack_anim_left"] = float(max(float(npc.get("attack_anim_left", 0.0) or 0.0), 0.40))
                                npc["action"] = "bruce_punch"
                        try:
                            self.player.hp = max(0, int(self.player.hp) - int(dmg))
                        except Exception:
                            pass
                        try:
                            self.player.morale = float(clamp(self.player.morale - (1.6 + float(dmg) * 0.22), 0.0, 100.0))
                        except Exception:
                            pass
                        try:
                            if to_p.length_squared() > 0.01:
                                self._spawn_hit_fx(pygame.Vector2(self.player.pos), dir=to_p.normalize())
                        except Exception:
                            pass

            moving = pygame.Vector2(vel).length_squared() > 1.0
            if moving:
                npc["walk_phase"] = float(npc.get("walk_phase", 0.0)) + float(dt_time) * 10.0 * (float(pygame.Vector2(vel).length()) / float(base_speed))
                axis = int(npc.get("axis", 0))
                vx = float(getattr(vel, "x", 0.0))
                vy = float(getattr(vel, "y", 0.0))
                ratio = abs(vy) / max(1e-6, abs(vx))
                if axis == 0:
                    if ratio > 1.18:
                        axis = 1
                else:
                    if ratio < 0.85:
                        axis = 0
                npc["axis"] = int(axis)
                if axis == 1:
                    npc["dir"] = "down" if vy >= 0.0 else "up"
                else:
                    npc["dir"] = "right" if vx >= 0.0 else "left"
                if bool(hostile) and (
                    npc_id in ("street_thug", "muscle_guy") or str(npc.get("role", "") or "") in ("police", "swat")
                ):
                    npc["dir"] = _face_to_player()
            else:
                npc["walk_phase"] = float(npc.get("walk_phase", 0.0)) * 0.92

            # If idle near the anchor, show the NPC's current story action.
            if bool(hostile):
                # Hostile pose is managed by the fight system; don't overwrite here.
                pass
            elif moving or not action_target:
                npc["action"] = ""
            else:
                try:
                    pos2 = pygame.Vector2(npc.get("pos", pos))
                    near2 = float((pos2 - anchor).length_squared()) <= float((self.TILE_SIZE * 1.60) ** 2)
                except Exception:
                    near2 = False
                if near2:
                    npc["action"] = str(action_target)
                    pp = float(npc.get("pose_phase", 0.0)) + float(dt_time) * float(pose_rate)
                    npc["pose_phase"] = float(pp)
                    _apply_action_facing(str(action_target), phase=float(pp))
                else:
                    npc["action"] = ""

        # Post-pass: prevent story NPCs from overlapping each other (soft collision volume).
        try:
            colliders: list[tuple[dict[str, object], pygame.Rect]] = []
            for npc in npcs:
                if not isinstance(npc, dict):
                    continue
                try:
                    pos = pygame.Vector2(npc.get("pos", pygame.Vector2(0, 0)))
                except Exception:
                    continue
                rect = pygame.Rect(
                    iround(float(pos.x) - float(npc_w) / 2.0),
                    iround(float(pos.y) - float(npc_h) / 2.0),
                    int(npc_w),
                    int(npc_h),
                )
                colliders.append((npc, rect))

            resolved: list[tuple[dict[str, object], pygame.Rect]] = []
            for npc, rect in colliders:
                rect = pygame.Rect(rect)
                for _ in range(6):
                    pushed = False
                    for _onpc, orect in resolved:
                        if not rect.colliderect(orect):
                            continue
                        dx = float(rect.centerx - orect.centerx)
                        dy = float(rect.centery - orect.centery)
                        overlap_x = (float(rect.w) + float(orect.w)) / 2.0 - abs(dx)
                        overlap_y = (float(rect.h) + float(orect.h)) / 2.0 - abs(dy)
                        if overlap_x <= 0.0 or overlap_y <= 0.0:
                            continue
                        sign_x = 1.0 if dx >= 0.0 else -1.0
                        sign_y = 1.0 if dy >= 0.0 else -1.0
                        if dx == 0.0:
                            sign_x = 1.0 if ((int(rect.centerx) + int(rect.centery)) & 1) else -1.0
                        if dy == 0.0:
                            sign_y = 1.0 if ((int(rect.centerx) - int(rect.centery)) & 1) else -1.0
                        move_x = int(sign_x * math.ceil(overlap_x))
                        move_y = int(sign_y * math.ceil(overlap_y))
                        if float(overlap_x) <= float(overlap_y):
                            candidates = [(int(move_x), 0), (0, int(move_y))]
                        else:
                            candidates = [(0, int(move_y)), (int(move_x), 0)]
                        moved = False
                        for mx, my in candidates:
                            if mx == 0 and my == 0:
                                continue
                            test = rect.move(int(mx), int(my))
                            if not self._collide_rect_world_story_npc(test):
                                rect = test
                                moved = True
                                pushed = True
                                break
                        if not moved and candidates:
                            rect = rect.move(int(candidates[0][0]), int(candidates[0][1]))
                            pushed = True
                    if not pushed:
                        break

                npc["pos"] = pygame.Vector2(float(rect.centerx), float(rect.centery))
                resolved.append((npc, rect))
        except Exception:
            pass

    def _story_bootstrap_traffic(self) -> None:
        if not bool(getattr(self, "story_enabled", False)):
            return
        if not bool(self._story_is_pre_apocalypse()):
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return
        if not bool(getattr(self, "story_traffic_enabled", True)):
            return
        traffic = getattr(self, "story_traffic", None)
        if not isinstance(traffic, list):
            self.story_traffic = []
            traffic = self.story_traffic
        rng = getattr(self, "story_traffic_rng", None)
        if not isinstance(rng, random.Random):
            rng = random.Random(int(getattr(self, "seed", 0)) ^ 0x54B3_9C21)
            self.story_traffic_rng = rng
        target = int(max(0, int(getattr(self, "story_traffic_max", 10))))
        # Spawn slightly fewer initially; updates will top up based on time-of-day.
        want = int(clamp(int(target), 0, 10))
        if len(traffic) >= want:
            return
        center = getattr(self, "story_origin_tile", None)
        if not (isinstance(center, tuple) and len(center) == 2):
            center = self._player_tile()
        for _ in range(int(want) - int(len(traffic))):
            actor = self._story_spawn_one_traffic(rng=rng, center_tile=(int(center[0]), int(center[1])), radius=42)
            if actor is not None:
                traffic.append(actor)

    def _story_traffic_rect_for_actor(self, actor: dict[str, object]) -> pygame.Rect | None:
        if not isinstance(actor, dict):
            return None
        try:
            pos = pygame.Vector2(actor.get("pos", pygame.Vector2(0, 0)))
        except Exception:
            return None
        kind = str(actor.get("kind", "car") or "car")

        if kind == "car":
            mid = str(actor.get("model_id", "beetle") or "beetle")
            model = self._CAR_MODELS.get(mid) or self._CAR_MODELS.get("rv")
            if model is None:
                return None
            cw, ch = int(model.collider[0]), int(model.collider[1])
            if cw <= 0 or ch <= 0:
                return None
            heading = float(actor.get("heading", 0.0))
            c = abs(math.cos(float(heading)))
            s = abs(math.sin(float(heading)))
            ww = float(cw) * c + float(ch) * s
            hh = float(cw) * s + float(ch) * c
            w = int(max(2, int(round(float(ww)))))
            h = int(max(2, int(round(float(hh)))))
            return pygame.Rect(
                iround(float(pos.x) - float(w) / 2.0),
                iround(float(pos.y) - float(h) / 2.0),
                int(w),
                int(h),
            )

        # Two-wheel (bike/moto).
        mid = str(actor.get("model_id", "bike") or "bike")
        d = str(actor.get("dir", "right") or "right")
        try:
            bw, bh = self._two_wheel_collider_px(mid)
        except Exception:
            bw, bh = (16, 10)
        if d in ("up", "down"):
            bw, bh = int(bh), int(bw)
        bw = max(2, int(bw))
        bh = max(2, int(bh))
        return pygame.Rect(
            iround(float(pos.x) - float(bw) / 2.0),
            iround(float(pos.y) - float(bh) / 2.0),
            int(bw),
            int(bh),
        )

    def _story_spawn_one_traffic(
        self,
        *,
        rng: random.Random,
        center_tile: tuple[int, int],
        radius: int,
        offscreen_only: bool = True,
    ) -> dict[str, object] | None:
        if not isinstance(rng, random.Random):
            rng = random.Random(int(getattr(self, "seed", 0)) ^ 0x54B3_9C21)
        radius = int(max(6, int(radius)))
        ts = float(self.TILE_SIZE)
        cx, cy = int(center_tile[0]), int(center_tile[1])
        center_world = pygame.Vector2((float(cx) + 0.5) * ts, (float(cy) + 0.5) * ts)
        view_r = float(math.hypot(float(INTERNAL_W) * 0.5, float(INTERNAL_H) * 0.5))
        spawn_min_dist = 0.0
        if bool(offscreen_only):
            max_possible = float(max(ts * 2.0, float(radius) * ts * 0.9))
            spawn_min_dist = float(min(float(view_r + ts * 3.0), float(max_possible)))
        spawn_min_dist2 = float(spawn_min_dist * spawn_min_dist)

        try:
            car_pool = [mid for mid in self._CAR_MODELS.keys() if str(mid) not in ("rv", "police")]
        except Exception:
            car_pool = ["beetle"]
        if not car_pool:
            car_pool = ["beetle"]
        bike_pool = ["bike", "bike_lady", "bike_mountain", "bike_auto"]
        moto_pool = ["moto", "moto_lux", "moto_long"]

        def road_axis_options(tx: int, ty: int) -> list[str]:
            # "h" => along X (left/right) for road_y; "v" => along Y (up/down) for road_x.
            ox = False
            oy = False
            try:
                ox = bool(getattr(self.world, "_is_road_x")(int(tx)))
            except Exception:
                ox = False
            try:
                oy = bool(getattr(self.world, "_is_road_y")(int(ty)))
            except Exception:
                oy = False
            axes: list[str] = []
            if oy:
                axes.append("h")
            if ox:
                axes.append("v")
            if not axes and bool(getattr(self.world, "is_road")(int(tx), int(ty))):
                axes = ["h", "v"]
            return axes

        traffic = getattr(self, "story_traffic", None)
        if not isinstance(traffic, list):
            traffic = []

        for _ in range(110):
            tx = int(cx + rng.randint(-radius, radius))
            ty = int(cy + rng.randint(-radius, radius))
            try:
                if not bool(self.world.is_road(int(tx), int(ty))):
                    continue
            except Exception:
                continue
            try:
                if self._peek_building_at_tile(int(tx), int(ty)) is not None:
                    continue
            except Exception:
                pass
            try:
                tid = int(self.world.peek_tile(int(tx), int(ty)))
                if bool(self._tile_solid(int(tid))):
                    continue
            except Exception:
                pass

            axes = road_axis_options(int(tx), int(ty))
            if not axes:
                continue
            axis = str(rng.choice(axes))
            if axis == "h":
                d = str(rng.choice(["left", "right"]))
                lane_axis = 0
                lane_line = int(ty)
            else:
                d = str(rng.choice(["up", "down"]))
                lane_axis = 1
                lane_line = int(tx)

            lane_offset = int(rng.choice([-2, -1, 1, 2]))
            px = (float(tx) + 0.5) * ts
            py = (float(ty) + 0.5) * ts
            if lane_axis == 0:
                py += float(lane_offset)
            else:
                px += float(lane_offset)
            pos = pygame.Vector2(float(px), float(py))

            if float(spawn_min_dist2) > 0.0 and float((pos - center_world).length_squared()) < float(spawn_min_dist2):
                continue

            too_close = False
            for a in traffic:
                if not isinstance(a, dict):
                    continue
                try:
                    ap = pygame.Vector2(a.get("pos", pygame.Vector2(0, 0)))
                    if float((ap - pos).length_squared()) < float((ts * 5.0) ** 2):
                        too_close = True
                        break
                except Exception:
                    continue
            if too_close:
                continue

            roll = float(rng.random())
            kind = "car"
            model_id = str(rng.choice(car_pool))
            if roll < 0.28:
                kind = "bike"
                model_id = str(rng.choice(bike_pool))
            elif roll < 0.42:
                kind = "moto"
                model_id = str(rng.choice(moto_pool))

            actor: dict[str, object] = {
                "kind": str(kind),
                "model_id": str(model_id),
                "pos": pygame.Vector2(pos),
                "dir": str(d),
                "lane_axis": int(lane_axis),
                "lane_line": int(lane_line),
                "lane_offset": int(lane_offset),
                "speed": float(rng.uniform(56.0, 86.0) if kind == "car" else rng.uniform(46.0, 70.0)),
                "anim": float(rng.random() * 10.0),
                "turn_cd": float(rng.uniform(0.0, 1.2)),
                "rng": random.Random(int(rng.randrange(0, 2**31 - 1)) ^ 0x1A2B_3C4D),
            }
            actor['spawn_fade_left'] = 0.24
            actor['spawn_fade_total'] = 0.24

            if kind == "car":
                # Heading in radians; 0 means "right". We rotate by -deg in draw.
                heading = 0.0
                if d == "left":
                    heading = math.pi
                elif d == "down":
                    heading = math.pi / 2.0
                elif d == "up":
                    heading = -math.pi / 2.0
                actor["heading"] = float(heading)
                actor["steer_state"] = 0
                actor["frame"] = int(rng.randrange(0, 2))
                # One "convertible + " in the flow.
                if float(rng.random()) < 0.12:
                    av = SurvivalAvatar(
                        gender=0,
                        height=1,
                        face=int(rng.randrange(0, len(SURVIVAL_FACE_OPTIONS))),
                        eyes=int(rng.randrange(0, len(SURVIVAL_EYE_OPTIONS))),
                        hair=int(rng.randrange(0, len(SURVIVAL_HAIR_OPTIONS))),
                        nose=int(rng.randrange(0, len(SURVIVAL_NOSE_OPTIONS))),
                        skin=int(rng.randrange(0, len(SURVIVAL_SKIN_OPTIONS))),
                        hair_color=int(rng.randrange(0, len(SURVIVAL_HAIR_COLOR_OPTIONS))),
                        eye_color=int(rng.randrange(0, len(SURVIVAL_EYE_COLOR_OPTIONS))),
                        mouth=int(rng.randrange(0, len(SURVIVAL_MOUTH_OPTIONS))),
                        beard=int(rng.choice([0, 0, 1, 2])),
                        makeup=0,
                        accessory=1,  # glasses
                        outfit=11,  # 
                    )
                    av.clamp_all()
                    actor["driver_style"] = "brag"
                    actor["driver_avatar"] = av

            if kind in ("bike", "moto"):
                try:
                    g = int(rng.randrange(0, len(SURVIVAL_GENDER_OPTIONS)))
                except Exception:
                    g = 0
                av = SurvivalAvatar(
                    gender=int(g),
                    height=int(rng.randrange(0, len(SURVIVAL_HEIGHT_OPTIONS))),
                    face=int(rng.randrange(0, len(SURVIVAL_FACE_OPTIONS))),
                    eyes=int(rng.randrange(0, len(SURVIVAL_EYE_OPTIONS))),
                    hair=int(rng.randrange(0, len(SURVIVAL_HAIR_OPTIONS))),
                    nose=int(rng.randrange(0, len(SURVIVAL_NOSE_OPTIONS))),
                    skin=int(rng.randrange(0, len(SURVIVAL_SKIN_OPTIONS))),
                    hair_color=int(rng.randrange(0, len(SURVIVAL_HAIR_COLOR_OPTIONS))),
                    eye_color=int(rng.randrange(0, len(SURVIVAL_EYE_COLOR_OPTIONS))),
                    mouth=int(rng.randrange(0, len(SURVIVAL_MOUTH_OPTIONS))),
                    beard=(int(rng.choice([0, 0, 1, 1, 2, 3])) if int(g) == 0 else 0),
                    makeup=(int(rng.choice([0, 1, 2])) if int(g) != 0 else 0),
                    accessory=(int(rng.choice([0, 0, 1, 2, 3])) if int(g) != 0 else int(rng.choice([0, 0, 1]))),
                    outfit=int(rng.randrange(0, len(SURVIVAL_OUTFIT_OPTIONS))),
                )
                av.clamp_all()
                actor["rider_avatar"] = av
                actor["rider_frames"] = HardcoreSurvivalState.build_avatar_cyclist_frames(av)
                actor["frame"] = int(rng.randrange(0, 2))

            return actor
        return None

    def _story_update_traffic(self, dt_time: float) -> None:
        if not bool(getattr(self, "story_enabled", False)):
            return
        if not bool(self._story_is_pre_apocalypse()):
            return
        if not bool(getattr(self, "story_traffic_enabled", True)):
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return
        traffic = getattr(self, "story_traffic", None)
        if not isinstance(traffic, list):
            self.story_traffic = []
            traffic = self.story_traffic
        if not traffic:
            self._story_bootstrap_traffic()

        rng = getattr(self, "story_traffic_rng", None)
        if not isinstance(rng, random.Random):
            rng = random.Random(int(getattr(self, "seed", 0)) ^ 0x54B3_9C21)
            self.story_traffic_rng = rng

        dt_time = float(max(0.0, dt_time))
        if dt_time <= 1e-6:
            return
        if dt_time > 0.25:
            dt_time = 0.25

        tday = float(self._time_of_day())
        max_n = int(max(0, int(getattr(self, "story_traffic_max", 10))))
        target = 4 if tday >= 0.85 or tday <= 0.18 else max_n
        target = int(clamp(int(target), 0, int(max_n)))

        center = self._player_tile()
        while len(traffic) < int(target) and len(traffic) < int(max_n):
            actor = self._story_spawn_one_traffic(rng=rng, center_tile=(int(center[0]), int(center[1])), radius=55)
            if actor is None:
                break
            traffic.append(actor)

        # Cull extras gently (keep variety).
        if len(traffic) > int(target):
            drop = int(len(traffic) - int(target))
            if drop > 0:
                pinned = [a for a in traffic if isinstance(a, dict) and bool(a.get("pinned", False))]
                others = [a for a in traffic if not (isinstance(a, dict) and bool(a.get("pinned", False)))]
                rng.shuffle(others)
                drop2 = int(min(int(drop), len(others)))
                if drop2 > 0:
                    del others[:drop2]
                traffic[:] = pinned + others

        ppos = pygame.Vector2(self.player.pos)
        max_dist2 = float((float(self.TILE_SIZE) * 95.0) ** 2)

        # Snapshot previous rects so traffic actors can collide with each other
        # using sweep checks (helps when dt spikes).
        try:
            for a in traffic:
                if not isinstance(a, dict):
                    continue
                try:
                    a["_prev_pos"] = pygame.Vector2(a.get("pos", pygame.Vector2(0, 0)))
                except Exception:
                    a["_prev_pos"] = pygame.Vector2(0, 0)
                try:
                    a["_prev_trect"] = self._story_traffic_rect_for_actor(a)
                except Exception:
                    a["_prev_trect"] = None
        except Exception:
            pass

        for a in traffic:
            if not isinstance(a, dict):
                continue
            try:
                pos = pygame.Vector2(a.get("pos", pygame.Vector2(0, 0)))
            except Exception:
                continue
            prev_pos = pygame.Vector2(pos)
            d = str(a.get("dir", "right") or "right")
            prev_dir = str(d)
            kind = str(a.get("kind", "car") or "car")
            speed = float(a.get("speed", 60.0))
            lane_axis = int(a.get("lane_axis", 0))
            lane_line = int(a.get("lane_line", 0))
            lane_offset = int(a.get("lane_offset", 0))
            prev_lane_axis = int(lane_axis)
            prev_lane_line = int(lane_line)
            turn_cd = float(a.get("turn_cd", 0.0))
            prng = a.get("rng", None)
            if not isinstance(prng, random.Random):
                prng = random.Random(int(rng.randrange(0, 2**31 - 1)) ^ 0x1A2B_3C4D)
                a["rng"] = prng

            fade_left = 0.0
            try:
                fade_left = float(a.get('spawn_fade_left', 0.0) or 0.0)
            except Exception:
                fade_left = 0.0
            if fade_left > 0.0:
                a['spawn_fade_left'] = float(max(0.0, float(fade_left) - float(dt_time)))

            need_reseed = False
            try:
                if float((pos - ppos).length_squared()) > float(max_dist2):
                    need_reseed = True
                tx_chk = int(math.floor(float(pos.x) / float(self.TILE_SIZE)))
                ty_chk = int(math.floor(float(pos.y) / float(self.TILE_SIZE)))
                if not bool(self.world.is_road(int(tx_chk), int(ty_chk))):
                    need_reseed = True
                if self._peek_building_at_tile(int(tx_chk), int(ty_chk)) is not None:
                    need_reseed = True
            except Exception:
                need_reseed = True
            if bool(need_reseed):
                replaced = False
                for _ in range(6):
                    new = self._story_spawn_one_traffic(
                        rng=rng,
                        center_tile=(int(center[0]), int(center[1])),
                        radius=70,
                        offscreen_only=True,
                    )
                    if isinstance(new, dict):
                        a.clear()
                        a.update(new)
                        replaced = True
                        break
                if not bool(replaced):
                    a['pos'] = pygame.Vector2(pos)
                continue

            # If the actor is too far away (or off-road), respawn it near the player.
            try:
                if float((pos - ppos).length_squared()) > float(max_dist2):
                    raise RuntimeError("respawn_far")
                tx = int(math.floor(float(pos.x) / float(self.TILE_SIZE)))
                ty = int(math.floor(float(pos.y) / float(self.TILE_SIZE)))
                if not bool(self.world.is_road(int(tx), int(ty))):
                    raise RuntimeError("respawn_offroad")
                if self._peek_building_at_tile(int(tx), int(ty)) is not None:
                    raise RuntimeError("respawn_building")
            except Exception:
                new = self._story_spawn_one_traffic(rng=rng, center_tile=(int(center[0]), int(center[1])), radius=55)
                if isinstance(new, dict):
                    a.clear()
                    a.update(new)
                continue

            prev_trect = None
            try:
                prev_actor = {
                    "kind": str(kind),
                    "model_id": str(a.get("model_id", "")),
                    "pos": pygame.Vector2(prev_pos),
                    "dir": str(prev_dir),
                    "heading": float(a.get("heading", 0.0)),
                }
                prev_trect = self._story_traffic_rect_for_actor(prev_actor)
            except Exception:
                prev_trect = None

            # Movement.
            dv = pygame.Vector2(0, 0)
            if d == "left":
                dv.x = -1
            elif d == "right":
                dv.x = 1
            elif d == "up":
                dv.y = -1
            else:
                dv.y = 1
            pos += dv * float(speed) * float(dt_time)

            # Keep the actor on its lane center.
            if lane_axis == 0:
                pos.y = (float(lane_line) + 0.5) * float(self.TILE_SIZE) + float(lane_offset)
            else:
                pos.x = (float(lane_line) + 0.5) * float(self.TILE_SIZE) + float(lane_offset)

            # Intersection turning (adds life; keeps it "orderly" by staying on roads).
            turn_cd = float(max(0.0, float(turn_cd) - float(dt_time)))
            if turn_cd <= 0.0:
                try:
                    tx = int(math.floor(float(pos.x) / float(self.TILE_SIZE)))
                    ty = int(math.floor(float(pos.y) / float(self.TILE_SIZE)))
                    on_x = bool(getattr(self.world, "_is_road_x")(int(tx)))
                    on_y = bool(getattr(self.world, "_is_road_y")(int(ty)))
                    at_junction = bool(on_x and on_y)
                except Exception:
                    at_junction = False
                    tx, ty = 0, 0
                is_police = str(a.get("tag", "") or "") == "police"
                if at_junction and (bool(is_police) or float(prng.random()) < 0.16):
                    if is_police:
                        # Police chase: pick a direction that reduces Manhattan distance to the player.
                        try:
                            ptx2, pty2 = self._player_tile()
                        except Exception:
                            ptx2, pty2 = int(tx), int(ty)
                        dxp = int(ptx2) - int(tx)
                        dyp = int(pty2) - int(ty)

                        def set_dir(nd: str) -> None:
                            nonlocal d
                            nd = str(nd)
                            a["dir"] = str(nd)
                            d = str(nd)
                            if kind == "car":
                                if nd == "left":
                                    a["heading"] = math.pi
                                elif nd == "right":
                                    a["heading"] = 0.0
                                elif nd == "up":
                                    a["heading"] = -math.pi / 2.0
                                else:
                                    a["heading"] = math.pi / 2.0

                        if lane_axis == 0:
                            # Decide whether to turn into vertical or reverse/continue horizontally.
                            if abs(int(dyp)) > abs(int(dxp)):
                                # Turn vertical.
                                nd = "up" if int(dyp) < 0 else "down"
                                a["lane_axis"] = 1
                                a["lane_line"] = int(tx)
                                lane_axis = 1
                                lane_line = int(tx)
                                set_dir(nd)
                            else:
                                # Stay on horizontal, but pick the correct chase direction (may U-turn).
                                nd = "left" if int(dxp) < 0 else "right"
                                set_dir(nd)
                        else:
                            # lane_axis == 1 (vertical)
                            if abs(int(dxp)) > abs(int(dyp)):
                                # Turn horizontal.
                                nd = "left" if int(dxp) < 0 else "right"
                                a["lane_axis"] = 0
                                a["lane_line"] = int(ty)
                                lane_axis = 0
                                lane_line = int(ty)
                                set_dir(nd)
                            else:
                                # Stay on vertical (may U-turn).
                                nd = "up" if int(dyp) < 0 else "down"
                                set_dir(nd)

                        # Snap to junction center so rotation doesn't "swim".
                        pos.update((float(tx) + 0.5) * float(self.TILE_SIZE), (float(ty) + 0.5) * float(self.TILE_SIZE))
                        if lane_axis == 0:
                            pos.y += float(lane_offset)
                        else:
                            pos.x += float(lane_offset)
                        turn_cd = float(prng.uniform(0.35, 0.75))
                    else:
                        if lane_axis == 0:
                            # Turn into vertical.
                            nd = "up" if float(prng.random()) < 0.5 else "down"
                            a["dir"] = str(nd)
                            a["lane_axis"] = 1
                            a["lane_line"] = int(tx)
                            lane_axis = 1
                            lane_line = int(tx)
                            d = str(nd)
                            if kind == "car":
                                a["heading"] = -math.pi / 2.0 if nd == "up" else math.pi / 2.0
                        else:
                            # Turn into horizontal.
                            nd = "left" if float(prng.random()) < 0.5 else "right"
                            a["dir"] = str(nd)
                            a["lane_axis"] = 0
                            a["lane_line"] = int(ty)
                            lane_axis = 0
                            lane_line = int(ty)
                            d = str(nd)
                            if kind == "car":
                                a["heading"] = math.pi if nd == "left" else 0.0
                        # Snap to junction center so rotation doesn't "swim".
                        pos.update((float(tx) + 0.5) * float(self.TILE_SIZE), (float(ty) + 0.5) * float(self.TILE_SIZE))
                        if lane_axis == 0:
                            pos.y += float(lane_offset)
                        else:
                            pos.x += float(lane_offset)
                        turn_cd = float(prng.uniform(0.9, 1.6))

            # Collision with humans: traffic should not clip through the player/NPCs.
            try:
                test_actor = {
                    "kind": str(kind),
                    "model_id": str(a.get("model_id", "")),
                    "pos": pygame.Vector2(pos),
                    "dir": str(d),
                    "heading": float(a.get("heading", 0.0)),
                }
                trect = self._story_traffic_rect_for_actor(test_actor)
            except Exception:
                trect = None

            blocked = False
            if isinstance(trect, pygame.Rect):
                try:
                    move_step = float((pygame.Vector2(pos) - pygame.Vector2(prev_pos)).length())
                except Exception:
                    move_step = 0.0
                use_sweep = bool(move_step > 6.0 and isinstance(prev_trect, pygame.Rect))

                def hits(target: pygame.Rect) -> bool:
                    if not isinstance(trect, pygame.Rect):
                        return False
                    try:
                        if trect.colliderect(target):
                            return True
                    except Exception:
                        return True
                    if bool(use_sweep) and isinstance(prev_trect, pygame.Rect):
                        try:
                            if not prev_trect.colliderect(target) and prev_trect.union(trect).colliderect(target):
                                return True
                        except Exception:
                            return True
                    return False

                # Active player (on foot or mounted).
                try:
                    m = getattr(self, "mount", None)
                except Exception:
                    m = None

                prect = None
                if m == "bike":
                    try:
                        mid_b = str(getattr(self.bike, "model_id", "bike"))
                        bw, bh = self._two_wheel_collider_px(mid_b)
                    except Exception:
                        bw, bh = (14, 10)
                    bd = str(getattr(self, "bike_dir", "right") or "right")
                    if bd in ("up", "down"):
                        bw, bh = int(bh), int(bw)
                    try:
                        bpos = pygame.Vector2(getattr(self.bike, "pos", pygame.Vector2(self.player.pos)))
                    except Exception:
                        bpos = pygame.Vector2(self.player.pos)
                    prect = pygame.Rect(
                        iround(float(bpos.x) - float(bw) / 2.0),
                        iround(float(bpos.y) - float(bh) / 2.0),
                        int(max(2, int(bw))),
                        int(max(2, int(bh))),
                    )
                elif m == "rv":
                    try:
                        rpos = pygame.Vector2(getattr(self.rv, "pos", pygame.Vector2(self.player.pos)))
                    except Exception:
                        rpos = pygame.Vector2(self.player.pos)
                    try:
                        mid_rv = str(getattr(self.rv, "model_id", "rv"))
                        model = self._CAR_MODELS.get(mid_rv) or self._CAR_MODELS.get("rv")
                    except Exception:
                        model = None
                    try:
                        cw = int(max(2, int(getattr(self.rv, "w", 0))))
                        ch = int(max(2, int(getattr(self.rv, "h", 0))))
                        dc = getattr(model, "drive_collider", None) if model is not None else None
                        if isinstance(dc, tuple) and len(dc) == 2:
                            dcw, dch = int(dc[0]), int(dc[1])
                            if dcw > 0 and dch > 0:
                                cw = int(max(2, min(int(cw), int(dcw))))
                                ch = int(max(2, min(int(ch), int(dch))))
                        heading = float(getattr(self.rv, "heading", 0.0))
                        c = abs(float(math.cos(float(heading))))
                        s = abs(float(math.sin(float(heading))))
                        ratio = float(s / max(1e-6, c))
                        axis = int(getattr(self, "_rv_drive_axis", 0))
                        if axis == 0:
                            if ratio > 1.18:
                                axis = 1
                        else:
                            if ratio < 0.85:
                                axis = 0
                        vw, vh = (int(ch), int(cw)) if axis == 1 else (int(cw), int(ch))
                        prect = pygame.Rect(
                            iround(float(rpos.x) - float(vw) / 2.0),
                            iround(float(rpos.y) - float(vh) / 2.0),
                            int(vw),
                            int(vh),
                        )
                    except Exception:
                        try:
                            prect = self._rv_collider_rect_at(rpos)
                        except Exception:
                            prect = None
                else:
                    try:
                        prect = self.player.rect_at()
                    except Exception:
                        prect = None

                if isinstance(prect, pygame.Rect) and hits(prect):
                    blocked = True

                # Player-owned parked vehicles also block traffic.
                if not blocked and m != "rv":
                    try:
                        if hits(self._rv_collider_rect_at()):
                            blocked = True
                    except Exception:
                        pass
                if not blocked and m != "bike":
                    try:
                        mid_b = str(getattr(self.bike, "model_id", "bike"))
                        bw, bh = self._two_wheel_collider_px(mid_b)
                    except Exception:
                        bw, bh = (14, 10)
                    bd = str(getattr(self, "bike_dir", "right") or "right")
                    if bd in ("up", "down"):
                        bw, bh = int(bh), int(bw)
                    try:
                        bpos = pygame.Vector2(getattr(self.bike, "pos", pygame.Vector2(0, 0)))
                    except Exception:
                        bpos = pygame.Vector2(0, 0)
                    brect = pygame.Rect(
                        iround(float(bpos.x) - float(bw) / 2.0),
                        iround(float(bpos.y) - float(bh) / 2.0),
                        int(max(2, int(bw))),
                        int(max(2, int(bh))),
                    )
                    if hits(brect):
                        blocked = True

                # Story NPCs.
                if not blocked:
                    npcs = getattr(self, "npcs", None)
                    if isinstance(npcs, list) and npcs:
                        npc_w, npc_h = self._story_npc_collider_wh()
                        for npc in npcs:
                            if not isinstance(npc, dict):
                                continue
                            try:
                                npos = pygame.Vector2(npc.get("pos", pygame.Vector2(0, 0)))
                            except Exception:
                                continue
                            nrect = pygame.Rect(
                                iround(float(npos.x) - float(npc_w) / 2.0),
                                iround(float(npos.y) - float(npc_h) / 2.0),
                                int(npc_w),
                                int(npc_h),
                            )
                            if hits(nrect):
                                blocked = True
                                break

                # Other traffic actors (cars/bikes) also collide with each other.
                if not blocked:
                    for o in traffic:
                        if not isinstance(o, dict) or o is a:
                            continue
                        try:
                            orect = self._story_traffic_rect_for_actor(o)
                        except Exception:
                            orect = None
                        if not isinstance(orect, pygame.Rect):
                            continue
                        if hits(orect):
                            blocked = True
                            break
                        # Symmetric sweep: check motion boxes vs motion boxes.
                        try:
                            o_prev = o.get("_prev_trect", None)
                            if isinstance(prev_trect, pygame.Rect) and isinstance(o_prev, pygame.Rect):
                                sweep_a = prev_trect.union(trect)
                                sweep_b = o_prev.union(orect)
                                if sweep_a.colliderect(sweep_b):
                                    blocked = True
                                    break
                        except Exception:
                            pass

                # Parked vehicles in the world also block traffic.
                if not blocked:
                    try:
                        ts = float(self.TILE_SIZE)
                        left = int(math.floor(float(trect.left) / float(ts)))
                        right = int(math.floor(float(trect.right - 1) / float(ts)))
                        top = int(math.floor(float(trect.top) / float(ts)))
                        bottom = int(math.floor(float(trect.bottom - 1) / float(ts)))
                        start_cx = left // self.CHUNK_SIZE
                        end_cx = right // self.CHUNK_SIZE
                        start_cy = top // self.CHUNK_SIZE
                        end_cy = bottom // self.CHUNK_SIZE
                        for cy in range(int(start_cy), int(end_cy) + 1):
                            for cx in range(int(start_cx), int(end_cx) + 1):
                                chunk = self.world.get_chunk(int(cx), int(cy))

                                for car in getattr(chunk, "cars", []):
                                    mid2 = str(getattr(car, "model_id", "rv"))
                                    model2 = self._CAR_MODELS.get(mid2) or self._CAR_MODELS.get("rv")
                                    if model2 is None:
                                        continue
                                    cw, ch = int(model2.collider[0]), int(model2.collider[1])
                                    if cw <= 0 or ch <= 0:
                                        continue
                                    cpos = pygame.Vector2(getattr(car, "pos", pygame.Vector2(0, 0)))
                                    chead = float(getattr(car, "heading", 0.0))
                                    c = abs(math.cos(float(chead)))
                                    s = abs(math.sin(float(chead)))
                                    ww = float(cw) * c + float(ch) * s
                                    hh = float(cw) * s + float(ch) * c
                                    pw = int(max(2, int(round(float(ww)))))
                                    ph = int(max(2, int(round(float(hh)))))
                                    crect = pygame.Rect(
                                        int(round(float(cpos.x) - float(pw) / 2.0)),
                                        int(round(float(cpos.y) - float(ph) / 2.0)),
                                        int(pw),
                                        int(ph),
                                    )
                                    if hits(crect):
                                        blocked = True
                                        break
                                if blocked:
                                    break

                                for b in getattr(chunk, "bikes", []):
                                    mid2 = str(getattr(b, "model_id", "bike"))
                                    bw, bh = self._two_wheel_collider_px(mid2)
                                    bd = str(getattr(b, "dir", "right"))
                                    if bd in ("up", "down"):
                                        bw, bh = int(bh), int(bw)
                                    bw = max(2, int(bw))
                                    bh = max(2, int(bh))
                                    bpos = pygame.Vector2(getattr(b, "pos", pygame.Vector2(0, 0)))
                                    brect = pygame.Rect(
                                        int(round(float(bpos.x) - float(bw) / 2.0)),
                                        int(round(float(bpos.y) - float(bh) / 2.0)),
                                        int(bw),
                                        int(bh),
                                    )
                                    if hits(brect):
                                        blocked = True
                                        break
                                if blocked:
                                    break
                            if blocked:
                                break
                    except Exception:
                        pass

            # Stop-and-yield when blocked; only reverse after being stuck for a bit.
            try:
                block_t = float(a.get("block_t", 0.0))
            except Exception:
                block_t = 0.0

            if blocked:
                block_t = float(block_t) + float(dt_time)
                # Restore the previous lane position; keep direction stable to prevent flicker.
                pos = pygame.Vector2(prev_pos)
                lane_axis = int(prev_lane_axis)
                lane_line = int(prev_lane_line)
                d = str(prev_dir)

                # If we've been blocked for a while (head-on traffic jam), turn around.
                if float(block_t) >= 1.25:
                    block_t = 0.0
                    if lane_axis == 0:
                        d = "left" if d == "right" else "right"
                    else:
                        d = "up" if d == "down" else "down"

                a["dir"] = str(d)
                a["lane_axis"] = int(lane_axis)
                a["lane_line"] = int(lane_line)
                if kind == "car":
                    if d == "left":
                        a["heading"] = math.pi
                    elif d == "right":
                        a["heading"] = 0.0
                    elif d == "up":
                        a["heading"] = -math.pi / 2.0
                    else:
                        a["heading"] = math.pi / 2.0
                turn_cd = float(max(float(turn_cd), float(prng.uniform(0.7, 1.4))))
                # Re-snap to lane after restoration.
                if lane_axis == 0:
                    pos.y = (float(lane_line) + 0.5) * float(self.TILE_SIZE) + float(lane_offset)
                else:
                    pos.x = (float(lane_line) + 0.5) * float(self.TILE_SIZE) + float(lane_offset)
            else:
                block_t = float(max(0.0, float(block_t) - float(dt_time) * 2.5))

            a["block_t"] = float(block_t)

            # Animate based on actual movement (prevents wheel/pedal flicker while blocked).
            try:
                moved_dist = float((pygame.Vector2(pos) - pygame.Vector2(prev_pos)).length())
            except Exception:
                moved_dist = 0.0
            try:
                anim = float(a.get("anim", 0.0))
            except Exception:
                anim = 0.0
            if float(moved_dist) > 0.05:
                anim = float(anim) + float(dt_time) * (4.0 if kind == "car" else 6.0)
            a["anim"] = float(anim)
            if kind in ("car", "bike", "moto"):
                a["frame"] = int(anim) % 2
            else:
                a["frame"] = int(a.get("frame", 0)) % 2

            a["turn_cd"] = float(turn_cd)
            a["pos"] = pygame.Vector2(pos)

    def _draw_story_traffic(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        if not bool(getattr(self, "story_enabled", False)):
            return
        if not bool(self._story_is_pre_apocalypse()):
            return
        if not bool(getattr(self, "story_traffic_enabled", True)):
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return
        traffic = getattr(self, "story_traffic", None)
        if not isinstance(traffic, list) or not traffic:
            return

        ts = int(self.TILE_SIZE)
        draw_list: list[dict[str, object]] = [a for a in traffic if isinstance(a, dict)]
        draw_list.sort(key=lambda a: float(getattr(a.get("pos", pygame.Vector2(0, 0)), "y", 0.0)))

        # Cache for "convertible + head" bases (before rotation).
        cache = getattr(self, "_TRAFFIC_CAR_BASE", None)
        if not isinstance(cache, dict):
            cache = {}
            self._TRAFFIC_CAR_BASE = cache

        for a in draw_list:
            try:
                pos = pygame.Vector2(a.get("pos", pygame.Vector2(0, 0)))
            except Exception:
                continue
            sx = iround(float(pos.x) - float(cam_x))
            sy = iround(float(pos.y) - float(cam_y))
            if sx < -120 or sx > INTERNAL_W + 120 or sy < -120 or sy > INTERNAL_H + 120:
                continue
            draw_alpha = 255
            try:
                fade_left = float(a.get('spawn_fade_left', 0.0) or 0.0)
                fade_total = float(a.get('spawn_fade_total', 0.0) or 0.0)
                if fade_left > 0.0 and fade_total > 1e-6:
                    draw_alpha = int(clamp(int(round(255.0 * (1.0 - fade_left / fade_total))), 0, 255))
            except Exception:
                draw_alpha = 255
            if draw_alpha <= 0:
                continue
            kind = str(a.get("kind", "car") or "car")
            mid = str(a.get("model_id", "beetle") or "beetle")
            frame = int(a.get("frame", 0)) % 2

            if kind == "car":
                steer_state = int(a.get("steer_state", 0))
                base = self._CAR_BASE.get((mid, int(steer_state), int(frame)))
                shadow_base = self._CAR_SHADOW.get((mid, int(steer_state), int(frame)))
                if base is None:
                    base = self._CAR_BASE.get(("schoolbus", 0, 0))
                    shadow_base = self._CAR_SHADOW.get(("schoolbus", 0, 0))
                if base is None:
                    continue

                driver_style = str(a.get("driver_style", "") or "")
                if driver_style == "brag":
                    key = (mid, int(steer_state), int(frame), "brag")
                    cached = cache.get(key)
                    if isinstance(cached, pygame.Surface):
                        base2 = cached
                    else:
                        base2 = base.copy()
                        try:
                            av = a.get("driver_avatar", None)
                            if not isinstance(av, SurvivalAvatar):
                                av = SurvivalAvatar(gender=0, accessory=1, outfit=11)
                            cols = HardcoreSurvivalState._avatar_colors(av)
                            hair = tuple(cols.get("hair", (30, 30, 34)))
                            skin = tuple(cols.get("skin", (220, 190, 160)))
                        except Exception:
                            hair = (30, 30, 34)
                            skin = (220, 190, 160)
                        outline = (10, 10, 12)
                        glass = (40, 40, 50)
                        w = int(base2.get_width())
                        h = int(base2.get_height())
                        cx = int(w // 2)
                        cy = int(h // 2) - 2
                        # Head + sunglasses.
                        pygame.draw.rect(base2, hair, pygame.Rect(cx - 2, cy - 3, 4, 2))
                        pygame.draw.rect(base2, skin, pygame.Rect(cx - 2, cy - 1, 4, 3))
                        pygame.draw.rect(base2, glass, pygame.Rect(cx - 2, cy, 4, 1))
                        pygame.draw.rect(base2, outline, pygame.Rect(cx - 3, cy - 3, 6, 5), 1)
                        cache[key] = base2
                    base = base2

                deg = -math.degrees(float(a.get("heading", 0.0)))
                spr = rotate_pixel_sprite(base, deg, step_deg=5.0)
                rect = spr.get_rect(center=(int(sx), int(sy)))
                if shadow_base is not None:
                    sh = rotate_pixel_sprite(shadow_base, deg, step_deg=5.0)
                    srect = sh.get_rect(center=(rect.centerx + 2, rect.centery + 6))
                    if int(draw_alpha) >= 255:
                        surface.blit(sh, srect)
                    else:
                        sh2 = sh.copy()
                        sh2.set_alpha(int(draw_alpha))
                        surface.blit(sh2, srect)
                if int(draw_alpha) >= 255:
                    surface.blit(spr, rect)
                else:
                    spr2 = spr.copy()
                    spr2.set_alpha(int(draw_alpha))
                    surface.blit(spr2, rect)
                continue

            # Two-wheel traffic (bike/moto) with rider.
            d = str(a.get("dir", "right") or "right")
            model = self._TWO_WHEEL_FRAMES.get(mid) or self._TWO_WHEEL_FRAMES.get("bike") or {}
            frames = model.get(d) or model.get("right") or self._BIKE_FRAMES.get("right", [])
            if not frames:
                continue
            spr = frames[min(int(frame), len(frames) - 1)]
            _cw, ch = self._two_wheel_collider_px(mid)
            ground_y = int(sy + int(ch) // 2)
            rect = spr.get_rect()
            baseline_y = int(self._sprite_baseline_y(spr))
            rect.centerx = int(sx)
            rect.bottom = int(int(ground_y) + int(rect.h - baseline_y))
            shadow = self._two_wheel_shadow_rect(rect, d, ground_y=int(ground_y))
            sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
            sh_alpha = int(clamp(int(round(120.0 * float(draw_alpha) / 255.0)), 0, 255))
            pygame.draw.ellipse(sh, (0, 0, 0, sh_alpha), sh.get_rect())
            surface.blit(sh, shadow.topleft)
            if int(draw_alpha) >= 255:
                surface.blit(spr, rect)
            else:
                spr2 = spr.copy()
                spr2.set_alpha(int(draw_alpha))
                surface.blit(spr2, rect)

            rider = None
            rf = a.get("rider_frames", None)
            if isinstance(rf, dict):
                try:
                    rlist = rf.get(d) or rf.get("right")
                    if isinstance(rlist, list) and rlist:
                        rider = rlist[int(frame) % len(rlist)]
                except Exception:
                    rider = None
            if rider is not None:
                rrect = rider.get_rect()
                seat_from_ground = 4 if d in ("up", "down") else 3
                if str(mid).startswith("moto"):
                    seat_from_ground = max(2, int(seat_from_ground) - 1)
                rrect.midbottom = (rect.centerx, int(int(ground_y) - int(seat_from_ground)))
                if int(draw_alpha) >= 255:
                    surface.blit(rider, rrect)
                else:
                    rider2 = rider.copy()
                    rider2.set_alpha(int(draw_alpha))
                    surface.blit(rider2, rrect)

    def _story_set_npc_hostile(self, npc_id: str, *, seconds: float = 10.0) -> None:
        npc_id = str(npc_id or "").strip()
        if not npc_id:
            return
        seconds = float(max(0.0, float(seconds)))
        npcs = getattr(self, "npcs", None)
        if not isinstance(npcs, list):
            return
        for npc in npcs:
            if not isinstance(npc, dict):
                continue
            if str(npc.get("id", "")) != npc_id:
                continue
            npc["hostile_left"] = float(max(float(npc.get("hostile_left", 0.0) or 0.0), float(seconds)))
            npc["attack_left"] = 0.0
            npc["stay_left"] = 0.0
            npc["goal_left"] = 0.0
            npc["stuck"] = 0.0
            npc["action"] = ""
            npc["path_pts"] = []
            npc["path_i"] = 0
            break

    def _story_nearest_npc(self, *, radius_px: float = 18.0) -> dict[str, object] | None:
        if not bool(getattr(self, "story_enabled", False)):
            return None
        if not bool(self._story_is_pre_apocalypse()):
            return None
        if getattr(self, "mount", None) is not None:
            return None
        npcs = getattr(self, "npcs", None)
        if not isinstance(npcs, list) or not npcs:
            return None
        r2 = float(radius_px) * float(radius_px)
        p = pygame.Vector2(self.player.pos)
        best: dict[str, object] | None = None
        best_d2 = 1e18
        for npc in npcs:
            if not isinstance(npc, dict):
                continue
            try:
                pos = pygame.Vector2(npc.get("pos", pygame.Vector2(0, 0)))
            except Exception:
                continue
            d2 = float((pos - p).length_squared())
            if d2 <= r2 and d2 < best_d2:
                best = npc
                best_d2 = d2
        return best

    def _try_talk_to_story_npc(self) -> bool:
        if bool(getattr(self, "conv_open", False)) or bool(getattr(self, "dialog_open", False)):
            return False
        npc = self._story_nearest_npc(radius_px=20.0)
        if npc is None:
            return False
        if float(npc.get("hostile_left", 0.0) or 0.0) > 0.0:
            self._set_hint("", seconds=1.0)
            return True
        script = str(npc.get("script", "") or "")
        if not script:
            self._set_hint("", seconds=1.0)
            return True
        self._conv_open_script(
            script,
            node="start",
            ctx={"npc_id": str(npc.get("id", "")), "npc_name": str(npc.get("name", ""))},
        )
        return True

    def _draw_story_npcs(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        if not bool(getattr(self, "story_enabled", False)):
            return
        if not bool(self._story_is_pre_apocalypse()):
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return
        npcs = getattr(self, "npcs", None)
        if not isinstance(npcs, list) or not npcs:
            return

        mouse = None
        if not self.inv_open and not bool(getattr(self, "world_map_open", False)):
            mouse = self.app.screen_to_internal(pygame.mouse.get_pos())
        mx, my = (int(mouse[0]), int(mouse[1])) if mouse is not None else (-999, -999)

        player_p = pygame.Vector2(self.player.pos)
        hovered: tuple[float, pygame.Surface, pygame.Rect, list[str], tuple[int, int]] | None = None

        def pose_sprite_for_npc(npc: dict[str, object], base: pygame.Surface, *, direction: str) -> pygame.Surface:
            action = str(npc.get("action", "") or "")
            if not action:
                return base
            cache = npc.get("pose_cache", None)
            if not isinstance(cache, dict):
                cache = {}
                npc["pose_cache"] = cache
            try:
                phase = float(npc.get("pose_phase", 0.0))
            except Exception:
                phase = 0.0

            rate = 2.0
            if action in ("type", "pushup"):
                rate = 3.0
            elif action in ("coffee",):
                rate = 1.6
            elif action in ("guard_scan", "flex"):
                rate = 2.2
            elif action in ("bruce_guard",):
                rate = 3.0
            elif action in ("bruce_punch",):
                rate = 7.0
            elif action in ("muscle_guard",):
                rate = 3.0
            elif action in ("muscle_punch",):
                rate = 6.0
            frame = int(phase * float(rate)) % 2
            key = (str(action), str(direction), int(frame))
            spr = cache.get(key)
            if isinstance(spr, pygame.Surface):
                return spr

            base_w, base_h = int(base.get_width()), int(base.get_height())
            pad_x = 0
            pad_y = 0
            # Some combat poses need extra canvas so fists can extend beyond the base sprite.
            if action in ("bruce_guard", "bruce_punch"):
                pad_x = 7
            elif action in ("muscle_guard", "muscle_punch"):
                pad_x = 10
            w = int(base_w + pad_x * 2)
            h = int(base_h + pad_y * 2)
            outline = (10, 10, 12)
            phone = (40, 40, 50)
            phone_hi = (230, 220, 140)
            sweat = (120, 170, 230)
            cup = (230, 230, 236)
            coffee = (160, 90, 44)
            laptop = (50, 50, 62)
            laptop_hi = (90, 90, 110)
            stick = (70, 70, 86)

            avatar = npc.get("avatar", None)
            if not isinstance(avatar, SurvivalAvatar):
                avatar = SurvivalAvatar()
            cols = HardcoreSurvivalState._avatar_colors(avatar)
            skin = tuple(cols.get("skin", (220, 190, 160)))

            def px(x: int, y: int, c: tuple[int, int, int]) -> None:
                x = int(x) + int(pad_x)
                y = int(y) + int(pad_y)
                if 0 <= int(x) < w and 0 <= int(y) < h:
                    try:
                        out.set_at((int(x), int(y)), c)
                    except Exception:
                        pass

            def mirror_x(x: int) -> int:
                return int(int(base_w) - 1 - int(x))

            if action == "pushup":
                out = pygame.Surface((w, h), pygame.SRCALPHA)
                off_y = 1 if int(frame) == 1 else 0
                out.blit(base, (int(pad_x), int(pad_y + off_y)))
                px(6, 1 if int(frame) == 1 else 0, sweat)
                px(7, 2 if int(frame) == 1 else 1, sweat)
            else:
                if int(pad_x) > 0 or int(pad_y) > 0:
                    out = pygame.Surface((w, h), pygame.SRCALPHA)
                    out.blit(base, (int(pad_x), int(pad_y)))
                else:
                    out = base.copy()

            if action == "guard_scan":
                x = 10 if str(direction) in ("right", "down") else 1
                for yy in range(9, 13):
                    px(int(x), int(yy), stick)
                px(int(x), 9, phone_hi)
            elif action == "type":
                # Tiny laptop/keyboard in front of the NPC.
                if str(direction) in ("left", "right"):
                    x0, y0 = (7, 11)
                    if str(direction) == "left":
                        x0 = mirror_x(x0 + 4)
                else:
                    x0, y0 = (4, 11)
                out.fill(laptop, pygame.Rect(int(x0), int(y0), 5, 2))
                px(int(x0), int(y0), laptop_hi)
                px(int(x0 + 4), int(y0), laptop_hi)
                if int(frame) == 1:
                    px(int(x0 + 2), int(y0), (90, 200, 120))
            elif action == "selfie":
                # Phone near the face + a tiny flash.
                x0, y0 = (8, 3)
                if str(direction) == "left":
                    x0 = mirror_x(x0 + 1)
                out.fill(phone, pygame.Rect(int(x0), int(y0), 2, 3))
                px(int(x0 + 1), int(y0), phone_hi)
                if int(frame) == 1:
                    px(int(x0 + 2 if str(direction) != "left" else x0 - 1), int(y0 + 1), phone_hi)
            elif action == "wave":
                # Raised hand above the head (wiggles).
                x = 9
                if str(direction) == "left":
                    x = mirror_x(x)
                y = 1 if int(frame) == 0 else 0
                px(int(x), int(y), skin)
                px(int(x), int(y + 1), skin)
            elif action == "coffee":
                # A cup near the mouth.
                x, y = (8, 6)
                if str(direction) == "left":
                    x = mirror_x(x)
                if str(direction) in ("left", "right"):
                    y = 5
                out.fill(cup, pygame.Rect(int(x), int(y), 2, 2))
                px(int(x + 1), int(y + 1), coffee)
            elif action == "flex":
                # Quick bicep hint.
                x = 10 if str(direction) != "left" else mirror_x(10)
                y = 8 if int(frame) == 0 else 7
                px(int(x), int(y), skin)
                px(int(x), int(y + 1), skin)
                px(int(x - 1 if str(direction) != "left" else x + 1), int(y), outline)
            elif action in ("bruce_guard", "bruce_punch"):
                #  + 
                is_punch = bool(str(action) == "bruce_punch")
                wind = bool(is_punch and int(frame) == 0)
                jab = bool(is_punch and int(frame) == 1)
                hi = phone_hi
                x_fist = int(base_w) + int(pad_x) - 2

                def sx(x: int) -> int:
                    x = int(x)
                    return mirror_x(x) if str(direction) == "left" else x

                if str(direction) in ("left", "right"):
                    # Guard hand near face.
                    px(sx(8), 4, skin)
                    px(sx(9), 4, skin)
                    px(sx(8), 5, outline)
                    # Rear hand near chest.
                    px(sx(7), 7, skin)
                    px(sx(7), 8, skin)
                    px(sx(6), 7, outline)
                    if wind:
                        # Wind-up: pull the lead fist back slightly.
                        px(sx(9), 6, skin)
                        px(sx(9), 5, outline)
                        px(sx(10), 6, outline)
                    if jab:
                        y = 7
                        # Arm extension (2px high) into the padded canvas.
                        for xx in range(8, int(x_fist)):
                            px(sx(xx), int(y), skin)
                            px(sx(xx), int(y - 1), skin)
                        # Fist (2x2).
                        for xx in (int(x_fist), int(x_fist) + 1):
                            px(sx(xx), int(y), skin)
                            px(sx(xx), int(y - 1), skin)
                        # Outline to separate from the body.
                        px(sx(int(x_fist) + 1), int(y - 2), outline)
                        px(sx(int(x_fist) + 1), int(y + 1), outline)
                        px(sx(int(x_fist)), int(y - 2), outline)
                        px(sx(int(x_fist)), int(y + 1), outline)
                        # Motion lines.
                        px(sx(int(x_fist) - 3), int(y - 3), hi)
                        px(sx(int(x_fist) - 2), int(y - 3), hi)
                        px(sx(int(x_fist) - 2), int(y - 2), hi)
                else:
                    # Up/Down: punch to the side so it's visible.
                    y = 6 if str(direction) == "up" else 9
                    px(6, int(y), skin)
                    px(6, int(y - 1), outline)
                    px(5, int(y), outline)
                    if wind:
                        px(7, int(y), skin)
                        px(7, int(y - 1), outline)
                    if jab:
                        for xx in range(7, int(x_fist)):
                            px(int(xx), int(y), skin)
                        for xx in (int(x_fist), int(x_fist) + 1):
                            px(int(xx), int(y), skin)
                        px(int(x_fist) + 1, int(y - 1), outline)
                        px(int(x_fist) + 1, int(y + 1), outline)
                        px(int(x_fist) - 1, int(y - 1), hi)
                        px(int(x_fist) - 2, int(y - 1), hi)
            elif action in ("muscle_guard", "muscle_punch"):
                # Bigger/thicker punch so it's always obvious the arm extends.
                is_punch = bool(str(action) == "muscle_punch")
                wind = bool(is_punch and int(frame) == 0)
                jab = bool(is_punch and int(frame) == 1)
                hi = phone_hi
                x_fist = int(base_w) + int(pad_x) - 2

                def sx(x: int) -> int:
                    x = int(x)
                    return mirror_x(x) if str(direction) == "left" else x

                if str(direction) in ("left", "right"):
                    # Guard: two chunky fists (face + chest).
                    for xx in (8, 9):
                        for yy in (4, 5):
                            px(sx(xx), int(yy), skin)
                    px(sx(7), 4, outline)
                    px(sx(7), 5, outline)

                    for xx in (6, 7):
                        for yy in (7, 8):
                            px(sx(xx), int(yy), skin)
                    px(sx(5), 7, outline)
                    px(sx(5), 8, outline)

                    if wind:
                        # Pull lead fist back slightly.
                        px(sx(9), 6, skin)
                        px(sx(10), 6, skin)
                        px(sx(10), 5, outline)

                    if jab:
                        y = 7
                        # Thick arm extension (3px tall).
                        for xx in range(7, int(x_fist)):
                            for yy in (y - 1, y, y + 1):
                                px(sx(xx), int(yy), skin)
                        # Big fist at the end.
                        for xx in (int(x_fist), int(x_fist) + 1):
                            for yy in (y - 1, y, y + 1):
                                px(sx(xx), int(yy), skin)
                        # Outline + motion.
                        px(sx(int(x_fist) + 1), int(y - 2), outline)
                        px(sx(int(x_fist) + 1), int(y + 2), outline)
                        px(sx(int(x_fist)), int(y - 2), outline)
                        px(sx(int(x_fist)), int(y + 2), outline)
                        px(sx(int(x_fist) - 1), int(y - 3), hi)
                        px(sx(int(x_fist)), int(y - 3), hi)
                else:
                    # Up/Down: punch to the side so it stays visible.
                    y = 6 if str(direction) == "up" else 9
                    px(6, int(y), skin)
                    px(6, int(y - 1), outline)
                    px(5, int(y), outline)
                    if wind:
                        px(7, int(y), skin)
                        px(7, int(y - 1), outline)
                    if jab:
                        for xx in range(7, int(x_fist)):
                            px(int(xx), int(y), skin)
                            px(int(xx), int(y - 1), skin)
                        for xx in (int(x_fist), int(x_fist) + 1):
                            px(int(xx), int(y), skin)
                            px(int(xx), int(y - 1), skin)
                        px(int(x_fist) + 1, int(y - 2), outline)
                        px(int(x_fist) + 1, int(y + 1), outline)
                        px(int(x_fist), int(y - 2), outline)
                        px(int(x_fist), int(y + 1), outline)
                        px(int(x_fist) - 1, int(y - 3), hi)

            cache[key] = out
            return out

        for npc in npcs:
            if not isinstance(npc, dict):
                continue
            frames = npc.get("frames", None)
            if not isinstance(frames, dict):
                continue
            d = str(npc.get("dir", "down") or "down")
            fr = frames.get(d) or frames.get("down")
            if not fr:
                continue
            try:
                pos = pygame.Vector2(npc.get("pos", pygame.Vector2(0, 0)))
            except Exception:
                continue

            # If the NPC is inside a cutaway building, hide it unless the player
            # is also inside the same building (prevents "standing on facades").
            try:
                ntx = int(math.floor(float(pos.x) / float(self.TILE_SIZE)))
                nty = int(math.floor(float(pos.y) / float(self.TILE_SIZE)))
                hit = self._peek_building_at_tile(int(ntx), int(nty))
                if hit is not None:
                    btx0, bty0, bw, bh = int(hit[0]), int(hit[1]), int(hit[2]), int(hit[3])
                    inside_key = getattr(self, "_inside_building_key", None)
                    same_building = (
                        isinstance(inside_key, tuple)
                        and len(inside_key) == 4
                        and (int(inside_key[0]), int(inside_key[1]), int(inside_key[2]), int(inside_key[3]))
                        == (int(btx0), int(bty0), int(bw), int(bh))
                    )
                    if not same_building:
                        continue
                    visible = getattr(self, "_inside_building_visible", None)
                    if isinstance(visible, set) and (int(ntx), int(nty)) not in visible:
                        continue
            except Exception:
                pass

            p = pygame.Vector2(pos) - pygame.Vector2(cam_x, cam_y)
            sx = iround(float(p.x))
            sy = iround(float(p.y))

            vel = npc.get("vel", pygame.Vector2(0, 0))
            try:
                moving = pygame.Vector2(vel).length_squared() > 1.0
            except Exception:
                moving = False
            if moving and len(fr) > 1:
                walk = fr[1:]
                phase = float(npc.get("walk_phase", 0.0))
                phase = (float(phase) % math.tau) / math.tau
                idx = int(phase * len(walk)) % len(walk) if walk else 0
                spr = walk[idx] if walk else fr[0]
            else:
                base = fr[0]
                spr = pose_sprite_for_npc(npc, base, direction=str(d)) if not bool(moving) else base

            # Some actions (e.g. combat stance) must be visible even while moving.
            try:
                act = str(npc.get("action", "") or "")
                if act in ("bruce_guard", "bruce_punch", "muscle_guard", "muscle_punch"):
                    spr = pose_sprite_for_npc(npc, spr, direction=str(d))
            except Exception:
                pass

            rect = spr.get_rect()
            rect.midbottom = (int(sx), iround(float(sy) + float(getattr(self.player, "h", 12)) / 2.0))

            shadow = pygame.Rect(0, 0, max(6, rect.w - 4), 4)
            shadow.center = (int(rect.centerx), int(rect.bottom - 2))
            draw_alpha = 255
            try:
                fade_left = float(npc.get('spawn_fade_left', 0.0) or 0.0)
                fade_total = float(npc.get('spawn_fade_total', 0.0) or 0.0)
                if fade_left > 0.0 and fade_total > 1e-6:
                    draw_alpha = int(clamp(int(round(255.0 * (1.0 - fade_left / fade_total))), 0, 255))
            except Exception:
                draw_alpha = 255
            if draw_alpha <= 0:
                continue
            if int(draw_alpha) >= 255:
                pygame.draw.ellipse(surface, (0, 0, 0), shadow)
                surface.blit(spr, rect)
            else:
                sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
                sh_alpha = int(clamp(int(round(120.0 * float(draw_alpha) / 255.0)), 0, 255))
                pygame.draw.ellipse(sh, (0, 0, 0, sh_alpha), sh.get_rect())
                surface.blit(sh, shadow.topleft)
                spr2 = spr.copy()
                spr2.set_alpha(int(draw_alpha))
                surface.blit(spr2, rect)

            if int(draw_alpha) < 210:
                continue

            # Name tag when close (avoids clutter).
            try:
                d2 = float((pos - player_p).length_squared())
                script = str(npc.get("script", "") or "")
                if script and d2 <= float((self.TILE_SIZE * 7.0) ** 2):
                    dot = (int(rect.centerx), int(rect.top - 8))
                    pygame.draw.circle(surface, (255, 220, 140), dot, 3)
                    pygame.draw.circle(surface, (0, 0, 0), dot, 3, 1)

                if d2 <= float((self.TILE_SIZE * 5.5) ** 2):
                    name = str(npc.get("name", "") or "")
                    if name:
                        font = self.app.font_s
                        img = font.render(name, False, pygame.Color(240, 240, 244))
                        pad = 3
                        tag = img.get_rect(midbottom=(int(rect.centerx), int(rect.top - 2)))
                        bg = pygame.Rect(tag.x - pad, tag.y - 1, tag.w + pad * 2, tag.h + 2)
                        pygame.draw.rect(surface, (0, 0, 0), bg, border_radius=5)
                        pygame.draw.rect(surface, (90, 90, 110), bg, 1, border_radius=5)
                        surface.blit(img, tag)
            except Exception:
                pass

            if mouse is not None and rect.collidepoint(int(mx), int(my)):
                name = str(npc.get("name", "") or "NPC")
                script = str(npc.get("script", "") or "")
                prompt = "E " if script else ""
                lines = [name, prompt]
                d2 = float((pos - player_p).length_squared())
                if hovered is None or d2 < hovered[0]:
                    hovered = (d2, spr, rect, lines, (mx, my))

        if hovered is not None:
            _d2, spr, rect, lines, mpos = hovered
            self._blit_sprite_outline(surface, spr, rect, color=(255, 245, 140))
            self._hover_tooltip = (lines, mpos)

    def _story_update(self, dt_time: float) -> None:
        if not bool(getattr(self, "story_enabled", False)):
            return
        dt_time = float(max(0.0, dt_time))

        pre = bool(self._story_is_pre_apocalypse())
        day = int(self._story_world_day())
        t = float(self._time_of_day())
        offset = int(self._story_day_offset())

        # Switch worldgen flavor for newly-generated chunks.
        try:
            if pre:
                self.world_gen_story_mode = "prelude"
            else:
                self.world_gen_story_mode = "apocalypse"
        except Exception:
            pass

        # Toggle zombies at outbreak.
        if pre:
            self.zombie_cap = 0
        else:
            if int(getattr(self, "zombie_cap", 0)) <= 0:
                self.zombie_cap = 8

        # Outbreak announcement (once).
        if (not pre) and "OUTBREAK" not in self.story_events_done:
            self.story_events_done.add("OUTBREAK")
            self._dialog_start(
                "",
                [
                    "",
                    "",
                    "",
                ],
                speed=58.0,
            )

        # D-2: hardware store preps (spawn kits on the ground once).
        if offset == -2 and "HW_KITS" not in self.story_events_done and t >= 0.40:
            self.story_events_done.add("HW_KITS")
            tx, ty = tuple(getattr(self, "story_hardware_tile", (0, 0)))
            pos = pygame.Vector2((float(tx) + 0.5) * float(self.TILE_SIZE), (float(ty) + 0.5) * float(self.TILE_SIZE))
            for iid, qty in (
                ("home_peephole_kit", 1),
                ("home_door_chain", 1),
                ("plank", 2),
                ("nails", 10),
            ):
                if iid in self._ITEMS:
                    self._drop_world_item(pos + pygame.Vector2(random.uniform(-6, 6), random.uniform(-6, 6)), iid, int(qty))
            self._set_hint("///", seconds=2.0)

        # Morning reminder: go to work (one ping per day during prelude).
        if pre and 0.34 <= t <= 0.42:
            last = int(getattr(self, "story_last_work_ping_day", 0))
            if int(day) != int(last):
                self.story_last_work_ping_day = int(day)
                if offset in (-3, -2, -1) and int(getattr(self, "story_work_clocked_day", 0)) != int(day):
                    self._set_hint("", seconds=1.6)

        # Lazy-spawn facility staff (clerks/doctors) near generated buildings.
        self._story_update_staff(float(dt_time))

    def _story_update_staff(self, dt_time: float) -> None:
        if not bool(getattr(self, "story_enabled", False)):
            return
        if not bool(self._story_is_pre_apocalypse()):
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return

        dt_time = float(max(0.0, dt_time))
        left = float(getattr(self, "story_staff_scan_left", 0.0))
        left = float(max(0.0, float(left) - float(dt_time)))
        if float(left) > 0.0:
            self.story_staff_scan_left = float(left)
            return
        self.story_staff_scan_left = 1.25

        spawned = getattr(self, "story_staff_spawned", None)
        if not isinstance(spawned, set):
            self.story_staff_spawned = set()
            spawned = self.story_staff_spawned

        npcs = getattr(self, "npcs", None)
        if not isinstance(npcs, list):
            self.npcs = []
            npcs = self.npcs

        # Ensure the staff scripts exist (minimal talking, no shop UI yet).
        staff_scripts: dict[str, dict[str, object]] = {
            "npc_staff_office_boss": {
                "start": {
                    "speaker": "",
                    "text": "{PLAYER_NAME}",
                    "options": [{"label": "", "action": "close"}],
                },
            },
            "npc_staff_office_secretary": {
                "start": {
                    "speaker": "",
                    "text": "~ ",
                    "options": [
                        {"label": "", "action": "hint:", "next": "start"},
                        {"label": "", "action": "close"},
                    ],
                },
            },
            "npc_staff_office_employee": {
                "start": {
                    "speaker": "",
                    "text": "",
                    "options": [{"label": "", "action": "close"}],
                },
            },
            "npc_staff_shop_clerk": {
                "start": {"speaker": "", "text": "", "options": [{"label": "", "action": "close"}]},
            },
            "npc_staff_shop_stocker": {
                "start": {"speaker": "", "text": "", "options": [{"label": "", "action": "close"}]},
            },
            "npc_staff_bookstore_clerk": {
                "start": {"speaker": "", "text": "", "options": [{"label": "", "action": "close"}]},
            },
            "npc_staff_gunshop_clerk": {
                "start": {"speaker": "", "text": "", "options": [{"label": "", "action": "close"}]},
            },
            "npc_staff_hospital_doctor": {
                "start": {"speaker": "", "text": "", "options": [{"label": "", "action": "hint:", "next": "start"}, {"label": "", "action": "close"}]},
            },
            "npc_staff_hospital_nurse": {
                "start": {"speaker": "", "text": "", "options": [{"label": "", "action": "close"}]},
            },
            "npc_staff_restaurant_waiter": {
                "start": {
                    "speaker": "",
                    "text": "",
                    "options": [{"label": "", "action": "close"}],
                },
            },
            "npc_staff_restaurant_chef": {
                "start": {
                    "speaker": "",
                    "text": "",
                    "options": [{"label": "", "action": "close"}],
                },
            },
        }
        try:
            scripts = getattr(self, "_CONV_SCRIPTS", None)
            if not isinstance(scripts, dict):
                self._CONV_SCRIPTS = {}
                scripts = self._CONV_SCRIPTS
            for sid, sdef in staff_scripts.items():
                if str(sid) not in scripts:
                    scripts[str(sid)] = dict(sdef)
        except Exception:
            pass

        staff_by_sign: dict[str, list[dict[str, object]]] = {
            "sign_office": [
                {"role": "boss", "name": "", "script": "npc_staff_office_boss", "gender": 0, "outfit": 11},
                {"role": "secretary", "name": "", "script": "npc_staff_office_secretary", "gender": 1, "outfit": 11},
                {"role": "employee1", "name": "", "script": "npc_staff_office_employee", "gender": 0, "outfit": 11},
                {"role": "employee2", "name": "", "script": "npc_staff_office_employee", "gender": 1, "outfit": 11},
            ],
            "sign_hospital": [
                {"role": "doctor", "name": "", "script": "npc_staff_hospital_doctor", "gender": 0, "outfit": 1},
                {"role": "nurse", "name": "", "script": "npc_staff_hospital_nurse", "gender": 1, "outfit": 1},
            ],
            "sign_shop": [
                {"role": "clerk", "name": "", "script": "npc_staff_shop_clerk", "gender": 1, "outfit": 6},
            ],
            "sign_shop_big": [
                {"role": "cashier", "name": "", "script": "npc_staff_shop_clerk", "gender": 1, "outfit": 6},
                {"role": "stocker", "name": "", "script": "npc_staff_shop_stocker", "gender": 0, "outfit": 6},
            ],
            "sign_bookstore": [
                {"role": "clerk", "name": "", "script": "npc_staff_bookstore_clerk", "gender": 0, "outfit": 1},
            ],
            "sign_gunshop": [
                {"role": "clerk", "name": "", "script": "npc_staff_gunshop_clerk", "gender": 0, "outfit": 2},
            ],
            "sign_chinese": [
                {"role": "waiter", "name": "", "script": "npc_staff_restaurant_waiter", "gender": 1, "outfit": 11},
                {"role": "chef", "name": "", "script": "npc_staff_restaurant_chef", "gender": 0, "outfit": 8},
            ],
        }

        door_tids = {
            int(self.T_DOOR),
            int(self.T_DOOR_HOME),
            int(self.T_DOOR_LOCKED),
            int(self.T_DOOR_HOME_LOCKED),
            int(self.T_DOOR_BROKEN),
        }

        def prop_tile(pr: object) -> tuple[int, int] | None:
            try:
                p = pygame.Vector2(getattr(pr, "pos", pygame.Vector2(0, 0)))
            except Exception:
                return None
            tx = int(math.floor(float(p.x) / float(self.TILE_SIZE)))
            ty = int(math.floor(float(p.y) / float(self.TILE_SIZE)))
            return int(tx), int(ty)

        def is_walkable_tid(tid: int) -> bool:
            tid = int(tid)
            if tid in door_tids:
                return False
            return not bool(self._tile_solid(int(tid)))

        def find_nearest_door(tx: int, ty: int, *, r: int = 5) -> tuple[int, int] | None:
            best: tuple[int, int, int] | None = None
            for dy in range(-int(r), int(r) + 1):
                for dx in range(-int(r), int(r) + 1):
                    nx = int(tx + dx)
                    ny = int(ty + dy)
                    tid = int(self.world.get_tile(int(nx), int(ny)))
                    if int(tid) not in door_tids:
                        continue
                    d2 = int(dx * dx + dy * dy)
                    if best is None or int(d2) < int(best[0]):
                        best = (int(d2), int(nx), int(ny))
            return (int(best[1]), int(best[2])) if best is not None else None

        def building_key_at_door(tx: int, ty: int) -> tuple[int, int, int, int] | None:
            try:
                hit = self._peek_building_at_tile(int(tx), int(ty))
            except Exception:
                hit = None
            if hit is None:
                return None
            return (int(hit[0]), int(hit[1]), int(hit[2]), int(hit[3]))

        def find_inside_tile(bkey: tuple[int, int, int, int], door: tuple[int, int]) -> tuple[int, int] | None:
            tx0, ty0, bw, bh = (int(bkey[0]), int(bkey[1]), int(bkey[2]), int(bkey[3]))
            dx, dy = int(door[0]), int(door[1])
            for ox, oy in ((0, -1), (0, 1), (-1, 0), (1, 0)):
                nx = int(dx + ox)
                ny = int(dy + oy)
                if not (int(tx0) <= int(nx) < int(tx0 + bw) and int(ty0) <= int(ny) < int(ty0 + bh)):
                    continue
                tid = int(self.world.get_tile(int(nx), int(ny)))
                if not bool(is_walkable_tid(int(tid))):
                    continue
                return int(nx), int(ny)
            # Fallback: scan for any walkable interior tile.
            for ny in range(int(ty0) + 1, int(ty0 + bh) - 1):
                for nx in range(int(tx0) + 1, int(tx0 + bw) - 1):
                    tid = int(self.world.get_tile(int(nx), int(ny)))
                    if bool(is_walkable_tid(int(tid))):
                        return int(nx), int(ny)
            return None

        def find_adjacent_floor_to(
            bkey: tuple[int, int, int, int],
            target_tid: int,
            *,
            reachable: set[tuple[int, int]] | None = None,
        ) -> tuple[int, int] | None:
            tx0, ty0, bw, bh = (int(bkey[0]), int(bkey[1]), int(bkey[2]), int(bkey[3]))
            want = int(target_tid)
            for ty in range(int(ty0) + 1, int(ty0 + bh) - 1):
                for tx in range(int(tx0) + 1, int(tx0 + bw) - 1):
                    if int(self.world.get_tile(int(tx), int(ty))) != int(want):
                        continue
                    for ox, oy in ((0, -1), (0, 1), (-1, 0), (1, 0)):
                        nx = int(tx + ox)
                        ny = int(ty + oy)
                        if not (int(tx0) <= int(nx) < int(tx0 + bw) and int(ty0) <= int(ny) < int(ty0 + bh)):
                            continue
                        tid2 = int(self.world.get_tile(int(nx), int(ny)))
                        if bool(is_walkable_tid(int(tid2))) and (reachable is None or (int(nx), int(ny)) in reachable):
                            return int(nx), int(ny)
            return None

        def add_staff_npc(
            *,
            npc_id: str,
            name: str,
            tile: tuple[int, int],
            gender: int,
            outfit: int,
            script: str,
            role: str = "staff",
        ) -> None:
            npc_id = str(npc_id)
            if any(isinstance(n, dict) and str(n.get("id", "")) == npc_id for n in npcs):
                return
            tx, ty = int(tile[0]), int(tile[1])
            tid = int(self.world.get_tile(int(tx), int(ty)))
            if not bool(is_walkable_tid(int(tid))):
                return
            if self._peek_building_at_tile(int(tx), int(ty)) is None:
                return

            seed = 0
            for ch in npc_id:
                seed = (seed * 131 + ord(ch)) & 0xFFFFFFFF
            rng = random.Random(int(seed) ^ int(getattr(self, "seed", 0)) ^ 0x4C6E6B51)
            g = int(gender)
            av = SurvivalAvatar(
                gender=int(g),
                height=rng.choice([0, 1, 1, 2]),
                face=rng.randrange(0, 3),
                eyes=rng.randrange(0, 4),
                hair=rng.randrange(0, len(SURVIVAL_HAIR_OPTIONS)),
                nose=rng.randrange(0, 3),
                skin=rng.randrange(0, len(SURVIVAL_SKIN_OPTIONS)),
                hair_color=rng.randrange(0, len(SURVIVAL_HAIR_COLOR_OPTIONS)),
                eye_color=rng.randrange(0, len(SURVIVAL_EYE_COLOR_OPTIONS)),
                mouth=rng.randrange(0, len(SURVIVAL_MOUTH_OPTIONS)),
                beard=(rng.choice([0, 0, 1, 1, 2, 3]) if g == 0 else 0),
                makeup=(rng.choice([0, 1, 2]) if g != 0 else 0),
                accessory=(rng.choice([0, 0, 1, 2, 3]) if g != 0 else rng.choice([0, 0, 1])),
                outfit=int(outfit),
            )
            av.clamp_all()
            frames = HardcoreSurvivalState.build_avatar_player_frames(av, run=False)
            pos = pygame.Vector2((float(tx) + 0.5) * float(self.TILE_SIZE), (float(ty) + 0.5) * float(self.TILE_SIZE))
            npcs.append(
                {
                    "id": str(npc_id),
                    "name": str(name),
                    "pos": pygame.Vector2(pos),
                    "dir": "down",
                    "walk_phase": float(rng.random() * math.tau),
                    "vel": pygame.Vector2(0, 0),
                    "goal": pygame.Vector2(pos),
                    "goal_left": 0.0,
                    "axis": 0,
                    "stuck": 0.0,
                    "rng": rng,
                    "speed": 0.0,
                    "home": (int(tx), int(ty)),
                    "work": (int(tx), int(ty)),
                    "frames": frames,
                    "script": str(script),
                    "role": str(role),
                    "avatar": av,
                    "action": "",
                    "pose_phase": float(rng.random() * math.tau),
                    "stay_left": 0.0,
                    "pose_cache": {},
                }
            )
            try:
                npcs[-1]['spawn_fade_left'] = 0.24
                npcs[-1]['spawn_fade_total'] = 0.24
            except Exception:
                pass

        def reachable_in_building(
            bkey: tuple[int, int, int, int],
            start: tuple[int, int],
        ) -> set[tuple[int, int]]:
            tx0, ty0, bw, bh = (int(bkey[0]), int(bkey[1]), int(bkey[2]), int(bkey[3]))
            sx, sy = (int(start[0]), int(start[1]))
            if not (int(tx0) <= int(sx) < int(tx0 + bw) and int(ty0) <= int(sy) < int(ty0 + bh)):
                return set()
            seen: set[tuple[int, int]] = set()
            stack = [(int(sx), int(sy))]
            while stack and len(seen) < int(bw) * int(bh):
                x, y = stack.pop()
                x = int(x)
                y = int(y)
                if (x, y) in seen:
                    continue
                if not (int(tx0) <= int(x) < int(tx0 + bw) and int(ty0) <= int(y) < int(ty0 + bh)):
                    continue
                try:
                    tid = int(self.world.peek_tile(int(x), int(y)))
                except Exception:
                    continue
                if bool(self._tile_solid(int(tid))):
                    continue
                seen.add((x, y))
                stack.extend([(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)])
            return seen

        ptx, pty = self._player_tile()
        pcx = int(ptx) // int(self.CHUNK_SIZE)
        pcy = int(pty) // int(self.CHUNK_SIZE)
        scan_r = 2
        for cy in range(int(pcy) - int(scan_r), int(pcy) + int(scan_r) + 1):
            for cx in range(int(pcx) - int(scan_r), int(pcx) + int(scan_r) + 1):
                chunk = self.world.peek_chunk(int(cx), int(cy))
                if chunk is None:
                    continue
                props = getattr(chunk, "props", None)
                if not isinstance(props, list) or not props:
                    continue
                for pr in props:
                    pid = str(getattr(pr, "prop_id", "") or "")
                    staff_defs = staff_by_sign.get(pid)
                    if not staff_defs:
                        continue
                    pt = prop_tile(pr)
                    if pt is None:
                        continue
                    door = find_nearest_door(int(pt[0]), int(pt[1]), r=5)
                    if door is None:
                        continue
                    bkey = building_key_at_door(int(door[0]), int(door[1]))
                    if bkey is None:
                        continue
                    start_inside = find_inside_tile(bkey, door=(int(door[0]), int(door[1])))
                    if start_inside is None:
                        continue
                    reachable = reachable_in_building(bkey, start=start_inside)
                    if not reachable:
                        reachable = None

                    office_pc_spots: list[tuple[int, int]] | None = None
                    office_used: set[tuple[int, int]] = set()
                    office_occupied: set[tuple[int, int]] = set()
                    if str(pid) == "sign_office":
                        # Pre-compute distinct "stand spots" next to PCs so boss/secretary/employees
                        # won't all spawn on the same tile.
                        try:
                            tx0, ty0, bw, bh = (int(bkey[0]), int(bkey[1]), int(bkey[2]), int(bkey[3]))
                            office_pc_spots = []
                            for yy in range(int(ty0) + 1, int(ty0 + bh) - 1):
                                for xx in range(int(tx0) + 1, int(tx0 + bw) - 1):
                                    if int(self.world.get_tile(int(xx), int(yy))) != int(self.T_PC):
                                        continue
                                    for ox, oy in ((0, -1), (0, 1), (-1, 0), (1, 0)):
                                        nx = int(xx + ox)
                                        ny = int(yy + oy)
                                        if not (int(tx0) <= int(nx) < int(tx0 + bw) and int(ty0) <= int(ny) < int(ty0 + bh)):
                                            continue
                                        tid2 = int(self.world.get_tile(int(nx), int(ny)))
                                        if not bool(is_walkable_tid(int(tid2))):
                                            continue
                                        if reachable is not None and (int(nx), int(ny)) not in reachable:
                                            continue
                                        office_pc_spots.append((int(nx), int(ny)))
                            # Remove duplicates and sort by distance to the door (secretary near, boss far).
                            uniq: list[tuple[int, int]] = []
                            seen: set[tuple[int, int]] = set()
                            for p in office_pc_spots:
                                if p in seen:
                                    continue
                                seen.add(p)
                                uniq.append(p)
                            office_pc_spots = uniq
                            dx0, dy0 = int(door[0]), int(door[1])
                            office_pc_spots.sort(key=lambda p: (int(p[0]) - int(dx0)) ** 2 + (int(p[1]) - int(dy0)) ** 2)
                        except Exception:
                            office_pc_spots = None
                        # Existing NPCs in the building should not be overlapped.
                        try:
                            tx0, ty0, bw, bh = (int(bkey[0]), int(bkey[1]), int(bkey[2]), int(bkey[3]))
                            for n in npcs:
                                if not isinstance(n, dict):
                                    continue
                                try:
                                    p = pygame.Vector2(n.get("pos", pygame.Vector2(0, 0)))
                                except Exception:
                                    continue
                                ntx = int(math.floor(float(p.x) / float(self.TILE_SIZE)))
                                nty = int(math.floor(float(p.y) / float(self.TILE_SIZE)))
                                if int(tx0) <= int(ntx) < int(tx0 + bw) and int(ty0) <= int(nty) < int(ty0 + bh):
                                    office_occupied.add((int(ntx), int(nty)))
                        except Exception:
                            office_occupied = set()

                    # Choose staff placement by role.
                    for sdef in staff_defs:
                        role = str(sdef.get("role", "staff"))
                        spawn_key = (int(bkey[0]), int(bkey[1]), f"{pid}:{role}")
                        if spawn_key in spawned:
                            continue

                        spot = None
                        if office_pc_spots is not None and (
                            str(role) == "boss" or str(role) == "secretary" or str(role).startswith("employee")
                        ):
                            cand_list = list(reversed(office_pc_spots)) if str(role) == "boss" else list(office_pc_spots)
                            for cand in cand_list:
                                if cand in office_used or cand in office_occupied:
                                    continue
                                spot = (int(cand[0]), int(cand[1]))
                                office_used.add(cand)
                                break
                        if role in ("doctor", "cashier", "clerk", "waiter"):
                            spot = find_adjacent_floor_to(bkey, int(self.T_TABLE), reachable=reachable)
                        elif role in ("nurse",):
                            spot = find_adjacent_floor_to(bkey, int(self.T_BED), reachable=reachable)
                        elif role in ("stocker", "chef"):
                            spot = find_adjacent_floor_to(bkey, int(self.T_SHELF), reachable=reachable)
                        elif role in ("boss", "secretary") or str(role).startswith("employee"):
                            spot = find_adjacent_floor_to(bkey, int(self.T_PC), reachable=reachable)
                        if spot is None:
                            spot = start_inside
                        if spot is None:
                            continue

                        npc_id = f"staff_{pid}_{int(bkey[0])}_{int(bkey[1])}_{role}"
                        add_staff_npc(
                            npc_id=npc_id,
                            name=str(sdef.get("name", "")),
                            tile=(int(spot[0]), int(spot[1])),
                            gender=int(sdef.get("gender", 0)),
                            outfit=int(sdef.get("outfit", 0)),
                            script=str(sdef.get("script", "")),
                            role=str(role),
                        )
                        spawned.add(spawn_key)

    def _crime_level_from_heat(self, heat: float) -> int:
        heat = float(max(0.0, float(heat)))
        if heat < 1.0:
            return 0
        if heat < 20.0:
            return 1
        if heat < 40.0:
            return 2
        if heat < 60.0:
            return 3
        if heat < 80.0:
            return 4
        return 5

    def _crime_add(self, heat: float, reason: str) -> None:
        # Add heat during the pre-apocalypse sandbox (GTA-like wanted system).
        if not bool(getattr(self, "story_enabled", False)):
            return
        if not bool(self._story_is_pre_apocalypse()):
            return
        heat = float(max(0.0, float(heat)))
        if heat <= 0.0:
            return

        cur = float(getattr(self, "crime_heat", 0.0))
        cur2 = float(clamp(float(cur) + float(heat), 0.0, 100.0))
        self.crime_heat = float(cur2)
        self.crime_last_reason = str(reason or "")

        prev_lvl = int(getattr(self, "wanted_level", 0))
        lvl = int(self._crime_level_from_heat(cur2))
        self.wanted_level = int(lvl)

        if int(lvl) <= 0:
            return
        if int(lvl) >= 2 and int(prev_lvl) < 2:
            self._set_hint(f" {lvl}", seconds=1.2)
            return
        if str(reason).strip():
            self._set_hint(f" {lvl}{str(reason).strip()}", seconds=1.0)
        else:
            self._set_hint(f" {lvl}", seconds=0.9)

    def _crime_clear_units(self) -> None:
        # Remove police cars and police NPCs (used when wanted clears or story ends).
        try:
            traffic = getattr(self, "story_traffic", None)
            if isinstance(traffic, list) and traffic:
                traffic[:] = [a for a in traffic if not (isinstance(a, dict) and str(a.get("tag", "")) == "police")]
        except Exception:
            pass
        try:
            npcs = getattr(self, "npcs", None)
            if isinstance(npcs, list) and npcs:
                npcs[:] = [
                    n
                    for n in npcs
                    if not (isinstance(n, dict) and str(n.get("role", "")) in ("police", "swat"))
                ]
        except Exception:
            pass

    def _crime_update(self, dt_time: float) -> None:
        if not bool(getattr(self, "story_enabled", False)) or not bool(self._story_is_pre_apocalypse()):
            if int(getattr(self, "wanted_level", 0)) > 0 or float(getattr(self, "crime_heat", 0.0)) > 0.0:
                self._crime_clear_units()
            self.crime_heat = 0.0
            self.wanted_level = 0
            self.crime_spawn_left = 0.0
            self.crime_last_reason = ""
            self.crime_heli_phase = 0.0
            return

        dt_time = float(max(0.0, float(dt_time)))
        if dt_time <= 1e-6:
            return

        # Decay wanted heat (faster when hidden indoors).
        heat = float(getattr(self, "crime_heat", 0.0))
        prev_lvl = int(getattr(self, "wanted_level", self._crime_level_from_heat(heat)))
        inside = getattr(self, "_inside_building_key", None) is not None
        if bool(getattr(self, "hr_interior", False)) or bool(getattr(self, "house_interior", False)) or bool(getattr(self, "sch_interior", False)):
            inside = True

        decay = 3.2
        if inside:
            decay = 6.0
        if prev_lvl >= 4:
            decay *= 0.55
        elif prev_lvl >= 2:
            decay *= 0.75
        heat = float(max(0.0, float(heat) - float(decay) * float(dt_time)))
        self.crime_heat = float(heat)

        lvl = int(self._crime_level_from_heat(heat))
        self.wanted_level = int(lvl)
        if lvl >= 5:
            self.crime_heli_phase = float(getattr(self, "crime_heli_phase", 0.0)) + float(dt_time) * 3.2
        else:
            self.crime_heli_phase = float(getattr(self, "crime_heli_phase", 0.0)) * 0.85

        # Cooldown between spawns so police trickle in rather than popping a crowd.
        spawn_left = float(getattr(self, "crime_spawn_left", 0.0))
        spawn_left = float(max(0.0, float(spawn_left) - float(dt_time)))
        self.crime_spawn_left = float(spawn_left)

        if lvl <= 0:
            if prev_lvl > 0:
                self._set_hint("", seconds=1.0)
            self._crime_clear_units()
            return

        # Level 1: only a warning; level 2+: police respond.
        desired_cars = 0
        desired_police = 0
        desired_swat = 0
        if lvl >= 2:
            desired_cars = 1
            desired_police = 2
        if lvl >= 3:
            desired_cars = 2
            desired_police = 3
        if lvl >= 4:
            desired_cars = 3
            desired_police = 4
        if lvl >= 5:
            desired_cars = 4
            desired_police = 4
            desired_swat = 2

        # If the player is in a full-screen interior, don't spawn new units (they'll wait outside).
        blocked = bool(getattr(self, "hr_interior", False)) or bool(getattr(self, "house_interior", False)) or bool(getattr(self, "sch_interior", False))

        # Ensure traffic list exists so police cars can reuse its movement/collision.
        traffic = getattr(self, "story_traffic", None)
        if not isinstance(traffic, list):
            self.story_traffic = []
            traffic = self.story_traffic

        # Ensure NPC list exists for police on foot.
        npcs = getattr(self, "npcs", None)
        if not isinstance(npcs, list):
            self.npcs = []
            npcs = self.npcs

        rng = getattr(self, "story_traffic_rng", None)
        if not isinstance(rng, random.Random):
            rng = random.Random(int(getattr(self, "seed", 0)) ^ 0x54B3_9C21)
            self.story_traffic_rng = rng

        def ensure_police_car() -> None:
            nonlocal spawn_left
            if bool(blocked) or float(spawn_left) > 0.0:
                return
            center = self._player_tile()
            actor = None
            for _ in range(60):
                cand = self._story_spawn_one_traffic(rng=rng, center_tile=(int(center[0]), int(center[1])), radius=70)
                if isinstance(cand, dict):
                    if str(cand.get("kind", "")) == "car":
                        actor = cand
                        break
                    actor = cand
            if not isinstance(actor, dict):
                return
            d = str(actor.get("dir", "right") or "right")
            heading = 0.0
            if d == "left":
                heading = math.pi
            elif d == "down":
                heading = math.pi / 2.0
            elif d == "up":
                heading = -math.pi / 2.0
            actor["kind"] = "car"
            actor["model_id"] = "police"
            actor["tag"] = "police"
            actor["pinned"] = True
            actor["speed"] = float(86.0 + 8.0 * float(lvl))
            actor["turn_cd"] = 0.0
            actor["heading"] = float(heading)
            actor["steer_state"] = 0
            actor["frame"] = int(rng.randrange(0, 2))
            # Remove any rider/convertible decoration from reused actors.
            for k in ("driver_style", "driver_avatar", "rider_avatar", "rider_frames"):
                actor.pop(k, None)
            traffic.append(actor)
            spawn_left = 0.7
            self.crime_spawn_left = float(spawn_left)

        def spawn_police_npc(*, role: str) -> None:
            nonlocal spawn_left
            if bool(blocked) or float(spawn_left) > 0.0:
                return
            role = str(role)
            base_name = "" if role == "police" else ""
            outfit = 2 if role == "police" else 12
            # Find a spawn tile on/near roads, outside buildings, not on solid tiles.
            ptx, pty = self._player_tile()
            tx_best = None
            ty_best = None
            player_center = pygame.Vector2((float(ptx) + 0.5) * float(self.TILE_SIZE), (float(pty) + 0.5) * float(self.TILE_SIZE))
            view_r = float(math.hypot(float(INTERNAL_W) * 0.5, float(INTERNAL_H) * 0.5))
            max_spawn_r = float(22.0 * float(self.TILE_SIZE))
            min_spawn_dist = float(min(float(view_r + float(self.TILE_SIZE) * 2.0), float(max_spawn_r * 0.85)))
            min_spawn_dist2 = float(min_spawn_dist * min_spawn_dist)
            for _ in range(140):
                tx = int(ptx + rng.randint(-22, 22))
                ty = int(pty + rng.randint(-22, 22))
                wx = (float(tx) + 0.5) * float(self.TILE_SIZE)
                wy = (float(ty) + 0.5) * float(self.TILE_SIZE)
                if float((pygame.Vector2(wx, wy) - player_center).length_squared()) < float(min_spawn_dist2):
                    continue
                if abs(int(tx) - int(ptx)) < 10 and abs(int(ty) - int(pty)) < 10:
                    continue
                try:
                    if self._peek_building_at_tile(int(tx), int(ty)) is not None:
                        continue
                except Exception:
                    pass
                try:
                    tid = int(self.world.peek_tile(int(tx), int(ty), default=int(self.T_GRASS)))
                except Exception:
                    tid = int(self.T_GRASS)
                if bool(self._tile_solid(int(tid))):
                    continue
                try:
                    on_road = bool(self.world.is_road(int(tx), int(ty)))
                except Exception:
                    on_road = False
                if not on_road and int(tid) not in (int(self.T_PAVEMENT), int(self.T_SIDEWALK), int(self.T_ROAD), int(self.T_HIGHWAY)):
                    continue
                tx_best, ty_best = int(tx), int(ty)
                break
            if tx_best is None or ty_best is None:
                return

            # Pick an unused id.
            used: set[str] = set()
            for n in npcs:
                if isinstance(n, dict):
                    used.add(str(n.get("id", "")))
            idx = 1
            while f"{role}_{idx}" in used and idx < 99:
                idx += 1
            npc_id = f"{role}_{idx}"

            g = 0 if role == "police" else 0
            av = SurvivalAvatar(
                gender=int(g),
                height=int(rng.choice([1, 1, 2])),
                face=int(rng.randrange(0, 3)),
                eyes=int(rng.randrange(0, 4)),
                hair=int(rng.randrange(0, len(SURVIVAL_HAIR_OPTIONS))),
                nose=int(rng.randrange(0, 3)),
                skin=int(rng.randrange(0, len(SURVIVAL_SKIN_OPTIONS))),
                hair_color=int(rng.randrange(0, len(SURVIVAL_HAIR_COLOR_OPTIONS))),
                eye_color=int(rng.randrange(0, len(SURVIVAL_EYE_COLOR_OPTIONS))),
                mouth=int(rng.randrange(0, len(SURVIVAL_MOUTH_OPTIONS))),
                beard=int(rng.choice([0, 0, 1, 1, 2])) if int(g) == 0 else 0,
                makeup=0,
                accessory=int(rng.choice([0, 1])),
                outfit=int(outfit),
            )
            av.clamp_all()
            frames = HardcoreSurvivalState.build_avatar_player_frames(av, run=False)
            pos = pygame.Vector2((float(tx_best) + 0.5) * float(self.TILE_SIZE), (float(ty_best) + 0.5) * float(self.TILE_SIZE))
            npcs.append(
                {
                    "id": npc_id,
                    "name": base_name,
                    "pos": pygame.Vector2(pos),
                    "dir": "down",
                    "walk_phase": float(rng.random() * math.tau),
                    "vel": pygame.Vector2(0, 0),
                    "goal": pygame.Vector2(pos),
                    "goal_left": 0.0,
                    "axis": 0,
                    "stuck": 0.0,
                    "rng": random.Random(int(rng.randrange(0, 2**31 - 1)) ^ 0x6F6C6963),
                    "speed": 86.0 if role == "police" else 92.0,
                    "home": (int(tx_best), int(ty_best)),
                    "work": (int(tx_best), int(ty_best)),
                    "frames": frames,
                    "script": "",
                    "role": role,
                    "avatar": av,
                    "action": "",
                    "pose_phase": float(rng.random() * math.tau),
                    "stay_left": 0.0,
                    "pose_cache": {},
                    "hostile_left": 3.0,
                    "attack_left": 0.0,
                    "attack_anim_left": 0.0,
                }
            )
            try:
                npcs[-1]['spawn_fade_left'] = 0.24
                npcs[-1]['spawn_fade_total'] = 0.24
            except Exception:
                pass
            spawn_left = 0.6
            self.crime_spawn_left = float(spawn_left)

        # Keep police NPCs hostile while wanted is active.
        for n in npcs:
            if not isinstance(n, dict):
                continue
            if str(n.get("role", "")) in ("police", "swat"):
                n["hostile_left"] = float(max(float(n.get("hostile_left", 0.0) or 0.0), 1.6))
                n["speed"] = float(max(float(n.get("speed", 28.0) or 28.0), 86.0))

        # Police cars: keep them pinned and fast.
        police_cars = [a for a in traffic if isinstance(a, dict) and str(a.get("tag", "")) == "police"]
        for a in police_cars:
            a["pinned"] = True
            a["kind"] = "car"
            a["model_id"] = "police"
            a["speed"] = float(max(float(a.get("speed", 0.0) or 0.0), 86.0 + 8.0 * float(lvl)))

        # Remove extras if wanted level dropped.
        if len(police_cars) > int(desired_cars):
            extra = police_cars[int(desired_cars) :]
            for a in extra:
                try:
                    traffic.remove(a)
                except Exception:
                    pass

        # Remove extra cops/swat (when wanted drops).
        police_npcs = [n for n in npcs if isinstance(n, dict) and str(n.get("role", "")) == "police"]
        swat_npcs = [n for n in npcs if isinstance(n, dict) and str(n.get("role", "")) == "swat"]
        if len(swat_npcs) > int(desired_swat):
            for n in swat_npcs[int(desired_swat) :]:
                try:
                    npcs.remove(n)
                except Exception:
                    pass
        if len(police_npcs) > int(desired_police):
            for n in police_npcs[int(desired_police) :]:
                try:
                    npcs.remove(n)
                except Exception:
                    pass

        # Spawn missing units (one per cooldown tick).
        if lvl >= 2:
            police_cars = [a for a in traffic if isinstance(a, dict) and str(a.get("tag", "")) == "police"]
            police_npcs = [n for n in npcs if isinstance(n, dict) and str(n.get("role", "")) == "police"]
            swat_npcs = [n for n in npcs if isinstance(n, dict) and str(n.get("role", "")) == "swat"]

            if len(police_cars) < int(desired_cars):
                ensure_police_car()
            elif lvl >= 5 and len(swat_npcs) < int(desired_swat):
                spawn_police_npc(role="swat")
            elif len(police_npcs) < int(desired_police):
                spawn_police_npc(role="police")

    def _draw_wanted_helicopter_overlay(self, surface: pygame.Surface) -> None:
        # Minimal "helicopter spotlight" for wanted level 5 (visual pressure).
        if int(getattr(self, "wanted_level", 0)) < 5:
            return
        if not bool(getattr(self, "story_enabled", False)) or not bool(self._story_is_pre_apocalypse()):
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return
        if getattr(self, "_inside_building_key", None) is not None:
            return
        try:
            phase = float(getattr(self, "crime_heli_phase", 0.0))
        except Exception:
            phase = 0.0

        anchor = getattr(self, "_last_player_screen_rect", None)
        if not isinstance(anchor, pygame.Rect):
            anchor = pygame.Rect(INTERNAL_W // 2 - 6, INTERNAL_H // 2 - 10, 12, 20)
        cx = int(anchor.centerx)
        cy = int(anchor.centery - 8)
        r = 96

        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        pygame.draw.circle(overlay, (190, 210, 255, 22), (cx, cy), r)
        ex = int(cx + math.cos(float(phase)) * float(r))
        ey = int(cy + math.sin(float(phase)) * float(r))
        pygame.draw.line(overlay, (230, 230, 255, 55), (cx, cy), (ex, ey), 2)
        pygame.draw.circle(overlay, (230, 230, 255, 40), (ex, ey), 3)
        surface.blit(overlay, (0, 0))

    def _speech_say(self, text: str, *, seconds: float = 1.2) -> None:
        self.speech_text = str(text)
        self.speech_left = float(max(0.0, float(seconds)))

    def _draw_speech_bubble(self, surface: pygame.Surface) -> None:
        if float(getattr(self, "speech_left", 0.0)) <= 0.0:
            return
        text = str(getattr(self, "speech_text", "")).strip()
        if not text:
            return
        try:
            font = self.app.font_s
            max_w = int(min(180, INTERNAL_W - 16))

            lines: list[str] = []
            cur = ""
            for ch in text:
                test = cur + ch
                if cur and font.size(test)[0] > max_w:
                    lines.append(cur)
                    cur = ch
                else:
                    cur = test
            if cur:
                lines.append(cur)
            drawn = lines[:2] if lines else [""]

            pad_x = 10
            pad_y = 8
            line_gap = 2
            tail_h = 8
            tail_w = 12
            bubble_bg = (0, 0, 0, 180)
            bubble_border = (220, 220, 235, 140)
            bubble_hi = (240, 220, 140, 20)

            content_w = max(1, max(int(font.size(str(ln))[0]) for ln in drawn))
            bubble_w = int(clamp(int(content_w + pad_x * 2), 64, INTERNAL_W - 12))
            bubble_h = int(clamp(int(len(drawn) * (font.get_height() + line_gap) + pad_y * 2), 30, 90))

            anchor = getattr(self, "_last_player_screen_rect", None)
            if not isinstance(anchor, pygame.Rect):
                anchor = pygame.Rect(INTERNAL_W // 2 - 6, INTERNAL_H // 2 - 10, 12, 20)
            mouth_x = int(anchor.centerx)
            mouth_y = int(anchor.top + max(2, int(anchor.h) // 4))

            # Tail tip position (screen).
            tip_x = int(mouth_x)
            tip_y = int(mouth_y - 2)

            bubble_surf = pygame.Surface((bubble_w, bubble_h + tail_h), pygame.SRCALPHA)
            panel = pygame.Surface((bubble_w, bubble_h), pygame.SRCALPHA)
            panel.fill(bubble_bg)
            pygame.draw.rect(panel, bubble_hi, panel.get_rect(), border_radius=10)
            pygame.draw.rect(panel, bubble_border, panel.get_rect(), 2, border_radius=10)
            bubble_surf.blit(panel, (0, 0))

            out = bubble_surf.get_rect(centerx=tip_x, bottom=tip_y + 1)
            out.left = int(clamp(int(out.left), 6, INTERNAL_W - out.w - 6))
            out.top = int(clamp(int(out.top), 6, INTERNAL_H - out.h - 6))

            tip_x_local = int(clamp(int(tip_x - out.left), 10, bubble_w - 11))
            base_y = int(bubble_h - 1)
            tip_y_local = int(bubble_h + tail_h - 1)
            tail = [(tip_x_local - tail_w // 2, base_y), (tip_x_local + tail_w // 2, base_y), (tip_x_local, tip_y_local)]
            pygame.draw.polygon(bubble_surf, bubble_bg, tail)
            pygame.draw.polygon(bubble_surf, bubble_border, tail, 2)

            tx = pad_x
            ty = pad_y
            for ln in drawn:
                bubble_surf.blit(font.render(str(ln), False, pygame.Color(230, 230, 240)), (tx, ty))
                ty += int(font.get_height() + line_gap)

            surface.blit(bubble_surf, out.topleft)
        except Exception:
            return

    def _draw_toilet_task_ui(self, surface: pygame.Surface) -> None:
        task = getattr(self, "toilet_task", None)
        if not isinstance(task, dict):
            return
        if getattr(self, "mount", None) is not None:
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return
        if str(getattr(self, "player_pose", "")) != "sit" or str(getattr(self, "player_pose_space", "")) != "world":
            return

        total = float(task.get("total", 1.0))
        left = float(task.get("left", 0.0))
        if total <= 1e-4:
            return
        p = float(clamp((total - left) / total, 0.0, 1.0))
        kind = str(task.get("kind", "pee"))

        label = "..." if kind == "poop" else "..."
        pct_text = f"{int(round(p * 100.0)):d}%"
        lines = [label, pct_text]

        try:
            font = self.app.font_s
            pad_x = 8
            pad_y = 6
            line_gap = 2
            tail_h = 6
            tail_w = 10
            bubble_bg = (0, 0, 0, 160)
            bubble_border = (220, 220, 235, 110)
            bubble_hi = (240, 220, 140, 18)

            font_h = int(font.get_height())
            content_w = max(1, max(int(font.size(str(ln))[0]) for ln in lines))
            bar_h = 6
            bar_gap = 4
            bubble_w = int(clamp(int(max(content_w + pad_x * 2, 84)), 84, INTERNAL_W - 12))
            bubble_h = int(clamp(int(pad_y * 2 + font_h + bar_gap + bar_h + bar_gap + font_h), 34, 78))

            anchor = getattr(self, "_last_player_screen_rect", None)
            if not isinstance(anchor, pygame.Rect):
                anchor = pygame.Rect(INTERNAL_W // 2 - 6, INTERNAL_H // 2 - 10, 12, 20)
            mouth_x = int(anchor.centerx)
            mouth_y = int(anchor.top + max(2, int(anchor.h) // 4))

            tip_x = int(mouth_x)
            tip_y = int(mouth_y - 12)

            bubble_surf = pygame.Surface((bubble_w, bubble_h + tail_h), pygame.SRCALPHA)
            panel = pygame.Surface((bubble_w, bubble_h), pygame.SRCALPHA)
            panel.fill(bubble_bg)
            pygame.draw.rect(panel, bubble_hi, panel.get_rect(), border_radius=10)
            pygame.draw.rect(panel, bubble_border, panel.get_rect(), 2, border_radius=10)
            bubble_surf.blit(panel, (0, 0))

            out = bubble_surf.get_rect(centerx=tip_x, bottom=tip_y + 1)
            out.left = int(clamp(int(out.left), 6, INTERNAL_W - out.w - 6))
            out.top = int(clamp(int(out.top), 6, INTERNAL_H - out.h - 6))

            tip_x_local = int(clamp(int(tip_x - out.left), 10, bubble_w - 11))
            base_y = int(bubble_h - 1)
            tip_y_local = int(bubble_h + tail_h - 1)
            tail = [(tip_x_local - tail_w // 2, base_y), (tip_x_local + tail_w // 2, base_y), (tip_x_local, tip_y_local)]
            pygame.draw.polygon(bubble_surf, bubble_bg, tail)
            pygame.draw.polygon(bubble_surf, bubble_border, tail, 2)

            text_col = pygame.Color(230, 230, 240)
            bubble_surf.blit(font.render(str(label), False, text_col), (pad_x, pad_y))

            bar_x = int(pad_x)
            bar_y = int(pad_y + font_h + bar_gap)
            bar_w = int(bubble_w - pad_x * 2)
            bar_rect = pygame.Rect(bar_x, bar_y, bar_w, bar_h)
            pygame.draw.rect(bubble_surf, (0, 0, 0, 130), bar_rect, border_radius=3)
            pygame.draw.rect(bubble_surf, (220, 220, 235, 120), bar_rect, 1, border_radius=3)
            inner = bar_rect.inflate(-2, -2)
            if inner.w > 0 and inner.h > 0:
                fill_w = int(clamp(int(round(float(inner.w) * p)), 0, inner.w))
                if fill_w > 0:
                    fill_col = (210, 180, 120, 210) if kind == "poop" else (120, 190, 230, 210)
                    bubble_surf.fill(fill_col, pygame.Rect(inner.x, inner.y, fill_w, inner.h))
                for i in range(1, 10):
                    x = int(inner.x + (inner.w * i) / 10.0)
                    if inner.x < x < inner.right:
                        bubble_surf.fill((0, 0, 0, 60), pygame.Rect(x, inner.y, 1, inner.h))

            pct_spr = font.render(str(pct_text), False, text_col)
            pct_y = int(bar_rect.bottom + bar_gap - 1)
            bubble_surf.blit(pct_spr, (int(bubble_w - pad_x - pct_spr.get_width()), pct_y))

            surface.blit(bubble_surf, out.topleft)
        except Exception:
            return

    def _draw_work_task_ui(self, surface: pygame.Surface) -> None:
        task = getattr(self, "work_task", None)
        if not isinstance(task, dict):
            return
        if getattr(self, "mount", None) is not None:
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return
        if str(getattr(self, "player_pose", "")) != "sit" or str(getattr(self, "player_pose_space", "")) != "world":
            return

        total = float(task.get("total", 1.0))
        left = float(task.get("left", 0.0))
        if total <= 1e-4:
            return
        p = float(clamp((total - left) / total, 0.0, 1.0))

        label = "?.."
        label = "..."
        pct_text = f"{int(round(p * 100.0)):d}%"
        lines = [label, pct_text]

        try:
            font = self.app.font_s
            pad_x = 8
            pad_y = 6
            bar_h = 6
            bar_gap = 4
            tail_h = 6
            tail_w = 10
            bubble_bg = (0, 0, 0, 160)
            bubble_border = (220, 220, 235, 110)
            bubble_hi = (160, 220, 255, 18)

            font_h = int(font.get_height())
            content_w = max(1, max(int(font.size(str(ln))[0]) for ln in lines))
            bubble_w = int(clamp(int(max(content_w + pad_x * 2, 84)), 84, INTERNAL_W - 12))
            bubble_h = int(clamp(int(pad_y * 2 + font_h + bar_gap + bar_h + bar_gap + font_h), 34, 78))

            anchor = getattr(self, "_last_player_screen_rect", None)
            if not isinstance(anchor, pygame.Rect):
                anchor = pygame.Rect(INTERNAL_W // 2 - 6, INTERNAL_H // 2 - 10, 12, 20)
            mouth_x = int(anchor.centerx)
            mouth_y = int(anchor.top + max(2, int(anchor.h) // 4))

            tip_x = int(mouth_x)
            tip_y = int(mouth_y - 12)

            bubble_surf = pygame.Surface((bubble_w, bubble_h + tail_h), pygame.SRCALPHA)
            panel = pygame.Surface((bubble_w, bubble_h), pygame.SRCALPHA)
            panel.fill(bubble_bg)
            pygame.draw.rect(panel, bubble_hi, panel.get_rect(), border_radius=10)
            pygame.draw.rect(panel, bubble_border, panel.get_rect(), 2, border_radius=10)
            bubble_surf.blit(panel, (0, 0))

            out = bubble_surf.get_rect(centerx=tip_x, bottom=tip_y + 1)
            out.left = int(clamp(int(out.left), 6, INTERNAL_W - out.w - 6))
            out.top = int(clamp(int(out.top), 6, INTERNAL_H - out.h - 6))

            tip_x_local = int(clamp(int(tip_x - out.left), 10, bubble_w - 11))
            base_y = int(bubble_h - 1)
            tip_y_local = int(bubble_h + tail_h - 1)
            tail = [(tip_x_local - tail_w // 2, base_y), (tip_x_local + tail_w // 2, base_y), (tip_x_local, tip_y_local)]
            pygame.draw.polygon(bubble_surf, bubble_bg, tail)
            pygame.draw.polygon(bubble_surf, bubble_border, tail, 2)

            text_col = pygame.Color(230, 230, 240)
            bubble_surf.blit(font.render(str(label), False, text_col), (pad_x, pad_y))

            bar_x = int(pad_x)
            bar_y = int(pad_y + font_h + bar_gap)
            bar_w = int(bubble_w - pad_x * 2)
            bar_rect = pygame.Rect(bar_x, bar_y, bar_w, bar_h)
            pygame.draw.rect(bubble_surf, (0, 0, 0, 130), bar_rect, border_radius=3)
            pygame.draw.rect(bubble_surf, (220, 220, 235, 120), bar_rect, 1, border_radius=3)
            inner = bar_rect.inflate(-2, -2)
            if inner.w > 0 and inner.h > 0:
                fill_w = int(clamp(int(round(float(inner.w) * p)), 0, inner.w))
                if fill_w > 0:
                    bubble_surf.fill((160, 220, 255, 210), pygame.Rect(inner.x, inner.y, fill_w, inner.h))
                for i in range(1, 10):
                    x = int(inner.x + (inner.w * i) / 10.0)
                    if inner.x < x < inner.right:
                        bubble_surf.fill((0, 0, 0, 60), pygame.Rect(x, inner.y, 1, inner.h))

            pct_spr = font.render(str(pct_text), False, text_col)
            pct_y = int(bar_rect.bottom + bar_gap - 1)
            bubble_surf.blit(pct_spr, (int(bubble_w - pad_x - pct_spr.get_width()), pct_y))

            surface.blit(bubble_surf, out.topleft)
        except Exception:
            return

    def _maybe_show_home_highrise_dialog(self) -> None:
        # Show a small home guidance dialog when the player walks up to their
        # home high-rise entrance on the world map.
        if bool(getattr(self, "dialog_open", False)):
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return
        home = getattr(self, "home_highrise_door", None)
        if home is None or not isinstance(home, tuple) or len(home) != 2:
            return
        try:
            hx, hy = int(home[0]), int(home[1])
        except Exception:
            return
        center = pygame.Vector2((float(hx) + 0.5) * float(self.TILE_SIZE), (float(hy) + 0.5) * float(self.TILE_SIZE))
        d2 = float((pygame.Vector2(self.player.pos) - center).length_squared())
        near = float(self.TILE_SIZE) * 3.2
        far = float(self.TILE_SIZE) * 4.8
        armed = bool(getattr(self, "home_highrise_dialog_armed", True))
        if armed and d2 <= near * near:
            self._speech_say("62", seconds=1.7)
            self.home_highrise_dialog_armed = False
            return
            home_floor = int(getattr(self, "home_highrise_floor", 0))
            home_room = str(getattr(self, "home_highrise_room", "")).strip()
            if home_floor > 0 and home_room:
                line1 = f"{home_room}{home_floor}F"
            elif home_floor > 0:
                line1 = f" {home_floor}F"
            else:
                line1 = ""
            line2 = f" {home_floor}F" if home_floor > 0 else ""
            self._dialog_start("", [line1, line2], speed=44.0)
            self.home_highrise_dialog_armed = False
            return
        if (not armed) and d2 >= far * far:
            self.home_highrise_dialog_armed = True

    def _draw_dialog(self, surface: pygame.Surface) -> None:
        if not bool(getattr(self, "dialog_open", False)):
            return
        title = str(getattr(self, "dialog_title", "")).strip() or ""
        full = str(getattr(self, "dialog_text_full", ""))
        shown = full[: int(max(0.0, float(getattr(self, "dialog_reveal", 0.0))))]

        # Speech bubble near the player (feels like it's "spoken" by the character).
        try:
            font = self.app.font_s
            max_w = int(min(220, INTERNAL_W - 16))

            lines: list[str] = []
            for para in str(shown).split("\n"):
                cur = ""
                for ch in para:
                    test = cur + ch
                    if cur and font.size(test)[0] > max_w:
                        lines.append(cur)
                        cur = ch
                    else:
                        cur = test
                lines.append(cur)
            while len(lines) > 1 and not str(lines[-1]).strip():
                lines.pop()

            drawn = lines[:3]
            if not drawn:
                drawn = [""]

            pad_x = 10
            pad_y = 8
            line_gap = 2
            tail_h = 8
            tail_w = 12
            bubble_bg = (0, 0, 0, 180)
            bubble_border = (220, 220, 235, 140)
            bubble_hi = (240, 220, 140, 20)

            def ellipsize(text: str, max_w: int) -> str:
                text = str(text)
                max_w = int(max_w)
                if max_w <= 0 or font.size(text)[0] <= max_w:
                    return text
                suffix = ""
                lo = 0
                hi = len(text)
                while lo < hi:
                    mid = (lo + hi) // 2
                    cand = text[:mid].rstrip() + suffix
                    if font.size(cand)[0] <= max_w:
                        lo = mid + 1
                    else:
                        hi = mid
                return text[: max(0, lo - 1)].rstrip() + suffix

            content_w = max(1, max(int(font.size(str(ln))[0]) for ln in drawn))
            tag_title = str(title) if title and title != "" else ""
            tag_w = int(font.size(tag_title)[0]) if tag_title else 0
            tip_text = "/Enter" if self._dialog_finished() else ""
            tip_w = int(font.size(tip_text)[0]) if tip_text else 0
            need_w = int(max(int(content_w), int(tag_w), int(tip_w) + 8))
            bubble_w = int(clamp(int(need_w + pad_x * 2), 96, INTERNAL_W - 12))
            bubble_h = int(clamp(int(len(drawn) * (font.get_height() + line_gap) + pad_y * 2), 36, 120))

            anchor = getattr(self, "_last_player_screen_rect", None)
            if not isinstance(anchor, pygame.Rect):
                anchor = pygame.Rect(INTERNAL_W // 2 - 6, INTERNAL_H // 2 - 10, 12, 20)
            mouth_x = int(anchor.centerx)
            mouth_y = int(anchor.top + max(2, int(anchor.h) // 4))

            # Tail tip position (screen).
            tip_x = int(mouth_x)
            tip_y = int(mouth_y - 2)

            bubble_surf = pygame.Surface((bubble_w, bubble_h + tail_h), pygame.SRCALPHA)
            panel = pygame.Surface((bubble_w, bubble_h), pygame.SRCALPHA)
            panel.fill(bubble_bg)
            pygame.draw.rect(panel, bubble_hi, panel.get_rect(), border_radius=10)
            pygame.draw.rect(panel, bubble_border, panel.get_rect(), 2, border_radius=10)
            bubble_surf.blit(panel, (0, 0))

            out = bubble_surf.get_rect(centerx=tip_x, bottom=tip_y + 1)
            if out.left < 4:
                out.left = 4
            if out.right > INTERNAL_W - 4:
                out.right = INTERNAL_W - 4
            if out.top < 4:
                out.top = 4
            if out.bottom > INTERNAL_H - 4:
                out.bottom = INTERNAL_H - 4

            tip_x_local = int(clamp(int(tip_x - out.left), 10, bubble_w - 11))
            base_y = int(bubble_h - 1)
            tip_y_local = int(bubble_h + tail_h - 1)
            tail = [(tip_x_local - tail_w // 2, base_y), (tip_x_local + tail_w // 2, base_y), (tip_x_local, tip_y_local)]
            pygame.draw.polygon(bubble_surf, bubble_bg, tail)
            pygame.draw.polygon(bubble_surf, bubble_border, tail, 2)

            tx = pad_x
            ty = pad_y
            for ln in drawn:
                bubble_surf.blit(font.render(str(ln), False, pygame.Color(230, 230, 240)), (tx, ty))
                ty += int(font.get_height() + line_gap)

            if not self._dialog_finished() and (int(float(getattr(self, "dialog_blink", 0.0)) * 3.0) % 2 == 0):
                last_ln = str(drawn[-1]) if drawn else ""
                cx = tx + max(0, int(font.size(last_ln)[0]))
                cy = ty - int(font.get_height() + line_gap)
                bubble_surf.blit(font.render("|", False, pygame.Color(240, 220, 140)), (cx, cy))

            if self._dialog_finished():
                tip = ellipsize("/Enter", int(bubble_w - 16))
                bubble_surf.blit(
                    font.render(tip, False, pygame.Color(170, 170, 180)),
                    (bubble_w - 6 - font.size(tip)[0], bubble_h - 6 - font.get_height()),
                )

            # Optional tiny title tag.
            if title and title != "":
                tag = font.render(ellipsize(str(title), int(bubble_w - pad_x * 2)), False, pygame.Color(240, 220, 140))
                bubble_surf.blit(tag, (pad_x, 2))

            surface.blit(bubble_surf, out.topleft)
            return
        except Exception:
            pass

        panel_h = 74
        pad_x = 12
        pad_y = 10
        panel = pygame.Rect(pad_x, INTERNAL_H - panel_h - pad_y, INTERNAL_W - pad_x * 2, panel_h)
        if panel.y < 6:
            panel.y = 6
        bg = pygame.Surface((panel.w, panel.h), pygame.SRCALPHA)
        bg.fill((0, 0, 0, 180))
        pygame.draw.rect(bg, (240, 220, 140, 26), bg.get_rect(), border_radius=10)
        pygame.draw.rect(bg, (220, 220, 235, 140), bg.get_rect(), 2, border_radius=10)
        surface.blit(bg, panel.topleft)

        font_t = self.app.font_m
        font = self.app.font_s
        surface.blit(font_t.render(title, False, pygame.Color(240, 240, 240)), (panel.x + 10, panel.y + 8))

        max_w = int(panel.w - 20)
        lines: list[str] = []
        for para in str(shown).split("\n"):
            cur = ""
            for ch in para:
                test = cur + ch
                if cur and font.size(test)[0] > max_w:
                    lines.append(cur)
                    cur = ch
                else:
                    cur = test
            lines.append(cur)
        # Trim trailing empty lines (but keep at least one line).
        while len(lines) > 1 and not str(lines[-1]).strip():
            lines.pop()

        tx = panel.x + 10
        ty = panel.y + 32
        drawn = lines[:3]
        for ln in drawn:
            surface.blit(font.render(str(ln), False, pygame.Color(230, 230, 240)), (tx, ty))
            ty += int(font.get_height() + 2)

        if not self._dialog_finished() and (int(float(getattr(self, "dialog_blink", 0.0)) * 3.0) % 2 == 0):
            last_ln = str(drawn[-1]) if drawn else ""
            cx = tx + max(0, int(font.size(last_ln)[0]))
            cy = ty - int(font.get_height() + 2)
            surface.blit(font.render("|", False, pygame.Color(240, 220, 140)), (cx, cy))
        if self._dialog_finished():
            tip = "/Enter "
            surface.blit(font.render(tip, False, pygame.Color(170, 170, 180)), (panel.right - 10 - font.size(tip)[0], panel.bottom - 16))

    def _bleed_total_rate(self) -> float:
        wounds = getattr(self, "bleed_wounds", None)
        if not isinstance(wounds, dict) or not wounds:
            return 0.0
        total = 0.0
        for v in wounds.values():
            try:
                total += max(0.0, float(v))
            except Exception:
                continue
        return float(total)

    def _apply_bleed(self, dt: float) -> None:
        rate = float(self._bleed_total_rate())
        if rate <= 0.0:
            self.bleed_accum = 0.0
            return
        self.bleed_accum = float(getattr(self, "bleed_accum", 0.0)) + float(rate) * float(dt)
        while float(self.bleed_accum) >= 1.0:
            self.bleed_accum = float(self.bleed_accum) - 1.0
            self.player.hp = max(0, int(self.player.hp) - 1)

    def _inflict_wound(self, part: str, *, rate: float) -> None:
        part = str(part)
        rate = float(rate)
        if rate <= 0.0 or self.player.hp <= 0:
            return
        wounds = getattr(self, "bleed_wounds", None)
        if not isinstance(wounds, dict):
            wounds = {}
            self.bleed_wounds = wounds
        # Cap wound count; keep the heaviest wounds and merge the rest.
        if len(wounds) >= 3 and part not in wounds:
            # Add to the weakest wound instead of creating a new slot.
            try:
                part = min(wounds.items(), key=lambda kv: float(kv[1]))[0]
            except Exception:
                pass
        prev = float(wounds.get(part, 0.0))
        wounds[part] = float(min(2.5, prev + rate))
        if prev <= 0.0:
            name = self._BODY_PART_NAMES.get(part, part)
            self._set_hint(f"{name}", seconds=1.6)

    def _bandage_one_wound(self) -> str | None:
        wounds = getattr(self, "bleed_wounds", None)
        if not isinstance(wounds, dict) or not wounds:
            return None
        try:
            part = max(wounds.items(), key=lambda kv: float(kv[1]))[0]
        except Exception:
            part = next(iter(wounds.keys()))
        try:
            del wounds[part]
        except Exception:
            pass
        return str(part)

    def _clear_all_wounds(self) -> int:
        wounds = getattr(self, "bleed_wounds", None)
        if not isinstance(wounds, dict) or not wounds:
            return 0
        n = len(wounds)
        try:
            wounds.clear()
        except Exception:
            self.bleed_wounds = {}
        return int(n)

    def _player_tile(self) -> tuple[int, int]:
        tx = int(math.floor(self.player.pos.x / self.TILE_SIZE))        
        ty = int(math.floor(self.player.pos.y / self.TILE_SIZE))        
        return tx, ty

    def _player_chunk(self) -> tuple[int, int]:
        tx, ty = self._player_tile()
        return tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE

    def _stream_world_chunks(self) -> None:
        # Stream/generate chunks ahead of the camera to avoid hitches when
        # walking diagonally across chunk corners. Render code only "peeks"
        # tiles/chunks and never generates them.
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "sch_interior", False))
            or bool(getattr(self, "house_interior", False))
        ):
            return

        tx, ty = self._player_tile()
        pcx = int(tx) // int(self.CHUNK_SIZE)
        pcy = int(ty) // int(self.CHUNK_SIZE)

        # Always ensure the current chunk exists (physics/collisions rely on it).
        self.world.get_chunk(int(pcx), int(pcy))

        # Collision safety near chunk edges: ensure neighbor chunks that the
        # player's collider might touch soon.
        lx = int(tx - pcx * int(self.CHUNK_SIZE))
        ly = int(ty - pcy * int(self.CHUNK_SIZE))
        margin = 3  # tiles
        need_x = [0]
        if lx <= int(margin):
            need_x.append(-1)
        elif lx >= int(self.CHUNK_SIZE) - 1 - int(margin):
            need_x.append(1)
        need_y = [0]
        if ly <= int(margin):
            need_y.append(-1)
        elif ly >= int(self.CHUNK_SIZE) - 1 - int(margin):
            need_y.append(1)
        for oy in need_y:
            for ox in need_x:
                if int(ox) == 0 and int(oy) == 0:
                    continue
                self.world.get_chunk(int(pcx + ox), int(pcy + oy))

        # Request chunks in/around the camera view for smooth scrolling.
        cam_x = int(getattr(self, "cam_x", 0))
        cam_y = int(getattr(self, "cam_y", 0))
        # Match (and slightly exceed) the draw margins so tall facades don't "vanish"
        # when walking quickly into a not-yet-generated chunk.
        sprinting = bool(getattr(self, "player_sprinting", False))
        margin_tiles = 6 if sprinting else 4
        start_tx = int(math.floor(float(cam_x) / float(self.TILE_SIZE))) - int(margin_tiles)
        start_ty = int(math.floor(float(cam_y) / float(self.TILE_SIZE))) - int(margin_tiles)
        end_tx = int(math.floor(float(cam_x + INTERNAL_W) / float(self.TILE_SIZE))) + int(margin_tiles)
        end_ty = int(math.floor(float(cam_y + INTERNAL_H) / float(self.TILE_SIZE))) + int(margin_tiles)

        chunk_pad = 2 if sprinting else 1
        start_cx = start_tx // int(self.CHUNK_SIZE) - int(chunk_pad)
        end_cx = end_tx // int(self.CHUNK_SIZE) + int(chunk_pad)
        start_cy = start_ty // int(self.CHUNK_SIZE) - int(chunk_pad)
        end_cy = end_ty // int(self.CHUNK_SIZE) + int(chunk_pad)
        for cy in range(int(start_cy), int(end_cy) + 1):
            for cx in range(int(start_cx), int(end_cx) + 1):
                self.world.request_chunk(int(cx), int(cy))

        tick = int(getattr(self, "_stream_tick", 0)) + 1
        self._stream_tick = int(tick)

        mount = getattr(self, "mount", None)
        moving = False
        if mount == "rv" and getattr(self, "rv", None) is not None:
            moving = self.rv.vel.length_squared() > 0.1
        elif mount == "bike" and getattr(self, "bike", None) is not None:
            moving = self.bike.vel.length_squared() > 0.1
        else:
            moving = self.player.vel.length_squared() > 0.1

        # Budgeted generation: keep the world streaming ahead so buildings
        # (including facades) don't "vanish" while walking into new chunks.
        try:
            pending = int(len(getattr(self.world, "_gen_queue", [])) - int(getattr(self.world, "_gen_queue_i", 0)))
        except Exception:
            pending = 0

        budget = 0
        if moving:
            # Always generate a little while moving; ramp up if we're behind.
            if pending > 0:
                budget = 2 if sprinting else 1
            if pending > 18:
                budget = 3 if sprinting else 2
        else:
            # Standing still: catch up faster.
            budget = 2 if pending > 0 else 0
            if pending > 18:
                budget = 3
        if budget > 0:
            self.world.pump_generation(max_chunks=int(budget))

    def _find_nearest_item(self, *, radius_px: float) -> tuple["_Chunk | None", "_WorldItem | None"]:
        cx, cy = self._player_chunk()
        best_d2 = float(radius_px * radius_px)
        best_item: HardcoreSurvivalState._WorldItem | None = None
        best_chunk: HardcoreSurvivalState._Chunk | None = None

        for oy in (-1, 0, 1):
            for ox in (-1, 0, 1):
                chunk = self.world.get_chunk(cx + ox, cy + oy)
                for it in chunk.items:
                    d2 = float((it.pos - self.player.pos).length_squared())
                    if d2 < best_d2:
                        best_d2 = d2
                        best_item = it
                        best_chunk = chunk

        return best_chunk, best_item

    def _find_nearest_parked_bike(
        self, *, radius_px: float
    ) -> tuple["_Chunk | None", "_ParkedBike | None", float]:
        cx, cy = self._player_chunk()
        best_d2 = float(radius_px * radius_px)
        best_bike: HardcoreSurvivalState._ParkedBike | None = None
        best_chunk: HardcoreSurvivalState._Chunk | None = None

        for oy in (-1, 0, 1):
            for ox in (-1, 0, 1):
                chunk = self.world.get_chunk(cx + ox, cy + oy)
                for b in getattr(chunk, "bikes", []):
                    pos = getattr(b, "pos", None)
                    if pos is None:
                        continue
                    d2 = float((pygame.Vector2(pos) - self.player.pos).length_squared())
                    if d2 < best_d2:
                        best_d2 = d2
                        best_bike = b
                        best_chunk = chunk

        return best_chunk, best_bike, best_d2

    def _find_nearest_parked_car(
        self, *, radius_px: float
    ) -> tuple["_Chunk | None", "_ParkedCar | None", float]:
        cx, cy = self._player_chunk()
        best_d2 = float(radius_px * radius_px)
        best_car: HardcoreSurvivalState._ParkedCar | None = None
        best_chunk: HardcoreSurvivalState._Chunk | None = None

        for oy in (-1, 0, 1):
            for ox in (-1, 0, 1):
                chunk = self.world.get_chunk(cx + ox, cy + oy)
                for car in getattr(chunk, "cars", []):
                    pos = getattr(car, "pos", None)
                    if pos is None:
                        continue
                    d2 = float((pygame.Vector2(pos) - self.player.pos).length_squared())
                    if d2 < best_d2:
                        best_d2 = d2
                        best_car = car
                        best_chunk = chunk

        return best_chunk, best_car, best_d2

    def _stash_personal_bike_as_parked(self) -> None:
        if not hasattr(self, "bike") or self.bike is None:
            return
        mid = str(getattr(self.bike, "model_id", "bike"))
        d = str(getattr(self, "bike_dir", "right"))
        pos = pygame.Vector2(self.bike.pos)
        w, h = self._two_wheel_collider_px(mid)

        def rect_at(p: pygame.Vector2) -> pygame.Rect:
            return pygame.Rect(
                int(iround(float(p.x) - float(w) / 2.0)),
                int(iround(float(p.y) - float(h) / 2.0)),
                int(w),
                int(h),
            )

        def inside_any_building(tx: int, ty: int) -> bool:
            ch = self.world.get_chunk(int(tx) // self.CHUNK_SIZE, int(ty) // self.CHUNK_SIZE)
            for bx0, by0, bw, bh, _roof_kind, _floors in getattr(ch, "buildings", []):
                if int(bx0) <= int(tx) < int(bx0) + int(bw) and int(by0) <= int(ty) < int(by0) + int(bh):
                    return True
            return False

        # Don't leave a parked bike "on top of" building roofs/facades.
        tx0 = int(math.floor(pos.x / self.TILE_SIZE))
        ty0 = int(math.floor(pos.y / self.TILE_SIZE))
        if inside_any_building(tx0, ty0) or self._collide_rect_world_vehicle(rect_at(pos)):
            found: pygame.Vector2 | None = None
            # Spiral search around the current tile.
            search_r = 6
            for r in range(int(search_r) + 1):
                for dy in range(-int(r), int(r) + 1):
                    for dx in range(-int(r), int(r) + 1):
                        if max(abs(int(dx)), abs(int(dy))) != int(r):
                            continue
                        tx = int(tx0 + int(dx))
                        ty = int(ty0 + int(dy))
                        if inside_any_building(tx, ty):
                            continue
                        p = pygame.Vector2(
                            (float(tx) + 0.5) * float(self.TILE_SIZE),
                            (float(ty) + 0.5) * float(self.TILE_SIZE),
                        )
                        if self._collide_rect_world_vehicle(rect_at(p)):
                            continue
                        found = p
                        break
                    if found is not None:
                        break
                if found is not None:
                    break
            if found is None:
                return
            pos = found

        tx = int(math.floor(pos.x / self.TILE_SIZE))
        ty = int(math.floor(pos.y / self.TILE_SIZE))
        chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
        for pb in getattr(chunk, "bikes", []):
            if (pygame.Vector2(getattr(pb, "pos", pos)) - pos).length_squared() <= (6.0 * 6.0):
                return
        parked = HardcoreSurvivalState._ParkedBike(
            pos=pos,
            model_id=mid,
            dir=d,
            frame=0,
            fuel=float(getattr(self.bike, "fuel", 0.0)),
        )
        try:
            setattr(parked, "owned", True)
        except Exception:
            pass
        chunk.bikes.append(parked)

    def _stash_personal_car_as_parked(self) -> None:
        if not hasattr(self, "rv") or self.rv is None:
            return
        mid = str(getattr(self.rv, "model_id", "rv"))
        pos = pygame.Vector2(self.rv.pos)
        heading = float(getattr(self.rv, "heading", 0.0))
        fuel = float(getattr(self.rv, "fuel", 0.0))

        def rect_at(p: pygame.Vector2) -> pygame.Rect:
            return self._rv_collider_rect_at(p)

        def inside_any_building(tx: int, ty: int) -> bool:
            ch = self.world.get_chunk(int(tx) // self.CHUNK_SIZE, int(ty) // self.CHUNK_SIZE)
            for bx0, by0, bw, bh, _roof_kind, _floors in getattr(ch, "buildings", []):
                if int(bx0) <= int(tx) < int(bx0) + int(bw) and int(by0) <= int(ty) < int(by0) + int(bh):
                    return True
            return False

        tx0 = int(math.floor(pos.x / self.TILE_SIZE))
        ty0 = int(math.floor(pos.y / self.TILE_SIZE))

        saved_mount = getattr(self, "mount", None)
        try:
            # Ignore self-car collision when checking for a safe parked spot.
            self.mount = "rv"
            if inside_any_building(tx0, ty0) or self._collide_rect_world_vehicle(rect_at(pos)):
                found: pygame.Vector2 | None = None
                search_r = 10
                for r in range(int(search_r) + 1):
                    for dy in range(-int(r), int(r) + 1):
                        for dx in range(-int(r), int(r) + 1):
                            if max(abs(int(dx)), abs(int(dy))) != int(r):
                                continue
                            tx = int(tx0 + int(dx))
                            ty = int(ty0 + int(dy))
                            if inside_any_building(tx, ty):
                                continue
                            p = pygame.Vector2(
                                (float(tx) + 0.5) * float(self.TILE_SIZE),
                                (float(ty) + 0.5) * float(self.TILE_SIZE),
                            )
                            if self._collide_rect_world_vehicle(rect_at(p)):
                                continue
                            found = p
                            break
                        if found is not None:
                            break
                    if found is not None:
                        break
                if found is None:
                    return
                pos = found
        finally:
            self.mount = saved_mount

        tx = int(math.floor(pos.x / self.TILE_SIZE))
        ty = int(math.floor(pos.y / self.TILE_SIZE))
        chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
        for pc in getattr(chunk, "cars", []):
            if (pygame.Vector2(getattr(pc, "pos", pos)) - pos).length_squared() <= (8.0 * 8.0):
                return
        parked = HardcoreSurvivalState._ParkedCar(
            pos=pos,
            model_id=mid,
            heading=float(heading),
            steer_state=0,
            frame=0,
            fuel=float(fuel),
        )
        try:
            setattr(parked, "owned", True)
        except Exception:
            pass
        chunk.cars.append(parked)

    def _special_building_for_door_tile(
        self, tx: int, ty: int
    ) -> HardcoreSurvivalState._SpecialBuilding | None:
        door = (int(tx), int(ty))
        cx = int(door[0]) // self.CHUNK_SIZE
        cy = int(door[1]) // self.CHUNK_SIZE
        for oy in (-1, 0, 1):
            for ox in (-1, 0, 1):
                chunk = self.world.get_chunk(int(cx + ox), int(cy + oy))
                for sb in getattr(chunk, "special_buildings", []):
                    if door in getattr(sb, "door_tiles", ()):
                        return sb
        return None

    def _try_walk_into_special_door(self, move: pygame.Vector2, dt: float) -> bool:
        if self.mount is not None:
            return False
        if move.length_squared() <= 0.001:
            return False

        rect = self.player.rect_at(self.player.pos)
        dx_f = float(self.player.vel.x) * float(dt)
        dy_f = float(self.player.vel.y) * float(dt)
        dx = int(round(dx_f))
        dy = int(round(dy_f))
        if dx == 0 and abs(dx_f) > 0.001:
            dx = 1 if dx_f > 0 else -1
        if dy == 0 and abs(dy_f) > 0.001:
            dy = 1 if dy_f > 0 else -1
        if dx == 0 and dy == 0:
            return False

        next_rect = rect.move(int(dx), int(dy))
        tx, ty = self._player_tile()
        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        for cx, cy in candidates:
            cx = int(cx)
            cy = int(cy)
            if int(self.world.get_tile(cx, cy)) != int(self.T_DOOR):
                continue
            door_rect = pygame.Rect(
                int(cx * self.TILE_SIZE),
                int(cy * self.TILE_SIZE),
                int(self.TILE_SIZE),
                int(self.TILE_SIZE),
            )
            if not next_rect.colliderect(door_rect):
                continue

            # Only enter if you're actually walking *towards* the door.
            door_center = pygame.Vector2(
                (float(cx) + 0.5) * float(self.TILE_SIZE),
                (float(cy) + 0.5) * float(self.TILE_SIZE),
            )
            to_door = door_center - pygame.Vector2(self.player.pos)
            if to_door.length_squared() > 0.001:
                to_door = to_door.normalize()
                if float(move.dot(to_door)) < 0.25:
                    continue

            sb = self._special_building_for_door_tile(cx, cy)
            if sb is None:
                continue
            kind = str(getattr(sb, "kind", ""))
            if kind == "house": 
                self._house_interior_enter(sb) 
                return True 
        return False 

    def _try_open_home_storage_world(self) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        home = getattr(self, "home_highrise_door", None)
        if home is None or not isinstance(home, tuple) or len(home) != 2:
            return False
        try:
            hx, hy = int(home[0]), int(home[1])
        except Exception:
            return False

        tx, ty = self._player_tile()
        found = self._multi_house_at(int(tx), int(ty))
        if found is None:
            return False
        _chunk, mh = found
        mh_tx0 = int(getattr(mh, "tx0", 0))
        mh_ty0 = int(getattr(mh, "ty0", 0))
        mh_w = int(getattr(mh, "w", 0))
        mh_h = int(getattr(mh, "h", 0))
        if not (mh_tx0 <= int(hx) < mh_tx0 + mh_w and mh_ty0 <= int(hy) < mh_ty0 + mh_h):
            return False

        home_floor = int(getattr(self, "home_highrise_floor", 0))
        cur_floor = int(getattr(mh, "cur_floor", 1))
        if home_floor <= 0 or int(cur_floor) != int(home_floor):
            return False

        # Ensure the home door + furniture exist (runs once).
        self._setup_home_highrise_world()

        candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
        for cx, cy in candidates:
            tid = int(self.world.get_tile(int(cx), int(cy)))
            if tid == int(self.T_FRIDGE):
                self._home_ui_open(storage_kind="fridge")
                return True
            if tid in (int(self.T_SHELF), int(self.T_CABINET)):
                self._home_ui_open(storage_kind="cabinet")
                return True
        return False

    def _try_rest_world_bed(self) -> bool:
        if getattr(self, "mount", None) is not None:
            return False

        # Pressing E again while sleeping gets you up.
        if str(getattr(self, "player_pose", "")) == "sleep" and str(getattr(self, "player_pose_space", "")) == "world":
            self._clear_player_pose()
            self._set_hint("", seconds=0.8)
            return True

        tx, ty = self._player_tile()
        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        bed_tile: tuple[int, int] | None = None
        for cx, cy in candidates:
            if int(self.world.get_tile(int(cx), int(cy))) == int(self.T_BED):
                bed_tile = (int(cx), int(cy))
                break
        if bed_tile is None:
            return False

        # Find the whole bed block (usually 2 tiles) so the anchor is centered.
        bx, by = bed_tile
        seen: set[tuple[int, int]] = set()
        stack = [(int(bx), int(by))]
        cells: list[tuple[int, int]] = []
        while stack and len(cells) < 24:
            cx, cy = stack.pop()
            cx = int(cx)
            cy = int(cy)
            if (cx, cy) in seen:
                continue
            seen.add((cx, cy))
            if int(self.world.get_tile(int(cx), int(cy))) != int(self.T_BED):
                continue
            cells.append((cx, cy))
            stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])

        if not cells:
            return False
        min_x = min(int(p[0]) for p in cells)
        max_x = max(int(p[0]) for p in cells)
        min_y = min(int(p[1]) for p in cells)
        max_y = max(int(p[1]) for p in cells)

        ax = (float(min_x + max_x + 1) * float(self.TILE_SIZE)) * 0.5
        ay = (float(min_y + max_y + 1) * float(self.TILE_SIZE)) * 0.5

        self.player.stamina = 100.0
        self.player.morale = float(clamp(self.player.morale + 10.0, 0.0, 100.0))
        self._set_player_pose("sleep", space="world", anchor=(ax, ay), seconds=0.0)
        self._set_hint("", seconds=1.1)
        return True

    def _try_use_pc_world(self) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        tx, ty = self._player_tile()
        sitting = str(getattr(self, "player_pose", "")) == "sit" and str(getattr(self, "player_pose_space", "")) == "world"
        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        hit: tuple[int, int] | None = None
        for cx, cy in candidates:
            if int(self.world.get_tile(int(cx), int(cy))) == int(self.T_PC):
                hit = (int(cx), int(cy))
                break
        if hit is None and sitting:
            best = None
            for dy2 in range(-2, 3):
                for dx2 in range(-2, 3):
                    if max(abs(int(dx2)), abs(int(dy2))) > 2:
                        continue
                    cx = int(tx + dx2)
                    cy = int(ty + dy2)
                    if int(self.world.get_tile(int(cx), int(cy))) != int(self.T_PC):
                        continue
                    key = (max(abs(int(dx2)), abs(int(dy2))), abs(int(dx2)) + abs(int(dy2)))
                    if best is None or key < best[0]:
                        best = (key, int(cx), int(cy))
            if best is not None:
                _key, cx, cy = best
                hit = (int(cx), int(cy))
        if hit is None:
            return False

        if not sitting:
            self._set_hint("", seconds=1.0)
            return True

        dx = int(hit[0]) - int(tx)
        dy = int(hit[1]) - int(ty)
        if abs(int(dx)) >= abs(int(dy)):
            if int(dx) > 0:
                self.player.dir = "right"
            elif int(dx) < 0:
                self.player.dir = "left"
        else:
            if int(dy) > 0:
                self.player.dir = "down"
            elif int(dy) < 0:
                self.player.dir = "up"

        # Office PC: clock in / work. (Shift+E keeps the original "PC opens map".)
        try:
            mods = pygame.key.get_mods()
            is_shift = bool(int(mods) & int(pygame.KMOD_SHIFT))
        except Exception:
            is_shift = False
        if not bool(is_shift):
            office_key = getattr(self, "story_office_key", None)
            if (
                isinstance(office_key, tuple)
                and len(office_key) == 4
                and bool(getattr(self, "story_enabled", False))
                and bool(self._story_is_pre_apocalypse())
            ):
                hit_b = self._peek_building_at_tile(int(hit[0]), int(hit[1]))
                if hit_b is not None and tuple(int(v) for v in hit_b[:4]) == tuple(int(v) for v in office_key):
                    pc_tiles = getattr(self, "story_office_player_pc_tiles", None)
                    if isinstance(pc_tiles, set) and pc_tiles and (int(hit[0]), int(hit[1])) not in pc_tiles:
                        self._set_hint("", seconds=1.0)
                    else:
                        if isinstance(getattr(self, "work_task", None), dict):
                            return True
                        day = int(self.world_time_s / max(1e-6, self.DAY_LENGTH_S)) + 1
                        if int(getattr(self, "story_work_clocked_day", 0)) < int(day):
                            total = 4.2
                            self.work_task = {"total": float(total), "left": float(total), "day": int(day)}
                            self._speech_say("...", seconds=1.0)
                            return True

        self._toggle_world_map(open=True)
        self._set_hint("", seconds=1.0)
        return True

    def _try_watch_tv_world(self) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        tx, ty = self._player_tile()
        candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
        hit: tuple[int, int] | None = None
        for cx, cy in candidates:
            if int(self.world.get_tile(int(cx), int(cy))) == int(self.T_TV):
                hit = (int(cx), int(cy))
                break
        if hit is None:
            return False

        states = getattr(self, "world_tv_states", None)
        if not isinstance(states, dict):
            states = {}
            self.world_tv_states = states
        key = (int(hit[0]), int(hit[1]))
        states[key] = not bool(states.get(key, False))
        tv_now = bool(states.get(key, False))
        if tv_now:
            self.player.morale = float(clamp(float(self.player.morale) + 2.0, 0.0, 100.0))
        self._gallery_open = False
        self._set_hint("" if tv_now else "", seconds=1.0)
        return True

    def _try_sit_world(self) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False
        if str(getattr(self, "player_pose", "")) == "sleep" and str(getattr(self, "player_pose_space", "")) == "world":
            return False

        tx, ty = self._player_tile()
        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        chosen: tuple[int, int, int] | None = None
        for cx, cy in candidates:
            tid = int(self.world.get_tile(int(cx), int(cy)))
            if tid in (int(self.T_CHAIR), int(self.T_SOFA)):
                chosen = (int(cx), int(cy), int(tid))
                break
        if chosen is None:
            return False

        cx, cy, tid = chosen
        seen: set[tuple[int, int]] = set()
        stack = [(int(cx), int(cy))]
        cells: list[tuple[int, int]] = []
        while stack and len(cells) < 24:
            sx, sy = stack.pop()
            sx = int(sx)
            sy = int(sy)
            if (sx, sy) in seen:
                continue
            seen.add((sx, sy))
            if int(self.world.get_tile(int(sx), int(sy))) != int(tid):
                continue
            cells.append((sx, sy))
            stack.extend([(sx + 1, sy), (sx - 1, sy), (sx, sy + 1), (sx, sy - 1)])
        if not cells:
            cells = [(int(cx), int(cy))]

        min_x = min(int(p[0]) for p in cells)
        max_x = max(int(p[0]) for p in cells)
        min_y = min(int(p[1]) for p in cells)
        max_y = max(int(p[1]) for p in cells)
        ax = (float(min_x + max_x + 1) * float(self.TILE_SIZE)) * 0.5
        ay = (float(min_y + max_y + 1) * float(self.TILE_SIZE)) * 0.5

        # Prefer an adjacent walkable tile so sitting never snaps into walls/outside.
        prefer = pygame.Vector2(self.player.pos)
        seat_building = self._peek_building_at_tile(int(cx), int(cy))
        need_home = bool(self._tile_in_home_world(int(cx), int(cy)))
        cand: list[tuple[float, int, int]] = []
        for sx, sy in cells:
            for dx2, dy2 in (
                (1, 0),
                (-1, 0),
                (0, 1),
                (0, -1),
                (1, 1),
                (1, -1),
                (-1, 1),
                (-1, -1),
            ):
                nx = int(sx) + int(dx2)
                ny = int(sy) + int(dy2)
                if need_home and not self._tile_in_home_world(int(nx), int(ny)):
                    continue
                if seat_building is not None:
                    nb = self._peek_building_at_tile(int(nx), int(ny))
                    if nb is None or tuple(nb[:4]) != tuple(seat_building[:4]):
                        continue
                tid2 = int(self.world.get_tile(int(nx), int(ny)))
                if bool(self._tile_solid(int(tid2))):
                    continue
                cxp = (float(nx) + 0.5) * float(self.TILE_SIZE)
                cyp = (float(ny) + 0.5) * float(self.TILE_SIZE)
                d2 = float((cxp - prefer.x) ** 2 + (cyp - prefer.y) ** 2)
                cand.append((d2, int(nx), int(ny)))
        if cand:
            cand.sort(key=lambda v: v[0])
            nx, ny = int(cand[0][1]), int(cand[0][2])
            ax = (float(nx) + 0.5) * float(self.TILE_SIZE)
            ay = (float(ny) + 0.5) * float(self.TILE_SIZE)

        dx = int(cx) - int(tx)
        dy = int(cy) - int(ty)
        if abs(int(dx)) >= abs(int(dy)):
            if int(dx) > 0:
                self.player.dir = "right"
            elif int(dx) < 0:
                self.player.dir = "left"
        else:
            if int(dy) > 0:
                self.player.dir = "down"
            elif int(dy) < 0:
                self.player.dir = "up"

        self._set_player_pose("sit", space="world", anchor=(ax, ay), seconds=0.0)
        self._set_hint("", seconds=0.9)
        return True

    def _try_unlock_near_door_world(self) -> bool:
        self._ensure_home_highrise_world_setup_for_player()
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        tx, ty = self._player_tile()
        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        for cx, cy in candidates:
            t = int(self.world.get_tile(int(cx), int(cy)))
            if t not in (int(self.T_DOOR_LOCKED), int(self.T_DOOR_HOME_LOCKED)):
                continue

            # Door rules:
            # - The green home door: key_house only.
            # - Other locked doors: can't be unlocked here (unless they're broken).
            if int(t) == int(self.T_DOOR_LOCKED):
                self._set_hint("", seconds=1.2)
                return True
            if int(self.inventory.count("key_house")) <= 0:
                self._set_hint("", seconds=1.1)
                return True
            has_key = int(self.inventory.count("key_house")) > 0
            has_crowbar = int(self.inventory.count("crowbar")) > 0
            if not (has_key or has_crowbar):
                self._set_hint("/", seconds=1.1)
                return True

            want = int(t)
            seen: set[tuple[int, int]] = set()
            stack = [(int(cx), int(cy))]
            cells: list[tuple[int, int]] = []
            while stack and len(cells) < 12:
                sx, sy = stack.pop()
                sx = int(sx)
                sy = int(sy)
                if (sx, sy) in seen:
                    continue
                seen.add((sx, sy))
                if int(self.world.get_tile(int(sx), int(sy))) != int(want):
                    continue
                cells.append((sx, sy))
                stack.extend([(sx + 1, sy), (sx - 1, sy), (sx, sy + 1), (sx, sy - 1)])
            if not cells:
                cells = [(int(cx), int(cy))]

            new_tid = int(self.T_DOOR) if int(want) == int(self.T_DOOR_LOCKED) else int(self.T_DOOR_HOME)
            for sx, sy in cells:
                self._world_set_tile(int(sx), int(sy), int(new_tid))
            self._set_hint("" if has_key else "", seconds=0.9)
            return True
        return False

    def _try_toggle_home_light_world(self) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        home_key = getattr(self, "home_highrise_world_key", None)
        if not (isinstance(home_key, tuple) and len(home_key) == 4):
            return False

        tx, ty = self._player_tile()
        hit = self._peek_building_at_tile(int(tx), int(ty))
        if hit is None:
            return False
        btx0, bty0, bw, bh = hit[:4]
        if (int(btx0), int(bty0), int(bw), int(bh)) != tuple(int(v) for v in home_key):
            return False
        home_floor = int(getattr(self, "home_highrise_world_floor", 0) or 0)
        if home_floor > 0:
            found = self._multi_house_at(int(tx), int(ty))
            if found is not None:
                _ch, mh = found
                if int(getattr(mh, "cur_floor", 1)) != int(home_floor):
                    return False

        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        for cx, cy in candidates:
            tid = int(self.world.get_tile(int(cx), int(cy)))
            if tid not in (int(self.T_LAMP), int(self.T_SWITCH)):
                continue
            self.home_light_on = not bool(getattr(self, "home_light_on", True))
            self._set_hint("" if bool(self.home_light_on) else "", seconds=0.8)
            return True
        return False

    def _try_refuel_at_gas_pump_world(self) -> bool:
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        tx, ty = self._player_tile()
        pump: tuple[int, int] | None = None
        for dy in (-1, 0, 1):
            for dx in (-1, 0, 1):
                cx = int(tx + dx)
                cy = int(ty + dy)
                if int(self.world.peek_tile(int(cx), int(cy))) == int(self.T_GAS_PUMP):
                    pump = (int(cx), int(cy))
                    break
            if pump is not None:
                break
        if pump is None:
            return False

        px, py = pump
        pump_pos = pygame.Vector2((float(px) + 0.5) * float(self.TILE_SIZE), (float(py) + 0.5) * float(self.TILE_SIZE))

        # Prefer the currently mounted vehicle; otherwise refuel a nearby personal vehicle.
        candidates: list[tuple[str, object]] = []
        if getattr(self, "mount", None) == "rv":
            candidates.append(("rv", self.rv))
        elif getattr(self, "mount", None) == "bike":
            mid = str(getattr(self.bike, "model_id", "bike"))
            if mid.startswith("moto"):
                candidates.append(("bike", self.bike))
        else:
            candidates.append(("rv", self.rv))
            mid = str(getattr(self.bike, "model_id", "bike"))
            if mid.startswith("moto"):
                candidates.append(("bike", self.bike))

        best: tuple[str, object] | None = None
        best_d2 = float(70.0 * 70.0)
        for kind, obj in candidates:
            pos = pygame.Vector2(getattr(obj, "pos", pygame.Vector2(0, 0)))
            d2 = float((pos - pump_pos).length_squared())
            if d2 <= best_d2:
                best = (str(kind), obj)
                best_d2 = d2

        if best is None:
            self._set_hint("", seconds=1.1)
            return True

        kind, target = best
        before = float(getattr(target, "fuel", 0.0))
        if before >= 99.9:
            self._set_hint("", seconds=0.9)
            return True

        try:
            setattr(target, "fuel", 100.0)
        except Exception:
            return False

        if kind == "rv":
            self._rv_no_fuel_warned = False
        else:
            self._bike_no_fuel_warned = False
        self._set_hint("", seconds=0.9)
        return True

    def _interact_primary(self) -> None:
        # Primary interact key on the world map: stairs/pickup (doors are walk-into).
        self._ensure_home_highrise_world_setup_for_player()
        if str(getattr(self, "player_pose", "")) == "sleep" and str(getattr(self, "player_pose_space", "")) == "world":
            self._clear_player_pose()
            self._set_hint("", seconds=0.8)
            return
        if str(getattr(self, "player_pose", "")) == "sit" and str(getattr(self, "player_pose_space", "")) == "world":
            if self._try_use_pc_world():
                return
            if self._try_watch_tv_world():
                return
            self._clear_player_pose()
            self._set_hint("", seconds=0.8)
            return
        if self._try_exit_rv_world_interior():
            return
        if self._try_refuel_at_gas_pump_world():
            return
        if self._try_use_highrise_elevator():
            return
        if self._try_use_multi_house_stairs():
            return
        if self._try_unlock_near_door_world():
            return
        if self._try_toggle_home_light_world():
            return
        if self._try_open_home_storage_world():
            return
        if self._try_talk_to_story_npc():
            return
        if self._try_pickup(quiet=True):
            return
        if self._try_sit_world():
            return
        if self._try_rest_world_bed():
            return
        if self._try_use_pc_world():
            return
        if self._try_watch_tv_world():
            return
        self._try_pickup(quiet=False)

    def _ensure_home_highrise_world_setup_for_player(self) -> None:
        # Lazy-init home high-rise layout only when the player is in the same
        # building footprint. Avoids startup reveal while restoring home doors.
        if bool(getattr(self, "_home_highrise_world_setup_done", False)):
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return

        home = getattr(self, "home_highrise_door", None)
        if not (isinstance(home, tuple) and len(home) == 2):
            return
        try:
            hx, hy = int(home[0]), int(home[1])
        except Exception:
            return

        found_home = self._multi_house_at(int(hx), int(hy))
        if found_home is None:
            return
        _home_chunk, home_mh = found_home

        try:
            tx, ty = self._player_tile()
        except Exception:
            return
        found_cur = self._multi_house_at(int(tx), int(ty))
        if found_cur is None:
            return
        _cur_chunk, cur_mh = found_cur

        home_key = (
            int(getattr(home_mh, "tx0", 0)),
            int(getattr(home_mh, "ty0", 0)),
            int(getattr(home_mh, "w", 0)),
            int(getattr(home_mh, "h", 0)),
        )
        cur_key = (
            int(getattr(cur_mh, "tx0", 0)),
            int(getattr(cur_mh, "ty0", 0)),
            int(getattr(cur_mh, "w", 0)),
            int(getattr(cur_mh, "h", 0)),
        )
        if tuple(cur_key) != tuple(home_key):
            return
        self._setup_home_highrise_world()

    def _player_in_home_world_building(self) -> bool:
        self._ensure_home_highrise_world_setup_for_player()
        home_key = getattr(self, "home_highrise_world_key", None)
        if not (isinstance(home_key, tuple) and len(home_key) == 4):
            return False
        tx, ty = self._player_tile()
        hit = self._peek_building_at_tile(int(tx), int(ty))
        if hit is None:
            return False
        btx0, bty0, bw, bh = hit[:4]
        if (int(btx0), int(bty0), int(bw), int(bh)) != tuple(int(v) for v in home_key):
            return False
        home_floor = int(getattr(self, "home_highrise_world_floor", 0) or 0)
        if home_floor > 0:
            found = self._multi_house_at(int(tx), int(ty))
            if found is not None:
                _ch, mh = found
                if int(getattr(mh, "cur_floor", 1)) != int(home_floor):
                    return False
        return True

    def _toggle_home_move_mode(self) -> None:
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return
        if bool(getattr(self, "home_move_mode", False)):
            # Exit: restore any carried furniture.
            try:
                self._home_move_cancel()
            except Exception:
                pass
            self.home_move_mode = False
            self._set_hint("", seconds=0.8)
            return

        if getattr(self, "mount", None) is not None:
            self._set_hint("", seconds=1.0)
            return
        if not self._player_in_home_world_building():
            self._set_hint("", seconds=1.1)
            return

        # Clear poses so movement/interaction state is clean.
        if getattr(self, "player_pose", None) is not None and str(getattr(self, "player_pose_space", "")) == "world":
            self._clear_player_pose()

        tx, ty = self._player_tile()
        self.home_move_mode = True
        self.home_move_cursor = (int(tx), int(ty))
        self.home_move_carry = None
        self._set_hint("E/QG", seconds=2.0)

    def _home_move_cursor_move(self, dx: int, dy: int) -> None:
        if not bool(getattr(self, "home_move_mode", False)):
            return
        cx, cy = getattr(self, "home_move_cursor", (0, 0))
        cx = int(cx)
        cy = int(cy)
        nx = int(cx + int(dx))
        ny = int(cy + int(dy))

        home_key = getattr(self, "home_highrise_world_key", None)
        if isinstance(home_key, tuple) and len(home_key) == 4:
            hit = self._peek_building_at_tile(int(nx), int(ny))
            if hit is None:
                return
            btx0, bty0, bw, bh = hit[:4]
            if (int(btx0), int(bty0), int(bw), int(bh)) != tuple(int(v) for v in home_key):
                return
        self.home_move_cursor = (int(nx), int(ny))

    def _home_move_cancel(self) -> None:
        carry = getattr(self, "home_move_carry", None)
        if not isinstance(carry, dict):
            self.home_move_carry = None
            return
        tid = int(carry.get("tid", 0))
        origin = carry.get("origin_cells", [])
        if isinstance(origin, list):
            for tx, ty in origin:
                try:
                    self._world_set_tile(int(tx), int(ty), int(tid))
                except Exception:
                    pass
            hp = carry.get("hp")
            if hp is not None and origin:
                try:
                    anchor = min((int(v[0]), int(v[1])) for v in origin if isinstance(v, tuple) and len(v) == 2)
                    self.world_furniture_hp[self._world_furniture_hp_key(int(anchor[0]), int(anchor[1]))] = int(hp)
                except Exception:
                    pass
        self.home_move_carry = None

    def _home_move_interact(self) -> None:
        if not bool(getattr(self, "home_move_mode", False)):
            return
        cur = getattr(self, "home_move_cursor", (0, 0))
        cx, cy = int(cur[0]), int(cur[1])

        movable = {
            int(self.T_TABLE),
            int(self.T_SHELF),
            int(self.T_CABINET),
            int(self.T_BED),
            int(self.T_SOFA),
            int(self.T_FRIDGE),
            int(self.T_TV),
            int(self.T_CHAIR),
            int(self.T_PC),
            int(self.T_LAMP),
            int(self.T_SWITCH),
            int(self.T_TOILET),
            int(self.T_SINK),
        }

        carry = getattr(self, "home_move_carry", None)
        if not isinstance(carry, dict):
            tid = int(self.world.get_tile(int(cx), int(cy)))
            if tid not in movable:
                self._set_hint("", seconds=0.9)
                return

            # Pick up a connected cluster (supports 2-tile beds/sofas/PC desks).
            seen: set[tuple[int, int]] = set()
            stack = [(int(cx), int(cy))]
            cells: list[tuple[int, int]] = []
            while stack and len(cells) < 12:
                x, y = stack.pop()
                x = int(x)
                y = int(y)
                if (x, y) in seen:
                    continue
                seen.add((x, y))
                if int(self.world.get_tile(int(x), int(y))) != int(tid):
                    continue
                cells.append((int(x), int(y)))
                stack.extend([(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)])

            if not cells:
                self._set_hint("", seconds=0.9)
                return

            offsets = [(int(x - cx), int(y - cy)) for x, y in cells]
            hp = None
            try:
                anchor = min(cells)
                hp_key = self._world_furniture_hp_key(int(anchor[0]), int(anchor[1]))
                hp = self.world_furniture_hp.pop(hp_key, None)
                for x, y in cells:
                    self.world_furniture_hp.pop(self._world_furniture_hp_key(int(x), int(y)), None)
            except Exception:
                hp = None
            carry: dict[str, object] = {"tid": int(tid), "offsets": offsets, "origin_cells": list(cells), "space": "home"}
            if hp is not None:
                carry["hp"] = int(hp)
            self.home_move_carry = carry
            for x, y in cells:
                self._world_set_tile(int(x), int(y), int(self.T_FLOOR))
            self._set_hint("E / Q", seconds=1.1)
            return

        # Place.
        tid = int(carry.get("tid", 0))
        offsets = carry.get("offsets", [])
        if not isinstance(offsets, list) or tid not in movable:
            self._home_move_cancel()
            return

        target_cells: list[tuple[int, int]] = [(int(cx + int(dx)), int(cy + int(dy))) for dx, dy in offsets]
        home_key = getattr(self, "home_highrise_world_key", None)
        if not (isinstance(home_key, tuple) and len(home_key) == 4):
            self._home_move_cancel()
            return

        for tx, ty in target_cells:
            hit = self._peek_building_at_tile(int(tx), int(ty))
            if hit is None:
                self._set_hint("", seconds=0.8)
                return
            btx0, bty0, bw, bh = hit[:4]
            if (int(btx0), int(bty0), int(bw), int(bh)) != tuple(int(v) for v in home_key):
                self._set_hint("", seconds=0.8)
                return
            if int(self.world.get_tile(int(tx), int(ty))) != int(self.T_FLOOR):
                self._set_hint("", seconds=0.8)
                return

        for tx, ty in target_cells:
            self._world_set_tile(int(tx), int(ty), int(tid))
        hp = carry.get("hp")
        if hp is not None:
            try:
                anchor = min(target_cells) if target_cells else (int(cx), int(cy))
                self.world_furniture_hp[self._world_furniture_hp_key(int(anchor[0]), int(anchor[1]))] = int(hp)
            except Exception:
                pass
        self.home_move_carry = None
        self._set_hint("", seconds=0.8)

    def _handle_home_move_mode_key(self, key: int) -> None:
        if not bool(getattr(self, "home_move_mode", False)):
            return
        key = int(key)
        if key in (pygame.K_ESCAPE, pygame.K_g):
            self._toggle_home_move_mode()
            return
        if key in (pygame.K_q,):
            self._home_move_cancel()
            self._set_hint("", seconds=0.8)
            return
        if key in (pygame.K_e, pygame.K_RETURN, pygame.K_SPACE):
            self._home_move_interact()
            return
        if key in (pygame.K_LEFT, pygame.K_a):
            self._home_move_cursor_move(-1, 0)
            return
        if key in (pygame.K_RIGHT, pygame.K_d):
            self._home_move_cursor_move(1, 0)
            return
        if key in (pygame.K_UP, pygame.K_w):
            self._home_move_cursor_move(0, -1)
            return
        if key in (pygame.K_DOWN, pygame.K_s):
            self._home_move_cursor_move(0, 1)
            return

    def _world_furniture_carry_active(self) -> bool:
        return isinstance(getattr(self, "home_move_carry", None), dict) and not bool(getattr(self, "home_move_mode", False))

    def _world_furniture_hp_key(self, tx: int, ty: int) -> tuple[object, ...]:
        tx = int(tx)
        ty = int(ty)
        if bool(self._tile_in_rv_world(int(tx), int(ty))):
            key = getattr(self, "_rv_world_int_active_key", None)
            if isinstance(key, tuple) and len(key) == 4:
                try:
                    rx0, ry0, rw, rh = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
                except Exception:
                    rx0, ry0, rw, rh = (0, 0, 0, 0)
                return ("rv", rx0, ry0, rw, rh, tx, ty)
            return ("rv", tx, ty)

        found = self._multi_house_at(int(tx), int(ty))
        if found is not None:
            _ch, mh = found
            try:
                bkey = (
                    int(getattr(mh, "tx0", 0)),
                    int(getattr(mh, "ty0", 0)),
                    int(getattr(mh, "w", 0)),
                    int(getattr(mh, "h", 0)),
                    int(getattr(mh, "cur_floor", 1)),
                )
            except Exception:
                bkey = (0, 0, 0, 0, 1)
            return ("mh",) + tuple(bkey) + (tx, ty)

        return ("world", tx, ty)

    def _world_furniture_connected_cells(self, tx: int, ty: int, tid: int, *, limit: int = 24) -> list[tuple[int, int]]:
        tx = int(tx)
        ty = int(ty)
        tid = int(tid)
        limit = int(limit)
        seen: set[tuple[int, int]] = set()
        stack = [(int(tx), int(ty))]
        cells: list[tuple[int, int]] = []
        while stack and len(cells) < int(limit):
            cx, cy = stack.pop()
            cx = int(cx)
            cy = int(cy)
            if (cx, cy) in seen:
                continue
            seen.add((cx, cy))
            if int(self.world.get_tile(int(cx), int(cy))) != int(tid):
                continue
            cells.append((int(cx), int(cy)))
            stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
        if not cells:
            cells = [(int(tx), int(ty))]
        return cells

    def _world_guess_base_tile_under_furniture(self, tx: int, ty: int) -> int:
        tx = int(tx)
        ty = int(ty)
        if bool(self._tile_in_rv_world(int(tx), int(ty))):
            base = getattr(self, "_rv_world_floor_base", None)
            if isinstance(base, dict):
                bt = base.get((int(tx), int(ty)))
                if bt is not None:
                    return int(bt)
            return int(self.T_FLOOR)

        counts: dict[int, int] = {}
        ignore = set(int(t) for t in self._WORLD_FURNITURE_HP_DEFAULTS.keys())
        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)):
            tid = int(self.world.get_tile(int(tx + dx), int(ty + dy)))
            if int(tid) in ignore:
                continue
            if bool(self._tile_solid(int(tid))):
                continue
            counts[int(tid)] = int(counts.get(int(tid), 0)) + 1
        if not counts:
            return int(self.T_FLOOR)
        best_tid = int(self.T_FLOOR)
        best_n = -1
        for tid, n in counts.items():
            if int(n) > int(best_n):
                best_tid = int(tid)
                best_n = int(n)
        return int(best_tid)

    def _world_furniture_damage_at(self, tx: int, ty: int, *, dmg: int, impact_dir: pygame.Vector2) -> bool:
        tx = int(tx)
        ty = int(ty)
        dmg = int(dmg)
        if dmg <= 0:
            return False
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        tid = int(self.world.get_tile(int(tx), int(ty)))
        if int(tid) not in self._WORLD_FURNITURE_HP_DEFAULTS:
            return False

        # HP is tracked per connected block (beds/sofas/PC desks may be 2 tiles).
        cells = self._world_furniture_connected_cells(int(tx), int(ty), int(tid), limit=24)
        anchor = min(cells) if cells else (int(tx), int(ty))
        key = self._world_furniture_hp_key(int(anchor[0]), int(anchor[1]))
        cur = int(self.world_furniture_hp.get(key, int(self._WORLD_FURNITURE_HP_DEFAULTS.get(int(tid), 20))))
        cur = int(cur) - int(dmg)
        if cur > 0:
            self.world_furniture_hp[key] = int(cur)
            self._spawn_hit_fx(pygame.Vector2((tx + 0.5) * self.TILE_SIZE, (ty + 0.5) * self.TILE_SIZE), dir=pygame.Vector2(impact_dir))
            self.app.play_sfx("hit")
            return True

        # Break: clear the whole connected block so 2-tile furniture doesn't split.
        center = pygame.Vector2((tx + 0.5) * self.TILE_SIZE, (ty + 0.5) * self.TILE_SIZE)
        try:
            self.world_furniture_hp.pop(key, None)
        except Exception:
            pass
        for cx, cy in cells:
            base_tid = int(self._world_guess_base_tile_under_furniture(int(cx), int(cy)))
            try:
                self._world_set_tile(int(cx), int(cy), int(base_tid))
            except Exception:
                pass
            # Defensive: clear any stale per-cell keys too.
            try:
                self.world_furniture_hp.pop(self._world_furniture_hp_key(int(cx), int(cy)), None)
            except Exception:
                pass

        # Drops: simple materials.
        try:
            extra = max(0, int(len(cells)) - 1)
            if int(tid) in self._WORLD_FURNITURE_WOOD_TILES:
                self._drop_world_item(center, "wood", int(clamp(random.randint(1, 2) + extra, 1, 6)))
            elif int(tid) in self._WORLD_FURNITURE_METAL_TILES:
                self._drop_world_item(center, "scrap", int(clamp(random.randint(1, 2) + extra, 1, 6)))
        except Exception:
            pass

        self._spawn_hit_fx(center, dir=pygame.Vector2(impact_dir))
        self.app.play_sfx("hit")
        self._set_hint("", seconds=0.7)
        return True

    def _world_context_action(self, action: str) -> None:
        action = str(action)
        target = getattr(self, "world_ctx_target", None)
        if not (isinstance(target, tuple) and len(target) == 3):
            return
        tx, ty, _tid = int(target[0]), int(target[1]), int(target[2])

        if action == "sit":
            self._try_sit_world()
            return
        if action == "sleep":
            self._try_rest_world_bed()
            return
        if action == "open":
            self._try_open_home_storage_world()
            return
        if action == "light":
            self._try_toggle_home_light_world()
            return
        if action == "lamp_cfg":
            self.lamp_cfg_open = True
            self.lamp_cfg_target = (int(tx), int(ty))
            self.lamp_cfg_rects = []
            # Close the context menu so it doesn't overlap.
            self.world_ctx_open = False
            self.world_ctx_target = None
            self.world_ctx_rects = []
            return
        if action == "tv":
            self._try_watch_tv_world()
            return
        if action == "drive":
            self._rv_world_try_drive_from_anywhere()
            return
        if action == "water":
            if not self._fill_sink_water_world_at(int(tx), int(ty)):
                self._set_hint("", seconds=0.9)
            return
        if action == "pc":
            if not (str(getattr(self, "player_pose", "")) == "sit" and str(getattr(self, "player_pose_space", "")) == "world"):
                self._try_sit_world()
            self._try_use_pc_world()
            return
        if action == "pee":
            if not self._use_toilet_world_at(int(tx), int(ty), kind="pee"):
                self._set_hint("", seconds=0.9)
            return
        if action == "poop":
            if not self._use_toilet_world_at(int(tx), int(ty), kind="poop"):
                self._set_hint("", seconds=0.9)
            return
        if action == "move":
            if self._home_furniture_pickup_at(int(tx), int(ty)):
                # Close the context menu immediately so clicks place furniture.
                self.world_ctx_open = False
                self.world_ctx_target = None
                self.world_ctx_rects = []
            else:
                self._set_hint("", seconds=0.9)
            return

    def _use_toilet_world_at(self, tx: int, ty: int, *, kind: str) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        tx = int(tx)
        ty = int(ty)
        ptx, pty = self._player_tile()
        if abs(int(tx) - int(ptx)) > 1 or abs(int(ty) - int(pty)) > 1:
            return False
        in_home = bool(self._tile_in_home_world(int(tx), int(ty)))
        in_rv = bool(self._tile_in_rv_world(int(tx), int(ty)))
        if not (in_home or in_rv):
            return False
        if int(self.world.get_tile(int(tx), int(ty))) != int(self.T_TOILET):
            return False

        kind = str(kind)
        if kind not in ("pee", "poop"):
            kind = "pee"

        # Already busy.
        if isinstance(getattr(self, "toilet_task", None), dict):
            return True

        # Find a nearby walkable tile to sit (never snap outside the building).
        toilet_building = self._peek_building_at_tile(int(tx), int(ty))
        prefer = pygame.Vector2(self.player.pos)
        best: tuple[float, int, int] | None = None
        for dx2, dy2 in (
            (0, 1),
            (0, -1),
            (1, 0),
            (-1, 0),
            (1, 1),
            (1, -1),
            (-1, 1),
            (-1, -1),
        ):
            nx = int(tx + dx2)
            ny = int(ty + dy2)
            if not self._tile_in_home_world(int(nx), int(ny)):
                continue
            if toilet_building is not None:
                nb = self._peek_building_at_tile(int(nx), int(ny))
                if nb is None or tuple(nb[:4]) != tuple(toilet_building[:4]):
                    continue
            tid2 = int(self.world.get_tile(int(nx), int(ny)))
            if bool(self._tile_solid(int(tid2))):
                continue
            cxp = (float(nx) + 0.5) * float(self.TILE_SIZE)
            cyp = (float(ny) + 0.5) * float(self.TILE_SIZE)
            d2 = float((cxp - prefer.x) ** 2 + (cyp - prefer.y) ** 2)
            if best is None or d2 < float(best[0]):
                best = (d2, int(nx), int(ny))
        if best is None:
            return False

        _d2, sx, sy = best
        ax = (float(sx) + 0.5) * float(self.TILE_SIZE)
        ay = (float(sy) + 0.5) * float(self.TILE_SIZE)

        # Face the toilet.
        fdx = int(tx) - int(sx)
        fdy = int(ty) - int(sy)
        if abs(int(fdx)) >= abs(int(fdy)):
            if int(fdx) > 0:
                self.player.dir = "right"
            elif int(fdx) < 0:
                self.player.dir = "left"
        else:
            if int(fdy) > 0:
                self.player.dir = "down"
            elif int(fdy) < 0:
                self.player.dir = "up"

        self.player.vel.update(0, 0)
        self._set_player_pose("sit", space="world", anchor=(ax, ay), seconds=0.0)

        total = 4.0 if kind == "poop" else 2.4
        self.toilet_task = {"kind": kind, "total": float(total), "left": float(total)}
        return True

    def _fill_sink_water_world_at(self, tx: int, ty: int) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        tx = int(tx)
        ty = int(ty)
        ptx, pty = self._player_tile()
        if abs(int(tx) - int(ptx)) > 1 or abs(int(ty) - int(pty)) > 1:
            return False
        if not self._tile_in_home_world(int(tx), int(ty)):
            return False
        if int(self.world.get_tile(int(tx), int(ty))) != int(self.T_SINK):
            return False

        held = getattr(self, "held_item", None)
        if isinstance(held, HardcoreSurvivalState._ItemStack) and str(getattr(held, "item_id", "")) == "cup":
            held.item_id = "cup_water"
            held.qty = 1
            self._speech_say("", seconds=1.1)
            return True

        inv = getattr(self, "inventory", None)
        if not isinstance(inv, HardcoreSurvivalState._Inventory):
            return False

        if int(inv.count("cup")) <= 0:
            self._set_hint("", seconds=1.2)
            return True

        removed = int(inv.remove("cup", 1))
        if removed <= 0:
            self._set_hint("", seconds=1.2)
            return True
        left = int(inv.add("cup_water", 1, self._ITEMS))
        if left > 0:
            inv.add("cup", 1, self._ITEMS)
            self._set_hint("", seconds=1.0)
            return True

        self._speech_say("", seconds=1.1)
        return True

    def _update_toilet_task(self, dt: float) -> None:
        task = getattr(self, "toilet_task", None)
        if not isinstance(task, dict):
            return
        if getattr(self, "mount", None) is not None:
            self.toilet_task = None
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            self.toilet_task = None
            return

        if str(getattr(self, "player_pose", "")) != "sit" or str(getattr(self, "player_pose_space", "")) != "world":
            # Cancelled (player moved / left pose).
            self.toilet_task = None
            return

        left = float(task.get("left", 0.0))
        left = max(0.0, left - float(dt))
        task["left"] = float(left)
        if left > 0.0:
            return

        kind = str(task.get("kind", "pee"))
        self.toilet_task = None
        self._clear_player_pose()

        if kind == "poop":
            self.player.morale = float(clamp(float(self.player.morale) + 1.0, 0.0, 100.0))
            self._speech_say("", seconds=1.2)
        else:
            self.player.morale = float(clamp(float(self.player.morale) + 0.5, 0.0, 100.0))
            self._speech_say("", seconds=1.2)

    def _update_work_task(self, dt: float) -> None:
        task = getattr(self, "work_task", None)
        if not isinstance(task, dict):
            return
        if getattr(self, "mount", None) is not None:
            self.work_task = None
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            self.work_task = None
            return
        if str(getattr(self, "player_pose", "")) != "sit" or str(getattr(self, "player_pose_space", "")) != "world":
            # Cancelled (player moved / left pose).
            self.work_task = None
            return

        left = float(task.get("left", 0.0))
        left = max(0.0, left - float(dt))
        task["left"] = float(left)
        if left > 0.0:
            return

        # Complete.
        try:
            day = int(task.get("day", 0))
        except Exception:
            day = 0
        if day <= 0:
            day = int(self.world_time_s / max(1e-6, self.DAY_LENGTH_S)) + 1

        self.work_task = None
        self.story_work_clocked_day = int(max(int(getattr(self, "story_work_clocked_day", 0)), int(day)))

        # Remember in story flags too (used by some dialog options).
        try:
            flags = getattr(self, "story_flags", None)
            if not isinstance(flags, set):
                flags = set()
                self.story_flags = flags
            flags.add("WORK_CLOCKED")
        except Exception:
            pass

        try:
            self.player.morale = float(clamp(float(self.player.morale) + 0.8, 0.0, 100.0))
        except Exception:
            pass
        self._speech_say("", seconds=1.2)

    def _handle_rv_mode_buttons_mouse(self, event: pygame.event.Event) -> bool:
        rects = getattr(self, "_rv_mode_btn_rects", None)
        if not isinstance(rects, dict) or not rects:
            return False
        if not hasattr(event, "pos"):
            return False
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return False
        mx, my = int(internal[0]), int(internal[1])
        btn = int(getattr(event, "button", 0))
        if btn != 1:
            return False

        for key, r in rects.items():
            if not isinstance(r, pygame.Rect):
                continue
            if not r.collidepoint(mx, my):
                continue
            key = str(key)

            if key == "life":
                if str(getattr(self.rv, "model_id", "rv")) != "rv":
                    self._set_hint("", seconds=1.0)
                    return True
                if bool(getattr(self, "rv_world_interior", False)):
                    return True
                if getattr(self, "mount", None) == "rv":
                    if abs(float(getattr(self.rv, "speed", 0.0))) > 1.0:
                        self._set_hint("", seconds=0.9)
                        return True
                if not self._can_access_rv():
                    self._set_hint("", seconds=0.9)
                    return True
                self._rv_world_interior_enter()
                return True

            if key == "drive":
                if getattr(self, "mount", None) == "rv":
                    return True
                if bool(getattr(self, "rv_world_interior", False)):
                    self._rv_world_try_drive_from_anywhere()
                    return True
                if not self._can_access_rv():
                    self._set_hint("", seconds=0.9)
                    return True
                if int(self.inventory.count("key_rv")) <= 0:
                    self._set_hint("", seconds=1.1)
                    return True
                self.mount = "rv"
                self.rv.vel.update(0, 0)
                self.rv.speed = 0.0
                self.player.pos.update(self.rv.pos)
                self.player.vel.update(0, 0)
                self._set_hint("", seconds=0.9)
                return True

            return True

        return False

    def _handle_world_context_menu_mouse(self, event: pygame.event.Event) -> bool:
        if bool(getattr(self, "home_move_mode", False)):
            return False
        if self._world_furniture_carry_active():
            return False
        if not bool(getattr(self, "world_ctx_open", False)):
            return False
        rects = getattr(self, "world_ctx_rects", None)
        if not isinstance(rects, list) or not rects:
            return False
        if not hasattr(event, "pos"):
            return False
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return False
        mx, my = int(internal[0]), int(internal[1])
        btn = int(getattr(event, "button", 0))
        if btn == 3:
            self.world_ctx_open = False
            self.world_ctx_target = None
            self.world_ctx_rects = []
            return True
        if btn != 1:
            return True
        for r, action in rects:
            if isinstance(r, pygame.Rect) and r.collidepoint(mx, my):
                self._world_context_action(str(action))
                self.world_ctx_open = False
                self.world_ctx_target = None
                self.world_ctx_rects = []
                return True
        # Click outside closes the menu (and consumes the click so it doesn't fire).
        self.world_ctx_open = False
        self.world_ctx_target = None
        self.world_ctx_rects = []
        return True

    def _handle_world_furniture_carry_mouse(self, event: pygame.event.Event) -> bool:
        if not self._world_furniture_carry_active():
            return False
        if not hasattr(event, "pos"):
            return False
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return False
        mx, my = int(internal[0]), int(internal[1])
        btn = int(getattr(event, "button", 0))
        if btn == 3:
            self._home_move_cancel()
            self._set_hint("", seconds=0.8)
            return True
        if btn != 1:
            return True

        cam_x, cam_y = getattr(self, "_last_cam_draw", (int(getattr(self, "cam_x", 0)), int(getattr(self, "cam_y", 0))))
        tx, ty = self._screen_to_world_tile(int(mx), int(my), int(cam_x), int(cam_y))
        mods = int(pygame.key.get_mods())
        if (mods & pygame.KMOD_SHIFT) != 0:
            if self._world_furniture_throw_to(int(tx), int(ty)):
                return True
        if self._home_furniture_place_at(int(tx), int(ty)):
            return True
        self._set_hint("", seconds=0.8)
        return True

    def _world_set_tile(self, tx: int, ty: int, tile_id: int) -> None:
        tx = int(tx)
        ty = int(ty)
        tile_id = int(tile_id)
        chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
        base_tx = int(chunk.cx) * int(self.CHUNK_SIZE)
        base_ty = int(chunk.cy) * int(self.CHUNK_SIZE)
        lx = int(tx - base_tx)
        ly = int(ty - base_ty)
        if not (0 <= lx < int(self.CHUNK_SIZE) and 0 <= ly < int(self.CHUNK_SIZE)):
            return
        chunk.tiles[int(ly) * int(self.CHUNK_SIZE) + int(lx)] = int(tile_id)

        # Keep multi-floor snapshots in sync so the change survives floor switches.
        found = self._multi_house_at(int(tx), int(ty))
        if found is None:
            return
        _ch, mh = found
        cur_floor = int(getattr(mh, "cur_floor", 1))
        tiles = mh.floor_tiles.get(int(cur_floor))
        if not isinstance(tiles, list):
            return
        w = int(getattr(mh, "w", 0))
        h = int(getattr(mh, "h", 0))
        if w <= 0 or h <= 0 or len(tiles) != int(w) * int(h):
            return
        mx = int(tx - int(getattr(mh, "tx0", 0)))
        my = int(ty - int(getattr(mh, "ty0", 0)))
        if not (0 <= mx < w and 0 <= my < h):
            return
        tiles[int(my) * int(w) + int(mx)] = int(tile_id)

    def _toggle_door_lock(self) -> None:
        self._ensure_home_highrise_world_setup_for_player()
        if getattr(self, "mount", None) is not None:
            self._set_hint("", seconds=1.1)
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return

        if int(self.inventory.count("key_house")) <= 0:
            self._set_hint("", seconds=1.1)
            return

        tx, ty = self._player_tile()
        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        chosen: tuple[int, int, int] | None = None
        for cx, cy in candidates:
            t = int(self.world.get_tile(int(cx), int(cy)))
            if t in (int(self.T_DOOR_HOME), int(self.T_DOOR_HOME_LOCKED)):
                chosen = (int(cx), int(cy), int(t))
                break
        if chosen is None:
            self._set_hint("", seconds=1.0)
            return
        cx, cy, t = chosen

        home_tiles = getattr(self, "home_highrise_world_home_door_tiles", None)
        if isinstance(home_tiles, list) and home_tiles:
            home_set = {(int(p[0]), int(p[1])) for p in home_tiles if isinstance(p, tuple) and len(p) == 2}
            if home_set and (int(cx), int(cy)) not in home_set:
                self._set_hint("", seconds=1.0)
                return
        group = (int(self.T_DOOR_HOME), int(self.T_DOOR_HOME_LOCKED))
        lock_tid = int(self.T_DOOR_HOME_LOCKED)
        unlock_tid = int(self.T_DOOR_HOME)
        is_locked = int(t) == int(self.T_DOOR_HOME_LOCKED)

        seen: set[tuple[int, int]] = set()
        stack = [(int(cx), int(cy))]
        cells: list[tuple[int, int]] = []
        while stack and len(cells) < 12:
            sx, sy = stack.pop()
            sx = int(sx)
            sy = int(sy)
            if (sx, sy) in seen:
                continue
            seen.add((sx, sy))
            if int(self.world.get_tile(int(sx), int(sy))) not in group:
                continue
            cells.append((sx, sy))
            stack.extend([(sx + 1, sy), (sx - 1, sy), (sx, sy + 1), (sx, sy - 1)])
        if not cells:
            cells = [(int(cx), int(cy))]

        if not is_locked:
            # Don't lock the doorway if the player is standing on it.
            prect = self.player.rect_at(self.player.pos)
            ts = int(self.TILE_SIZE)
            for sx, sy in cells:
                door_rect = pygame.Rect(int(sx) * ts, int(sy) * ts, ts, ts)
                if prect.colliderect(door_rect):
                    self._set_hint("", seconds=1.0)
                    return
            for sx, sy in cells:
                self._world_set_tile(int(sx), int(sy), int(lock_tid))
            self._set_hint("", seconds=0.9)
            return

        for sx, sy in cells:
            self._world_set_tile(int(sx), int(sy), int(unlock_tid))
        self._set_hint("", seconds=0.9)

    def _toggle_barricade(self) -> None:
        if getattr(self, "mount", None) is not None:
            self._set_hint("", seconds=1.1)
            return
        tx, ty = self._player_tile()
        candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
        chosen: tuple[int, int, int] | None = None
        for cx, cy in candidates:
            t = int(self.world.get_tile(int(cx), int(cy)))
            if t in (
                int(self.T_DOOR),
                int(self.T_DOOR_HOME),
                int(self.T_DOOR_LOCKED),
                int(self.T_DOOR_HOME_LOCKED),
                int(self.T_BARRICADE),
            ):
                chosen = (int(cx), int(cy), int(t))
                break
        if chosen is None:
            self._set_hint("", seconds=1.0)
            return
        cx, cy, t = chosen

        if t in (int(self.T_DOOR), int(self.T_DOOR_HOME), int(self.T_DOOR_LOCKED), int(self.T_DOOR_HOME_LOCKED)):
            need_plank = 1
            need_nails = 4
            if int(self.inventory.count("plank")) < int(need_plank) or int(self.inventory.count("nails")) < int(need_nails):
                self._set_hint("+", seconds=1.2)
                return
            self.inventory.remove("plank", int(need_plank))
            self.inventory.remove("nails", int(need_nails))
            self._world_set_tile(int(cx), int(cy), int(self.T_BARRICADE))
            self._set_hint("", seconds=0.9)
            return

        # Remove barricade.
        if int(self.inventory.count("crowbar")) <= 0 and int(self.inventory.count("hammer")) <= 0:
            self._set_hint("/", seconds=1.2)
            return
        self._world_set_tile(int(cx), int(cy), int(self.T_DOOR))
        # Recover a little material.
        self.inventory.add("nails", 2, self._ITEMS)
        self.inventory.add("plank", 1, self._ITEMS)
        self._set_hint("", seconds=0.9)

    def _try_use_highrise_elevator(self) -> bool:
        if getattr(self, "world_elevator_ui_open", False):
            return True
        if getattr(self, "mount", None) is not None:
            return False

        tx, ty = self._player_tile()
        candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
        chosen: tuple[int, int] | None = None
        for cx, cy in candidates:
            if int(self.world.get_tile(int(cx), int(cy))) == int(self.T_ELEVATOR):
                chosen = (int(cx), int(cy))
                break
        if chosen is None:
            return False
        cx, cy = chosen

        found = self._multi_house_at(int(cx), int(cy))
        if found is None:
            return False
        chunk, mh = found

        # Only high-rises use elevators on the world map.
        style = 0
        tx0 = int(getattr(mh, "tx0", 0))
        ty0 = int(getattr(mh, "ty0", 0))
        bw = int(getattr(mh, "w", 0))
        bh = int(getattr(mh, "h", 0))
        for b in getattr(chunk, "buildings", []):
            if int(b[0]) == int(tx0) and int(b[1]) == int(ty0) and int(b[2]) == int(bw) and int(b[3]) == int(bh):
                roof_kind = int(b[4]) if len(b) > 4 else 0
                style, _var = self._building_roof_style_var(int(roof_kind))
                break
        if int(style) != 6:
            return False

        floors = int(max(1, int(getattr(mh, "floors", 1))))
        if floors <= 1:
            self._set_hint("", seconds=1.0)
            return True

        self._world_elevator_open(chunk, mh, elev_tile=(int(cx), int(cy)))
        return True

    def _multi_house_at(self, tx: int, ty: int) -> tuple["_Chunk", "_MultiHouse"] | None:
        tx = int(tx)
        ty = int(ty)
        chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
        for mh in getattr(chunk, "multi_houses", []):
            if int(mh.tx0) <= tx < int(mh.tx0) + int(mh.w) and int(mh.ty0) <= ty < int(mh.ty0) + int(mh.h):
                return chunk, mh
        return None

    def _multi_house_apply_floor(self, chunk: "_Chunk", mh: "_MultiHouse") -> None:
        tiles = mh.floor_tiles.get(int(getattr(mh, "cur_floor", 1)))
        if not tiles:
            return
        base_tx = int(chunk.cx) * int(self.CHUNK_SIZE)
        base_ty = int(chunk.cy) * int(self.CHUNK_SIZE)
        ox = int(getattr(mh, "tx0", 0)) - int(base_tx)
        oy = int(getattr(mh, "ty0", 0)) - int(base_ty)
        if not (0 <= ox < int(self.CHUNK_SIZE) and 0 <= oy < int(self.CHUNK_SIZE)):
            return
        w = int(getattr(mh, "w", 0))
        h = int(getattr(mh, "h", 0))
        cs = int(self.CHUNK_SIZE)
        if w <= 0 or h <= 0:
            return
        if ox + w > cs or oy + h > cs:
            return
        for yy in range(int(h)):
            row_off = int((oy + yy) * cs + ox)
            src_off = int(yy * w)
            for xx in range(int(w)):
                chunk.tiles[int(row_off + xx)] = int(tiles[int(src_off + xx)])

    def _setup_home_highrise_world(self) -> None:
        # One-time furnishing for the player's high-rise home on the world map.
        # If an existing save predates features (e.g. toilet), we patch in the
        # missing pieces without re-randomizing the whole layout.
        already = bool(getattr(self, "_home_highrise_world_setup_done", False))
        home = getattr(self, "home_highrise_door", None)
        if not isinstance(home, tuple) or len(home) != 2:
            return
        try:
            hx, hy = int(home[0]), int(home[1])
        except Exception:
            return

        found = self._multi_house_at(int(hx), int(hy))
        if found is None:
            return
        chunk, mh = found

        tx0 = int(getattr(mh, "tx0", 0))
        ty0 = int(getattr(mh, "ty0", 0))
        bw = int(getattr(mh, "w", 0))
        bh = int(getattr(mh, "h", 0))
        if bw <= 0 or bh <= 0:
            return

        # Confirm this multi-house is a high-rise building footprint.
        style = 0
        for b in getattr(chunk, "buildings", []):
            if int(b[0]) == int(tx0) and int(b[1]) == int(ty0) and int(b[2]) == int(bw) and int(b[3]) == int(bh):
                roof_kind = int(b[4]) if len(b) > 4 else 0
                style, _var = self._building_roof_style_var(int(roof_kind))
                break
        if int(style) != 6:
            return

        floors = int(max(1, int(getattr(mh, "floors", 1))))
        floors = int(min(int(floors), int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
        if floors <= 1:
            return

        home_floor = int(getattr(self, "home_highrise_floor", 0))
        if home_floor <= 0:
            return
        home_floor = int(clamp(int(home_floor), 1, int(floors)))

        base_tiles = mh.floor_tiles.get(int(home_floor))
        if not isinstance(base_tiles, list):
            return
        w = int(bw)
        h = int(bh)
        if len(base_tiles) != int(w) * int(h):
            return

        # IMPORTANT: upper floors may share the same list instance; copy so only the home floor is furnished.
        tiles = list(int(t) for t in base_tiles)
        mh.floor_tiles[int(home_floor)] = tiles

        def get(x: int, y: int) -> int:
            return int(tiles[int(y) * int(w) + int(x)])

        def set_t(x: int, y: int, tid: int) -> None:
            tiles[int(y) * int(w) + int(x)] = int(tid)

        def has_toilet() -> bool:
            return any(int(t) == int(self.T_TOILET) for t in tiles)

        # Identify unit-entry doors by looking at the public lobby/corridor region.
        # This stays stable even after we add interior room doors for the home layout.
        door_like = {
            int(self.T_DOOR),
            int(self.T_DOOR_HOME),
            int(self.T_DOOR_LOCKED),
            int(self.T_DOOR_HOME_LOCKED),
            int(self.T_DOOR_BROKEN),
        }

        # Public region seed: elevator tile (always in the lobby).
        elev: tuple[int, int] | None = None
        for yy in range(1, int(h) - 1):
            row_off = int(yy) * int(w)
            for xx in range(1, int(w) - 1):
                if int(tiles[int(row_off + xx)]) == int(self.T_ELEVATOR):
                    elev = (int(xx), int(yy))
                    break
            if elev is not None:
                break
        if elev is None:
            return

        def public_passable(x: int, y: int) -> bool:
            if not (0 <= int(x) < int(w) and 0 <= int(y) < int(h)):
                return False
            tid = int(get(int(x), int(y)))
            if int(tid) in door_like:
                return False
            tdef = self._TILES.get(int(tid))
            return bool(tdef is not None and not bool(getattr(tdef, "solid", False)))

        public: set[tuple[int, int]] = set()
        stack = [elev]
        while stack:
            x, y = stack.pop()
            x = int(x)
            y = int(y)
            if (x, y) in public:
                continue
            if not public_passable(int(x), int(y)):
                continue
            public.add((int(x), int(y)))
            stack.extend(((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)))

        # Candidate unit-entry door tiles are those that border the public region.
        unit_doors: list[tuple[int, int]] = []
        for yy in range(1, int(h) - 1):
            row_off = int(yy) * int(w)
            for xx in range(1, int(w) - 1):
                tid = int(tiles[int(row_off + xx)])
                if int(tid) not in door_like:
                    continue
                near_public = False
                near_private = False
                for ox, oy in ((0, -1), (-1, 0), (1, 0), (0, 1)):
                    nx, ny = int(xx + ox), int(yy + oy)
                    if not (0 <= int(nx) < int(w) and 0 <= int(ny) < int(h)):
                        continue
                    if (int(nx), int(ny)) in public:
                        near_public = True
                    else:
                        nt = int(get(int(nx), int(ny)))
                        if int(nt) != int(self.T_WALL):
                            near_private = True
                if near_public and near_private:
                    unit_doors.append((int(xx), int(yy)))

        if not unit_doors:
            return
        unit_doors.sort(key=lambda p: (int(p[0]), int(p[1])))

        # Doorways can be 1-2 tiles wide; group contiguous door tiles so we
        # pick a whole doorway as a "unit door".
        unit_door_set = {(int(x), int(y)) for (x, y) in unit_doors}
        seen_doors: set[tuple[int, int]] = set()
        door_clusters: list[list[tuple[int, int]]] = []
        for px, py in unit_doors:
            px = int(px)
            py = int(py)
            if (px, py) in seen_doors:
                continue
            stack = [(int(px), int(py))]
            comp: list[tuple[int, int]] = []
            while stack:
                sx, sy = stack.pop()
                sx = int(sx)
                sy = int(sy)
                if (sx, sy) in seen_doors:
                    continue
                if (sx, sy) not in unit_door_set:
                    continue
                seen_doors.add((sx, sy))
                comp.append((sx, sy))
                stack.extend(((sx + 1, sy), (sx - 1, sy), (sx, sy + 1), (sx, sy - 1)))
            if comp:
                comp.sort(key=lambda q: (int(q[0]), int(q[1])))
                door_clusters.append(comp)
        if not door_clusters:
            return
        door_clusters.sort(
            key=lambda comp: (
                min(int(q[0]) for q in comp),
                min(int(q[1]) for q in comp),
                int(len(comp)),
            )
        )

        unit = int(getattr(self, "home_highrise_unit", 1))
        unit = int(clamp(int(unit), 1, int(len(door_clusters))))
        home_cluster = door_clusters[int(unit - 1)]
        dx, dy = home_cluster[0]

        # Mark the home door as green. Default to *locked* so only the
        # matching key can open it.
        if not already:
            for hx2, hy2 in home_cluster:
                set_t(int(hx2), int(hy2), int(self.T_DOOR_HOME_LOCKED))
        else:
            # Don't re-lock existing saves; just ensure the tile is a home door.
            for hx2, hy2 in home_cluster:
                cur_home_door = int(get(int(hx2), int(hy2)))
                if cur_home_door == int(self.T_DOOR):
                    set_t(int(hx2), int(hy2), int(self.T_DOOR_HOME))
                elif cur_home_door == int(self.T_DOOR_LOCKED):
                    set_t(int(hx2), int(hy2), int(self.T_DOOR_HOME_LOCKED))
        self.home_highrise_world_key = (int(tx0), int(ty0), int(w), int(h))
        self.home_highrise_world_floor = int(home_floor)
        self.home_highrise_world_home_door = (int(tx0 + dx), int(ty0 + dy))
        self.home_highrise_world_home_door_tiles = [(int(tx0 + x), int(ty0 + y)) for (x, y) in home_cluster]

        # Lock other unit-entry doors; a few are randomly broken (enterable).
        # IMPORTANT: these are the doors from the *base building plan* (unit doors),
        # not the interior bedroom/bath doors we add later.
        try:
            seed_base = int(self.seed) ^ 0x6B8B4567
            for comp in door_clusters:
                if comp is home_cluster:
                    continue
                # Only patch untouched unit doors; preserve any player changes.
                if any(int(get(int(ux), int(uy))) != int(self.T_DOOR) for (ux, uy) in comp):
                    continue
                ax0, ay0 = comp[0]
                hh = int(self._hash2_u32(int(tx0 + ax0), int(ty0 + ay0), int(seed_base)))
                # ~18% broken doors.
                tid = int(self.T_DOOR_BROKEN) if int(hh % 100) < 18 else int(self.T_DOOR_LOCKED)
                for ux, uy in comp:
                    set_t(int(ux), int(uy), int(tid))
        except Exception:
            pass

        # Migration: if any non-entry interior doors were accidentally locked by
        # older logic, unlock them (keep unit-entry doors as-is).
        unit_door_set_all: set[tuple[int, int]] = set()
        for comp in door_clusters:
            for x, y in comp:
                unit_door_set_all.add((int(x), int(y)))

        for yy in range(1, int(h) - 1):
            row_off = int(yy) * int(w)
            for xx in range(1, int(w) - 1):
                if (int(xx), int(yy)) in unit_door_set_all:
                    continue
                tid = int(tiles[int(row_off + xx)])
                if tid in (int(self.T_DOOR_LOCKED), int(self.T_DOOR_HOME_LOCKED), int(self.T_DOOR_HOME)):
                    tiles[int(row_off + xx)] = int(self.T_DOOR)

        # Flood-fill the apartment region above the door (skip the elevator lobby below).
        start: tuple[int, int] | None = (int(dx), int(dy - 1))

        def is_floor(x: int, y: int) -> bool:
            if not (0 <= int(x) < int(w) and 0 <= int(y) < int(h)):
                return False
            # For initial carve (fresh layout), the apartment interior is all floor so
            # this behaves like a floor-only flood-fill. For older saves, internal
            # room doors already exist; treat them as passable so the region covers
            # the whole apartment (but never cross the green home door to the hall).
            tid = int(get(int(x), int(y)))
            if int(tid) == int(self.T_FLOOR):
                return True
            if int(tid) == int(self.T_DOOR):
                return True
            return False

        if start is None or not is_floor(int(start[0]), int(start[1])):
            start = None
            for sx, sy in ((dx, dy - 1), (dx - 1, dy), (dx + 1, dy), (dx, dy + 1)):
                if is_floor(int(sx), int(sy)):
                    start = (int(sx), int(sy))
                    break
        if start is None:
            return

        region: set[tuple[int, int]] = set()
        stack = [start]
        while stack:
            x, y = stack.pop()
            x = int(x)
            y = int(y)
            if (x, y) in region:
                continue
            if not is_floor(int(x), int(y)):
                continue
            region.add((int(x), int(y)))
            stack.extend(((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)))
        if not region:
            return

        # Patch pass: if this home was already set up previously, avoid changing
        # walls/furniture; only ensure critical fixtures exist.
        if already:
            # Always enforce "toilet is in the bathroom" for older saves.
            # We don't re-carve the whole layout; we relocate the toilet into the
            # smallest south-side room (rooms are split by doors/walls).
            def passable_tid(tid: int) -> bool:
                tdef = self._TILES.get(int(tid))
                return bool(tdef is not None and not bool(getattr(tdef, "solid", False)))

            min_x = min(int(p[0]) for p in region)
            max_x = max(int(p[0]) for p in region)
            min_y = min(int(p[1]) for p in region)
            max_y = max(int(p[1]) for p in region)
            south_y = int((min_y + max_y) // 2)

            # Build floor-room components (doors split rooms).
            floor_cells = {(int(x), int(y)) for (x, y) in region if int(get(int(x), int(y))) == int(self.T_FLOOR)}
            comps: list[set[tuple[int, int]]] = []
            seen_fc: set[tuple[int, int]] = set()
            for cell in list(floor_cells):
                if cell in seen_fc:
                    continue
                stack2 = [cell]
                comp: set[tuple[int, int]] = set()
                while stack2:
                    cx2, cy2 = stack2.pop()
                    if (int(cx2), int(cy2)) in seen_fc:
                        continue
                    if (int(cx2), int(cy2)) not in floor_cells:
                        continue
                    seen_fc.add((int(cx2), int(cy2)))
                    comp.add((int(cx2), int(cy2)))
                    stack2.extend(
                        (
                            (int(cx2) + 1, int(cy2)),
                            (int(cx2) - 1, int(cy2)),
                            (int(cx2), int(cy2) + 1),
                            (int(cx2), int(cy2) - 1),
                        )
                    )
                if comp:
                    comps.append(comp)

            start_xy = (int(start[0]), int(start[1])) if isinstance(start, tuple) else None
            main_comp: set[tuple[int, int]] | None = None
            if start_xy is not None and start_xy in floor_cells:
                for c in comps:
                    if start_xy in c:
                        main_comp = c
                        break
            if main_comp is None and comps:
                main_comp = max(comps, key=lambda c: len(c))

            bath_comp: set[tuple[int, int]] | None = None
            bath_key: tuple[int, int, int] | None = None  # (size, -max_y, -max_x)
            for c in comps:
                if main_comp is not None and c is main_comp:
                    continue
                if not c:
                    continue
                c_max_y = max(int(p[1]) for p in c)
                if c_max_y <= int(south_y):
                    continue
                c_max_x = max(int(p[0]) for p in c)
                key = (int(len(c)), -int(c_max_y), -int(c_max_x))
                if bath_key is None or key < bath_key:
                    bath_key = key
                    bath_comp = c

            toilet_cells = {
                (int(i) % int(w), int(i) // int(w))
                for i, t in enumerate(tiles)
                if int(t) == int(self.T_TOILET)
            }
            need_relocate = False
            if not toilet_cells:
                need_relocate = True
            elif bath_comp is not None:
                # If we can identify a bathroom room-component, keep the toilet there.
                def toilet_in_bathroom(pos: tuple[int, int]) -> bool:
                    x, y = pos
                    if (int(x), int(y)) in bath_comp:
                        return True
                    for ox, oy in ((0, -1), (-1, 0), (1, 0), (0, 1)):
                        if (int(x + ox), int(y + oy)) in bath_comp:
                            return True
                    return False

                need_relocate = not any(toilet_in_bathroom(c) for c in toilet_cells)
            else:
                # No clear bathroom component: keep any existing toilet in the south half.
                need_relocate = not any(int(y) > int(south_y) for (_x, y) in toilet_cells)

            if not need_relocate:
                self._home_highrise_world_setup_done = True
                try:
                    if int(getattr(mh, "cur_floor", 1)) == int(home_floor):
                        self._multi_house_apply_floor(chunk, mh)
                except Exception:
                    pass
                return

            target_room = bath_comp if bath_comp is not None else None
            candidates = list(target_room) if target_room is not None else [(int(x), int(y)) for (x, y) in floor_cells]
            candidates.sort(key=lambda p: (int(p[1]), int(p[0])), reverse=True)

            def adj_has_door(x: int, y: int) -> bool:
                for ox, oy in ((0, -1), (-1, 0), (1, 0), (0, 1)):
                    nx, ny = int(x + ox), int(y + oy)
                    if not (0 <= int(nx) < int(w) and 0 <= int(ny) < int(h)):
                        continue
                    if int(get(int(nx), int(ny))) == int(self.T_DOOR):
                        return True
                return False

            best: tuple[int, int] | None = None
            for x, y in candidates:
                x = int(x)
                y = int(y)
                if y <= int(south_y):
                    continue
                if int(get(int(x), int(y))) != int(self.T_FLOOR):
                    continue
                if adj_has_door(int(x), int(y)):
                    continue
                ok_adj = False
                for ox, oy in ((0, -1), (-1, 0), (1, 0), (0, 1)):
                    nx, ny = int(x + ox), int(y + oy)
                    if not (0 <= int(nx) < int(w) and 0 <= int(ny) < int(h)):
                        continue
                    if passable_tid(int(get(int(nx), int(ny)))):
                        ok_adj = True
                        break
                if not ok_adj:
                    continue
                best = (int(x), int(y))
                break

            # If the room is tiny, allow placing next to the door.
            if best is None:
                for x, y in candidates:
                    x = int(x)
                    y = int(y)
                    if y <= int(south_y):
                        continue
                    if int(get(int(x), int(y))) != int(self.T_FLOOR):
                        continue
                    ok_adj = False
                    for ox, oy in ((0, -1), (-1, 0), (1, 0), (0, 1)):
                        nx, ny = int(x + ox), int(y + oy)
                        if not (0 <= int(nx) < int(w) and 0 <= int(ny) < int(h)):
                            continue
                        if passable_tid(int(get(int(nx), int(ny)))):
                            ok_adj = True
                            break
                    if not ok_adj:
                        continue
                    best = (int(x), int(y))
                    break

            if best is not None:
                # Clear existing toilets first (so we don't leave a random one in the living room).
                for i, t in enumerate(list(tiles)):
                    if int(t) == int(self.T_TOILET):
                        tiles[int(i)] = int(self.T_FLOOR)
                bx, by = best
                set_t(int(bx), int(by), int(self.T_TOILET))
                try:
                    self._multi_house_apply_floor(chunk, mh)
                except Exception:
                    pass
            self._home_highrise_world_setup_done = True
            try:
                if int(getattr(mh, "cur_floor", 1)) == int(home_floor):
                    self._multi_house_apply_floor(chunk, mh)
            except Exception:
                pass
            return

        min_x = min(int(p[0]) for p in region)
        max_x = max(int(p[0]) for p in region)
        min_y = min(int(p[1]) for p in region)
        max_y = max(int(p[1]) for p in region)

        # Keep the entry area clear so the player never gets stuck at the door.
        reserved: set[tuple[int, int]] = set()
        ex, ey = start
        for oy in (-1, 0, 1):
            for ox in (-1, 0, 1):
                reserved.add((int(ex + ox), int(ey + oy)))
        layout_guard: set[tuple[int, int]] = set(reserved)

        def can_place(cells: list[tuple[int, int]]) -> bool:
            for x, y in cells:
                x = int(x)
                y = int(y)
                if (x, y) in reserved:
                    return False
                if (x, y) not in region:
                    return False
                if int(get(x, y)) != int(self.T_FLOOR):
                    return False
            return True

        def place(tid: int, cells: list[tuple[int, int]]) -> bool:
            if not can_place(cells):
                return False
            for x, y in cells:
                set_t(int(x), int(y), int(tid))
            return True

        # Home floorplan (world-map, NOT full-screen): 1 living + 2 bedrooms + 1 bath + 1 kitchen.
        rect_w = int(max_x - min_x + 1)
        rect_h = int(max_y - min_y + 1)
        # Debug: helps validate that the home is actually >= 100 floor tiles.
        self._home_highrise_world_debug = {"region": int(len(region)), "rect_w": int(rect_w), "rect_h": int(rect_h)}

        def set_if_clear(x: int, y: int, tid: int) -> bool:
            x = int(x)
            y = int(y)
            if (x, y) in reserved:
                return False
            if (x, y) not in region:
                return False
            if int(get(x, y)) != int(self.T_FLOOR):
                return False
            set_t(int(x), int(y), int(tid))
            return True

        def set_if_floor(x: int, y: int, tid: int) -> bool:
            x = int(x)
            y = int(y)
            if (x, y) not in region:
                return False
            if int(get(int(x), int(y))) != int(self.T_FLOOR):
                return False
            set_t(int(x), int(y), int(tid))
            return True

        def wall_at(x: int, y: int) -> None:
            x = int(x)
            y = int(y)
            if (x, y) in layout_guard:
                return
            if (x, y) not in region:
                return
            if int(get(x, y)) != int(self.T_FLOOR):
                return
            set_t(int(x), int(y), int(self.T_WALL))

        def door_at(x: int, y: int) -> None:
            x = int(x)
            y = int(y)
            if (x, y) in layout_guard:
                return
            if (x, y) not in region:
                return
            set_t(int(x), int(y), int(self.T_DOOR))

        def reserve_near(x: int, y: int) -> None:
            # Reserve a tiny cross-shaped passage so doors/corridors stay usable,
            # without wasting too much space in smaller apartments.
            x = int(x)
            y = int(y)
            for ox, oy in ((0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)):
                reserved.add((int(x + ox), int(y + oy)))

        door_clear: list[tuple[int, int, list[tuple[int, int]]]] = []

        did_layout = False
        layout_kind = "none"  # home_v2 | classic | classic_small | none
        bed_wall_y = None
        bed_div_x = None
        service_wall_x = None
        bath_box: tuple[int, int, int, int] | None = None  # (x0,y0,x1,y1) interior floor rect
        kitchen_box: tuple[int, int, int, int] | None = None  # (x0,y0,x1,y1) interior floor rect
        bed1_box: tuple[int, int, int, int] | None = None
        bed2_box: tuple[int, int, int, int] | None = None
        living_box: tuple[int, int, int, int] | None = None

        # Prefer a "real home" plan for narrow but tall apartments.
        min_home_tiles = 100
        if int(rect_w) >= 7 and int(rect_h) >= 12 and len(region) >= int(min_home_tiles) and int(rect_w) <= 8:
            layout_kind = "home_v2"
            did_layout = True

            # Allocate a living band at the bottom while guaranteeing space for
            # 2 bedrooms + separator walls.
            # Narrow apartments need a bit more living depth so the kitchen isn't
            # a 2-row strip (we need room for fridge + counters).
            min_living_h = 7
            min_bed_total = 8  # 2 bedrooms (>=3 each) + 1 sep wall + 1 boundary wall
            max_living_h = max(int(min_living_h), int(rect_h) - int(min_bed_total))
            living_h = int(clamp(int(round(float(rect_h) * 0.42)), int(min_living_h), int(max_living_h)))
            living_top_y = int(max_y - int(living_h) + 1)
            bed_zone_wall_y = int(living_top_y - 1)  # wall row between bedrooms and living

            # Corridor at x=min_x; bedrooms start after a wall at x=min_x+1.
            corridor_wall_x = int(min_x + 1)
            room_x0 = int(corridor_wall_x + 1)

            bed_zone_h = int(bed_zone_wall_y - min_y)  # rows above the boundary wall
            min_bed_h = 3

            # Basic sanity: need at least a 3-tile wide bedroom side and enough height.
            ok_home_v2 = not (
                int(room_x0) >= int(max_x - 1)
                or int(bed_zone_wall_y) <= int(min_y + 5)
                or int(bed_zone_h) < int(min_bed_h * 2 + 1)
            )
            if not ok_home_v2:
                did_layout = False
                layout_kind = "none"
            else:
                bed1_h_max = int(bed_zone_h - (int(min_bed_h) + 1))
                bed1_h = int(clamp(int(round(float(bed_zone_h) * 0.52)), int(min_bed_h), int(bed1_h_max)))
                bed_sep_y = int(min_y + int(bed1_h))  # wall row between bedrooms
                bed1_y0 = int(min_y)
                bed1_y1 = int(bed_sep_y - 1)
                bed2_y0 = int(bed_sep_y + 1)
                bed2_y1 = int(bed_zone_wall_y - 1)
                if int(bed2_y1 - bed2_y0 + 1) < int(min_bed_h):
                    did_layout = False
                    layout_kind = "none"
                else:
                    # Compute the living-side kitchen/bath strip.
                    living_band_h = int(max_y - living_top_y + 1)
                    service_w = 2 if int(rect_w) <= 7 else 3
                    service_w = int(clamp(int(service_w), 2, max(2, int(rect_w) - 4)))
                    service_x0 = int(max_x - int(service_w) + 1)
                    service_wall = int(service_x0 - 1)

                    # Keep at least a 4-tile living width.
                    if int(service_wall - min_x) < 5:
                        service_w = 2
                        service_x0 = int(max_x - 1)
                        service_wall = int(service_x0 - 1)

                    kitchen_min_h = 3
                    bath_target_h = 3
                    max_bath_h = int(living_band_h) - int(kitchen_min_h) - 1  # leave 1 wall row
                    max_bath_h = int(max(2, int(max_bath_h)))
                    bath_h = int(clamp(int(bath_target_h), 2, int(max_bath_h)))
                    bath_y0 = int(max_y - int(bath_h) + 1)
                    bath_sep_y = int(bath_y0 - 1)
                    kitchen_y0 = int(living_top_y)
                    kitchen_y1 = int(bath_sep_y - 1)

                    # Require a usable kitchen band.
                    if int(kitchen_y1) < int(kitchen_y0) + int(kitchen_min_h - 1):
                        did_layout = False
                        layout_kind = "none"
                    else:
                        # Corridor wall (separates corridor from bedrooms).
                        for yy in range(int(min_y), int(bed_zone_wall_y) + 1):
                            wall_at(int(corridor_wall_x), int(yy))

                        # Bedroom separator + boundary wall (bedroom side only; keep corridor open).
                        for xx in range(int(room_x0), int(max_x) + 1):
                            wall_at(int(xx), int(bed_sep_y))
                            wall_at(int(xx), int(bed_zone_wall_y))

                        def pick_door_y(y0: int, y1: int) -> int:
                            y0 = int(y0)
                            y1 = int(y1)
                            if y1 - y0 < 3:
                                return int(clamp(int(y0 + 1), int(y0), int(y1)))
                            return int(clamp(int((y0 + y1) // 2), int(y0 + 1), int(y1 - 1)))

                        for dy2 in (pick_door_y(int(bed1_y0), int(bed1_y1)), pick_door_y(int(bed2_y0), int(bed2_y1))):
                            door_at(int(corridor_wall_x), int(dy2))
                            door_clear.append(
                                (
                                    int(corridor_wall_x),
                                    int(dy2),
                                    [(int(corridor_wall_x - 1), int(dy2)), (int(corridor_wall_x + 1), int(dy2))],
                                )
                            )
                            reserve_near(int(corridor_wall_x - 1), int(dy2))
                            reserve_near(int(corridor_wall_x + 1), int(dy2))

                        # Vertical wall between living and the service strip.
                        for yy in range(int(living_top_y), int(max_y) + 1):
                            wall_at(int(service_wall), int(yy))

                        # Horizontal wall between kitchen and bathroom (service strip only).
                        for xx in range(int(service_x0), int(max_x) + 1):
                            wall_at(int(xx), int(bath_sep_y))

                        # Doors into kitchen and bath (on the service wall).
                        kitchen_door_y = int((int(kitchen_y0) + int(kitchen_y1)) // 2)
                        bath_door_y = int((int(bath_y0) + int(max_y)) // 2)
                        for dy2 in (int(kitchen_door_y), int(bath_door_y)):
                            door_at(int(service_wall), int(dy2))
                            door_clear.append(
                                (
                                    int(service_wall),
                                    int(dy2),
                                    [(int(service_wall - 1), int(dy2)), (int(service_wall + 1), int(dy2))],
                                )
                            )
                            reserve_near(int(service_wall - 1), int(dy2))
                            reserve_near(int(service_wall + 1), int(dy2))

                        # Boxes for furnishing (interior floor rects).
                        bed1_box = (int(room_x0), int(bed1_y0), int(max_x), int(bed1_y1))
                        bed2_box = (int(room_x0), int(bed2_y0), int(max_x), int(bed2_y1))
                        living_box = (int(min_x), int(living_top_y), int(service_wall - 1), int(max_y))
                        kitchen_box = (int(service_x0), int(kitchen_y0), int(max_x), int(kitchen_y1))
                        bath_box = (int(service_x0), int(bath_y0), int(max_x), int(max_y))
                        # Keep the 1-tile corridor strip clear so bedrooms never get blocked by furniture.
                        for yy in range(int(min_y), int(max_y) + 1):
                            reserved.add((int(min_x), int(yy)))

        # Only attempt the room carve when there's enough space to walk.
        if (not did_layout) and int(rect_w) >= 7 and int(rect_h) >= 6:
            did_layout = True
            layout_kind = "classic"
            # Bedrooms (north) vs living/kitchen/bath (south).
            max_bed = int(rect_h) - 4 if int(rect_h) >= 6 else int(rect_h) - 3
            max_bed = int(max(2, int(max_bed)))
            bed_depth = int(clamp(int(round(float(rect_h) * 0.45)), 2, int(max_bed)))
            bed_wall_y = int(clamp(int(min_y + bed_depth), int(min_y + 2), int(max_y - 2)))

            # Two bedrooms split left/right.
            bed_div_x = int(clamp(int(min_x + (int(rect_w) // 2)), int(min_x + 3), int(max_x - 3)))

            # Horizontal wall between bedrooms and living area.
            for xx in range(int(min_x), int(max_x) + 1):
                wall_at(int(xx), int(bed_wall_y))
            # Vertical wall between the two bedrooms.
            for yy in range(int(min_y), int(bed_wall_y)):
                wall_at(int(bed_div_x), int(yy))

            # Bedroom doors on the bedroom/living separator.
            left_door_x = int(
                clamp(
                    int((int(min_x) + int(bed_div_x)) // 2),
                    int(min_x + 1),
                    int(bed_div_x - 1),
                )
            )
            right_door_x = int(
                clamp(int((int(bed_div_x + 1) + int(max_x)) // 2), int(bed_div_x + 1), int(max_x - 1))
            )
            door_at(int(left_door_x), int(bed_wall_y))
            door_at(int(right_door_x), int(bed_wall_y))
            door_clear.append((int(left_door_x), int(bed_wall_y), [(int(left_door_x), int(bed_wall_y - 1)), (int(left_door_x), int(bed_wall_y + 1))]))
            door_clear.append((int(right_door_x), int(bed_wall_y), [(int(right_door_x), int(bed_wall_y - 1)), (int(right_door_x), int(bed_wall_y + 1))]))
            reserve_near(int(left_door_x), int(bed_wall_y + 1))
            reserve_near(int(right_door_x), int(bed_wall_y + 1))
            reserve_near(int(left_door_x), int(bed_wall_y - 1))
            reserve_near(int(right_door_x), int(bed_wall_y - 1))
            reserve_near(int(left_door_x), int(bed_wall_y - 1))
            reserve_near(int(right_door_x), int(bed_wall_y - 1))

            south_top_y = int(bed_wall_y + 1)
            south_h = int(max_y - south_top_y + 1)

            # Kitchen/bath service strip on the right (keeps living room larger).
            service_w = 0
            if int(rect_w) >= 14:
                service_w = 4
            elif int(rect_w) >= 10:
                service_w = 3
            elif int(rect_w) >= 7:
                service_w = 2
            if int(service_w) > 0 and int(south_h) >= 3:
                service_wall_x = int(max_x - int(service_w))
                for yy in range(int(south_top_y), int(max_y) + 1):
                    wall_at(int(service_wall_x), int(yy))

                # Door into the kitchen/service area.
                kitchen_door_y = int(south_top_y)
                door_at(int(service_wall_x), int(kitchen_door_y))
                door_clear.append(
                    (
                        int(service_wall_x),
                        int(kitchen_door_y),
                        [(int(service_wall_x - 1), int(kitchen_door_y)), (int(service_wall_x + 1), int(kitchen_door_y))],
                    )
                )
                reserve_near(int(service_wall_x - 1), int(kitchen_door_y))
                reserve_near(int(service_wall_x + 1), int(kitchen_door_y))

                # Bathroom: take the bottom slice of the service area (not just 1 row).
                min_kitchen_h = 2
                min_bath_h = 2
                max_bath_h = int(south_h) - int(min_kitchen_h) - 1  # leave 1 wall row too
                if int(max_bath_h) < int(min_bath_h):
                    bath_h = 1
                else:
                    bath_h = int(clamp(int(round(float(south_h) * 0.45)), int(min_bath_h), int(max_bath_h)))
                bath_sep_y = int(max_y - int(bath_h))
                bath_sep_y = int(clamp(int(bath_sep_y), int(south_top_y + 1), int(max_y - 1)))
                for xx in range(int(service_wall_x + 1), int(max_x) + 1):
                    wall_at(int(xx), int(bath_sep_y))
                bath_door_x = int(service_wall_x + 1)
                door_at(int(bath_door_x), int(bath_sep_y))
                door_clear.append(
                    (
                        int(bath_door_x),
                        int(bath_sep_y),
                        [(int(bath_door_x), int(bath_sep_y - 1)), (int(bath_door_x), int(bath_sep_y + 1))],
                    )
                )
                reserve_near(int(bath_door_x), int(bath_sep_y + 1))
                reserve_near(int(bath_door_x), int(bath_sep_y - 1))
                bath_box = (int(service_wall_x + 1), int(bath_sep_y + 1), int(max_x), int(max_y))
        elif (not did_layout) and int(rect_w) >= 5 and int(rect_h) >= 6:
            # Small-unit fallback: still carve the same concept (1211) in a compact way.
            did_layout = True
            layout_kind = "classic_small"
            bed_wall_y = int(clamp(int(min_y + 2), int(min_y + 2), int(max_y - 2)))
            bed_div_x = int(clamp(int(min_x + (int(rect_w) // 2)), int(min_x + 2), int(max_x - 2)))

            # Bedrooms vs living separator.
            for xx in range(int(min_x), int(max_x) + 1):
                wall_at(int(xx), int(bed_wall_y))
            for yy in range(int(min_y), int(bed_wall_y)):
                wall_at(int(bed_div_x), int(yy))

            # Bedroom doors.
            left_door_x = int(clamp(int(min_x + 1), int(min_x + 1), int(bed_div_x - 1)))
            right_door_x = int(clamp(int(bed_div_x + 1), int(bed_div_x + 1), int(max_x - 1)))
            door_at(int(left_door_x), int(bed_wall_y))
            door_at(int(right_door_x), int(bed_wall_y))
            door_clear.append((int(left_door_x), int(bed_wall_y), [(int(left_door_x), int(bed_wall_y - 1)), (int(left_door_x), int(bed_wall_y + 1))]))
            door_clear.append((int(right_door_x), int(bed_wall_y), [(int(right_door_x), int(bed_wall_y - 1)), (int(right_door_x), int(bed_wall_y + 1))]))
            reserve_near(int(left_door_x), int(bed_wall_y + 1))
            reserve_near(int(right_door_x), int(bed_wall_y + 1))

            # Living (left) + service (right) split on the same divider.
            service_wall_x = int(bed_div_x)
            south_top_y = int(bed_wall_y + 1)
            for yy in range(int(south_top_y), int(max_y) + 1):
                wall_at(int(service_wall_x), int(yy))
            service_door_y = int(clamp(int(south_top_y), int(south_top_y), int(max_y - 1)))
            door_at(int(service_wall_x), int(service_door_y))
            door_clear.append(
                (
                    int(service_wall_x),
                    int(service_door_y),
                    [(int(service_wall_x - 1), int(service_door_y)), (int(service_wall_x + 1), int(service_door_y))],
                )
            )
            reserve_near(int(service_wall_x - 1), int(service_door_y))
            reserve_near(int(service_wall_x + 1), int(service_door_y))

            # Bathroom: bottom slice of the service area.
            bath_h = 2 if int(max_y - south_top_y + 1) >= 4 else 1
            bath_sep_y = int(max_y - int(bath_h))
            bath_sep_y = int(clamp(int(bath_sep_y), int(south_top_y + 1), int(max_y - 1)))
            for xx in range(int(service_wall_x + 1), int(max_x) + 1):
                wall_at(int(xx), int(bath_sep_y))
            bath_door_x = int(service_wall_x + 1)
            door_at(int(bath_door_x), int(bath_sep_y))
            door_clear.append(
                (
                    int(bath_door_x),
                    int(bath_sep_y),
                    [(int(bath_door_x), int(bath_sep_y - 1)), (int(bath_door_x), int(bath_sep_y + 1))],
                )
            )
            reserve_near(int(bath_door_x), int(bath_sep_y + 1))
            reserve_near(int(bath_door_x), int(bath_sep_y - 1))
            bath_box = (int(service_wall_x + 1), int(bath_sep_y + 1), int(max_x), int(max_y))

        def place_in_rect(tid: int, shape: list[tuple[int, int]], *, x0: int, y0: int, x1: int, y1: int) -> bool:
            x0 = int(x0)
            y0 = int(y0)
            x1 = int(x1)
            y1 = int(y1)
            if x1 < x0 or y1 < y0:
                return False
            for yy in range(int(y0), int(y1) + 1):
                for xx in range(int(x0), int(x1) + 1):
                    cells = [(int(xx + dx2), int(yy + dy2)) for dx2, dy2 in shape]
                    if place(int(tid), cells):
                        return True
            return False

        if (
            did_layout
            and str(layout_kind) == "home_v2"
            and bed1_box is not None
            and bed2_box is not None
            and living_box is not None
            and kitchen_box is not None
            and bath_box is not None
        ):
            b1x0, b1y0, b1x1, b1y1 = (int(v) for v in bed1_box)
            b2x0, b2y0, b2x1, b2y1 = (int(v) for v in bed2_box)
            lvx0, lvy0, lvx1, lvy1 = (int(v) for v in living_box)
            kx0, ky0, kx1, ky1 = (int(v) for v in kitchen_box)
            bax0, bay0, bax1, bay1 = (int(v) for v in bath_box)

            # Beds (2-tile connected).
            bed_shape_h = [(0, 0), (1, 0)]
            place_in_rect(int(self.T_BED), bed_shape_h, x0=int(b1x0), y0=int(b1y0 + 1), x1=int(b1x1 - 1), y1=int(b1y1))
            place_in_rect(int(self.T_BED), bed_shape_h, x0=int(b2x0), y0=int(b2y0 + 1), x1=int(b2x1 - 1), y1=int(b2y1))

            # Bedroom storage (wardrobe/bookshelf).
            if not place_in_rect(int(self.T_SHELF), [(0, 0)], x0=int(b1x1), y0=int(b1y0 + 1), x1=int(b1x1), y1=int(b1y1)):
                place_in_rect(int(self.T_SHELF), [(0, 0)], x0=int(b1x0), y0=int(b1y0), x1=int(b1x1), y1=int(b1y1))

            # Study: PC desk near the top-right of bedroom 2.
            pc_shape = [(0, 0), (1, 0)]
            pc_anchor: tuple[int, int] | None = None
            for yy in range(int(b2y0 + 1), int(b2y1) + 1):
                for xx in range(int(b2x1 - 1), int(b2x0) - 1, -1):
                    if place(int(self.T_PC), [(int(xx), int(yy)), (int(xx + 1), int(yy))]):
                        pc_anchor = (int(xx), int(yy))
                        break
                if pc_anchor is not None:
                    break
            if pc_anchor is None:
                # Fallback: any fit in the study bedroom.
                for yy in range(int(b2y0), int(b2y1) + 1):
                    for xx in range(int(b2x0), int(b2x1)):
                        if place(int(self.T_PC), [(int(xx), int(yy)), (int(xx + 1), int(yy))]):
                            pc_anchor = (int(xx), int(yy))
                            break
                    if pc_anchor is not None:
                        break

            # Chair in front of the desk (try a few cells).
            if pc_anchor is not None:
                dx, dy = pc_anchor
                for sx, sy in (
                    (dx, dy + 1),
                    (dx + 1, dy + 1),
                    (dx, dy + 2),
                    (dx + 1, dy + 2),
                    (dx - 1, dy + 1),
                    (dx + 2, dy + 1),
                ):
                    if set_if_clear(int(sx), int(sy), int(self.T_CHAIR)):
                        break

            # Living room: sofa + TV + small table.
            sofa_y = int(max(int(lvy0), int(lvy1 - 2)))
            # Try to keep the far-right tile free for the TV by shortening the sofa run.
            sofa_x1 = int(max(int(lvx0 + 1), int(lvx1 - 2)))
            if not place_in_rect(int(self.T_SOFA), [(0, 0), (1, 0)], x0=int(lvx0 + 1), y0=int(sofa_y), x1=int(sofa_x1), y1=int(sofa_y)):
                place_in_rect(int(self.T_SOFA), [(0, 0), (1, 0)], x0=int(lvx0 + 1), y0=int(sofa_y), x1=int(lvx1 - 1), y1=int(sofa_y))

            tv_pos: tuple[int, int] | None = None
            for ty3 in (int(sofa_y), int(sofa_y - 1), int(sofa_y + 1), int(lvy0 + 1), int(lvy1 - 1)):
                if set_if_clear(int(lvx1), int(ty3), int(self.T_TV)):
                    tv_pos = (int(lvx1), int(ty3))
                    break

            # Table near center with one chair (some houses are intentionally unfurnished).
            if random.random() < 0.75:
                cx2 = int((int(lvx0) + int(lvx1)) // 2)
                cy2 = int((int(lvy0) + int(lvy1)) // 2)
                table_pos: tuple[int, int] | None = None
                for r in range(0, 6):
                    for dy2 in range(-int(r), int(r) + 1):
                        for dx2 in range(-int(r), int(r) + 1):
                            tx2 = int(cx2 + dx2)
                            ty2 = int(cy2 + dy2)
                            if (tx2, ty2) in reserved:
                                continue
                            if (tx2, ty2) not in region:
                                continue
                            if int(get(int(tx2), int(ty2))) != int(self.T_FLOOR):
                                continue
                            if place(int(self.T_TABLE), [(int(tx2), int(ty2))]):
                                table_pos = (int(tx2), int(ty2))
                                break
                        if table_pos is not None:
                            break
                    if table_pos is not None:
                        break
                if table_pos is not None:
                    tx2, ty2 = table_pos
                    for (sx, sy) in ((tx2, ty2 + 1), (tx2 + 1, ty2), (tx2 - 1, ty2), (tx2, ty2 - 1)):
                        if set_if_clear(int(sx), int(sy), int(self.T_CHAIR)):
                            break

            # Kitchen: fridge + cabinets.
            fridge_ok = False
            for fx, fy in (
                (int(kx1), int(ky0)),
                (int(kx1), int(ky1)),
                (int(kx0), int(ky0)),
                (int(kx0), int(ky1)),
                (int(kx1), int(ky0 + 1)),
                (int(kx0), int(ky0 + 1)),
            ):
                if set_if_clear(int(fx), int(fy), int(self.T_FRIDGE)):
                    fridge_ok = True
                    break
            if not fridge_ok:
                place_in_rect(int(self.T_FRIDGE), [(0, 0)], x0=int(kx0), y0=int(ky0), x1=int(kx1), y1=int(ky1))

            cab_count = 0
            for sx, sy in (
                (int(kx0), int(ky0)),
                (int(kx0), int(ky1)),
                (int(kx1), int(ky0)),
                (int(kx1), int(ky1)),
                (int(kx0), int(ky0 + 1)),
                (int(kx1), int(ky0 + 1)),
            ):
                if set_if_clear(int(sx), int(sy), int(self.T_CABINET)):
                    cab_count += 1
                if cab_count >= 2:
                    break
            if cab_count == 0:
                place_in_rect(int(self.T_CABINET), [(0, 0)], x0=int(kx0), y0=int(ky0), x1=int(kx1), y1=int(ky1))

            # Bathroom: toilet + sink (faucet).
            placed_toilet = False
            for ty3 in range(int(bay1), int(bay0) - 1, -1):
                for tx3 in range(int(bax1), int(bax0) - 1, -1):
                    # Avoid the door-adjacent tile.
                    if int(tx3) == int(bax0) and int(ty3) == int(bay0):
                        continue
                    if set_if_floor(int(tx3), int(ty3), int(self.T_TOILET)):
                        placed_toilet = True
                        break
                if placed_toilet:
                    break
            if not placed_toilet:
                place_in_rect(int(self.T_TOILET), [(0, 0)], x0=int(bax0), y0=int(bay0), x1=int(bax1), y1=int(bay1))

            if not set_if_clear(int(bax0), int(bay0), int(self.T_SINK)):
                place_in_rect(int(self.T_SINK), [(0, 0)], x0=int(bax0), y0=int(bay0), x1=int(bax1), y1=int(bay1))

        elif did_layout and bed_wall_y is not None and bed_div_x is not None:
            south_top_y = int(bed_wall_y + 1)

            # Bedrooms: beds + a small study.
            bed_shape_h = [(0, 0), (1, 0)]
            if not place_in_rect(
                int(self.T_BED),
                bed_shape_h,
                x0=int(min_x + 1),
                y0=int(min_y + 1),
                x1=int(bed_div_x - 2),
                y1=int(bed_wall_y - 2),
            ):
                place_in_rect(
                    int(self.T_BED),
                    bed_shape_h,
                    x0=int(min_x),
                    y0=int(min_y),
                    x1=int(bed_div_x - 1),
                    y1=int(bed_wall_y - 1),
                )
            if not place_in_rect(
                int(self.T_BED),
                bed_shape_h,
                x0=int(bed_div_x + 1),
                y0=int(min_y + 1),
                x1=int(max_x - 2),
                y1=int(bed_wall_y - 2),
            ):
                place_in_rect(
                    int(self.T_BED),
                    bed_shape_h,
                    x0=int(bed_div_x + 1),
                    y0=int(min_y),
                    x1=int(max_x),
                    y1=int(bed_wall_y - 1),
                )
            place_in_rect(
                int(self.T_PC),
                [(0, 0), (1, 0)],
                x0=int(bed_div_x + 1),
                y0=int(bed_wall_y - 2),
                x1=int(max_x - 2),
                y1=int(bed_wall_y - 2),
            )
            place_in_rect(
                int(self.T_SHELF),
                [(0, 0)],
                x0=int(min_x + 1),
                y0=int(min_y + 1),
                x1=int(min_x + 2),
                y1=int(bed_wall_y - 2),
            )

            # Living room: sofa + TV + table.
            living_x1 = int(max_x if service_wall_x is None else service_wall_x - 1)
            for sy in (int(max_y - 2), int(max_y - 3), int(max_y - 1), int(south_top_y)):
                if int(sy) < int(south_top_y) or int(sy) > int(max_y - 1):
                    continue
                if place_in_rect(
                    int(self.T_SOFA),
                    [(0, 0), (1, 0)],
                    x0=int(min_x + 1),
                    y0=int(sy),
                    x1=int(max(int(min_x + 2), int(living_x1 - 2))),
                    y1=int(sy),
                ):
                    break
            for ty3 in (int(max_y - 2), int(max_y - 3), int(max_y - 1), int(south_top_y)):
                if int(ty3) < int(south_top_y) or int(ty3) > int(max_y - 1):
                    continue
                if place_in_rect(
                    int(self.T_TV),
                    [(0, 0)],
                    x0=int(max(int(min_x + 1), int(living_x1 - 2))),
                    y0=int(ty3),
                    x1=int(living_x1 - 1),
                    y1=int(ty3),
                ):
                    break
            if random.random() < 0.75:
                table_pos: tuple[int, int] | None = None
                cx2 = int((min_x + living_x1) // 2)
                cy2 = int((south_top_y + max_y) // 2)
                for r in range(0, max(2, max(living_x1 - min_x, max_y - south_top_y) + 1)):
                    for dy2 in range(-int(r), int(r) + 1):
                        for dx2 in range(-int(r), int(r) + 1):
                            tx2 = int(cx2 + dx2)
                            ty2 = int(cy2 + dy2)
                            if (tx2, ty2) in reserved:
                                continue
                            if (tx2, ty2) not in region:
                                continue
                            if int(get(tx2, ty2)) != int(self.T_FLOOR):
                                continue
                            if place(int(self.T_TABLE), [(int(tx2), int(ty2))]):
                                table_pos = (int(tx2), int(ty2))
                                break
                        if table_pos is not None:
                            break
                    if table_pos is not None:
                        break
                if table_pos is not None:
                    tx2, ty2 = table_pos
                    for cells in ([(tx2, ty2 + 1)], [(tx2 + 1, ty2)], [(tx2 - 1, ty2)], [(tx2, ty2 - 1)]):
                        if place(int(self.T_CHAIR), [(int(c[0]), int(c[1])) for c in cells]):
                            break

            # Kitchen: fridge + shelf (if service area exists, prefer it; otherwise tuck into living corner).
            if service_wall_x is not None:
                place_in_rect(
                    int(self.T_FRIDGE),
                    [(0, 0)],
                    x0=int(service_wall_x + 1),
                    y0=int(south_top_y),
                    x1=int(max_x - 1),
                    y1=int(max_y - 1),
                )
                place_in_rect(
                    int(self.T_CABINET),
                    [(0, 0)],
                    x0=int(service_wall_x + 1),
                    y0=int(south_top_y),
                    x1=int(max_x - 1),
                    y1=int(max_y - 1),
                )
            else:
                if not place_in_rect(
                    int(self.T_FRIDGE),
                    [(0, 0)],
                    x0=int(max(int(min_x + 1), int(max_x - 2))),
                    y0=int(south_top_y),
                    x1=int(max_x - 1),
                    y1=int(max_y - 2),
                ):
                    place_in_rect(
                        int(self.T_FRIDGE),
                        [(0, 0)],
                        x0=int(min_x + 1),
                        y0=int(south_top_y),
                        x1=int(max_x - 1),
                        y1=int(max_y - 2),
                    )

            # Bathroom: toilet + sink (faucet).
            if bath_box is not None:
                bx0, by0, bx1, by1 = bath_box
                # Place toilet first (priority)  avoid blocking the bathroom door
                # (the tile right behind the door is bx0/by0).
                placed_toilet = False
                for ty3 in range(int(by1), int(by0) - 1, -1):
                    for tx3 in range(int(bx1), int(bx0) - 1, -1):
                        if int(tx3) == int(bx0) and int(ty3) == int(by0):
                            continue
                        # Ignore "reserved" for the toilet so small bathrooms still get one.
                        if set_if_floor(int(tx3), int(ty3), int(self.T_TOILET)):
                            placed_toilet = True
                            break
                    if placed_toilet:
                        break
                if not placed_toilet:
                    place_in_rect(
                        int(self.T_TOILET),
                        [(0, 0)],
                        x0=int(bx0),
                        y0=int(by0),
                        x1=int(bx1),
                        y1=int(by1),
                )
                # Then place sink.
                place_in_rect(
                    int(self.T_SINK),
                    [(0, 0)],
                    x0=int(bx0),
                    y0=int(by0),
                    x1=int(bx1 - 2),
                    y1=int(by1),
                )
            elif service_wall_x is not None:
                # Small layout: put toilet + sink into the bathroom corner.
                bx = int(max_x)
                by = int(max_y)
                # Try to place toilet
                for ox, oy in ((0, 0), (-1, 0), (0, -1)):
                    if set_if_clear(int(bx + ox), int(by + oy), int(self.T_TOILET)):
                        break
                # Then place sink nearby
                for ox, oy in ((-1, 0), (0, -1), (-1, -1)):
                    if set_if_clear(int(bx + ox), int(by + oy), int(self.T_SINK)):
                        break
        else:
            # Fallback: minimal furnishing if the apartment is too small to carve.
            for cells in (
                [(min_x + 1, min_y + 1), (min_x + 2, min_y + 1)],
                [(max_x - 2, min_y + 1), (max_x - 1, min_y + 1)],
            ):
                if place(int(self.T_BED), [(int(c[0]), int(c[1])) for c in cells]):
                    break
            place(int(self.T_FRIDGE), [(int(max_x - 1), int(min_y + 1))])
            place(int(self.T_CABINET), [(int(max_x - 2), int(min_y + 1))])
            place(int(self.T_SOFA), [(int(min_x + 1), int(max_y - 2)), (int(min_x + 2), int(max_y - 2))])
            place(int(self.T_TV), [(int(max_x - 1), int(max_y - 2))])

        # Lighting: a lamp in the living area (toggle on the lamp itself).
        def place_decor(tid: int, candidates: list[tuple[int, int]]) -> bool:
            for x, y in candidates:
                x = int(x)
                y = int(y)
                if (x, y) not in region:
                    continue
                if int(get(x, y)) != int(self.T_FLOOR):
                    continue
                set_t(int(x), int(y), int(tid))
                return True
            return False

        lamp_y0 = int(min_y if bed_wall_y is None else (bed_wall_y + 1))
        lamp_x1 = int(max_x if service_wall_x is None else (service_wall_x - 1))
        lamp_cx = int((min_x + lamp_x1) // 2)
        lamp_cy = int(clamp(int((lamp_y0 + max_y) // 2), int(lamp_y0), int(max_y - 1)))
        place_decor(
            int(self.T_LAMP),
            [
                (lamp_cx, lamp_cy),
                (lamp_cx + 1, lamp_cy),
                (lamp_cx - 1, lamp_cy),
                (lamp_cx, lamp_cy + 1),
                (lamp_cx, lamp_cy - 1),
            ],
        )

        # Ensure the home always has a toilet (older layouts or tight shapes can miss it).
        if not has_toilet():
            # Prefer putting it inside the bathroom box if we carved one.
            if bath_box is not None:
                bx0, by0, bx1, by1 = bath_box
                for ty3 in range(int(by1), int(by0) - 1, -1):
                    for tx3 in range(int(bx1), int(bx0) - 1, -1):
                        if int(tx3) == int(bx0) and int(ty3) == int(by0):
                            continue
                        if int(get(int(tx3), int(ty3))) != int(self.T_FLOOR):
                            continue
                        set_t(int(tx3), int(ty3), int(self.T_TOILET))
                        break
                    if has_toilet():
                        break

            if not has_toilet():
                avoid: set[tuple[int, int]] = set()
                for _dx2, _dy2, adj2 in list(door_clear):
                    for ax2, ay2 in adj2:
                        avoid.add((int(ax2), int(ay2)))

                def passable_tid(tid: int) -> bool:
                    tdef = self._TILES.get(int(tid))
                    return bool(tdef is not None and not bool(getattr(tdef, "solid", False)))

                placed = False
                for px, py in sorted(region, key=lambda p: (int(p[1]), int(p[0])), reverse=True):
                    if (int(px), int(py)) in avoid or (int(px), int(py)) in reserved:
                        continue
                    if int(get(int(px), int(py))) != int(self.T_FLOOR):
                        continue
                    ok_adj = False
                    for ox, oy in ((0, -1), (-1, 0), (1, 0), (0, 1)):
                        nx, ny = int(px + ox), int(py + oy)
                        if not (0 <= int(nx) < int(w) and 0 <= int(ny) < int(h)):
                            continue
                        if passable_tid(int(get(int(nx), int(ny)))):
                            ok_adj = True
                            break
                    if not ok_adj:
                        continue
                    set_t(int(px), int(py), int(self.T_TOILET))
                    placed = True
                    break

                # Last resort: drop it anywhere walkable in the apartment.
                if not placed:
                    for px, py in sorted(region, key=lambda p: (int(p[1]), int(p[0])), reverse=True):
                        if (int(px), int(py)) in avoid or (int(px), int(py)) in reserved:
                            continue
                        if int(get(int(px), int(py))) != int(self.T_FLOOR):
                            continue
                        set_t(int(px), int(py), int(self.T_TOILET))
                        break

        # Guarantee doors are usable: clear solid tiles right next to each interior door we placed.
        def clear_passage_cell(x: int, y: int) -> None:
            x = int(x)
            y = int(y)
            if (x, y) not in region:
                return
            tid = int(get(x, y))
            if tid in (
                int(self.T_FLOOR),
                int(self.T_DOOR),
                int(self.T_DOOR_HOME),
                int(self.T_DOOR_LOCKED),
                int(self.T_DOOR_HOME_LOCKED),
                int(self.T_ELEVATOR),
                int(self.T_STAIRS_UP),
                int(self.T_STAIRS_DOWN),
            ):
                return
            set_t(int(x), int(y), int(self.T_FLOOR))

        for _dx, _dy, adj in list(door_clear):
            for ax, ay in adj:
                clear_passage_cell(int(ax), int(ay))

        self._home_highrise_world_setup_done = True
        try:
            if int(getattr(mh, "cur_floor", 1)) == int(home_floor):
                self._multi_house_apply_floor(chunk, mh)
        except Exception:
            pass

    def _debug_enter_home_world(self) -> bool:
        # Debug helper: teleport to the home apartment (world-map view), no full-screen mode.
        if bool(getattr(self, "hr_interior", False)) or bool(getattr(self, "house_interior", False)) or bool(getattr(self, "sch_interior", False)):
            return False
        home = getattr(self, "home_highrise_door", None)
        if not isinstance(home, tuple) or len(home) != 2:
            return False
        try:
            hx, hy = int(home[0]), int(home[1])
        except Exception:
            return False

        found = self._multi_house_at(int(hx), int(hy))
        if found is None:
            return False
        chunk, mh = found

        floors = int(max(1, int(getattr(mh, "floors", 1))))
        floors = int(min(int(floors), int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
        home_floor = int(getattr(self, "home_highrise_floor", 1) or 1)
        home_floor = int(clamp(int(home_floor), 1, int(floors)))
        mh.cur_floor = int(home_floor)

        # Ensure green door + home layout exist.
        self._setup_home_highrise_world()
        self._multi_house_apply_floor(chunk, mh)

        door = getattr(self, "home_highrise_world_home_door", None)
        if not isinstance(door, tuple) or len(door) != 2:
            door = (int(hx), int(hy))
        gx, gy = int(door[0]), int(door[1])

        def passable(tx: int, ty: int) -> bool:
            try:
                tid = int(self.world.get_tile(int(tx), int(ty)))
            except Exception:
                return False
            tdef = self._TILES.get(int(tid))
            return bool(tdef is not None and not bool(getattr(tdef, "solid", False)))

        spawn: tuple[int, int] | None = None
        for tx, ty in (
            (gx, gy - 1),
            (gx, gy),
            (gx - 1, gy - 1),
            (gx + 1, gy - 1),
            (gx - 1, gy),
            (gx + 1, gy),
            (gx, gy + 1),
        ):
            if passable(int(tx), int(ty)):
                spawn = (int(tx), int(ty))
                break
        if spawn is None:
            spawn = (int(gx), int(gy))

        sx, sy = spawn
        self.player.vel.update(0, 0)
        self.player.pos.update((float(sx) + 0.5) * float(self.TILE_SIZE), (float(sy) + 0.5) * float(self.TILE_SIZE))
        self._set_hint("(K)", seconds=1.0)
        return True

    def _teleport_to_bathroom(self) -> bool:
        """Teleport to bathroom (toilet) in home on world map."""
        if bool(getattr(self, "hr_interior", False)) or bool(getattr(self, "house_interior", False)) or bool(getattr(self, "sch_interior", False)):
            return False
        home = getattr(self, "home_highrise_door", None)
        if not isinstance(home, tuple) or len(home) != 2:
            self._set_hint("", seconds=1.0)
            return False
        try:
            hx, hy = int(home[0]), int(home[1])
        except Exception:
            return False

        found = self._multi_house_at(int(hx), int(hy))
        if found is None:
            return False
        chunk, mh = found

        floors = int(max(1, int(getattr(mh, "floors", 1))))
        floors = int(min(int(floors), int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
        home_floor = int(getattr(self, "home_highrise_floor", 1) or 1)
        home_floor = int(clamp(int(home_floor), 1, int(floors)))
        mh.cur_floor = int(home_floor)

        self._setup_home_highrise_world()
        self._multi_house_apply_floor(chunk, mh)

        # Find toilet position
        tx0 = int(getattr(mh, "tx0", 0))
        ty0 = int(getattr(mh, "ty0", 0))
        bw = int(getattr(mh, "w", 0))
        bh = int(getattr(mh, "h", 0))

        base_tiles = mh.floor_tiles.get(int(home_floor))
        toilet_pos: tuple[int, int] | None = None
        if isinstance(base_tiles, list) and len(base_tiles) == bw * bh:
            for yy in range(bh):
                for xx in range(bw):
                    if int(base_tiles[yy * bw + xx]) == int(self.T_TOILET):
                        toilet_pos = (tx0 + xx, ty0 + yy)
                        break
                if toilet_pos:
                    break

        if toilet_pos is None:
            self._set_hint("", seconds=1.0)
            return False

        # Find passable tile near toilet
        tx, ty = toilet_pos
        def passable(px: int, py: int) -> bool:
            try:
                tid = int(self.world.get_tile(int(px), int(py)))
            except Exception:
                return False
            tdef = self._TILES.get(int(tid))
            return bool(tdef is not None and not bool(getattr(tdef, "solid", False)))

        spawn: tuple[int, int] | None = None
        for dx, dy in ((0, -1), (-1, 0), (1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1), (1, 1)):
            if passable(tx + dx, ty + dy):
                spawn = (tx + dx, ty + dy)
                break
        if spawn is None:
            spawn = (tx, ty)

        sx, sy = spawn
        self.player.vel.update(0, 0)
        self.player.pos.update((float(sx) + 0.5) * float(self.TILE_SIZE), (float(sy) + 0.5) * float(self.TILE_SIZE))
        self._set_hint("", seconds=1.0)
        return True

    def _try_use_multi_house_stairs(self) -> bool:
        self._ensure_home_highrise_world_setup_for_player()
        tx, ty = self._player_tile()
        candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
        chosen: tuple[int, int, int] | None = None
        for cx, cy in candidates:
            t = int(self.world.get_tile(int(cx), int(cy)))
            if t in (int(self.T_STAIRS_UP), int(self.T_STAIRS_DOWN)):
                chosen = (int(cx), int(cy), int(t))
                break
        if chosen is None:
            return False
        cx, cy, t = chosen
        found = self._multi_house_at(int(cx), int(cy))
        if found is None:
            return False
        chunk, mh = found
        floors = int(max(1, int(getattr(mh, "floors", 1))))
        floors = int(min(int(floors), int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
        cur = int(max(1, int(getattr(mh, "cur_floor", 1))))

        if t == int(self.T_STAIRS_UP):
            if cur >= floors:
                self._set_hint("", seconds=1.0)
                return True
            mh.cur_floor = int(cur + 1)
        else:
            if cur <= 1:
                self._set_hint("", seconds=1.0)
                return True
            mh.cur_floor = int(cur - 1)

        self._multi_house_apply_floor(chunk, mh)
        self.player.vel.update(0, 0)
        self.player.pos.update((float(cx) + 0.5) * float(self.TILE_SIZE), (float(cy) + 0.5) * float(self.TILE_SIZE))
        self._set_hint(f"{int(getattr(mh, 'cur_floor', 1))}F", seconds=0.8)
        return True

    def _try_enter_highrise(self) -> bool:
        if getattr(self, "hr_interior", False):
            return False
        tx, ty = self._player_tile()
        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        for cx, cy in candidates:
            if self.world.get_tile(int(cx), int(cy)) != int(self.T_DOOR):
                continue
            chunk = self.world.get_chunk(int(cx) // self.CHUNK_SIZE, int(cy) // self.CHUNK_SIZE)
            for sb in getattr(chunk, "special_buildings", []):
                if getattr(sb, "kind", "") != "highrise":
                    continue
                if (int(cx), int(cy)) not in set(getattr(sb, "door_tiles", ())):
                    continue
                if self.mount is not None:
                    self._set_hint("", seconds=1.2)
                    return True
                self._hr_interior_enter(sb)
                return True
        return False

    def _try_enter_school(self) -> bool:
        if getattr(self, "sch_interior", False):
            return False
        tx, ty = self._player_tile()
        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        for cx, cy in candidates:
            if self.world.get_tile(int(cx), int(cy)) != int(self.T_DOOR):
                continue
            chunk = self.world.get_chunk(int(cx) // self.CHUNK_SIZE, int(cy) // self.CHUNK_SIZE)
            for sb in getattr(chunk, "special_buildings", []):
                if getattr(sb, "kind", "") != "school":
                    continue
                if (int(cx), int(cy)) not in set(getattr(sb, "door_tiles", ())):
                    continue
                if self.mount is not None:
                    self._set_hint("", seconds=1.2)
                    return True
                self._sch_interior_enter(sb)
                return True
        return False

    def _try_pickup(self, *, quiet: bool = False) -> bool:
        chunk, it = self._find_nearest_item(radius_px=18.0)
        if it is None or chunk is None:
            if not bool(quiet):
                self._set_hint("")
            return False
        idef = self._ITEMS.get(it.item_id)
        if idef is None:
            self._set_hint("")
            return True

        # If it's a small tool (like a cup) and the hand is empty, carry it in-hand.
        held = getattr(self, "held_item", None)
        if held is None and self.gun is None and str(getattr(idef, "kind", "")) == "tool":
            take = int(clamp(int(getattr(it, "qty", 1)), 0, 1))
            if take > 0:
                st = HardcoreSurvivalState._ItemStack(item_id=str(it.item_id), qty=int(take))
                if str(getattr(st, "item_id", "")) == "flashlight":
                    if "charge" not in st.meta:
                        st.meta["charge"] = 1.0
                self.held_item = st
                left2 = int(getattr(it, "qty", 1)) - int(take)
                if left2 <= 0:
                    try:
                        chunk.items.remove(it)
                    except ValueError:
                        pass
                else:
                    it.qty = int(left2)
                self._set_hint(f" {idef.name}")
                return True
        add_meta: dict[str, object] | None = None
        if str(getattr(it, "item_id", "")) == "flashlight":
            add_meta = {"charge": 1.0}
        left = self.inventory.add(it.item_id, int(it.qty), self._ITEMS, meta=add_meta)
        taken = int(it.qty) - int(left)
        if taken <= 0:
            self._set_hint("")
            return True
        if left <= 0:
            try:
                chunk.items.remove(it)
            except ValueError:
                pass
        else:
            it.qty = int(left)
        self._set_hint(f" {idef.name} x{taken}")
        return True

    def _drop_selected(self) -> None:
        stack = self.inventory.drop_slot(int(self.inv_index))
        if stack is None:
            self._set_hint("")
            return
        idef = self._ITEMS.get(stack.item_id)
        name = idef.name if idef is not None else stack.item_id
        offset = pygame.Vector2(random.randint(-6, 6), random.randint(-6, 6))
        self._drop_world_item(pygame.Vector2(self.player.pos) + offset, stack.item_id, int(stack.qty))
        self._set_hint(f" {name} x{stack.qty}")

    def _stow_held_item(self, *, quiet: bool = False) -> bool:
        held = getattr(self, "held_item", None)
        if not isinstance(held, HardcoreSurvivalState._ItemStack) or int(getattr(held, "qty", 0)) <= 0:
            return False

        meta = dict(getattr(held, "meta", {})) if isinstance(getattr(held, "meta", None), dict) else None
        left = int(self.inventory.add(str(getattr(held, "item_id", "")), int(getattr(held, "qty", 1)), self._ITEMS, meta=meta))
        if left > 0:
            if not bool(quiet):
                self._set_hint("", seconds=1.0)
            return False

        if str(getattr(held, "item_id", "")) == "flashlight":
            self.flashlight_on = False
        self.held_item = None

        if not bool(quiet):
            idef = self._ITEMS.get(str(getattr(held, "item_id", "")))
            name = idef.name if idef is not None else str(getattr(held, "item_id", ""))
            self._set_hint(f" {name}", seconds=0.8)
        return True

    def _flashlight_charge(self) -> float:
        held = getattr(self, "held_item", None)
        if not isinstance(held, HardcoreSurvivalState._ItemStack) or str(getattr(held, "item_id", "")) != "flashlight":
            return 0.0
        meta = getattr(held, "meta", None)
        if not isinstance(meta, dict):
            meta = {}
            held.meta = meta
        try:
            charge = float(meta.get("charge", 1.0))
        except Exception:
            charge = 1.0
        charge = float(clamp(charge, 0.0, 1.0))
        meta["charge"] = float(charge)
        return float(charge)

    def _flashlight_toggle(self) -> None:
        held = getattr(self, "held_item", None)
        if not isinstance(held, HardcoreSurvivalState._ItemStack) or str(getattr(held, "item_id", "")) != "flashlight":
            self.flashlight_on = False
            self._set_hint("", seconds=1.0)
            return

        charge = float(self._flashlight_charge())
        if charge <= 0.01:
            self.flashlight_on = False
            self._set_hint("", seconds=1.2)
            return

        self.flashlight_on = not bool(getattr(self, "flashlight_on", False))
        self._set_hint("" if bool(self.flashlight_on) else "", seconds=0.8)

    def _update_flashlight(self, dt: float) -> None:
        # Keep flashlight state consistent (and drain battery when on).
        held = getattr(self, "held_item", None)
        if not isinstance(held, HardcoreSurvivalState._ItemStack) or str(getattr(held, "item_id", "")) != "flashlight":
            self.flashlight_on = False
            return

        charge = float(self._flashlight_charge())
        if charge <= 0.01:
            self.flashlight_on = False
            return

        if not bool(getattr(self, "flashlight_on", False)):
            return

        # Drain ~10 minutes from full to empty.
        drain_per_s = 1.0 / 600.0
        charge = float(clamp(charge - float(dt) * float(drain_per_s), 0.0, 1.0))
        held.meta["charge"] = float(charge)
        if charge <= 0.01:
            held.meta["charge"] = 0.0
            self.flashlight_on = False
            self._set_hint("", seconds=1.0)

    def _use_consumable(self, item_id: str) -> bool:
        item_id = str(item_id)
        if item_id == "cola":
            self.player.thirst = clamp(self.player.thirst + 42.0, 0.0, 100.0)
            self.player.morale = clamp(self.player.morale + 5.0, 0.0, 100.0)
            self.player.stamina = clamp(self.player.stamina + 6.0, 0.0, 100.0)
            self._set_hint("++ +")
            return True
        if item_id == "food_can":
            self.player.hunger = clamp(self.player.hunger + 38.0, 0.0, 100.0)
            self.player.morale = clamp(self.player.morale + 4.0, 0.0, 100.0)
            self.player.condition = clamp(self.player.condition + 2.0, 0.0, 100.0)
            self._set_hint("+ +")
            return True
        if item_id == "water":
            self.player.thirst = clamp(self.player.thirst + 50.0, 0.0, 100.0)
            self.player.morale = clamp(self.player.morale + 2.0, 0.0, 100.0)
            self._set_hint("+")
            return True
        if item_id == "cup_water":
            self.player.thirst = clamp(self.player.thirst + 35.0, 0.0, 100.0)
            self.player.morale = clamp(self.player.morale + 1.0, 0.0, 100.0)
            self._set_hint("", seconds=1.0)
            return True
        if item_id == "bandage":
            stopped = self._bandage_one_wound()
            self.player.hp = int(clamp(self.player.hp + 18, 0, 100))    
            self.player.condition = clamp(self.player.condition + 3.0, 0.0, 100.0)
            if stopped:
                name = self._BODY_PART_NAMES.get(str(stopped), str(stopped))
                self._set_hint(f"{name}", seconds=1.2)
            else:
                self._set_hint("+")
            return True
        if item_id == "medkit":
            cleared = self._clear_all_wounds()
            self.player.hp = int(clamp(self.player.hp + 55, 0, 100))     
            self.player.condition = clamp(self.player.condition + 10.0, 0.0, 100.0)
            self.player.morale = clamp(self.player.morale + 3.0, 0.0, 100.0)
            if cleared > 0:
                self._set_hint(" + ++")
            else:
                self._set_hint("++")
            return True

        if item_id == "gas_can":
            add = float(getattr(self, "GAS_CAN_REFUEL", 45.0))
            add = float(clamp(add, 5.0, 100.0))

            kind: str | None = None
            target: object | None = None

            if self.mount == "rv":
                kind = "rv"
                target = self.rv
            elif self.mount == "bike":
                mid = str(getattr(self.bike, "model_id", "bike"))
                if mid.startswith("moto"):
                    kind = "bike"
                    target = self.bike
                else:
                    self._set_hint("", seconds=1.0)
                    return False
            else:
                best_kind: str | None = None
                best_target: object | None = None
                best_d2 = float(28.0 * 28.0)

                rv_d2 = float((self.player.pos - self.rv.pos).length_squared())
                if rv_d2 <= best_d2:
                    best_kind = "rv"
                    best_target = self.rv
                    best_d2 = rv_d2

                mid = str(getattr(self.bike, "model_id", "bike"))
                if mid.startswith("moto"):
                    bike_d2 = float((self.player.pos - self.bike.pos).length_squared())
                    if bike_d2 <= best_d2:
                        best_kind = "bike"
                        best_target = self.bike
                        best_d2 = bike_d2

                # Also allow refueling parked motorcycles.
                parked_chunk, parked_bike, parked_d2 = self._find_nearest_parked_bike(radius_px=28.0)
                if parked_bike is not None and parked_chunk is not None:
                    pb_mid = str(getattr(parked_bike, "model_id", "bike"))
                    if pb_mid.startswith("moto") and float(parked_d2) <= float(best_d2):
                        best_kind = "parked"
                        best_target = parked_bike
                        best_d2 = float(parked_d2)

                kind = best_kind
                target = best_target

            if kind is None or target is None:
                self._set_hint("", seconds=1.1)
                return False

            before = float(getattr(target, "fuel", 0.0))
            if before >= 99.9:
                self._set_hint("", seconds=1.0)
                return False

            after = float(clamp(before + add, 0.0, 100.0))
            try:
                setattr(target, "fuel", after)
            except Exception:
                return False

            if kind == "rv":
                self._rv_no_fuel_warned = False
                self._set_hint("", seconds=0.9)
            elif kind in ("bike", "parked"):
                self._bike_no_fuel_warned = False
                self._set_hint("", seconds=0.9)
            else:
                self._set_hint("", seconds=0.9)
            return True

        # Generic consumables (so the bulk item library is actually usable).
        idef = self._ITEMS.get(item_id)
        if idef is None:
            return False
        kind = str(getattr(idef, "kind", ""))
        if kind not in ("food", "drink", "med"):
            return False

        seed = 0
        for ch in str(item_id):
            seed = (seed * 131 + ord(ch)) & 0xFFFFFFFF

        if kind == "drink":
            thirst = 20.0 + float(seed % 30)  # 20..49
            morale = 1.0 + float((seed >> 3) % 4)  # 1..4
            self.player.thirst = clamp(self.player.thirst + thirst, 0.0, 100.0)
            self.player.morale = clamp(self.player.morale + morale, 0.0, 100.0)
            self._set_hint(f"{idef.name}+")
            return True

        if kind == "food":
            hunger = 18.0 + float(seed % 25)  # 18..42
            morale = 1.0 + float((seed >> 2) % 4)  # 1..4
            cond = float((seed >> 8) % 3)  # 0..2
            self.player.hunger = clamp(self.player.hunger + hunger, 0.0, 100.0)
            self.player.morale = clamp(self.player.morale + morale, 0.0, 100.0)
            self.player.condition = clamp(self.player.condition + cond, 0.0, 100.0)
            self._set_hint(f"{idef.name}+")
            return True

        # kind == "med"
        heal = 10.0 + float(seed % 18)  # 10..27
        cond = 2.0 + float((seed >> 5) % 5)  # 2..6
        morale = 0.0 + float((seed >> 9) % 3)  # 0..2
        stopped = None
        if any(k in str(item_id) for k in ("bandage", "suture", "splint", "iodine", "antiseptic", "ointment", "disinfect")):
            stopped = self._bandage_one_wound()
        self.player.hp = int(clamp(float(self.player.hp) + heal, 0.0, 100.0))
        self.player.condition = clamp(self.player.condition + cond, 0.0, 100.0)
        self.player.morale = clamp(self.player.morale + morale, 0.0, 100.0)
        if stopped:
            name = self._BODY_PART_NAMES.get(str(stopped), str(stopped))
            self._set_hint(f"{idef.name}({name})")
        else:
            self._set_hint(f"{idef.name}+")
        return True
        return False

    def _gun_effective_def(self, gun: "HardcoreSurvivalState._Gun | None" = None) -> "HardcoreSurvivalState._GunDef | None":
        gun = self.gun if gun is None else gun
        if gun is None:
            return None
        base = self._GUNS.get(str(getattr(gun, "gun_id", "")))
        if base is None:
            return None

        mag_add = 0
        fire_rate_mult = 1.0
        reload_mult = 1.0
        damage_mult = 1.0
        damage_add = 0
        bullet_speed_mult = 1.0
        spread_mult = 1.0
        noise_mult = 1.0

        mods = getattr(gun, "mods", None)
        if isinstance(mods, dict):
            for _slot, mod_id in list(mods.items()):
                mdef = self._GUN_MODS.get(str(mod_id))
                if mdef is None:
                    continue
                if str(getattr(gun, "gun_id", "")) not in tuple(getattr(mdef, "compat", ())):
                    continue
                mag_add += int(getattr(mdef, "mag_add", 0))
                fire_rate_mult *= float(getattr(mdef, "fire_rate_mult", 1.0))
                reload_mult *= float(getattr(mdef, "reload_mult", 1.0))
                damage_mult *= float(getattr(mdef, "damage_mult", 1.0))
                damage_add += int(getattr(mdef, "damage_add", 0))
                bullet_speed_mult *= float(getattr(mdef, "bullet_speed_mult", 1.0))
                spread_mult *= float(getattr(mdef, "spread_mult", 1.0))
                noise_mult *= float(getattr(mdef, "noise_mult", 1.0))

        mag_size = max(1, int(round(float(base.mag_size) + float(mag_add))))
        fire_rate = max(0.1, float(base.fire_rate) * float(fire_rate_mult))
        reload_s = max(0.20, float(base.reload_s) * float(reload_mult))
        damage = int(max(1.0, float(base.damage) * float(damage_mult) + float(damage_add)))
        bullet_speed = max(40.0, float(base.bullet_speed) * float(bullet_speed_mult))
        spread_deg = max(0.25, float(base.spread_deg) * float(spread_mult))
        noise_radius = max(60.0, float(base.noise_radius) * float(noise_mult))

        return HardcoreSurvivalState._GunDef(
            id=str(base.id),
            name=str(base.name),
            ammo_item=str(base.ammo_item),
            mag_size=int(mag_size),
            fire_rate=float(fire_rate),
            reload_s=float(reload_s),
            damage=int(damage),
            bullet_speed=float(bullet_speed),
            spread_deg=float(spread_deg),
            noise_radius=float(noise_radius),
            muzzle_flash_s=float(getattr(base, "muzzle_flash_s", 0.06)),
            bullet_ttl=float(getattr(base, "bullet_ttl", 1.35)),
            bullet_kind=str(getattr(base, "bullet_kind", "bullet")),
            aoe_radius=float(getattr(base, "aoe_radius", 0.0)),
            aoe_damage=int(getattr(base, "aoe_damage", 0)),
        )

    def _gun_mod_label(self, gun: "HardcoreSurvivalState._Gun | None" = None) -> str:
        gun = self.gun if gun is None else gun
        if gun is None:
            return ""
        mods = getattr(gun, "mods", None)
        if not isinstance(mods, dict) or not mods:
            return ""
        names: list[str] = []
        for _slot, mid in mods.items():
            mdef = self._GUN_MODS.get(str(mid))
            if mdef is None:
                continue
            if str(getattr(gun, "gun_id", "")) not in tuple(getattr(mdef, "compat", ())):
                continue
            n = str(getattr(mdef, "name", "")).strip()
            if n:
                names.append(n)
        if not names:
            return ""
        return " +".join(names[:3])

    def _equip_selected(self) -> None:
        if not (0 <= int(self.inv_index) < len(self.inventory.slots)):
            return
        stack = self.inventory.slots[int(self.inv_index)]
        if stack is None:
            self._set_hint("")
            return
        idef = self._ITEMS.get(stack.item_id)
        if idef is None:
            self._set_hint("")
            return

        if idef.kind == "gun_mod":
            if self.gun is None:
                self._set_hint("", seconds=1.0)
                return
            mdef = self._GUN_MODS.get(str(stack.item_id))
            if mdef is None:
                self._set_hint("", seconds=1.0)
                return
            if str(getattr(self.gun, "gun_id", "")) not in tuple(getattr(mdef, "compat", ())):
                self._set_hint("", seconds=1.0)
                return

            slot_key = str(getattr(mdef, "slot", ""))
            if not slot_key:
                self._set_hint("", seconds=1.0)
                return

            old = None
            try:
                old = (self.gun.mods or {}).get(slot_key)
            except Exception:
                old = None

            if str(old or "") == str(getattr(mdef, "id", "")):
                self._set_hint("", seconds=0.8)
                return

            if old:
                left = int(self.inventory.add(str(old), 1, self._ITEMS))
                if left > 0:
                    self._set_hint("", seconds=1.0)
                    return

            if stack.qty > 1:
                stack.qty -= 1
            else:
                self.inventory.slots[int(self.inv_index)] = None

            try:
                self.gun.mods[slot_key] = str(getattr(mdef, "id", ""))
            except Exception:
                self.gun.mods = {slot_key: str(getattr(mdef, "id", ""))}

            # Installing parts changes timings/capacity: cancel reload and clamp mag.
            try:
                self.gun.reload_left = 0.0
                self.gun.reload_total = 0.0
            except Exception:
                pass
            self._reload_lock_dir = None

            gdef2 = self._gun_effective_def(self.gun)
            if gdef2 is not None:
                try:
                    self.gun.mag = int(clamp(int(self.gun.mag), 0, int(gdef2.mag_size)))
                except Exception:
                    pass

            self._set_hint(f" {getattr(mdef, 'name', '')}")
            return

        # Hands are exclusive: stow any held tool before equipping a weapon.
        if str(getattr(idef, "kind", "")) in ("gun", "melee"):
            if isinstance(getattr(self, "held_item", None), HardcoreSurvivalState._ItemStack):
                if not self._stow_held_item(quiet=True):
                    self._set_hint("", seconds=1.0)
                    return

        if idef.kind != "gun": 
            if idef.kind == "melee": 
                def clone_obj(o: object) -> object: 
                    if isinstance(o, dict): 
                        return {str(k): clone_obj(v) for k, v in o.items()} 
                    if isinstance(o, list): 
                        return [clone_obj(v) for v in o] 
                    if isinstance(o, tuple): 
                        return tuple(clone_obj(v) for v in o) 
                    return o 
 
                before_slots: list[HardcoreSurvivalState._ItemStack | None] = [] 
                for s in self.inventory.slots: 
                    if s is None: 
                        before_slots.append(None) 
                        continue 
                    before_slots.append( 
                        HardcoreSurvivalState._ItemStack( 
                            item_id=str(getattr(s, "item_id", "")), 
                            qty=int(getattr(s, "qty", 0)), 
                            meta=(clone_obj(getattr(s, "meta", {})) if isinstance(getattr(s, "meta", None), dict) else {}), 
                        ) 
                    ) 
 
                before_gun: HardcoreSurvivalState._Gun | None = None 
                if self.gun is not None: 
                    before_gun = HardcoreSurvivalState._Gun( 
                        gun_id=str(getattr(self.gun, "gun_id", "")), 
                        mag=int(getattr(self.gun, "mag", 0)), 
                        mods=dict(getattr(self.gun, "mods", {}) or {}), 
                        cooldown_left=float(getattr(self.gun, "cooldown_left", 0.0)), 
                        reload_left=float(getattr(self.gun, "reload_left", 0.0)), 
                        reload_total=float(getattr(self.gun, "reload_total", 0.0)), 
                    ) 
                before_melee = str(getattr(self, "melee_weapon_id", "") or "") 
                before_reload_lock = pygame.Vector2(getattr(self, "_reload_lock_dir", pygame.Vector2(0, 0))) if getattr(self, "_reload_lock_dir", None) is not None else None 
 
                try: 
                    new_melee_id = str(stack.item_id) 
                    if stack.qty > 1: 
                        stack.qty -= 1 
                    else: 
                        self.inventory.slots[int(self.inv_index)] = None 
 
                    if before_melee: 
                        left = int(self.inventory.add(before_melee, 1, self._ITEMS)) 
                        if left > 0: 
                            raise RuntimeError("inv_full_old_melee") 
 
                    if before_gun is not None and str(getattr(before_gun, "gun_id", "")): 
                        old_meta = {"mag": int(getattr(before_gun, "mag", 0)), "mods": dict(getattr(before_gun, "mods", {}) or {})} 
                        left = int(self.inventory.add(str(before_gun.gun_id), 1, self._ITEMS, meta=old_meta)) 
                        if left > 0: 
                            raise RuntimeError("inv_full_old_gun") 
 
                    self.gun = None 
                    self._reload_lock_dir = None 
                    self.melee_weapon_id = new_melee_id 
                except Exception: 
                    self.inventory.slots[:] = before_slots 
                    self.gun = before_gun 
                    self.melee_weapon_id = before_melee 
                    self._reload_lock_dir = before_reload_lock 
                    self._set_hint("", seconds=1.0) 
                    return 
 
                self._set_hint(f" {idef.name}") 
                return 
 
            if idef.kind == "clothes": 
                new_outfit = self._CLOTHES_OUTFIT_INDEX.get(str(stack.item_id)) 
                if new_outfit is None: 
                    self._set_hint("", seconds=1.0)
                    return
                if str(getattr(self, "clothes_id", "") or "") == str(stack.item_id):
                    self._set_hint("", seconds=0.8)
                    return

                old = str(getattr(self, "clothes_id", "") or "")
                if stack.qty > 1:
                    stack.qty -= 1
                else:
                    self.inventory.slots[int(self.inv_index)] = None

                if old:
                    left = int(self.inventory.add(old, 1, self._ITEMS))
                    if left > 0:
                        self.inventory.add(str(stack.item_id), 1, self._ITEMS)
                        self._set_hint("", seconds=1.0)
                        return

                try:
                    self.avatar.outfit = int(new_outfit)
                    self.avatar.clamp_all()
                except Exception:
                    pass
                self.player_frames = HardcoreSurvivalState.build_avatar_player_frames(self.avatar, run=False)
                self.player_frames_run = HardcoreSurvivalState.build_avatar_player_frames(self.avatar, run=True)
                self.cyclist_frames = HardcoreSurvivalState.build_avatar_cyclist_frames(self.avatar)

                self.clothes_id = str(stack.item_id)
                self._set_hint(f"{idef.name}")
                return

            if idef.kind in ("food", "drink", "med", "fuel"):
                ok = self._use_consumable(stack.item_id)
                if not ok:
                    if not str(getattr(self, "hint_text", "")).strip():
                        self._set_hint("", seconds=1.0)
                    return
                if str(stack.item_id) == "cup_water":
                    # Drinking a cup leaves the empty cup behind (so you can refill it).
                    self.inventory.slots[int(self.inv_index)] = HardcoreSurvivalState._ItemStack(item_id="cup", qty=1)
                    return
                stack.qty -= 1
                if stack.qty <= 0:
                    self.inventory.slots[int(self.inv_index)] = None     
                return

            if str(stack.item_id) == "battery":
                held = getattr(self, "held_item", None)
                if isinstance(held, HardcoreSurvivalState._ItemStack) and str(getattr(held, "item_id", "")) == "flashlight":
                    if not isinstance(getattr(held, "meta", None), dict):
                        held.meta = {}
                    held.meta["charge"] = 1.0
                    self.flashlight_on = False
                    stack.qty -= 1
                    if int(stack.qty) <= 0:
                        self.inventory.slots[int(self.inv_index)] = None
                    self._set_hint("", seconds=1.0)
                else:
                    self._set_hint("", seconds=1.0)
                return

            if str(getattr(idef, "kind", "")) == "tool":
                # Hold a small tool in-hand (e.g. cup).
                held = getattr(self, "held_item", None)
                if isinstance(held, HardcoreSurvivalState._ItemStack):
                    held_meta = dict(getattr(held, "meta", {})) if isinstance(getattr(held, "meta", None), dict) else None
                    left = int(self.inventory.add(str(held.item_id), int(held.qty), self._ITEMS, meta=held_meta))
                    if left > 0:
                        self._set_hint("")
                        return
                    if str(getattr(held, "item_id", "")) == "flashlight":
                        self.flashlight_on = False
                    self.held_item = None

                take = int(min(int(getattr(stack, "qty", 1)), 1))
                if take <= 0:
                    return
                new_meta: dict[str, object] = dict(getattr(stack, "meta", {})) if isinstance(getattr(stack, "meta", None), dict) else {}
                if str(stack.item_id) == "flashlight" and "charge" not in new_meta:
                    new_meta["charge"] = 1.0
                stack.qty -= int(take)
                if int(stack.qty) <= 0:
                    self.inventory.slots[int(self.inv_index)] = None
                self.held_item = HardcoreSurvivalState._ItemStack(item_id=str(stack.item_id), qty=int(take), meta=new_meta)
                if str(stack.item_id) == "flashlight":
                    self.flashlight_on = False
                    self._set_hint("T /  X ", seconds=1.2)
                    return
                self._set_hint(f" {idef.name}")
                return
            self._set_hint("/")
            return

        gun_def = self._GUNS.get(stack.item_id)
        if gun_def is None:
            self._set_hint("")
            return

        saved_meta: dict[str, object] = {}
        try: 
            if isinstance(getattr(stack, "meta", None), dict): 
                saved_meta = dict(getattr(stack, "meta", {})) 
        except Exception: 
            saved_meta = {} 

        def clone_obj(o: object) -> object: 
            if isinstance(o, dict): 
                return {str(k): clone_obj(v) for k, v in o.items()} 
            if isinstance(o, list): 
                return [clone_obj(v) for v in o] 
            if isinstance(o, tuple): 
                return tuple(clone_obj(v) for v in o) 
            return o 

        before_slots: list[HardcoreSurvivalState._ItemStack | None] = [] 
        for s in self.inventory.slots: 
            if s is None: 
                before_slots.append(None) 
                continue 
            before_slots.append( 
                HardcoreSurvivalState._ItemStack( 
                    item_id=str(getattr(s, "item_id", "")), 
                    qty=int(getattr(s, "qty", 0)), 
                    meta=(clone_obj(getattr(s, "meta", {})) if isinstance(getattr(s, "meta", None), dict) else {}), 
                ) 
            ) 

        before_gun: HardcoreSurvivalState._Gun | None = None 
        if self.gun is not None: 
            before_gun = HardcoreSurvivalState._Gun( 
                gun_id=str(getattr(self.gun, "gun_id", "")), 
                mag=int(getattr(self.gun, "mag", 0)), 
                mods=dict(getattr(self.gun, "mods", {}) or {}), 
                cooldown_left=float(getattr(self.gun, "cooldown_left", 0.0)), 
                reload_left=float(getattr(self.gun, "reload_left", 0.0)), 
                reload_total=float(getattr(self.gun, "reload_total", 0.0)), 
            ) 
        before_melee = str(getattr(self, "melee_weapon_id", "") or "") 
        before_reload_lock = pygame.Vector2(getattr(self, "_reload_lock_dir", pygame.Vector2(0, 0))) if getattr(self, "_reload_lock_dir", None) is not None else None 

        if stack.qty > 1: 
            stack.qty -= 1 
        else: 
            self.inventory.slots[int(self.inv_index)] = None 

        try: 
            if before_gun is not None: 
                old_meta = {"mag": int(getattr(before_gun, "mag", 0)), "mods": dict(getattr(before_gun, "mods", {}) or {})} 
                left = int(self.inventory.add(str(before_gun.gun_id), 1, self._ITEMS, meta=old_meta)) 
                if left > 0: 
                    raise RuntimeError("inv_full_old_gun") 

            if before_melee: 
                left = int(self.inventory.add(before_melee, 1, self._ITEMS)) 
                if left > 0: 
                    raise RuntimeError("inv_full_old_melee") 
        except Exception: 
            self.inventory.slots[:] = before_slots 
            self.gun = before_gun 
            self.melee_weapon_id = before_melee 
            self._reload_lock_dir = before_reload_lock 
            self._set_hint("", seconds=1.0) 
            return 
 
        mag = int(gun_def.mag_size)  
        mods: dict[str, str] = {}  
        try:  
            if isinstance(saved_meta, dict):
                if isinstance(saved_meta.get("mag"), (int, float)):
                    mag = int(saved_meta["mag"])
                if isinstance(saved_meta.get("mods"), dict):
                    mods = {str(k): str(v) for k, v in saved_meta["mods"].items()}
        except Exception:
            mag = int(gun_def.mag_size)
            mods = {}

        self.gun = HardcoreSurvivalState._Gun(gun_id=gun_def.id, mag=int(mag), mods=mods) 
        gdef2 = self._gun_effective_def(self.gun) 
        if gdef2 is not None: 
            self.gun.mag = int(clamp(int(self.gun.mag), 0, int(gdef2.mag_size))) 
        self._reload_lock_dir = None
        self.melee_weapon_id = "" 
        self._set_hint(f" {gun_def.name}") 

    def _start_reload(self) -> None:
        if self.gun is None:
            self._set_hint("")
            return
        gun_def = self._gun_effective_def(self.gun)
        if gun_def is None:
            self._set_hint("")
            return
        if self.gun.reload_left > 0.0:
            return
        need = int(gun_def.mag_size) - int(self.gun.mag)
        if need <= 0:
            self._set_hint("")
            return
        if self.inventory.count(gun_def.ammo_item) <= 0:
            self._set_hint("")
            return
        lock = pygame.Vector2(self.aim_dir)
        if lock.length_squared() <= 0.001:
            lock = pygame.Vector2(self.player.facing)
        self._reload_lock_dir = lock.normalize() if lock.length_squared() > 0.001 else pygame.Vector2(1, 0)
        self.gun.reload_total = float(gun_def.reload_s)
        self.gun.reload_left = float(gun_def.reload_s)
        self._set_hint("", seconds=0.8)

    def _start_punch(self) -> None: 
        # J: melee swing / punch (only when not holding a gun). 
        if self.player.hp <= 0: 
            return 
        if getattr(self, "mount", None) is not None: 
            self._set_hint("", seconds=0.9) 
            return 
        if self.gun is not None: 
            self._set_hint("/", seconds=1.0) 
            return 
        if ( 
            bool(getattr(self, "hr_interior", False)) 
            or bool(getattr(self, "sch_interior", False)) 
            or bool(getattr(self, "house_interior", False)) 
        ):
            return
        if float(getattr(self, "punch_cooldown_left", 0.0)) > 0.0:
            return

        # Melee direction follows player movement/facing (snapped to 4-dir) so
        # pressing J always attacks the way you're moving (no "").
        aim = pygame.Vector2(getattr(self.player, "facing", pygame.Vector2(1, 0)))
        if aim.length_squared() <= 0.001:
            aim = pygame.Vector2(1, 0)
        ax = abs(float(aim.x))
        ay = abs(float(aim.y))
        if ax >= ay:
            aim = pygame.Vector2(1 if float(aim.x) >= 0.0 else -1, 0)
        else:
            aim = pygame.Vector2(0, 1 if float(aim.y) >= 0.0 else -1)
        self.punch_dir = aim.normalize()
        self.punch_hand = 1 - int(getattr(self, "punch_hand", 0))
        mdef = self._MELEE_DEFS.get(str(getattr(self, "melee_weapon_id", "")) or "") or self._MELEE_DEFS.get("fist")
        if mdef is None:
            return
        self._melee_swing_id = str(getattr(mdef, "id", "fist"))
        self.punch_left = float(getattr(mdef, "total_s", self._PUNCH_TOTAL_S))
        self.punch_hit_done = False
        self.punch_cooldown_left = float(getattr(mdef, "cooldown_s", self._PUNCH_COOLDOWN_S))

        # Small stamina cost (no hard gate).
        try:
            cost = float(getattr(mdef, "stamina_cost", 5.0))
            self.player.stamina = float(clamp(float(self.player.stamina) - float(cost), 0.0, 100.0))
        except Exception:
            pass

        self.app.play_sfx("swing")

    def _update_punch(self, dt: float) -> None:
        self.punch_cooldown_left = max(0.0, float(getattr(self, "punch_cooldown_left", 0.0)) - dt)

        left = float(getattr(self, "punch_left", 0.0))
        if left <= 0.0:
            self.punch_left = 0.0
            return

        left = max(0.0, left - dt)
        self.punch_left = float(left)

        if bool(getattr(self, "punch_hit_done", False)):
            return

        mdef = self._MELEE_DEFS.get(str(getattr(self, "_melee_swing_id", "")) or "") or self._MELEE_DEFS.get("fist")
        total = float(getattr(mdef, "total_s", self._PUNCH_TOTAL_S)) if mdef is not None else float(self._PUNCH_TOTAL_S)
        t = 1.0 - float(left) / max(1e-6, total)
        base_hit_t = float(getattr(mdef, "hit_t", self._PUNCH_HIT_T)) if mdef is not None else float(self._PUNCH_HIT_T)
        windup_s = float(getattr(mdef, "windup_s", self._PUNCH_WINDUP_S)) if mdef is not None else float(self._PUNCH_WINDUP_S)
        hit_t = max(float(base_hit_t), float(windup_s) / max(1e-6, total))
        if t < hit_t:
            return

        self.punch_hit_done = True
        self._punch_apply_hit()

    def _punch_apply_hit(self) -> None:
        pdir = pygame.Vector2(getattr(self, "punch_dir", pygame.Vector2(0, 0)))
        if pdir.length_squared() <= 0.001:
            pdir = pygame.Vector2(self.player.facing)
        if pdir.length_squared() <= 0.001:
            pdir = pygame.Vector2(1, 0)
        pdir = pdir.normalize()

        mdef = self._MELEE_DEFS.get(str(getattr(self, "_melee_swing_id", "")) or "") or self._MELEE_DEFS.get("fist")
        swing_id = str(getattr(mdef, "id", "fist")) if mdef is not None else "fist"

        origin = pygame.Vector2(self.player.pos)
        max_r = float(getattr(mdef, "range_px", getattr(self, "_PUNCH_RANGE_PX", 18.0))) if mdef is not None else float(getattr(self, "_PUNCH_RANGE_PX", 18.0))
        max_r2 = float(max_r * max_r)
        arc_dot = float(getattr(mdef, "arc_dot", getattr(self, "_PUNCH_ARC_DOT", 0.28))) if mdef is not None else float(getattr(self, "_PUNCH_ARC_DOT", 0.28))

        best: HardcoreSurvivalState._Zombie | None = None
        best_d2 = 1e18
        for z in self.zombies:
            if int(getattr(z, "hp", 0)) <= 0:
                continue
            to = pygame.Vector2(z.pos) - origin
            d2 = float(to.length_squared())
            if d2 > max_r2:
                continue
            if d2 > 0.001:
                dot = float(to.normalize().dot(pdir))
                if dot < arc_dot:
                    continue
            if d2 < best_d2:
                best = z
                best_d2 = d2

        dmg = int(getattr(mdef, "damage", self._PUNCH_DAMAGE)) if mdef is not None else int(self._PUNCH_DAMAGE)

        if best is not None:
            best.hp = int(best.hp) - int(dmg)
            if int(best.hp) > 0:
                stag_s = float(getattr(mdef, "stagger_s", self._PUNCH_STAGGER_S)) if mdef is not None else float(self._PUNCH_STAGGER_S)
                stag_spd = float(getattr(mdef, "stagger_speed", self._PUNCH_STAGGER_SPEED)) if mdef is not None else float(self._PUNCH_STAGGER_SPEED)
                best.stagger_left = max(float(getattr(best, "stagger_left", 0.0)), float(stag_s))
                best.stagger_vel = pygame.Vector2(pdir) * float(stag_spd)
            else:
                self._kill_zombie(best, impact_dir=pdir)

            self._spawn_hit_fx(pygame.Vector2(best.pos), dir=pdir)
            self.app.play_sfx("hit")
            nrad = float(getattr(mdef, "noise_radius", 120.0)) if mdef is not None else 120.0
            loud = 0.22 if str(getattr(mdef, "id", "fist")) == "fist" else 0.30
            self.noise_left = max(float(getattr(self, "noise_left", 0.0)), float(loud))
            self.noise_radius = max(float(getattr(self, "noise_radius", 0.0)), float(nrad))
            # Zombies become corpses (decay later) instead of being removed immediately.
            return

        # No zombie hit: allow punching story NPCs in the prelude (starts a brawl + crime heat).
        try:
            if bool(getattr(self, "story_enabled", False)) and bool(self._story_is_pre_apocalypse()):
                npcs = getattr(self, "npcs", None)
                if isinstance(npcs, list) and npcs:
                    best_npc: dict[str, object] | None = None
                    best_npc_d2 = 1e18
                    for npc in npcs:
                        if not isinstance(npc, dict):
                            continue
                        try:
                            npos = pygame.Vector2(npc.get("pos", pygame.Vector2(0, 0)))
                        except Exception:
                            continue
                        to = pygame.Vector2(npos) - origin
                        d2 = float(to.length_squared())
                        if d2 > max_r2:
                            continue
                        if d2 > 0.001:
                            dot = float(to.normalize().dot(pdir))
                            if dot < arc_dot:
                                continue
                        if d2 < best_npc_d2:
                            best_npc = npc
                            best_npc_d2 = d2
                    if best_npc is not None:
                        npc_id = str(best_npc.get("id", "") or "")
                        self._story_set_npc_hostile(npc_id, seconds=12.0)
                        try:
                            best_npc["attack_anim_left"] = float(
                                max(float(best_npc.get("attack_anim_left", 0.0) or 0.0), 0.35)
                            )
                        except Exception:
                            pass
                        try:
                            hit_pos = pygame.Vector2(best_npc.get("pos", origin))
                        except Exception:
                            hit_pos = origin + pdir * float(max_r)
                        self._spawn_hit_fx(pygame.Vector2(hit_pos), dir=pdir)
                        self.app.play_sfx("hit")
                        self._crime_add(10.0 if swing_id == "fist" else 18.0, "" if swing_id == "fist" else "")
                        return
        except Exception:
            pass

        # No zombie hit: allow melee to damage/break furniture (tables/chairs/etc).
        struct_dmg = int(max(1, int(round(float(dmg) * 0.80))))
        if swing_id == "fist":
            struct_dmg = 1
        elif swing_id == "melee_pipe":
            struct_dmg = int(max(struct_dmg, 10))

        # Sample a few points along the swing reach to find a furniture tile.
        step_len = max(6.0, float(self.TILE_SIZE) * 0.45)
        steps = int(clamp(int(math.ceil(max_r / step_len)), 1, 10))
        for i in range(1, int(steps) + 1): 
            p = origin + pdir * (float(i) / float(steps)) * float(max_r) 
            tx = int(math.floor(float(p.x) / float(self.TILE_SIZE))) 
            ty = int(math.floor(float(p.y) / float(self.TILE_SIZE))) 
            if self._world_furniture_damage_at(int(tx), int(ty), dmg=int(struct_dmg), impact_dir=pygame.Vector2(pdir)): 
                nrad = float(getattr(mdef, "noise_radius", 120.0)) if mdef is not None else 120.0 
                loud = 0.18 if swing_id == "fist" else 0.26 
                self.noise_left = max(float(getattr(self, "noise_left", 0.0)), float(loud)) 
                self.noise_radius = max(float(getattr(self, "noise_radius", 0.0)), float(nrad)) 
                return 
        return 

    def _spawn_hit_fx(self, pos: pygame.Vector2, *, dir: pygame.Vector2) -> None:
        pos = pygame.Vector2(pos)
        d = pygame.Vector2(dir)
        if d.length_squared() <= 0.001:
            d = pygame.Vector2(1, 0)
        d = d.normalize()

        rnd = getattr(self, "fx_rng", None)
        if not isinstance(rnd, random.Random):
            rnd = random.Random(1234)

        base_ang = float(math.atan2(float(d.y), float(d.x)))
        count = 7
        for _ in range(count):
            ang = base_ang + float(rnd.uniform(-1.15, 1.15))
            spd = float(rnd.uniform(35.0, 130.0))
            vel = pygame.Vector2(math.cos(ang), math.sin(ang)) * spd
            ttl = float(rnd.uniform(0.10, 0.22))
            self.hit_fx.append(HardcoreSurvivalState._HitFX(pos=pygame.Vector2(pos), vel=vel, ttl=ttl))

        # A brighter "spark" reads better than pure blood at 1x.
        self.hit_fx.append(
            HardcoreSurvivalState._HitFX(
                pos=pygame.Vector2(pos) + d * 2.0,
                vel=pygame.Vector2(d) * 10.0,
                ttl=0.08,
                color=(255, 220, 160),
            )
        )

        if len(self.hit_fx) > 240:
            self.hit_fx = self.hit_fx[-240:]

    def _update_hit_fx(self, dt: float) -> None:
        if not getattr(self, "hit_fx", None):
            return
        alive: list[HardcoreSurvivalState._HitFX] = []
        for fx in self.hit_fx:
            fx.pos += fx.vel * dt
            fx.vel *= 0.82
            fx.ttl -= dt
            if float(fx.ttl) > 0.0:
                alive.append(fx)
        self.hit_fx = alive

    def _draw_hit_fx(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        if not getattr(self, "hit_fx", None):
            return
        for fx in self.hit_fx:
            p = pygame.Vector2(fx.pos) - pygame.Vector2(cam_x, cam_y)
            x = iround(float(p.x))
            y = iround(float(p.y))
            if not (0 <= x < INTERNAL_W and 0 <= y < INTERNAL_H):
                continue
            # Big at first, then fade to single pixels.
            if float(fx.ttl) > 0.14:
                surface.fill(fx.color, pygame.Rect(int(x), int(y), 2, 1))
            else:
                surface.fill(fx.color, pygame.Rect(int(x), int(y), 1, 1))

    def _toggle_vehicle(self) -> None:
        if self.mount is not None:
            mount_kind = str(self.mount)
            if self.mount == "rv":
                vehicle_pos = pygame.Vector2(self.rv.pos)
                vw, vh = float(self.rv.w), float(self.rv.h)
                self.rv.vel.update(0, 0)
                self.rv.speed = 0.0
                self.rv.steer = 0.0
            else:
                vehicle_pos = pygame.Vector2(self.bike.pos)
                vw, vh = float(self.bike.w), float(self.bike.h)
                self.bike.vel.update(0, 0)

            # Dismount: choose a nearby free spot. RV uses heading-relative exits so the
            # player doesn't overlap the rotated sprite.
            ph = float(max(int(self.player.w), int(getattr(self.player, "collider_h", self.player.h)))) / 2.0
            if self.mount == "rv":
                heading = float(getattr(self.rv, "heading", 0.0))
                fwd = pygame.Vector2(math.cos(float(heading)), math.sin(float(heading)))
                if fwd.length_squared() < 0.001:
                    fwd = pygame.Vector2(1, 0)
                fwd = fwd.normalize()
                right = pygame.Vector2(-float(fwd.y), float(fwd.x))
                side_margin = float(vh) / 2.0 + float(ph) + 8.0
                fwd_margin = float(vw) / 2.0 + float(ph) + 8.0
                exits = [
                    right * float(side_margin),
                    -right * float(side_margin),
                    fwd * float(fwd_margin),
                    -fwd * float(fwd_margin),
                ]
            else:
                exits = [
                    pygame.Vector2(vw / 2 + float(ph) + 4, 0),
                    pygame.Vector2(-(vw / 2 + float(ph) + 4), 0),
                    pygame.Vector2(0, vh / 2 + float(ph) + 4),
                    pygame.Vector2(0, -(vh / 2 + float(ph) + 4)),
                ]

            # Treat the vehicle as solid (as it will be after dismount) while searching.
            self.mount = None
            placed = False
            # Prevent dismount/teleporting through walls: require the path from the
            # vehicle center to the exit point to be unobstructed (except for the vehicle itself).
            ignore_rect: pygame.Rect | None = None
            try:
                if str(mount_kind) == "rv":
                    ignore_rect = self._rv_collider_rect_at(vehicle_pos)
                elif str(mount_kind) == "bike":
                    ignore_rect = pygame.Rect(
                        iround(float(vehicle_pos.x) - float(vw) / 2.0),
                        iround(float(vehicle_pos.y) - float(vh) / 2.0),
                        int(vw),
                        int(vh),
                    )
            except Exception:
                ignore_rect = None

            def path_clear(dst: pygame.Vector2) -> bool:
                try:
                    a = pygame.Vector2(vehicle_pos)
                    b = pygame.Vector2(dst)
                    d = b - a
                    dist = float(d.length())
                    if dist <= 0.5:
                        return True
                    step_len = max(1.0, float(self.TILE_SIZE) / 4.0)
                    steps = int(clamp(int(math.ceil(dist / step_len)), 1, 80))
                    for i in range(1, int(steps) + 1):
                        t = float(i) / float(steps)
                        p2 = a + d * t
                        hits = self._collide_rect_world(self.player.rect_at(p2))
                        if not hits:
                            continue
                        for hh in hits:
                            if ignore_rect is not None and hh == ignore_rect:
                                continue
                            return False
                    return True
                except Exception:
                    return False

            for off in exits:
                p = vehicle_pos + off
                if not self._collide_rect_world(self.player.rect_at(p)) and path_clear(p):
                    self.player.pos.update(p)
                    placed = True
                    break
            if not placed:
                self.mount = mount_kind
                self.player.pos.update(vehicle_pos)
                self._set_hint("", seconds=1.0)
                return

            self.mount = None
            self._set_hint("")
            return

        rv_d2 = float((self.player.pos - self.rv.pos).length_squared())
        bike_d2 = float((self.player.pos - self.bike.pos).length_squared())
        parked_chunk, parked_bike, parked_d2 = self._find_nearest_parked_bike(radius_px=18.0)
        # Cars are large; use a bigger pickup radius than bikes so you can interact near the doors.
        parked_car_chunk, parked_car, parked_car_d2 = self._find_nearest_parked_car(radius_px=70.0)
        # Moving (story) traffic can also be hijacked like GTA.
        traffic = getattr(self, "story_traffic", None)
        traffic_pick: dict[str, object] | None = None
        traffic_pick_kind = ""
        traffic_pick_d2 = 1e18
        if (
            bool(getattr(self, "story_enabled", False))
            and bool(self._story_is_pre_apocalypse())
            and bool(getattr(self, "story_traffic_enabled", True))
            and isinstance(traffic, list)
        ):
            for a in traffic:
                if not isinstance(a, dict):
                    continue
                kind2 = str(a.get("kind", "") or "")
                if kind2 not in ("car", "bike", "moto"):
                    continue
                try:
                    pos2 = pygame.Vector2(a.get("pos", pygame.Vector2(0, 0)))
                except Exception:
                    continue
                try:
                    d2 = float((pos2 - self.player.pos).length_squared())
                except Exception:
                    continue
                rad = 80.0 if kind2 == "car" else 36.0
                if d2 <= float(rad * rad) and d2 < float(traffic_pick_d2):
                    traffic_pick = a
                    traffic_pick_kind = str(kind2)
                    traffic_pick_d2 = float(d2)
        try:
            pad = 22
            can_rv = bool(
                self._rv_collider_rect_at()
                .inflate(int(pad * 2), int(pad * 2))
                .collidepoint(int(round(float(self.player.pos.x))), int(round(float(self.player.pos.y))))
            )
        except Exception:
            can_rv = rv_d2 <= (22.0 * 22.0)
        can_bike = bike_d2 <= (18.0 * 18.0)
        can_parked_bike = parked_bike is not None and parked_chunk is not None
        can_parked_car = parked_car is not None and parked_car_chunk is not None
        can_traffic_car = traffic_pick is not None and traffic_pick_kind == "car"
        can_traffic_bike = traffic_pick is not None and traffic_pick_kind in ("bike", "moto")
        if not can_rv and not can_bike and not can_parked_bike and not can_parked_car and not can_traffic_car and not can_traffic_bike:
            self._set_hint("")
            return

        # Choose the nearest available vehicle (parked beats personal when closer).
        choice: tuple[str, float] | None = None
        for kind, ok, d2 in (
            ("traffic_car", bool(can_traffic_car), float(traffic_pick_d2)),
            ("traffic_bike", bool(can_traffic_bike), float(traffic_pick_d2)),
            ("parked_car", bool(can_parked_car), float(parked_car_d2)),
            ("parked_bike", bool(can_parked_bike), float(parked_d2)),
            ("bike", bool(can_bike), float(bike_d2)),
            ("car", bool(can_rv), float(rv_d2)),
        ):
            if not ok:
                continue
            if choice is None or float(d2) < float(choice[1]):
                choice = (str(kind), float(d2))
        if choice is None:
            self._set_hint("")
            return
        pick = str(choice[0])

        if pick == "traffic_car":
            if traffic_pick is None or not isinstance(traffic, list):
                self._set_hint("")
                return
            try:
                wpos = pygame.Vector2(traffic_pick.get("pos", self.player.pos))
            except Exception:
                wpos = pygame.Vector2(self.player.pos)
            mid = str(traffic_pick.get("model_id", "beetle") or "beetle")
            head = float(traffic_pick.get("heading", 0.0) or 0.0)
            try:
                self._stash_personal_car_as_parked()
            except Exception:
                pass
            self.rv.pos.update(wpos)
            self.rv.vel.update(0, 0)
            self.rv.model_id = str(mid)
            # Traffic actors don't track fuel; assume some usable amount.
            self.rv.fuel = float(clamp(55.0 + random.uniform(-20.0, 25.0), 10.0, 95.0))
            self.rv.heading = float(head)
            self.rv.speed = 0.0
            self.rv.steer = 0.0
            self._apply_rv_model()
            self.rv_hotwired = True
            try:
                traffic.remove(traffic_pick)
            except Exception:
                pass
            self.mount = "rv"
            self.player.pos.update(self.rv.pos)
            self.player.vel.update(0, 0)
            self._crime_add(42.0, "")
            model = self._CAR_MODELS.get(str(self.rv.model_id))
            name = model.name if model is not None else str(self.rv.model_id)
            self._set_hint(f"{name}", seconds=1.0)
            return

        if pick == "traffic_bike":
            if traffic_pick is None or not isinstance(traffic, list):
                self._set_hint("")
                return
            try:
                wpos = pygame.Vector2(traffic_pick.get("pos", self.player.pos))
            except Exception:
                wpos = pygame.Vector2(self.player.pos)
            mid = str(traffic_pick.get("model_id", "bike") or "bike")
            d = str(traffic_pick.get("dir", "right") or "right")
            try:
                self._stash_personal_bike_as_parked()
            except Exception:
                pass
            self.bike.pos.update(wpos)
            self.bike.vel.update(0, 0)
            self.bike.model_id = str(mid)
            self.bike.fuel = float(clamp(55.0 + random.uniform(-25.0, 30.0), 0.0, 95.0)) if str(mid).startswith("moto") else 0.0
            self.bike_dir = str(d)
            self.bike_anim = 0.0
            self._apply_bike_model()
            self.bike_hotwired = bool(str(mid).startswith("moto"))
            try:
                traffic.remove(traffic_pick)
            except Exception:
                pass
            self.mount = "bike"
            self.player.pos.update(self.bike.pos)
            self._crime_add(28.0 if str(mid).startswith("moto") else 22.0, "")
            self._set_hint(f" {self._two_wheel_name(self.bike.model_id)}", seconds=1.0)
            return

        if pick == "parked_car":
            pc = parked_car
            if pc is None or parked_car_chunk is None:
                self._set_hint("")
                return
            # Need to be actually close to the car, not just within the scan radius.
            try:
                pad = 22
                wpos = pygame.Vector2(getattr(pc, "pos", self.player.pos))
                mid = str(getattr(pc, "model_id", "rv"))
                cmodel = self._CAR_MODELS.get(str(mid)) or self._CAR_MODELS.get("rv")
                cw, ch = (cmodel.collider if cmodel is not None else (22, 14))
                chead = float(getattr(pc, "heading", 0.0))
                c = abs(math.cos(float(chead)))
                s = abs(math.sin(float(chead)))
                ww = float(cw) * c + float(ch) * s
                hh = float(cw) * s + float(ch) * c
                aabb = pygame.Rect(
                    iround(float(wpos.x) - float(ww) / 2.0),
                    iround(float(wpos.y) - float(hh) / 2.0),
                    int(max(2, int(round(float(ww))))),
                    int(max(2, int(round(float(hh))))),
                )
                near = bool(
                    aabb.inflate(int(pad * 2), int(pad * 2)).collidepoint(
                        int(round(float(self.player.pos.x))), int(round(float(self.player.pos.y)))
                    )
                )
            except Exception:
                near = (self.player.pos - pygame.Vector2(getattr(pc, "pos", self.player.pos))).length_squared() <= (22.0 * 22.0)
            if not near:
                self._set_hint(": F ", seconds=1.0)
                return
            owned = bool(getattr(pc, "owned", False))
            has_key = int(self.inventory.count("key_rv")) > 0
            if owned and not has_key:
                self._set_hint("", seconds=1.1)
                return
            try:
                self._stash_personal_car_as_parked()
            except Exception:
                pass
            self.rv.pos.update(pygame.Vector2(getattr(pc, "pos", self.player.pos)))
            self.rv.vel.update(0, 0)
            self.rv.model_id = str(getattr(pc, "model_id", "rv"))
            self.rv.fuel = float(getattr(pc, "fuel", 0.0))
            self.rv.heading = float(getattr(pc, "heading", 0.0))
            self.rv.speed = 0.0
            self.rv.steer = 0.0
            self._apply_rv_model()
            self.rv_hotwired = bool((not owned) and (not has_key))
            try:
                parked_car_chunk.cars.remove(pc)
            except Exception:
                pass
            self.mount = "rv"
            self.player.pos.update(self.rv.pos)
            self.player.vel.update(0, 0)
            model = self._CAR_MODELS.get(str(self.rv.model_id))
            name = model.name if model is not None else str(self.rv.model_id)
            if not owned:
                self._crime_add(40.0 if not has_key else 28.0, "")
                self._set_hint(f"{name}", seconds=1.0)
            else:
                self._set_hint(f"{name}", seconds=1.0)
            return

        if pick == "parked_bike":
            # Take a parked two-wheeler (including motorcycles) and mount it.
            pb = parked_bike
            pb_mid = str(getattr(pb, "model_id", "bike")) if pb is not None else "bike"
            owned = bool(getattr(pb, "owned", False))
            has_key = int(self.inventory.count("key_moto")) > 0
            if owned and pb_mid.startswith("moto") and not has_key:
                self._set_hint("", seconds=1.1)
                return
            try:
                self._stash_personal_bike_as_parked()
            except Exception:
                pass
            self.bike.pos.update(pygame.Vector2(getattr(pb, "pos", self.player.pos)))
            self.bike.vel.update(0, 0)
            self.bike.model_id = str(getattr(pb, "model_id", "bike"))
            self.bike.fuel = float(getattr(pb, "fuel", 0.0))
            self.bike_dir = str(getattr(pb, "dir", "right"))
            self.bike_anim = 0.0
            self._apply_bike_model()
            self.bike_hotwired = bool((not owned) and pb_mid.startswith("moto") and (not has_key))
            try:
                parked_chunk.bikes.remove(pb)
            except Exception:
                pass
            self.mount = "bike"
            self.player.pos.update(self.bike.pos)
            if not owned:
                heat = 26.0 if pb_mid.startswith("moto") else 22.0
                if pb_mid.startswith("moto") and not has_key:
                    heat = 34.0
                self._crime_add(float(heat), "")
                self._set_hint(f" {self._two_wheel_name(self.bike.model_id)}", seconds=1.0)
            else:
                self._set_hint(f" {self._two_wheel_name(self.bike.model_id)}")
            return

        if pick == "bike":
            mid = str(getattr(self.bike, "model_id", "bike"))
            if mid.startswith("moto") and int(self.inventory.count("key_moto")) <= 0 and not bool(getattr(self, "bike_hotwired", False)):
                self._set_hint("", seconds=1.1)
                return
            self.mount = "bike"
            self.player.pos.update(self.bike.pos)
            self._set_hint(f" {self._two_wheel_name(getattr(self.bike, 'model_id', 'bike'))}")
            return

        # Car (personal): F is always mount/drive. Use H to enter the RV interior.

        if int(self.inventory.count("key_rv")) <= 0 and not bool(getattr(self, "rv_hotwired", False)):
            self._set_hint("", seconds=1.1)
            return
        self.mount = "rv"
        self.player.pos.update(self.rv.pos)
        model = self._CAR_MODELS.get(str(getattr(self.rv, "model_id", "rv")))
        name = model.name if model is not None else str(getattr(self.rv, "model_id", "rv"))
        self._set_hint(f"{name}", seconds=1.0)

    def _compute_player_pixel_lock_world_xy(self) -> tuple[int, int]:
        # Integer world coords used for pixel-locked camera/render/aim.
        # Keep this deterministic and monotonic to avoid diagonal jitter.
        try:
            px = float(self.player.pos.x)
            py = float(self.player.pos.y)
        except Exception:
            px = float(getattr(getattr(self.player, "pos", None), "x", 0.0))
            py = float(getattr(getattr(self.player, "pos", None), "y", 0.0))

        prev = getattr(self, '_player_pixel_lock_world_xy', None)
        prev_x = None
        prev_y = None
        if isinstance(prev, tuple) and len(prev) == 2:
            try:
                prev_x = int(prev[0])
                prev_y = int(prev[1])
            except Exception:
                prev_x = None
                prev_y = None

        prev_float = getattr(self, '_player_pixel_lock_prev_world_xy', None)
        dx_f = 0.0
        dy_f = 0.0
        if isinstance(prev_float, tuple) and len(prev_float) == 2:
            try:
                dx_f = float(px) - float(prev_float[0])
                dy_f = float(py) - float(prev_float[1])
            except Exception:
                dx_f = 0.0
                dy_f = 0.0
        self._player_pixel_lock_prev_world_xy = (float(px), float(py))

        # Teleport / respawn / big correction: snap lock and clear residual.
        if prev_x is None or prev_y is None or abs(float(dx_f)) > 20.0 or abs(float(dy_f)) > 20.0:
            ix = int(iround(float(px)))
            iy = int(iround(float(py)))
            self._player_pixel_lock_residual_xy = (0.0, 0.0)
            return int(ix), int(iy)

        # Tiny opposite-direction jitter from collision resolution can create
        # visible up-left/down-right wobble. Ignore very small reverse drift.
        try:
            ivx = float(getattr(self.player.vel, "x", 0.0))
            ivy = float(getattr(self.player.vel, "y", 0.0))
        except Exception:
            ivx = 0.0
            ivy = 0.0
        if abs(float(ivx)) > 1e-4 and (float(dx_f) * float(ivx)) < 0.0 and abs(float(dx_f)) < 0.35:
            dx_f = 0.0
        if abs(float(ivy)) > 1e-4 and (float(dy_f) * float(ivy)) < 0.0 and abs(float(dy_f)) < 0.35:
            dy_f = 0.0

        # Pixel-step integrator: convert float displacement to integer camera
        # steps using residual accumulation. This gives stable, evenly-spaced
        # diagonal stepping (much less perceived shake than absolute re-rounding).
        rx = 0.0
        ry = 0.0
        residual = getattr(self, '_player_pixel_lock_residual_xy', None)
        if isinstance(residual, tuple) and len(residual) == 2:
            try:
                rx = float(residual[0])
                ry = float(residual[1])
            except Exception:
                rx = 0.0
                ry = 0.0

        rx = float(rx) + float(dx_f)
        ry = float(ry) + float(dy_f)

        # Whole-pixel steps for this frame.
        if float(rx) >= 0.0:
            sx = int(math.floor(float(rx)))
        else:
            sx = int(math.ceil(float(rx)))
        if float(ry) >= 0.0:
            sy = int(math.floor(float(ry)))
        else:
            sy = int(math.ceil(float(ry)))

        # On slow normalized diagonals (e.g., 1px/frame cardinals -> 0.707px/frame
        # diagonals), X/Y residuals stay phase-locked and produce occasional
        # (0,0) frames. That "full-frame stall" reads as camera shake/stutter.
        #
        # Break the tie by advancing *one* axis on such frames (alternating axes),
        # borrowing from the residual so long-term average speed stays correct.
        try:
            diag = abs(float(dx_f)) > 1e-6 and abs(float(dy_f)) > 1e-6
            slow = abs(float(dx_f)) < 1.05 and abs(float(dy_f)) < 1.05
            if diag and slow and int(sx) == 0 and int(sy) == 0:
                # Only do this when we're "close enough" to a step; avoids
                # large negative residual spikes at very low speeds.
                if abs(float(rx)) >= 0.55 and abs(float(ry)) >= 0.55:
                    phase = int(getattr(self, "_player_pixel_lock_diag_phase", 0))
                    # Pick the axis with larger residual magnitude; if equal,
                    # alternate for symmetry.
                    if abs(float(rx)) > abs(float(ry)) + 1e-6:
                        choose_x = True
                    elif abs(float(ry)) > abs(float(rx)) + 1e-6:
                        choose_x = False
                    else:
                        choose_x = (int(phase) % 2) == 0
                    if choose_x:
                        sx = 1 if float(rx) > 0.0 else -1
                        sy = 0
                    else:
                        sx = 0
                        sy = 1 if float(ry) > 0.0 else -1
                    self._player_pixel_lock_diag_phase = int(phase) + 1
        except Exception:
            pass

        rx = float(rx) - float(sx)
        ry = float(ry) - float(sy)
        self._player_pixel_lock_residual_xy = (float(rx), float(ry))

        ix = int(prev_x) + int(sx)
        iy = int(prev_y) + int(sy)

        # Keep lock close to true position to avoid long-term drift.
        min_x = int(math.floor(float(px))) - 1
        max_x = int(math.ceil(float(px))) + 1
        min_y = int(math.floor(float(py))) - 1
        max_y = int(math.ceil(float(py))) + 1
        ix = int(clamp(int(ix), int(min_x), int(max_x)))
        iy = int(clamp(int(iy), int(min_y), int(max_y)))
        return int(ix), int(iy)

    def _compute_aim_dir(self) -> pygame.Vector2:
        m = self.app.screen_to_internal(pygame.mouse.get_pos())
        if m is None:
            d = pygame.Vector2(self.player.facing)
            return d.normalize() if d.length_squared() > 0.001 else pygame.Vector2(1, 0)
        mw = pygame.Vector2(m) + pygame.Vector2(float(self.cam_x), float(self.cam_y))
        # Stabilize aim against sub-pixel player movement by computing the aim
        # vector from the *same pixel-locked anchor* used by the camera/render.
        # This prevents tiny aim jitter (and 4-dir sprite flicker) while walking
        # diagonally with the mouse held steady.
        try:
            px, py = getattr(self, "_player_pixel_lock_world_xy")
            px = float(px)
            py = float(py)
        except Exception:
            px_i, py_i = self._compute_player_pixel_lock_world_xy()
            px = float(px_i)
            py = float(py_i)
        v = mw - pygame.Vector2(float(px), float(py))
        if v.length_squared() <= 0.001:
            d = pygame.Vector2(self.player.facing)
            return d.normalize() if d.length_squared() > 0.001 else pygame.Vector2(1, 0)
        return v.normalize()

    def _fire(self) -> None:
        if self.gun is None:
            return
        gun_def = self._gun_effective_def(self.gun)
        if gun_def is None:
            return
        if self.gun.reload_left > 0.0 or self.gun.cooldown_left > 0.0:
            return
        if int(self.gun.mag) <= 0:
            self._set_hint("R", seconds=0.8)
            return

        aim = pygame.Vector2(self.aim_dir)
        if aim.length_squared() <= 0.001:
            aim = pygame.Vector2(self.player.facing)
        if aim.length_squared() <= 0.001:
            aim = pygame.Vector2(1, 0)
        aim = aim.normalize()
        base_ang = math.atan2(aim.y, aim.x)
        spread = math.radians(float(gun_def.spread_deg))
        ang = base_ang + random.uniform(-spread, spread)
        d = pygame.Vector2(math.cos(ang), math.sin(ang))

        # Spawn from muzzle (hand-bone) so visuals match bullets.
        height_delta = 0
        av = getattr(self, "avatar", None)
        if av is not None:
            hidx = int(getattr(av, "height", 1))
            height_delta = 1 if hidx == 0 else -1 if hidx == 2 else 0

        face = pygame.Vector2(aim)
        if abs(face.y) >= abs(face.x):
            spr_dir = "down" if face.y >= 0 else "up"
        else:
            spr_dir = "right" if face.x >= 0 else "left"

        pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
        pf_run = getattr(self, "player_frames_run", None)
        is_run = bool(getattr(self, "player_sprinting", False))
        pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
        frames = pf.get(spr_dir, pf["down"])
        moving = self.player.vel.length_squared() > 1.0
        bob = 0
        step_idx = 0
        idle_anim = True
        if moving and len(frames) > 1:
            idle_anim = False
            walk = frames[1:]
            phase = (float(self.player.walk_phase) % math.tau) / math.tau
            step_idx = int(phase * len(walk)) % len(walk)
            if is_run and step_idx in (1, 4):
                bob = 1
            spr = walk[step_idx]
        else:
            spr = frames[0]

        rect = spr.get_rect()
        rect.midbottom = (
            iround(float(self.player.pos.x)),
            iround(float(self.player.pos.y) + float(self.player.h) / 2.0),
        )
        rect.y += int(bob)
        sk = self._survivor_skeleton_nodes(
            spr_dir,
            int(step_idx),
            idle=bool(idle_anim),
            height_delta=int(height_delta),
            run=bool(is_run),
        )
        hand_node = sk.get("r_hand")
        if hand_node is not None:
            hx, hy = hand_node
            base_hand = pygame.Vector2(int(rect.left + hx), int(rect.top + hy))
        else:
            base_hand = pygame.Vector2(rect.centerx, rect.centery + 3)
        muzzle = base_hand + aim * 17.0
        spawn = pygame.Vector2(muzzle)
        bkind = str(getattr(gun_def, "bullet_kind", "bullet"))
        self.bullets.append(
            HardcoreSurvivalState._Bullet(
                pos=spawn,
                vel=d * float(gun_def.bullet_speed),
                ttl=float(getattr(gun_def, "bullet_ttl", 1.35)),
                dmg=int(gun_def.damage),
                kind=bkind,
                aoe_radius=float(getattr(gun_def, "aoe_radius", 0.0)),
                aoe_damage=int(getattr(gun_def, "aoe_damage", 0)),
            )
        )
        self.gun.mag = int(self.gun.mag) - 1
        self.gun.cooldown_left = 1.0 / max(0.1, float(gun_def.fire_rate))
        self.app.play_sfx("shot")
        self.muzzle_flash_left = float(getattr(gun_def, "muzzle_flash_s", 0.06))
        self.noise_left = max(float(getattr(self, "noise_left", 0.0)), 0.95 if bkind == "rocket" else 0.55)
        self.noise_radius = max(float(getattr(self, "noise_radius", 0.0)), float(getattr(gun_def, "noise_radius", 220.0)))

    def _update_bullets(self, dt: float) -> None:
        if not self.bullets:
            return
        alive: list[HardcoreSurvivalState._Bullet] = []

        def explode(
            center: pygame.Vector2,
            *,
            radius: float,
            splash: int,
            direct: HardcoreSurvivalState._Zombie | None = None,
            direct_damage: int = 0,
        ) -> None:
            center = pygame.Vector2(center)
            radius = float(radius)
            splash = int(splash)
            direct_damage = int(direct_damage)

            # Direct hit (rockets).
            if direct is not None and int(getattr(direct, "hp", 0)) > 0 and direct_damage > 0:
                try:
                    direct.hp = int(direct.hp) - int(direct_damage)
                except Exception:
                    pass
                if int(getattr(direct, "hp", 0)) <= 0:
                    self._kill_zombie(direct, impact_dir=pygame.Vector2(direct.pos) - center)
                else:
                    to = pygame.Vector2(direct.pos) - center
                    if to.length_squared() > 0.001:
                        direct.stagger_left = max(float(getattr(direct, "stagger_left", 0.0)), 0.18)
                        direct.stagger_vel = to.normalize() * 120.0

            if radius <= 1.0 or splash <= 0:
                return

            r2 = float(radius * radius)
            for z in self.zombies:
                if direct is not None and z is direct:
                    continue
                if int(getattr(z, "hp", 0)) <= 0:
                    continue
                to = pygame.Vector2(z.pos) - center
                d2 = float(to.length_squared())
                if d2 > r2:
                    continue
                t = 1.0 - math.sqrt(d2) / max(1e-6, float(radius))
                dmg = int(max(1, int(round(float(splash) * (0.35 + 0.65 * float(t))))))
                z.hp = int(z.hp) - int(dmg)
                if int(z.hp) > 0:
                    z.stagger_left = max(float(getattr(z, "stagger_left", 0.0)), 0.18)
                    if to.length_squared() > 0.001:
                        z.stagger_vel = to.normalize() * (85.0 + 60.0 * float(t))
                else:
                    self._kill_zombie(z, impact_dir=to)

            # FX + noise.
            try:
                base_dir = pygame.Vector2(1, 0)
                if direct is not None:
                    base_dir = pygame.Vector2(direct.pos) - center
                self._spawn_hit_fx(center, dir=base_dir)
                for _ in range(10):
                    ang = random.random() * math.tau
                    spd = random.uniform(80.0, 220.0)
                    vel = pygame.Vector2(math.cos(ang), math.sin(ang)) * spd
                    self.hit_fx.append(
                        HardcoreSurvivalState._HitFX(pos=pygame.Vector2(center), vel=vel, ttl=0.18, color=(255, 190, 120))
                    )
            except Exception:
                pass
            self.noise_left = max(float(getattr(self, "noise_left", 0.0)), 1.0)
            self.noise_radius = max(float(getattr(self, "noise_radius", 0.0)), 420.0)

        for b in self.bullets:
            b.pos += b.vel * dt
            b.ttl -= dt
            bkind = str(getattr(b, "kind", "bullet"))

            if b.ttl <= 0.0:
                if bkind == "rocket":
                    explode(
                        pygame.Vector2(b.pos),
                        radius=float(getattr(b, "aoe_radius", 0.0)),
                        splash=int(getattr(b, "aoe_damage", 0)),
                    )
                continue

            tx = int(math.floor(b.pos.x / self.TILE_SIZE))
            ty = int(math.floor(b.pos.y / self.TILE_SIZE))
            tile = self.world.get_tile(tx, ty)
            if self._tile_solid(tile):
                if bkind == "rocket":
                    explode(
                        pygame.Vector2(b.pos),
                        radius=float(getattr(b, "aoe_radius", 0.0)),
                        splash=int(getattr(b, "aoe_damage", 0)),
                    )
                continue

            hit = False
            for z in self.zombies:
                if int(getattr(z, "hp", 0)) <= 0:
                    continue
                if z.rect().collidepoint(int(round(b.pos.x)), int(round(b.pos.y))):
                    if bkind == "rocket":
                        explode(
                            pygame.Vector2(b.pos),
                            radius=float(getattr(b, "aoe_radius", 0.0)),
                            splash=int(getattr(b, "aoe_damage", 0)),
                            direct=z,
                            direct_damage=int(getattr(b, "dmg", 0)),
                        )
                    else:
                        z.hp = int(z.hp) - int(b.dmg)
                        if int(z.hp) > 0:
                            z.stagger_left = max(float(getattr(z, "stagger_left", 0.0)), 0.12)
                            if b.vel.length_squared() > 0.1:
                                z.stagger_vel = pygame.Vector2(b.vel).normalize() * 85.0
                        else:
                            self._kill_zombie(z, impact_dir=pygame.Vector2(b.vel))
                    hit = True
                    break
            if hit:
                continue
            alive.append(b)

        self.bullets = alive
        # Zombies become corpses (decay later) instead of being removed immediately.

    def _thrown_furniture_try_place_at(self, tf: "HardcoreSurvivalState._ThrownFurniture", anchor_tx: int, anchor_ty: int) -> bool:
        try:
            tid = int(getattr(tf, "tid", 0))
            offsets = getattr(tf, "offsets", [])
        except Exception:
            return False
        if tid <= 0 or not isinstance(offsets, list) or not offsets:
            return False

        space = str(getattr(tf, "space", "world"))
        if space not in ("home", "rv", "world"):
            space = "world"

        anchor_tx = int(anchor_tx)
        anchor_ty = int(anchor_ty)
        cells: list[tuple[int, int]] = []
        for off in offsets:
            if not (isinstance(off, tuple) and len(off) == 2):
                continue
            dx, dy = int(off[0]), int(off[1])
            cells.append((int(anchor_tx + dx), int(anchor_ty + dy)))
        if not cells:
            return False

        for tx, ty in cells:
            if space == "rv":
                if not self._tile_in_rv_world(int(tx), int(ty)):
                    return False
                base = getattr(self, "_rv_world_floor_base", None)
                if not isinstance(base, dict):
                    return False
                want = base.get((int(tx), int(ty)))
                if want is None:
                    return False
                if int(self.world.peek_tile(int(tx), int(ty))) != int(want):
                    return False
            elif space == "home":
                if not self._tile_in_home_world(int(tx), int(ty)):
                    return False
                if int(self.world.peek_tile(int(tx), int(ty))) != int(self.T_FLOOR):
                    return False
            else:
                base_tid = int(self.world.peek_tile(int(tx), int(ty)))
                if int(base_tid) in self._WORLD_FURNITURE_HP_DEFAULTS:
                    return False
                if int(base_tid) in (
                    int(self.T_DOOR),
                    int(self.T_DOOR_HOME),
                    int(self.T_DOOR_BROKEN),
                    int(self.T_STAIRS_UP),
                    int(self.T_STAIRS_DOWN),
                    int(self.T_ELEVATOR),
                ):
                    return False
                if bool(self._tile_solid(int(base_tid))):
                    return False

        for tx, ty in cells:
            self._world_set_tile(int(tx), int(ty), int(tid))

        hp = getattr(tf, "hp", None)
        if hp is not None:
            try:
                anchor = min(cells)
                self.world_furniture_hp[self._world_furniture_hp_key(int(anchor[0]), int(anchor[1]))] = int(hp)
            except Exception:
                pass
        return True

    def _thrown_furniture_break_drop(self, *, tid: int, cells_n: int, pos: pygame.Vector2, impact_dir: pygame.Vector2) -> None:
        tid = int(tid)
        cells_n = int(max(1, int(cells_n)))
        pos = pygame.Vector2(pos)
        d = pygame.Vector2(impact_dir)
        if d.length_squared() <= 0.001:
            d = pygame.Vector2(1, 0)
        self._spawn_hit_fx(pos, dir=d)
        self.app.play_sfx("hit")
        try:
            extra = max(0, int(cells_n) - 1)
            if int(tid) in self._WORLD_FURNITURE_WOOD_TILES:
                self._drop_world_item(pos, "wood", int(clamp(random.randint(1, 2) + extra, 1, 6)))
            elif int(tid) in self._WORLD_FURNITURE_METAL_TILES:
                self._drop_world_item(pos, "scrap", int(clamp(random.randint(1, 2) + extra, 1, 6)))
        except Exception:
            pass
        self.noise_left = max(float(getattr(self, "noise_left", 0.0)), 0.28)
        self.noise_radius = max(float(getattr(self, "noise_radius", 0.0)), 190.0)

    def _update_thrown_furniture(self, dt: float) -> None:
        thrown = getattr(self, "thrown_furniture", None)
        if not isinstance(thrown, list) or not thrown:
            return
        alive: list[HardcoreSurvivalState._ThrownFurniture] = []
        ts = float(max(1, int(self.TILE_SIZE)))

        for tf in thrown:
            if not isinstance(tf, HardcoreSurvivalState._ThrownFurniture):
                continue

            tf.ttl = float(getattr(tf, "ttl", 0.0)) - float(dt)
            # Simple drag so throws feel weighty.
            try:
                tf.vel *= max(0.0, 1.0 - float(dt) * 1.8)
            except Exception:
                pass

            next_pos = pygame.Vector2(getattr(tf, "pos", pygame.Vector2(0, 0))) + pygame.Vector2(getattr(tf, "vel", pygame.Vector2(0, 0))) * float(dt)
            cells_n = int(max(1, len(getattr(tf, "offsets", []))))
            hit_rad = 6 + 2 * int(min(4, max(0, cells_n - 1)))

            # Zombie hit first (treat as a weapon impact; it breaks on hit).
            hit_z: HardcoreSurvivalState._Zombie | None = None
            for z in self.zombies:
                if int(getattr(z, "hp", 0)) <= 0:
                    continue
                try:
                    if z.rect().inflate(int(hit_rad), int(hit_rad)).collidepoint(int(round(next_pos.x)), int(round(next_pos.y))):
                        hit_z = z
                        break
                except Exception:
                    continue
            if hit_z is not None:
                dmg = int(10 + 3 * int(min(4, max(0, cells_n - 1))))
                try:
                    hit_z.hp = int(hit_z.hp) - int(dmg)
                except Exception:
                    pass
                if int(getattr(hit_z, "hp", 0)) > 0:
                    try:
                        hit_z.stagger_left = max(float(getattr(hit_z, "stagger_left", 0.0)), 0.22)
                        v = pygame.Vector2(getattr(tf, "vel", pygame.Vector2(1, 0)))
                        if v.length_squared() > 0.001:
                            hit_z.stagger_vel = v.normalize() * 140.0
                    except Exception:
                        pass
                else:
                    self._kill_zombie(hit_z, impact_dir=pygame.Vector2(getattr(tf, "vel", pygame.Vector2(1, 0))))
                self._thrown_furniture_break_drop(tid=int(getattr(tf, "tid", 0)), cells_n=int(cells_n), pos=pygame.Vector2(hit_z.pos), impact_dir=pygame.Vector2(getattr(tf, "vel", pygame.Vector2(1, 0))))
                continue

            # Tile collision / landing.
            tx = int(math.floor(float(next_pos.x) / ts))
            ty = int(math.floor(float(next_pos.y) / ts))
            if float(getattr(tf, "ttl", 0.0)) <= 0.0 or bool(self._tile_solid(int(self.world.get_tile(int(tx), int(ty))))):
                placed = False
                # Try a few nearby tiles so it "lands" naturally instead of always breaking.
                for ox, oy in (
                    (0, 0),
                    (1, 0),
                    (-1, 0),
                    (0, 1),
                    (0, -1),
                    (1, 1),
                    (1, -1),
                    (-1, 1),
                    (-1, -1),
                ):
                    if self._thrown_furniture_try_place_at(tf, int(tx + ox), int(ty + oy)):
                        placed = True
                        break
                if not placed:
                    self._thrown_furniture_break_drop(tid=int(getattr(tf, "tid", 0)), cells_n=int(cells_n), pos=pygame.Vector2(getattr(tf, "pos", next_pos)), impact_dir=pygame.Vector2(getattr(tf, "vel", pygame.Vector2(1, 0))))
                continue

            tf.pos = pygame.Vector2(next_pos)
            alive.append(tf)

        self.thrown_furniture = alive

    def _kill_zombie(self, z: "HardcoreSurvivalState._Zombie", *, impact_dir: pygame.Vector2 | None = None) -> None:
        # Convert a zombie into a corpse that slowly decays away.
        try:
            if int(getattr(z, "hp", 0)) <= 0 and float(getattr(z, "corpse_left", 0.0)) > 0.0:
                return
        except Exception:
            pass

        try:
            z.hp = 0
        except Exception:
            return

        try:
            z.vel.update(0, 0)
        except Exception:
            z.vel = pygame.Vector2(0, 0)
        try:
            z.stagger_left = 0.0
            z.stagger_vel.update(0, 0)
        except Exception:
            pass

        try:
            z.death_t = 0.0
            total = float(getattr(self, "_ZOMBIE_CORPSE_TOTAL_S", 14.0))
            z.corpse_total = float(total)
            z.corpse_left = float(total)
        except Exception:
            pass

        # Orient the corpse based on the impact direction (purely visual).
        try:
            if isinstance(impact_dir, pygame.Vector2) and impact_dir.length_squared() > 0.001:
                v = pygame.Vector2(impact_dir)
                if abs(float(v.x)) >= abs(float(v.y)):
                    z.dir = "right" if float(v.x) >= 0 else "left"
                else:
                    z.dir = "down" if float(v.y) >= 0 else "up"
        except Exception:
            pass

        self._on_zombie_killed(z)

    def _push_corpse_off_vehicle(
        self,
        z: "HardcoreSurvivalState._Zombie",
        *,
        vehicle_rect: pygame.Rect,
        dir_vec: pygame.Vector2,
    ) -> None:
        """Prevent vehicle-killed corpses from sitting on top of the vehicle."""
        try:
            if int(getattr(z, "hp", 0)) > 0:
                return
            if float(getattr(z, "corpse_left", 0.0)) <= 0.0:
                return
        except Exception:
            return

        try:
            if not z.rect().colliderect(vehicle_rect):
                return
        except Exception:
            return

        base = pygame.Vector2(getattr(z, "pos", pygame.Vector2(0, 0)))
        try:
            d = pygame.Vector2(dir_vec)
            if d.length_squared() <= 0.001:
                d = pygame.Vector2(1, 0)
            else:
                d = d.normalize()
        except Exception:
            d = pygame.Vector2(1, 0)
        right = pygame.Vector2(-float(d.y), float(d.x))

        # Prefer pushing forward far enough to clear the vehicle AABB.
        try:
            push = float(max(int(vehicle_rect.w), int(vehicle_rect.h))) * 0.55 + 10.0
        except Exception:
            push = 58.0
        push = float(clamp(push, 24.0, 140.0))

        offsets = [
            d * push,
            d * push + right * 14.0,
            d * push - right * 14.0,
            d * (push * 1.25),
            right * (push * 0.55),
            -right * (push * 0.55),
        ]

        for off in offsets:
            try:
                cand = pygame.Vector2(base) + pygame.Vector2(off)
                tx = int(math.floor(float(cand.x) / float(self.TILE_SIZE)))
                ty = int(math.floor(float(cand.y) / float(self.TILE_SIZE)))
                tid = int(self.world.get_tile(int(tx), int(ty)))
                if bool(self._tile_solid(int(tid))):
                    continue
                z.pos.update(cand)
                if not z.rect().colliderect(vehicle_rect):
                    return
            except Exception:
                continue

        # Last resort: march forward until clear.
        try:
            for i in range(1, 30):
                cand = pygame.Vector2(base) + d * float(push + i * 6.0)
                tx = int(math.floor(float(cand.x) / float(self.TILE_SIZE)))
                ty = int(math.floor(float(cand.y) / float(self.TILE_SIZE)))
                tid = int(self.world.get_tile(int(tx), int(ty)))
                if bool(self._tile_solid(int(tid))):
                    continue
                z.pos.update(cand)
                if not z.rect().colliderect(vehicle_rect):
                    return
        except Exception:
            pass

        # Restore if we couldn't find a better spot.
        try:
            z.pos.update(base)
        except Exception:
            pass

    def _drop_world_item(self, pos: pygame.Vector2, item_id: str, qty: int) -> None:
        item_id = str(item_id)
        qty = int(qty)
        if qty <= 0:
            return
        # Avoid spawning drops on walls/facades/water: nudge to the nearest non-solid tile.
        pos = pygame.Vector2(pos)
        try:
            tx0 = int(math.floor(float(pos.x) / float(self.TILE_SIZE)))
            ty0 = int(math.floor(float(pos.y) / float(self.TILE_SIZE)))
            tid0 = int(self.world.get_tile(int(tx0), int(ty0)))
            avoid_tids = {
                int(self.T_DOOR),
                int(self.T_DOOR_HOME),
                int(self.T_DOOR_LOCKED),
                int(self.T_DOOR_HOME_LOCKED),
                int(self.T_DOOR_BROKEN),
                int(self.T_STAIRS_UP),
                int(self.T_STAIRS_DOWN),
                int(self.T_ELEVATOR),
            }
            if bool(self._tile_solid(int(tid0))) or int(tid0) in avoid_tids:
                best: pygame.Vector2 | None = None
                best_d2 = 1e30
                best_any: pygame.Vector2 | None = None
                best_any_d2 = 1e30
                max_r = 3  # tiles
                for r in range(1, int(max_r) + 1):
                    for oy in range(-r, r + 1):
                        for ox in range(-r, r + 1):
                            if abs(int(ox)) != int(r) and abs(int(oy)) != int(r):
                                continue
                            tx = int(tx0 + ox)
                            ty = int(ty0 + oy)
                            tid = int(self.world.get_tile(int(tx), int(ty)))
                            if bool(self._tile_solid(int(tid))):
                                continue
                            cx = (float(tx) + 0.5) * float(self.TILE_SIZE)
                            cy = (float(ty) + 0.5) * float(self.TILE_SIZE)
                            cand = pygame.Vector2(cx, cy)
                            d2 = float((cand - pos).length_squared())
                            if int(tid) in avoid_tids:
                                if d2 < best_any_d2:
                                    best_any_d2 = d2
                                    best_any = cand
                                continue
                            if d2 < best_d2:
                                best_d2 = d2
                                best = cand
                    if best is not None:
                        break
                if best is None and best_any is not None:
                    best = best_any
                if best is not None:
                    pos = best
        except Exception:
            pos = pygame.Vector2(pos)
        tx = int(math.floor(float(pos.x) / float(self.TILE_SIZE)))
        ty = int(math.floor(float(pos.y) / float(self.TILE_SIZE)))
        chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
        chunk.items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(pos), item_id=item_id, qty=qty))

    def _on_zombie_killed(self, z: "HardcoreSurvivalState._Zombie") -> None:
        kind = str(getattr(z, "kind", "walker"))
        pos = pygame.Vector2(z.pos)

        # Lightweight loot loop: enough to reinforce survival, not enough to break it.
        if random.random() < 0.22:
            self._drop_world_item(pos, "scrap", random.randint(1, 2))
        if random.random() < (0.12 if kind == "runner" else 0.06):
            self._drop_world_item(pos, "ammo_9mm", random.randint(3, 7))
        if random.random() < (0.06 if kind == "runner" else 0.02):
            self._drop_world_item(pos, random.choice(["ammo_556", "ammo_762"]), random.randint(2, 6))
        if random.random() < 0.008:
            self._drop_world_item(pos, "ammo_rocket", 1)
        if kind == "screamer" and random.random() < 0.045:
            self._drop_world_item(
                pos,
                random.choice(
                    [
                        "mod_optic_reddot",
                        "mod_optic_4x",
                        "mod_optic_holo",
                        "mod_muzzle_suppressor_9mm",
                        "mod_muzzle_suppressor_rifle",
                        "mod_muzzle_flash_hider_rifle",
                        "mod_undergrip_stab",
                        "mod_undergrip_bipod",
                        "mod_stock_tactical",
                        "mod_trigger_light",
                    ]
                ),
                1,
            )
        if random.random() < 0.07:
            self._drop_world_item(pos, "bandage", 1)
        if random.random() < 0.05:
            self._drop_world_item(pos, random.choice(["cola", "food_can", "water"]), 1)

    def _pick_zombie_kind(self, *, in_town: bool) -> str:
        season = int(self._season_index())
        tday = (float(self.world_time_s) % float(self.DAY_LENGTH_S)) / max(1e-6, float(self.DAY_LENGTH_S))
        night = bool(tday < 0.25 or tday > 0.75)

        weights: dict[str, float] = {"walker": 0.72, "runner": 0.22, "screamer": 0.06}
        if in_town:
            weights = {"walker": 0.55, "runner": 0.25, "screamer": 0.20}

        if night:
            weights["runner"] += 0.10
            weights["screamer"] += 0.06
            weights["walker"] -= 0.16

        # Season flavor (lightweight).
        if season == 1:  # summer
            weights["screamer"] += 0.05
            weights["walker"] -= 0.05
        elif season == 2:  # autumn
            weights["walker"] += 0.08
            weights["runner"] -= 0.04
        elif season == 3:  # winter
            weights["walker"] += 0.10
            weights["runner"] -= 0.06
            weights["screamer"] -= 0.04

        total = 0.0
        for v in weights.values():
            total += max(0.0, float(v))
        if total <= 0.0001:
            return "walker"
        r = random.random() * total
        acc = 0.0
        for k in ("walker", "runner", "screamer"):
            acc += max(0.0, float(weights.get(k, 0.0)))
            if r <= acc:
                return k
        return "walker"

    def _spawn_one_zombie(self, target_pos: pygame.Vector2, *, in_town: bool) -> None:
        kind = self._pick_zombie_kind(in_town=in_town)
        mdef = self._MONSTER_DEFS.get(kind, self._MONSTER_DEFS["walker"])
        # Spawn outside the current camera view so zombies "walk in" instead of popping in.
        view_r = float(math.hypot(float(INTERNAL_W) * 0.5, float(INTERNAL_H) * 0.5))
        min_dist = view_r + (70.0 if in_town else 110.0)
        max_dist = min_dist + (160.0 if in_town else 260.0)
        for _ in range(24):
            ang = random.random() * math.tau
            dist = random.uniform(float(min_dist), float(max_dist))
            pos = pygame.Vector2(target_pos) + pygame.Vector2(math.cos(ang), math.sin(ang)) * float(dist)
            tx = int(math.floor(pos.x / self.TILE_SIZE))
            ty = int(math.floor(pos.y / self.TILE_SIZE))
            tile = int(self.world.get_tile(tx, ty))
            if self._tile_solid(tile):
                continue
            # Don't spawn zombies inside buildings or on interior tiles.
            if tile in (int(self.T_FLOOR), int(self.T_DOOR)):
                continue
            chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
            in_building = False
            for bx0, by0, bw, bh, _roof_kind, _floors in getattr(chunk, "buildings", []):
                if int(bx0) <= int(tx) < int(bx0) + int(bw) and int(by0) <= int(ty) < int(by0) + int(bh):
                    in_building = True
                    break
            if in_building:
                continue
            hp = int(mdef.hp) + (6 if in_town else 0)
            speed = float(mdef.speed)
            z = HardcoreSurvivalState._Zombie(
                pos=pos,
                vel=pygame.Vector2(0, 0),
                hp=hp,
                speed=speed,
                kind=str(kind),
                dir="down",
                anim=random.random() * 2.0,
                attack_left=random.random() * float(mdef.attack_cd),
                scream_left=(random.random() * float(mdef.scream_cd) if float(mdef.scream_cd) > 0.0 else 0.0),
                wander_dir=pygame.Vector2(0, 0),
                wander_left=0.0,
                stagger_left=0.0,
                stagger_vel=pygame.Vector2(0, 0),
            )
            self.zombies.append(z)
            return

    def _update_zombies(self, dt: float) -> None:
        target = pygame.Vector2(self.player.pos)
        suppress_gather = False
        try:
            tx = int(math.floor(float(target.x) / float(self.TILE_SIZE)))
            ty = int(math.floor(float(target.y) / float(self.TILE_SIZE)))
            p_tile = int(self.world.get_tile(int(tx), int(ty)))
            if p_tile in (
                int(self.T_FLOOR),
                int(self.T_DOOR),
                int(self.T_ELEVATOR),
                int(self.T_STAIRS_UP),
                int(self.T_STAIRS_DOWN),
            ):
                found = self._multi_house_at(int(tx), int(ty))
                if found is not None:
                    chunk, mh = found
                    style = 0
                    tx0 = int(getattr(mh, "tx0", 0))
                    ty0 = int(getattr(mh, "ty0", 0))
                    bw = int(getattr(mh, "w", 0))
                    bh = int(getattr(mh, "h", 0))
                    for b in getattr(chunk, "buildings", []):
                        if int(b[0]) == int(tx0) and int(b[1]) == int(ty0) and int(b[2]) == int(bw) and int(b[3]) == int(bh):
                            roof_kind = int(b[4]) if len(b) > 4 else 0
                            style, _var = self._building_roof_style_var(int(roof_kind))
                            break
                    if int(style) == 6:
                        cur_floor = int(max(1, int(getattr(mh, "cur_floor", 1))))
                        if int(cur_floor) > 4:
                            suppress_gather = True
        except Exception:
            suppress_gather = False

        # Update corpse decay + vehicle-hit cooldown, and drop fully decayed corpses.
        if self.zombies:
            kept: list[HardcoreSurvivalState._Zombie] = []
            for z in self.zombies:
                try:
                    z.vehicle_hit_left = max(0.0, float(getattr(z, "vehicle_hit_left", 0.0)) - dt)
                except Exception:
                    pass

                if int(getattr(z, "hp", 0)) > 0:
                    kept.append(z)
                    continue

                corpse_left = float(getattr(z, "corpse_left", 0.0))
                if corpse_left <= 0.0:
                    continue
                try:
                    z.corpse_left = max(0.0, float(corpse_left) - dt)
                    z.death_t = float(getattr(z, "death_t", 0.0)) + dt
                except Exception:
                    pass
                if float(getattr(z, "corpse_left", 0.0)) > 0.0:
                    kept.append(z)
            self.zombies = kept

        # Vehicle collision: drive into zombies to damage/kill them (they become corpses).
        try:
            if self.mount == "rv" and self.zombies:
                v = pygame.Vector2(getattr(self.rv, "vel", pygame.Vector2(0, 0)))
                spd = float(v.length())
                if spd >= 12.0:
                    vrect = self._rv_collider_rect_at()
                    hitrect = vrect.inflate(-max(0, int(vrect.w // 4)), -max(0, int(vrect.h // 4)))
                    if hitrect.w <= 0 or hitrect.h <= 0:
                        hitrect = vrect
                    dir_vec = v.normalize() if v.length_squared() > 0.001 else pygame.Vector2(1, 0)
                    hit_cd = float(getattr(self, "_ZOMBIE_VEHICLE_HIT_CD_S", 0.18))
                    for z in self.zombies:
                        if int(getattr(z, "hp", 0)) <= 0:
                            continue
                        if float(getattr(z, "vehicle_hit_left", 0.0)) > 0.0:
                            continue
                        if hitrect.colliderect(z.rect()):
                            z.vehicle_hit_left = float(hit_cd)
                            dmg = int(clamp(spd * 0.45, 10.0, 120.0))
                            z.hp = int(z.hp) - int(dmg)
                            if int(z.hp) <= 0:
                                self._kill_zombie(z, impact_dir=v)
                                try:
                                    self._push_corpse_off_vehicle(z, vehicle_rect=vrect, dir_vec=dir_vec)
                                except Exception:
                                    pass
                            else:
                                z.stagger_left = max(float(getattr(z, "stagger_left", 0.0)), 0.22)
                                z.stagger_vel = pygame.Vector2(dir_vec) * min(260.0, spd * 1.35)
                                self._spawn_hit_fx(pygame.Vector2(z.pos), dir=dir_vec)
        except Exception:
            pass

        cap = max(0, int(getattr(self, "zombie_cap", 8)))
        if cap <= 0:
            return

        alive_n = 0
        for z in self.zombies:
            if int(getattr(z, "hp", 0)) > 0:
                alive_n += 1

        self.spawn_left -= dt
        if suppress_gather:
            # High floors shouldn't endlessly pull/spawn hordes at the building base.
            self.spawn_left = max(float(self.spawn_left), 3.0)
        elif self.spawn_left <= 0.0 and int(alive_n) < int(cap):
            tx = int(math.floor(target.x / self.TILE_SIZE))
            ty = int(math.floor(target.y / self.TILE_SIZE))
            chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
            in_town = chunk.town_kind is not None
            self.spawn_left = 6.5 if in_town else 10.0
            spawn_n = 1
            for _ in range(spawn_n):
                self._spawn_one_zombie(target, in_town=in_town)
                # Re-count alive zombies so corpses don't block spawns.
                alive_n = 0
                for zz in self.zombies:
                    if int(getattr(zz, "hp", 0)) > 0:
                        alive_n += 1

        if getattr(self, "zombie_frozen", False):
            for z in self.zombies:
                z.vel.update(0, 0)
            return

        for z in self.zombies:
            if int(getattr(z, "hp", 0)) <= 0:
                continue
            kind = str(getattr(z, "kind", "walker"))
            mdef = self._MONSTER_DEFS.get(kind, self._MONSTER_DEFS["walker"])

            z.attack_left = max(0.0, float(getattr(z, "attack_left", 0.0)) - dt)
            z.scream_left = max(0.0, float(getattr(z, "scream_left", 0.0)) - dt)
            z.wander_left = max(0.0, float(getattr(z, "wander_left", 0.0)) - dt)
            z.stagger_left = max(0.0, float(getattr(z, "stagger_left", 0.0)) - dt)

            if float(z.stagger_left) > 0.0:
                z.pos = self._move_box(z.pos, z.stagger_vel, dt, w=z.w, h=z.h)
                z.stagger_vel *= 0.86
                z.anim = float(z.anim) + dt * 10.0
                continue

            to_p = target - z.pos
            d2 = float(to_p.length_squared())

            sense = float(mdef.sense)
            # Vehicles are loud: pull monsters from farther away (even if RV is "safe").
            if (not suppress_gather) and self.mount == "rv":
                sense += 80.0 + min(120.0, abs(float(getattr(self.rv, "speed", 0.0))) * 1.1)
            if (not suppress_gather) and getattr(self, "noise_left", 0.0) > 0.0:
                sense = max(sense, float(getattr(self, "noise_radius", 0.0)))

            alerted = (not suppress_gather) and d2 <= (sense * sense)
            if alerted:
                if kind == "screamer" and float(z.scream_left) <= 0.0 and d2 <= float(mdef.scream_radius) ** 2:
                    z.scream_left = float(mdef.scream_cd)
                    if int(alive_n) < int(cap):
                        for _ in range(int(mdef.scream_spawn)):
                            if int(alive_n) >= int(cap):
                                break
                            self._spawn_one_zombie(target, in_town=True)
                            before = int(alive_n)
                            alive_n = 0
                            for zz in self.zombies:
                                if int(getattr(zz, "hp", 0)) > 0:
                                    alive_n += 1
                            if int(alive_n) <= int(before):
                                break
                    self._set_hint("", seconds=1.3)

                if d2 > 1.0:
                    dir_vec = to_p.normalize()
                    want = dir_vec * float(z.speed)
                    accel = 5.5 if kind == "runner" else 3.6 if kind == "screamer" else 2.8
                    a = float(clamp(1.0 - math.exp(-dt * float(accel)), 0.0, 1.0))
                    z.vel = z.vel.lerp(want, a)
                else:
                    z.vel.update(0, 0)
            else:
                if float(z.wander_left) <= 0.0 or z.wander_dir.length_squared() <= 0.001:
                    ang = random.random() * math.tau
                    z.wander_dir = pygame.Vector2(math.cos(ang), math.sin(ang))
                    z.wander_left = random.uniform(0.6, 1.8)
                want = pygame.Vector2(z.wander_dir) * float(mdef.roam_speed)
                accel = 3.0 if kind == "runner" else 2.2 if kind == "screamer" else 1.8
                a = float(clamp(1.0 - math.exp(-dt * float(accel)), 0.0, 1.0))
                z.vel = z.vel.lerp(want, a)

            if z.vel.length_squared() > 0.1:
                ztx = int(math.floor(z.pos.x / self.TILE_SIZE))
                zty = int(math.floor(z.pos.y / self.TILE_SIZE))
                z_under = self.world.get_tile(ztx, zty)
                z.vel *= self._tile_slow(z_under) * self._weather_move_mult()
                if abs(float(z.vel.y)) >= abs(float(z.vel.x)):
                    z.dir = "down" if float(z.vel.y) >= 0 else "up"
                else:
                    z.dir = "right" if float(z.vel.x) >= 0 else "left"
                anim_base = 1.8 if kind == "walker" else 2.4 if kind == "screamer" else 3.4
                z.anim = float(z.anim) + dt * float(anim_base) * (z.vel.length() / max(1.0, float(z.speed)))
            else:
                z.anim = float(z.anim) * 0.88

            z.pos = self._move_box(z.pos, z.vel, dt, w=z.w, h=z.h)       

            # Player/zombie collision volume (prevent overlap).
            if self.mount != "rv":
                try:
                    prect = self.player.rect_at()
                    zrect = z.rect()
                    if zrect.colliderect(prect):
                        dx = float(zrect.centerx - prect.centerx)
                        dy = float(zrect.centery - prect.centery)
                        overlap_x = (float(zrect.w) + float(prect.w)) / 2.0 - abs(dx)
                        overlap_y = (float(zrect.h) + float(prect.h)) / 2.0 - abs(dy)
                        if overlap_x > 0.0 and overlap_y > 0.0:
                            sign_x = 1.0 if dx >= 0.0 else -1.0
                            sign_y = 1.0 if dy >= 0.0 else -1.0
                            if dx == 0.0:
                                sign_x = 1.0 if ((int(zrect.centerx) + int(zrect.centery)) & 1) else -1.0
                            if dy == 0.0:
                                sign_y = 1.0 if ((int(zrect.centerx) - int(zrect.centery)) & 1) else -1.0
                            move_x = int(sign_x * math.ceil(overlap_x))
                            move_y = int(sign_y * math.ceil(overlap_y))
                            # Prefer the smaller axis push, but don't shove into walls.
                            candidates: list[tuple[int, int]] = []
                            if float(overlap_x) <= float(overlap_y):
                                candidates = [(int(move_x), 0), (0, int(move_y))]
                            else:
                                candidates = [(0, int(move_y)), (int(move_x), 0)]
                            moved = False
                            for mx, my in candidates:
                                if mx == 0 and my == 0:
                                    continue
                                test = zrect.move(int(mx), int(my))
                                if not self._collide_rect_world(test):
                                    zrect = test
                                    moved = True
                                    break
                            if not moved and candidates:
                                zrect = zrect.move(int(candidates[0][0]), int(candidates[0][1]))
                            z.pos.update(float(zrect.centerx), float(zrect.centery))
                except Exception:
                    pass

            if self.mount != "rv" and float(z.attack_left) <= 0.0 and (z.pos - self.player.pos).length_squared() <= float(mdef.attack_range) ** 2:       
                z.attack_left = float(mdef.attack_cd)
                self.player.hp = max(0, int(self.player.hp) - int(mdef.dmg))
                self.player.morale = float(clamp(self.player.morale - (2.0 + float(mdef.dmg) * 0.35), 0.0, 100.0))

                # Chance to inflict a bleeding wound (scratch/bite).
                try:
                    chance = float(clamp(0.12 + 0.02 * float(mdef.dmg), 0.08, 0.55))
                    if random.random() < chance:
                        dx = float(self.player.pos.x - z.pos.x)
                        dy = float(self.player.pos.y - z.pos.y)
                        side_left = dx > 0.0
                        part = "torso"
                        if abs(dy) > abs(dx) and dy > 0.0 and random.random() < 0.18:
                            part = "head"
                        elif random.random() < 0.38:
                            part = "torso"
                        else:
                            if abs(dx) >= abs(dy):
                                part = "left_arm" if side_left else "right_arm"
                                if random.random() < 0.35:
                                    part = "left_leg" if side_left else "right_leg"
                            else:
                                part = "left_leg" if side_left else "right_leg"
                                if random.random() < 0.35:
                                    part = "left_arm" if side_left else "right_arm"
                        rate = float(clamp(0.18 + 0.01 * float(mdef.dmg), 0.12, 0.60))
                        self._inflict_wound(part, rate=rate)
                except Exception:
                    pass

    def _season_index(self) -> int:
        day = int(self.world_time_s / max(1e-6, self.DAY_LENGTH_S)) + 1
        return ((day - 1) // max(1, int(self.SEASON_LENGTH_DAYS))) % len(self.SEASONS)

    def _tint(self, c: tuple[int, int, int], *, add: tuple[int, int, int] = (0, 0, 0)) -> tuple[int, int, int]:
        r = int(clamp(c[0] + add[0], 0, 255))
        g = int(clamp(c[1] + add[1], 0, 255))
        b = int(clamp(c[2] + add[2], 0, 255))
        return r, g, b

    @staticmethod
    def _pixel_outline_rect(
        surface: pygame.Surface,
        rect: pygame.Rect,
        fill_color: tuple[int, int, int] | tuple[int, int, int, int],
        outline_color: tuple[int, int, int] = (10, 10, 12),
    ) -> None:
        """Draw a filled rectangle with 1-pixel outline (no border_radius, pure pixel style)."""
        # Draw outline first (1 pixel larger on each side).
        outline_rect = rect.inflate(2, 2)
        pygame.draw.rect(surface, outline_color, outline_rect)
        # Draw fill on top.
        pygame.draw.rect(surface, fill_color, rect)

    @staticmethod
    def _smoothstep(edge0: float, edge1: float, x: float) -> float:
        if edge0 == edge1:
            return 0.0
        t = float(clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0))
        return t * t * (3.0 - 2.0 * t)

    def _time_of_day(self) -> float:
        return (float(self.world_time_s) % float(self.DAY_LENGTH_S)) / max(
            1e-6,
            float(self.DAY_LENGTH_S),
        )

    def _daylight_amount(self) -> tuple[float, float]:
        tday = float(self._time_of_day())
        dawn_start, dawn_end = 0.22, 0.28
        dusk_start, dusk_end = 0.72, 0.78
        # Keep nights readable (roughly like ~20:00) so the world doesn't become
        # pitch-black without lamps. Lamps/streetlights still matter for detail.
        night_ambient = 0.28

        if tday < dawn_start or tday >= dusk_end:
            return float(night_ambient), tday
        if tday < dawn_end:
            t = float(self._smoothstep(dawn_start, dawn_end, tday))
            return float(float(night_ambient) + (1.0 - float(night_ambient)) * t), tday
        if tday < dusk_start:
            return 1.0, tday
        t = float(self._smoothstep(dusk_start, dusk_end, tday))
        return float(1.0 - (1.0 - float(night_ambient)) * t), tday

    def _make_day_night_overlay_surface(self, *, in_rv: bool) -> pygame.Surface | None:
        daylight, tday = self._daylight_amount()
        # Night should be dark, but not total blackout (so it's playable without
        # staring only at light halos). Interiors get a lighter overlay.
        max_alpha = 230 if not in_rv else 80
        a = int(round(float(max_alpha) * (1.0 - float(daylight))))
        if a <= 0:
            return None

        # With a night ambient floor, daylight is never 0.0, so pick colors by time.
        if 0.22 <= tday < 0.28:
            col = (36, 26, 64)  # dawn
        elif 0.72 <= tday < 0.78:
            col = (64, 34, 26)  # dusk
        else:
            col = (8, 10, 18) if float(daylight) < 0.95 else (12, 14, 30)  # night / (unused) day

        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((int(col[0]), int(col[1]), int(col[2]), int(a)))
        return overlay

    def _draw_day_night_overlay(self, surface: pygame.Surface, *, in_rv: bool) -> None:
        overlay = self._make_day_night_overlay_surface(in_rv=in_rv)
        if overlay is None:
            return
        try:
            self._carve_flashlight_from_night_overlay(overlay)
        except Exception:
            pass
        surface.blit(overlay, (0, 0))

    def _blit_screen(self, surface: pygame.Surface, src: pygame.Surface, *, pos: tuple[int, int], alpha: int = 255) -> None:
        alpha = int(clamp(int(alpha), 0, 255))
        if alpha <= 0:
            return

        src_rect = src.get_rect(topleft=(int(pos[0]), int(pos[1])))
        clip = src_rect.clip(surface.get_clip())
        if clip.w <= 0 or clip.h <= 0:
            return
        dx = int(clip.x - src_rect.x)
        dy = int(clip.y - src_rect.y)
        src_sub = src.subsurface(pygame.Rect(int(dx), int(dy), int(clip.w), int(clip.h)))
        dst_sub = surface.subsurface(clip)

        cache = getattr(self, "_screen_white_cache", {})
        white = cache.get((int(clip.w), int(clip.h)))
        if white is None:
            white = pygame.Surface((int(clip.w), int(clip.h))).convert()
            white.fill((255, 255, 255))
            cache[(int(clip.w), int(clip.h))] = white
            self._screen_white_cache = cache

        inv_dst = white.copy()
        inv_dst.blit(dst_sub, (0, 0), special_flags=pygame.BLEND_RGB_SUB)
        inv_src = white.copy()
        inv_src.blit(src_sub, (0, 0), special_flags=pygame.BLEND_RGB_SUB)
        inv_dst.blit(inv_src, (0, 0), special_flags=pygame.BLEND_RGB_MULT)

        out = white.copy()
        out.blit(inv_dst, (0, 0), special_flags=pygame.BLEND_RGB_SUB)
        if alpha < 255:
            out.set_alpha(int(alpha))
        surface.blit(out, clip.topleft)

    def _radial_gray_gradient(self, radius_px: int) -> pygame.Surface:
        radius_px = int(radius_px)
        radius_px = max(1, radius_px)
        cache: dict[int, pygame.Surface] = getattr(self, "_radial_gray_grad_cache", {})
        cached = cache.get(int(radius_px))
        if isinstance(cached, pygame.Surface):
            return cached

        size = int(radius_px) * 2 + 1
        g = pygame.Surface((int(size), int(size))).convert()
        g.fill((0, 0, 0))
        rings = int(clamp(int(round(float(radius_px) * 0.65)), 24, 120))
        for i in range(int(rings)):
            t = float(i) / float(max(1, int(rings) - 1))
            r = int(round(float(radius_px) * (1.0 - t)))
            if r <= 0:
                continue
            v = int(round(255.0 * ((1.0 - t) ** 2)))
            v = int(clamp(int(v), 0, 255))
            if v <= 0:
                continue
            pygame.draw.circle(g, (int(v), int(v), int(v)), (int(radius_px), int(radius_px)), int(r))

        cache[int(radius_px)] = g
        self._radial_gray_grad_cache = cache
        return g

    def _carve_world_lamps_from_night_overlay(
        self,
        overlay: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
    ) -> None:
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return

        try:
            night_a = int(overlay.get_at((0, 0))[3])
        except Exception:
            night_a = int(overlay.get_alpha() or 0)
        if int(night_a) <= 0:
            return

        ts = int(self.TILE_SIZE)
        if ts <= 0:
            return

        home_on = bool(getattr(self, "home_light_on", True))

        # World lamps: home lamps (toggleable) + streetlamps (always on).
        lamps: list[tuple[int, int, bool]] = []  # (tx, ty, restrict_to_home)
        seen_lamps: set[tuple[int, int]] = set()
        for ty in range(int(start_ty), int(end_ty) + 1):
            for tx in range(int(start_tx), int(end_tx) + 1):
                if int(self.world.peek_tile(int(tx), int(ty))) != int(self.T_LAMP):
                    continue
                restrict_home = bool(self._tile_in_home_world(int(tx), int(ty)))
                if restrict_home and not home_on:
                    continue
                key = (int(tx), int(ty))
                if key in seen_lamps:
                    continue
                seen_lamps.add(key)
                lamps.append((int(tx), int(ty), bool(restrict_home)))

        # Streetlamps are props, not tiles (so sidewalks remain sidewalks).
        rv_hide: tuple[int, int, int, int] | None = None
        if bool(getattr(self, "rv_world_interior", False)):
            key = getattr(self, "_rv_world_int_active_key", None)
            if isinstance(key, tuple) and len(key) == 4:
                try:
                    rv_hide = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
                except Exception:
                    rv_hide = None

        start_cx = int(start_tx) // int(self.CHUNK_SIZE)
        end_cx = int(end_tx) // int(self.CHUNK_SIZE)
        start_cy = int(start_ty) // int(self.CHUNK_SIZE)
        end_cy = int(end_ty) // int(self.CHUNK_SIZE)
        for cy in range(int(start_cy), int(end_cy) + 1):
            for cx in range(int(start_cx), int(end_cx) + 1):
                chunk = self.world.peek_chunk(int(cx), int(cy))
                if chunk is None:
                    continue
                for pr in getattr(chunk, "props", []):
                    if str(getattr(pr, "prop_id", "")) != "streetlamp":
                        continue
                    px = float(getattr(getattr(pr, "pos", pygame.Vector2(0, 0)), "x", 0.0))
                    py = float(getattr(getattr(pr, "pos", pygame.Vector2(0, 0)), "y", 0.0))
                    tx = int(math.floor(px / float(ts)))
                    ty = int(math.floor(py / float(ts)))
                    if rv_hide is not None:
                        rx0, ry0, rw, rh = rv_hide
                        if int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh):
                            continue
                    if tx < int(start_tx) or tx > int(end_tx) or ty < int(start_ty) or ty > int(end_ty):
                        continue
                    key = (int(tx), int(ty))
                    if key in seen_lamps:
                        continue
                    seen_lamps.add(key)
                    lamps.append((int(tx), int(ty), False))
        if not lamps:
            return

        cfg = getattr(self.app, "config", None)
        radius_tiles = int(getattr(cfg, "lamp_world_radius_tiles", 3)) if cfg is not None else 3
        radius_tiles = int(clamp(int(radius_tiles), 2, 18))
        intensity = float(getattr(cfg, "lamp_world_intensity", 1.0)) if cfg is not None else 1.0
        intensity = float(clamp(float(intensity), 0.0, 3.0))
        # Opacity controls halo only; brightness of the lit area is intensity-based.
        if intensity <= 0.01:
            return

        radius_px = int(max(int(ts) * 2, int(ts) * int(radius_tiles)))
        max_sub_alpha = int(clamp(int(round(float(night_a) * 1.0 * float(intensity))), 0, int(night_a)))
        if max_sub_alpha <= 0:
            return

        hole_key = (int(ts), int(radius_px), int(max_sub_alpha))
        hole = getattr(self, "_lamp_hole_cache", {}).get(hole_key) if hasattr(self, "_lamp_hole_cache") else None
        if hole is None:
            g = pygame.Surface((radius_px * 2 + 1, radius_px * 2 + 1), pygame.SRCALPHA)
            rings = 18
            for i in range(rings):
                t = float(i) / float(max(1, rings - 1))
                r = int(round(float(radius_px) * (1.0 - t)))
                if r <= 0:
                    continue
                a = int(round(float(max_sub_alpha) * ((1.0 - t) ** 2)))
                a = int(clamp(int(a), 0, 255))
                if a <= 0:
                    continue
                pygame.draw.circle(g, (0, 0, 0, int(a)), (radius_px, radius_px), int(r))
            cache = getattr(self, "_lamp_hole_cache", {})
            cache[hole_key] = g
            self._lamp_hole_cache = cache
            hole = g

        door_blocks = {
            int(self.T_DOOR),
            int(self.T_DOOR_HOME),
            int(self.T_DOOR_LOCKED),
            int(self.T_DOOR_HOME_LOCKED),
        }

        for lx, ly, restrict_home in lamps:
            base_rect = self._world_tile_screen_rect(int(lx), int(ly), int(cam_x), int(cam_y))
            cx, cy = int(base_rect.centerx), int(base_rect.centery)
            ox = int(cx - radius_px)
            oy = int(cy - radius_px)

            # Streetlamps (restrict_home=False) use simple circle without wall occlusion for performance.
            if not bool(restrict_home):
                overlay.blit(hole, (int(ox), int(oy)), special_flags=pygame.BLEND_RGBA_SUB)
                continue

            # Home lamps use BFS for wall occlusion.
            seen: set[tuple[int, int]] = set()
            lit: list[tuple[int, int]] = []
            stack = [(int(lx), int(ly))]
            r2 = int(radius_tiles) * int(radius_tiles)
            while stack and len(lit) < 1600:
                x, y = stack.pop()
                x = int(x)
                y = int(y)
                if (x, y) in seen:
                    continue
                seen.add((x, y))
                dx = int(x - int(lx))
                dy = int(y - int(ly))
                if int(dx * dx + dy * dy) > int(r2):
                    continue
                if not self._tile_in_home_world(int(x), int(y)):
                    continue
                tid = int(self.world.peek_tile(int(x), int(y)))
                if int(tid) in door_blocks:
                    continue
                if bool(self._tile_solid(int(tid))):
                    continue
                lit.append((int(x), int(y)))
                stack.extend(((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)))

            mask = pygame.Surface(hole.get_size(), pygame.SRCALPHA)
            mask.fill((0, 0, 0, 0))
            mask_bounds = mask.get_rect()
            for tx, ty in lit:
                r = self._world_tile_screen_rect(int(tx), int(ty), int(cam_x), int(cam_y))
                lr = r.move(-int(ox), -int(oy))
                lr = lr.clip(mask_bounds)
                if lr.w > 0 and lr.h > 0:
                    mask.fill((255, 255, 255, 255), lr)

            tmp = hole.copy()
            tmp.blit(mask, (0, 0), special_flags=pygame.BLEND_RGBA_MULT)
            overlay.blit(tmp, (int(ox), int(oy)), special_flags=pygame.BLEND_RGBA_SUB)

    def _carve_vehicle_headlights_from_night_overlay(
        self,
        overlay: pygame.Surface,
        cam_x: int,
        cam_y: int,
    ) -> None:
        if self.mount != "rv":
            return
        if bool(getattr(self, "rv_world_interior", False)):
            return
        if not bool(getattr(self, "rv_headlights_on", True)):
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return

        try:
            night_a = int(overlay.get_at((0, 0))[3])
        except Exception:
            night_a = int(overlay.get_alpha() or 0)
        if int(night_a) <= 0:
            return

        daylight, _tday = self._daylight_amount()
        if float(daylight) >= 0.92:
            return

        max_sub_alpha = int(clamp(int(round(float(night_a) * 1.25)), 0, int(night_a)))
        if max_sub_alpha <= 0:
            return

        forward = pygame.Vector2(math.cos(float(self.rv.heading)), math.sin(float(self.rv.heading)))
        if forward.length_squared() <= 0.001:
            forward = pygame.Vector2(1, 0)
        forward = forward.normalize()
        side = forward.rotate(90)

        rv_w = float(getattr(self.rv, "w", 80.0))
        rv_h = float(getattr(self.rv, "h", 40.0))
        front_off = max(10.0, rv_w * 0.5 - 10.0)
        head_sep = float(clamp(rv_h * 0.18, 8.0, 18.0))

        length = int(clamp(int(round(max(120.0, rv_w * 1.20))), 90, 220))
        base_half_ang = 26.0

        def carve_cone(origin_world: pygame.Vector2) -> None:
            sx = int(round(float(origin_world.x) - float(cam_x)))
            sy = int(round(float(origin_world.y) - float(cam_y)))

            left_dir = forward.rotate(-base_half_ang)
            right_dir = forward.rotate(base_half_ang)
            p1 = pygame.Vector2(sx, sy) + left_dir * float(length)
            p2 = pygame.Vector2(sx, sy) + right_dir * float(length)
            pad = 10
            minx = int(math.floor(min(float(sx), float(p1.x), float(p2.x)) - pad))
            miny = int(math.floor(min(float(sy), float(p1.y), float(p2.y)) - pad))
            maxx = int(math.ceil(max(float(sx), float(p1.x), float(p2.x)) + pad))
            maxy = int(math.ceil(max(float(sy), float(p1.y), float(p2.y)) + pad))

            bounds = overlay.get_rect()
            if maxx < bounds.left or maxy < bounds.top or minx > bounds.right or miny > bounds.bottom:
                return
            minx = int(clamp(minx, 0, bounds.w - 1))
            miny = int(clamp(miny, 0, bounds.h - 1))
            maxx = int(clamp(maxx, 0, bounds.w - 1))
            maxy = int(clamp(maxy, 0, bounds.h - 1))
            bw = int(maxx - minx + 1)
            bh = int(maxy - miny + 1)
            if bw <= 1 or bh <= 1:
                return

            beam = pygame.Surface((bw, bh), pygame.SRCALPHA)
            ox = sx - minx
            oy = sy - miny

            # Strong at the center, fades forward.
            steps = 8
            for i in range(steps):
                t = float(i) / float(max(1, steps - 1))
                a = int(round(float(max_sub_alpha) * ((1.0 - t) ** 2)))
                if a <= 0:
                    continue
                l = float(length) * (0.35 + 0.65 * t)
                ang = float(base_half_ang) * (0.55 + 0.45 * t)
                ld = forward.rotate(-ang)
                rd = forward.rotate(ang)
                q1 = pygame.Vector2(float(ox), float(oy)) + ld * l
                q2 = pygame.Vector2(float(ox), float(oy)) + rd * l
                pts = [(float(ox), float(oy)), (float(q1.x), float(q1.y)), (float(q2.x), float(q2.y))]
                pygame.draw.polygon(beam, (0, 0, 0, int(a)), pts)

            pygame.draw.circle(beam, (0, 0, 0, int(max_sub_alpha)), (int(ox), int(oy)), 6)
            overlay.blit(beam, (int(minx), int(miny)), special_flags=pygame.BLEND_RGBA_SUB)

        base = pygame.Vector2(self.rv.pos) + forward * float(front_off)
        carve_cone(base + side * head_sep)
        carve_cone(base - side * head_sep)

    def _carve_flashlight_from_night_overlay(self, overlay: pygame.Surface) -> None:
        if not bool(getattr(self, "flashlight_on", False)):
            return

        held = getattr(self, "held_item", None)
        if not isinstance(held, HardcoreSurvivalState._ItemStack) or str(getattr(held, "item_id", "")) != "flashlight":
            self.flashlight_on = False
            return

        charge = float(self._flashlight_charge())
        if charge <= 0.01:
            self.flashlight_on = False
            return

        try:
            night_a = int(overlay.get_at((0, 0))[3])
        except Exception:
            night_a = int(overlay.get_alpha() or 0)
        if int(night_a) <= 0:
            return

        r = getattr(self, "_last_player_screen_rect", None)
        if not isinstance(r, pygame.Rect):
            return

        sx = int(r.centerx)
        sy = int(r.centery + 2)

        # Aim direction (screen-space so it works in interiors too).
        aim: pygame.Vector2 | None = None
        try:
            m = self.app.screen_to_internal(pygame.mouse.get_pos())
        except Exception:
            m = None
        if m is not None:
            v = pygame.Vector2(float(m[0]) - float(sx), float(m[1]) - float(sy))
            if v.length_squared() > 0.001:
                aim = v.normalize()
        if aim is None:
            face = None
            if bool(getattr(self, "house_interior", False)):
                face = getattr(self, "house_int_facing", None)
            elif bool(getattr(self, "sch_interior", False)):
                face = getattr(self, "sch_int_facing", None)
            elif bool(getattr(self, "hr_interior", False)):
                face = getattr(self, "hr_int_facing", None)
            if not isinstance(face, pygame.Vector2):
                face = getattr(getattr(self, "player", None), "facing", pygame.Vector2(1, 0))
            aim = pygame.Vector2(face)
            if aim.length_squared() <= 0.001:
                aim = pygame.Vector2(1, 0)
            aim = aim.normalize()

        max_sub_alpha = int(clamp(int(round(float(night_a) * 1.25 * float(charge))), 0, int(night_a)))
        if max_sub_alpha <= 0:
            return

        length = int(clamp(int(round(160.0 + 20.0 * float(charge))), 110, 200))
        base_half_ang = 28.0

        left_dir = aim.rotate(-base_half_ang)
        right_dir = aim.rotate(base_half_ang)
        p1 = pygame.Vector2(float(sx), float(sy)) + left_dir * float(length)
        p2 = pygame.Vector2(float(sx), float(sy)) + right_dir * float(length)

        pad = 10
        minx = int(math.floor(min(float(sx), float(p1.x), float(p2.x)) - pad))
        miny = int(math.floor(min(float(sy), float(p1.y), float(p2.y)) - pad))
        maxx = int(math.ceil(max(float(sx), float(p1.x), float(p2.x)) + pad))
        maxy = int(math.ceil(max(float(sy), float(p1.y), float(p2.y)) + pad))

        bounds = overlay.get_rect()
        if maxx < bounds.left or maxy < bounds.top or minx > bounds.right or miny > bounds.bottom:
            return
        minx = int(clamp(minx, 0, bounds.w - 1))
        miny = int(clamp(miny, 0, bounds.h - 1))
        maxx = int(clamp(maxx, 0, bounds.w - 1))
        maxy = int(clamp(maxy, 0, bounds.h - 1))
        bw = int(maxx - minx + 1)
        bh = int(maxy - miny + 1)
        if bw <= 1 or bh <= 1:
            return

        beam = pygame.Surface((bw, bh), pygame.SRCALPHA)
        ox = sx - minx
        oy = sy - miny

        # Strong at the center, fades forward.
        steps = 8
        for i in range(steps):
            t = float(i) / float(max(1, steps - 1))
            a = int(round(float(max_sub_alpha) * ((1.0 - t) ** 2)))
            if a <= 0:
                continue
            l = float(length) * (0.30 + 0.70 * t)
            ang = float(base_half_ang) * (0.60 + 0.40 * t)
            ld = aim.rotate(-ang)
            rd = aim.rotate(ang)
            q1 = pygame.Vector2(float(ox), float(oy)) + ld * l
            q2 = pygame.Vector2(float(ox), float(oy)) + rd * l
            pts = [(float(ox), float(oy)), (float(q1.x), float(q1.y)), (float(q2.x), float(q2.y))]
            pygame.draw.polygon(beam, (0, 0, 0, int(a)), pts)

        pygame.draw.circle(beam, (0, 0, 0, int(max_sub_alpha)), (int(ox), int(oy)), 7)
        overlay.blit(beam, (int(minx), int(miny)), special_flags=pygame.BLEND_RGBA_SUB)

    def _draw_world_lighting(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
    ) -> None:
        overlay = self._make_day_night_overlay_surface(in_rv=False)
        if overlay is not None:
            try:
                self._carve_world_lamps_from_night_overlay(overlay, cam_x, cam_y, start_tx, end_tx, start_ty, end_ty)
                self._carve_vehicle_headlights_from_night_overlay(overlay, cam_x, cam_y)
                self._carve_flashlight_from_night_overlay(overlay)
            except Exception:
                pass
            surface.blit(overlay, (0, 0))
        # Soft halo (screen blend) is optional and should never wash out detail.
        self._draw_world_lamp_glows(surface, cam_x, cam_y, start_tx, end_tx, start_ty, end_ty)

    def _draw_world_lamp_glows(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
    ) -> None:
        if bool(getattr(self, "hr_interior", False)) or bool(getattr(self, "house_interior", False)) or bool(getattr(self, "sch_interior", False)):
            return

        daylight, _tday = self._daylight_amount()

        ts = int(self.TILE_SIZE)
        if ts <= 0:
            return

        home_on = bool(getattr(self, "home_light_on", True))

        # World lamps: home lamps (toggleable) + streetlamps (always on).
        lamps: list[tuple[int, int, bool]] = []  # (tx, ty, restrict_to_home)
        seen_lamps: set[tuple[int, int]] = set()
        for ty in range(int(start_ty), int(end_ty) + 1):
            for tx in range(int(start_tx), int(end_tx) + 1):
                if int(self.world.peek_tile(int(tx), int(ty))) != int(self.T_LAMP):
                    continue
                restrict_home = bool(self._tile_in_home_world(int(tx), int(ty)))
                if restrict_home and not home_on:
                    continue
                key = (int(tx), int(ty))
                if key in seen_lamps:
                    continue
                seen_lamps.add(key)
                lamps.append((int(tx), int(ty), bool(restrict_home)))

        # Streetlamps are props, not tiles (so sidewalks remain sidewalks).
        rv_hide: tuple[int, int, int, int] | None = None
        if bool(getattr(self, "rv_world_interior", False)):
            key = getattr(self, "_rv_world_int_active_key", None)
            if isinstance(key, tuple) and len(key) == 4:
                try:
                    rv_hide = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
                except Exception:
                    rv_hide = None

        start_cx = int(start_tx) // int(self.CHUNK_SIZE)
        end_cx = int(end_tx) // int(self.CHUNK_SIZE)
        start_cy = int(start_ty) // int(self.CHUNK_SIZE)
        end_cy = int(end_ty) // int(self.CHUNK_SIZE)
        for cy in range(int(start_cy), int(end_cy) + 1):
            for cx in range(int(start_cx), int(end_cx) + 1):
                chunk = self.world.peek_chunk(int(cx), int(cy))
                if chunk is None:
                    continue
                for pr in getattr(chunk, "props", []):
                    if str(getattr(pr, "prop_id", "")) != "streetlamp":
                        continue
                    px = float(getattr(getattr(pr, "pos", pygame.Vector2(0, 0)), "x", 0.0))
                    py = float(getattr(getattr(pr, "pos", pygame.Vector2(0, 0)), "y", 0.0))
                    tx = int(math.floor(px / float(ts)))
                    ty = int(math.floor(py / float(ts)))
                    if rv_hide is not None:
                        rx0, ry0, rw, rh = rv_hide
                        if int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh):
                            continue
                    if tx < int(start_tx) or tx > int(end_tx) or ty < int(start_ty) or ty > int(end_ty):
                        continue
                    key = (int(tx), int(ty))
                    if key in seen_lamps:
                        continue
                    seen_lamps.add(key)
                    lamps.append((int(tx), int(ty), False))
        if not lamps:
            return

        cfg = getattr(self.app, "config", None)
        radius_tiles = int(getattr(cfg, "lamp_world_radius_tiles", 3)) if cfg is not None else 3
        radius_tiles = int(clamp(int(radius_tiles), 2, 18))
        intensity = float(getattr(cfg, "lamp_world_intensity", 1.0)) if cfg is not None else 1.0
        intensity = float(clamp(float(intensity), 0.0, 3.0))
        radius_px = int(max(int(ts) * 2, int(ts) * int(radius_tiles)))
        halo = float(getattr(cfg, "lamp_world_halo", 0.35)) if cfg is not None else 0.35
        halo = float(clamp(float(halo), 0.0, 1.5))

        # Keep a visible (but subtle) bloom even in daytime.
        day_factor = float(clamp(0.45 + 0.55 * (1.0 - float(daylight)), 0.45, 1.0))
        halo_strength = float(halo) * float(day_factor) * float(clamp(float(intensity), 0.0, 1.0))
        halo_strength = float(clamp(float(halo_strength), 0.0, 1.0))
        halo_alpha = int(clamp(int(round(255.0 * float(halo_strength))), 0, 255))
        if halo_alpha <= 0:
            return

        # Bloom source stays the same size; transparency is applied at blit-time.
        cache: dict[int, pygame.Surface] = getattr(self, "_world_lamp_bloom_cache", {})
        glow = cache.get(int(radius_px))
        if glow is None:
            grad = self._radial_gray_gradient(int(radius_px))
            g = grad.copy()
            g.fill((90, 90, 90), special_flags=pygame.BLEND_RGB_MULT)
            g.fill((236, 222, 194), special_flags=pygame.BLEND_RGB_MULT)
            cache[int(radius_px)] = g
            self._world_lamp_bloom_cache = cache
            glow = g

        door_blocks = {
            int(self.T_DOOR),
            int(self.T_DOOR_HOME),
            int(self.T_DOOR_LOCKED),
            int(self.T_DOOR_HOME_LOCKED),
        }

        for lx, ly, restrict_home in lamps:
            base_rect = self._world_tile_screen_rect(int(lx), int(ly), int(cam_x), int(cam_y))
            cx, cy = int(base_rect.centerx), int(base_rect.centery)
            ox = int(cx - radius_px)
            oy = int(cy - radius_px)

            # Streetlamps (restrict_home=False) use simple glow without wall occlusion for performance.
            if not bool(restrict_home):
                self._blit_screen(surface, glow, pos=(int(ox), int(oy)), alpha=int(halo_alpha))
                continue

            # Home lamps use BFS for wall occlusion.
            seen: set[tuple[int, int]] = set()
            lit: list[tuple[int, int]] = []
            stack = [(int(lx), int(ly))]
            r2 = int(radius_tiles) * int(radius_tiles)
            while stack and len(lit) < 1400:
                x, y = stack.pop()
                x = int(x)
                y = int(y)
                if (x, y) in seen:
                    continue
                seen.add((x, y))
                dx = int(x - int(lx))
                dy = int(y - int(ly))
                if int(dx * dx + dy * dy) > int(r2):
                    continue
                if not self._tile_in_home_world(int(x), int(y)):
                    continue

                tid = int(self.world.peek_tile(int(x), int(y)))
                if int(tid) in door_blocks:
                    continue
                if bool(self._tile_solid(int(tid))):
                    continue
                lit.append((int(x), int(y)))
                stack.extend(((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)))

            # Build a local mask surface (white where visible tiles exist).
            mask = pygame.Surface(glow.get_size()).convert()
            mask.fill((0, 0, 0))
            mask_bounds = mask.get_rect()
            for tx, ty in lit:
                r = self._world_tile_screen_rect(int(tx), int(ty), int(cam_x), int(cam_y))
                lr = r.move(-int(ox), -int(oy))
                lr = lr.clip(mask_bounds)
                if lr.w > 0 and lr.h > 0:
                    mask.fill((255, 255, 255), lr)

            tmp = glow.copy()
            tmp.blit(mask, (0, 0), special_flags=pygame.BLEND_RGB_MULT)
            self._blit_screen(surface, tmp, pos=(int(ox), int(oy)), alpha=int(halo_alpha))

    def _season_index_for_day(self, day: int) -> int:
        return ((int(day) - 1) // max(1, int(self.SEASON_LENGTH_DAYS))) % len(self.SEASONS)

    @staticmethod
    def _pick_weighted_key(rng: random.Random, weights: dict[str, float], order: Sequence[str], default: str) -> str:
        total = 0.0
        for v in weights.values():
            total += max(0.0, float(v))
        if total <= 0.0001:
            return default
        r = rng.random() * total
        acc = 0.0
        for k in order:
            acc += max(0.0, float(weights.get(k, 0.0)))
            if r <= acc:
                return str(k)
        return default

    def _weather_for_day(self, day: int) -> tuple[str, float, float]:
        day = max(1, int(day))
        season_idx = int(self._season_index_for_day(day))
        seed = int(self._hash2_u32(day, season_idx, int(self.seed) ^ 0x2D5A61B9))
        rng = random.Random(seed)

        if season_idx == 0:  # spring
            weights = {"clear": 0.46, "cloudy": 0.30, "rain": 0.20, "storm": 0.04, "snow": 0.0}
        elif season_idx == 1:  # summer
            weights = {"clear": 0.55, "cloudy": 0.20, "rain": 0.16, "storm": 0.09, "snow": 0.0}
        elif season_idx == 2:  # autumn
            weights = {"clear": 0.38, "cloudy": 0.28, "rain": 0.22, "storm": 0.12, "snow": 0.0}
        else:  # winter
            weights = {"clear": 0.36, "cloudy": 0.30, "rain": 0.06, "storm": 0.08, "snow": 0.20}

        kind = self._pick_weighted_key(rng, weights, self.WEATHER_KINDS, "clear")
        if kind == "clear":
            intensity = 0.0
        elif kind == "cloudy":
            intensity = float(rng.uniform(0.30, 0.70))
        elif kind == "rain":
            intensity = float(rng.uniform(0.35, 0.80))
        elif kind == "storm":
            intensity = float(rng.uniform(0.75, 1.0))
        else:  # snow
            intensity = float(rng.uniform(0.35, 0.95))

        wind_scale = 14.0
        if kind in ("rain", "snow"):
            wind_scale = 28.0
        if kind == "storm":
            wind_scale = 44.0
        wind = float(rng.uniform(-1.0, 1.0) * wind_scale)
        return str(kind), float(intensity), float(wind)

    def _set_weather_targets_for_day(self, day: int) -> None:
        kind, intensity, wind = self._weather_for_day(day)
        self.weather_target_kind = str(kind)
        self.weather_target_intensity = float(clamp(float(intensity), 0.0, 1.0))
        self.weather_wind_target = float(clamp(float(wind), -60.0, 60.0))

    def _sync_weather_particles(self) -> None:
        kind = str(getattr(self, "weather_kind", "clear"))
        intensity = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))
        rng = getattr(self, "weather_rng", None) or random.Random(int(self.seed) ^ 0xA53C9F17)
        self.weather_rng = rng

        if kind in ("rain", "storm"):
            base = 70 if kind == "rain" else 110
            target = int(base + 120 * intensity)
            while len(self._rain_drops) < target:
                x = float(rng.uniform(-20.0, float(INTERNAL_W) + 20.0))
                y = float(rng.uniform(-float(INTERNAL_H), float(INTERNAL_H)))
                spd = float(rng.uniform(320.0, 620.0) * (0.65 + 0.45 * intensity))
                self._rain_drops.append([x, y, spd])
            if len(self._rain_drops) > target:
                self._rain_drops = self._rain_drops[:target]
        else:
            self._rain_drops.clear()

        if kind == "snow":
            target = int(40 + 90 * intensity)
            while len(self._snow_flakes) < target:
                x = float(rng.uniform(-10.0, float(INTERNAL_W) + 10.0))
                y = float(rng.uniform(-float(INTERNAL_H), float(INTERNAL_H)))
                spd = float(rng.uniform(18.0, 46.0) * (0.60 + 0.55 * intensity))
                drift = float(rng.uniform(-16.0, 16.0))
                self._snow_flakes.append([x, y, spd, drift])
            if len(self._snow_flakes) > target:
                self._snow_flakes = self._snow_flakes[:target]
        else:
            self._snow_flakes.clear()

    def _update_weather(self, dt: float) -> None:
        dt = float(max(0.0, dt))
        day = int(self.world_time_s / max(1e-6, float(self.DAY_LENGTH_S))) + 1
        if int(day) != int(getattr(self, "weather_day", 0)):
            self.weather_day = int(day)
            self._set_weather_targets_for_day(int(day))

        # Smooth wind.
        wind = float(getattr(self, "weather_wind", 0.0))
        wind_t = float(getattr(self, "weather_wind_target", 0.0))
        wind_step = 18.0 * dt
        if wind < wind_t:
            wind = min(wind_t, wind + wind_step)
        else:
            wind = max(wind_t, wind - wind_step)
        self.weather_wind = float(wind)

        kind = str(getattr(self, "weather_kind", "clear"))
        inten = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))
        target_kind = str(getattr(self, "weather_target_kind", kind))
        target_inten = float(clamp(float(getattr(self, "weather_target_intensity", inten)), 0.0, 1.0))

        step = dt / max(1e-6, float(self.WEATHER_TRANSITION_S))
        step = float(clamp(step, 0.0, 1.0))

        if kind != target_kind:
            inten = max(0.0, inten - step)
            if inten <= 0.02:
                kind = target_kind
        else:
            if inten < target_inten:
                inten = min(target_inten, inten + step)
            else:
                inten = max(target_inten, inten - step)

        self.weather_kind = str(kind)
        self.weather_intensity = float(inten)

        # Lightning (storm only).
        flash_left = float(getattr(self, "weather_flash_left", 0.0))
        if flash_left > 0.0:
            flash_left = max(0.0, flash_left - dt)
        elif kind == "storm" and inten > 0.55:
            rng = getattr(self, "weather_rng", None) or random.Random(int(self.seed) ^ 0xA53C9F17)
            if rng.random() < dt * (0.06 + 0.18 * inten):
                flash_left = 0.12
        self.weather_flash_left = float(flash_left)

        # Update particles positions.
        self._sync_weather_particles()
        if kind in ("rain", "storm") and self._rain_drops:
            dx = float(self.weather_wind) * 0.25
            for drop in self._rain_drops:
                drop[0] += dx * dt
                drop[1] += float(drop[2]) * dt
                if drop[1] > float(INTERNAL_H) + 16.0 or drop[0] < -40.0 or drop[0] > float(INTERNAL_W) + 40.0:
                    drop[0] = float(self.weather_rng.uniform(-20.0, float(INTERNAL_W) + 20.0))
                    drop[1] = float(self.weather_rng.uniform(-18.0, -2.0))
                    drop[2] = float(self.weather_rng.uniform(320.0, 620.0) * (0.65 + 0.45 * inten))

        if kind == "snow" and self._snow_flakes:
            dx = float(self.weather_wind) * 0.20
            for flake in self._snow_flakes:
                flake[0] += (dx + float(flake[3])) * dt
                flake[1] += float(flake[2]) * dt
                if flake[1] > float(INTERNAL_H) + 12.0:
                    flake[0] = float(self.weather_rng.uniform(-10.0, float(INTERNAL_W) + 10.0))
                    flake[1] = float(self.weather_rng.uniform(-16.0, -2.0))
                if flake[0] < -16.0:
                    flake[0] = float(INTERNAL_W) + 12.0
                elif flake[0] > float(INTERNAL_W) + 16.0:
                    flake[0] = -12.0

    def _weather_move_mult(self) -> float:
        kind = str(getattr(self, "weather_kind", "clear"))
        inten = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))
        if kind == "rain":
            return float(1.0 - 0.10 * inten)
        if kind == "storm":
            return float(1.0 - 0.16 * inten)
        if kind == "snow":
            return float(1.0 - 0.12 * inten)
        return 1.0

    def _draw_weather_effects(self, surface: pygame.Surface, *, in_rv: bool) -> None:
        kind = str(getattr(self, "weather_kind", "clear"))
        inten = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))
        if inten <= 0.01:
            return
        suppress_precip = bool(getattr(self, "rv_world_interior", False))
        layer: pygame.Surface = getattr(self, "_weather_layer", None) or pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        self._weather_layer = layer
        layer.fill((0, 0, 0, 0))

        daylight, _tday = self._daylight_amount()
        drop_col = (200, 200, 216) if daylight >= 0.55 else (140, 140, 155)
        tint_mult = 0.55 if in_rv else 1.0

        rv_clips: list[pygame.Rect] | None = None

        # If the player is inside their home on the world map, don't render rain
        # through the interior area (only outside the apartment footprint).
        home_clips: list[pygame.Rect] | None = None
        if (not in_rv) and bool(getattr(self, "home_highrise_world_key", None)):
            try:
                ptx, pty = self._player_tile()
                if self._tile_in_home_world(int(ptx), int(pty)):
                    home_key = getattr(self, "home_highrise_world_key", None)
                    if isinstance(home_key, tuple) and len(home_key) == 4:
                        tx0, ty0, w, h = (int(home_key[0]), int(home_key[1]), int(home_key[2]), int(home_key[3]))
                        cam_x, cam_y_draw = getattr(
                            self,
                            "_last_cam_draw",
                            (int(getattr(self, "cam_x", 0)), int(getattr(self, "cam_y", 0))),
                        )
                        ts = int(max(1, int(getattr(self, "TILE_SIZE", self.TILE_SIZE))))

                        start_y = int(ty0)
                        shift_px = 0

                        overlay = getattr(self, "_inside_highrise_floor_overlay", None)
                        if overlay is not None:
                            try:
                                otx0, oty0, ow, oh, floor_y0, offset_px = (
                                    int(overlay[0]),
                                    int(overlay[1]),
                                    int(overlay[2]),
                                    int(overlay[3]),
                                    int(overlay[4]),
                                    int(overlay[5]),
                                )
                                if (otx0, oty0, ow, oh) == (int(tx0), int(ty0), int(w), int(h)) and int(offset_px) > 0:
                                    start_y = int(max(int(oty0), int(floor_y0) - 1))
                                    shift_px = int(offset_px)
                            except Exception:
                                pass

                        if shift_px <= 0:
                            mask = getattr(self, "_inside_highrise_draw_mask", None)
                            if mask is not None:
                                try:
                                    mtx0, mty0, mw, mh, floor_y0 = (
                                        int(mask[0]),
                                        int(mask[1]),
                                        int(mask[2]),
                                        int(mask[3]),
                                        int(mask[4]),
                                    )
                                    if (mtx0, mty0, mw, mh) == (int(tx0), int(ty0), int(w), int(h)):
                                        start_y = int(max(int(mty0), int(floor_y0) - 1))
                                except Exception:
                                    pass

                        x_px = int(tx0) * ts - int(cam_x)
                        y_px = int(start_y) * ts - int(cam_y_draw) - int(shift_px)
                        w_px = int(w) * ts
                        h_px = int((int(ty0) + int(h) - int(start_y)) * ts)
                        block = pygame.Rect(int(x_px), int(y_px), int(w_px), int(h_px))
                        screen = pygame.Rect(0, 0, INTERNAL_W, INTERNAL_H)
                        block = block.clip(screen)

                        if block.w > 0 and block.h > 0:
                            home_clips = []
                            if block.top > 0:
                                home_clips.append(pygame.Rect(0, 0, INTERNAL_W, block.top))
                            if block.bottom < INTERNAL_H:
                                home_clips.append(pygame.Rect(0, block.bottom, INTERNAL_W, INTERNAL_H - block.bottom))
                            if block.left > 0:
                                home_clips.append(pygame.Rect(0, block.top, block.left, block.h))
                            if block.right < INTERNAL_W:
                                home_clips.append(pygame.Rect(block.right, block.top, INTERNAL_W - block.right, block.h))
            except Exception:
                home_clips = None

        precip_clips = rv_clips if rv_clips is not None else home_clips

        # Base tint per weather.
        if kind == "cloudy":
            a = int(round(40.0 * inten * tint_mult))
            pygame.draw.rect(layer, (40, 44, 52, a), layer.get_rect())
        elif kind == "rain":
            a = int(round(55.0 * inten * tint_mult))
            pygame.draw.rect(layer, (32, 40, 58, a), layer.get_rect())   
        elif kind == "storm":
            a = int(round(85.0 * inten * tint_mult))
            pygame.draw.rect(layer, (22, 26, 44, a), layer.get_rect())   
        elif kind == "snow":
            a = int(round(32.0 * inten * tint_mult))
            pygame.draw.rect(layer, (180, 190, 210, a), layer.get_rect())

        # Precipitation.
        if (not suppress_precip) and kind in ("rain", "storm") and self._rain_drops:
            alpha = int(round((120 if kind == "rain" else 160) * inten))
            alpha = int(clamp(alpha, 20, 210))
            dx = int(round(clamp(float(self.weather_wind) * 0.05, -4.0, 4.0)))
            ln = 6 + int(round(4.0 * inten))
            if precip_clips:
                for cr in precip_clips:
                    layer.set_clip(cr)
                    for x, y, _spd in self._rain_drops:
                        xi = int(x)
                        yi = int(y)
                        pygame.draw.line(layer, (drop_col[0], drop_col[1], drop_col[2], alpha), (xi, yi), (xi + dx, yi + ln), 1)
                layer.set_clip(None)
            else:
                for x, y, _spd in self._rain_drops:
                    xi = int(x)
                    yi = int(y)
                    pygame.draw.line(layer, (drop_col[0], drop_col[1], drop_col[2], alpha), (xi, yi), (xi + dx, yi + ln), 1)
        elif (not suppress_precip) and kind == "snow" and self._snow_flakes:
            alpha = int(round(170.0 * inten))
            alpha = int(clamp(alpha, 30, 230))
            if precip_clips:
                for cr in precip_clips:
                    layer.set_clip(cr)
                    for x, y, _spd, _drift in self._snow_flakes:
                        xi = int(x)
                        yi = int(y)
                        if 0 <= xi < INTERNAL_W and 0 <= yi < INTERNAL_H:
                            layer.fill((235, 235, 245, alpha), pygame.Rect(xi, yi, 1, 1))
                            if (xi + yi) % 7 == 0:
                                layer.fill((235, 235, 245, max(20, alpha - 60)), pygame.Rect(xi, yi + 1, 1, 1))
                layer.set_clip(None)
            else:
                for x, y, _spd, _drift in self._snow_flakes:
                    xi = int(x)
                    yi = int(y)
                    if 0 <= xi < INTERNAL_W and 0 <= yi < INTERNAL_H:
                        layer.fill((235, 235, 245, alpha), pygame.Rect(xi, yi, 1, 1))
                        if (xi + yi) % 7 == 0:
                            layer.fill((235, 235, 245, max(20, alpha - 60)), pygame.Rect(xi, yi + 1, 1, 1))

        # Lightning flash overlay.
        flash_left = float(getattr(self, "weather_flash_left", 0.0))
        if kind == "storm" and flash_left > 0.0:
            p = float(clamp(flash_left / 0.12, 0.0, 1.0))
            a = int(round(210.0 * p))
            pygame.draw.rect(layer, (255, 255, 255, a), layer.get_rect())

        surface.blit(layer, (0, 0))

    def _tile_color(self, tile_id: int) -> tuple[int, int, int]:
        t = self._TILES.get(int(tile_id))
        base = t.color if t is not None else (255, 0, 255)
        season = self._season_index()
        if tile_id in (self.T_GRASS, self.T_FOREST):
            if season == 0:  # spring
                return self._tint(base, add=(4, 10, 4))
            if season == 1:  # summer
                return self._tint(base, add=(0, 0, 0))
            if season == 2:  # autumn
                return self._tint(base, add=(18, 8, -10))
            return self._tint(base, add=(28, 28, 28))  # winter
        if tile_id == self.T_WHEAT:
            if season == 0:  # spring (greener)
                return self._tint(base, add=(-10, 10, -14))
            if season == 1:  # summer
                return self._tint(base, add=(0, 0, 0))
            if season == 2:  # autumn (riper)
                return self._tint(base, add=(18, 6, -14))
            return self._tint(base, add=(24, 24, 24))  # winter (dull)
        if tile_id == self.T_MOUNTAIN:
            if season == 0:  # spring
                return self._tint(base, add=(6, 6, 8))
            if season == 2:  # autumn
                return self._tint(base, add=(8, 4, 2))
            if season == 3:  # winter (snowy tint)
                return self._tint(base, add=(30, 30, 40))
            return self._tint(base, add=(0, 0, 0))
        if tile_id == self.T_WATER and season == 3:
            return self._tint(base, add=(10, 10, 22))
        return base

    def _minimap_color(self, tile_id: int) -> tuple[int, int, int]:
        # Minimap / world map palette.
        # Do NOT reveal interior layouts: all building-interior tiles (walls/floors/doors/furniture)
        # are rendered as a solid "roof" blob.
        tile_id = int(tile_id)
        if tile_id in (
            int(self.T_WALL),
            int(self.T_FLOOR),
            int(self.T_DOOR),
            int(self.T_DOOR_HOME),
            int(self.T_DOOR_LOCKED),
            int(self.T_DOOR_HOME_LOCKED),
            int(self.T_DOOR_BROKEN),
            int(self.T_STAIRS_UP),
            int(self.T_STAIRS_DOWN),
            int(self.T_TABLE),
            int(self.T_SHELF),
            int(self.T_CABINET),
            int(self.T_SINK),
            int(self.T_BED),
            int(self.T_SOFA),
            int(self.T_FRIDGE),
            int(self.T_TV),
            int(self.T_CHAIR),
            int(self.T_PC),
            int(self.T_LAMP),
            int(self.T_SWITCH),
            int(self.T_STEER),
            int(self.T_TOILET),
            int(self.T_ELEVATOR),
            int(self.T_BARRICADE),
        ):
            return (72, 72, 92)
        if tile_id == int(self.T_ROAD):
            return (92, 92, 96)
        if tile_id == int(self.T_HIGHWAY):
            return (82, 82, 88)
        if tile_id == int(self.T_PAVEMENT):
            return (72, 72, 76)
        if tile_id == int(self.T_PARKING):
            return (62, 62, 70)
        if tile_id == int(self.T_COURT):
            return (126, 92, 70)
        if tile_id == int(self.T_SIDEWALK):
            return (174, 154, 104)
        if tile_id == int(self.T_BRICK):
            return (166, 112, 96)
        if tile_id == int(self.T_CONCRETE):
            return (118, 118, 128)
        if tile_id == int(self.T_SAND):
            return (194, 176, 112)
        if tile_id == int(self.T_BOARDWALK):
            return (156, 116, 68)
        if tile_id == int(self.T_MARSH):
            return (62, 98, 66)
        if tile_id == int(self.T_WHEAT):
            return (206, 186, 88)
        if tile_id == int(self.T_MOUNTAIN):
            return (118, 120, 128)
        return self._tile_color(tile_id)

    def _peek_building_at_tile(self, tx: int, ty: int) -> tuple[int, int, int, int, int, int] | None:
        tx = int(tx)
        ty = int(ty)
        cx = int(tx) // int(self.CHUNK_SIZE)
        cy = int(ty) // int(self.CHUNK_SIZE)

        best: tuple[int, int, int, int, int, int] | None = None
        best_area: int | None = None

        def scan_chunk(chunk: "_Chunk") -> None:
            nonlocal best, best_area
            for b in getattr(chunk, "buildings", []):
                btx0, bty0, bw, bh = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                if not (int(btx0) <= int(tx) < int(btx0) + int(bw) and int(bty0) <= int(ty) < int(bty0) + int(bh)):
                    continue
                area = int(bw) * int(bh)
                if best_area is None or int(area) < int(best_area):
                    roof_kind = int(b[4]) if len(b) > 4 else 0
                    floors = int(b[5]) if len(b) > 5 else 0
                    best = (int(btx0), int(bty0), int(bw), int(bh), int(roof_kind), int(floors))
                    best_area = int(area)

        # Fast path: same chunk first.
        chunk0 = self.world.peek_chunk(int(cx), int(cy))
        if chunk0 is not None:
            scan_chunk(chunk0)
            if best is not None:
                return best

        # Fallback: scan adjacent chunks to cover buildings registered in their origin chunk.
        for oy in (-1, 0, 1):
            for ox in (-1, 0, 1):
                if ox == 0 and oy == 0:
                    continue
                chunk = self.world.peek_chunk(int(cx + ox), int(cy + oy))
                if chunk is None:
                    continue
                scan_chunk(chunk)
        return best

    def _draw_world_tile(
        self,
        surface: pygame.Surface,
        rect: pygame.Rect,
        *,
        tx: int,
        ty: int,
        tile_id: int,
        apply_mask: bool = True,
    ) -> None:
        tx = int(tx)
        ty = int(ty)
        tile_id = int(tile_id)

        if apply_mask:
            # High-rise 1F: when the player is inside, hide the non-floor "back"
            # filler area (so it doesn't show up as a black block). We draw it
            # as whatever is just outside the building's north edge, making it
            # look like "nothing" was built there.
            mask = getattr(self, "_inside_highrise_draw_mask", None)
            if mask is not None:
                try:
                    tx0, ty0, w, h, floor_y0 = mask
                    if (
                        int(tx0) <= int(tx) < int(tx0) + int(w)
                        and int(ty0) <= int(ty) < int(ty0) + int(h)
                        and int(ty) < int(floor_y0) - 1
                    ):
                        outside = int(self.world.peek_tile(int(tx), int(ty0) - 1, default=int(self.T_GRASS)))
                        tile_id = outside
                except Exception:
                    pass

            # High-rise upper floors: base layer shouldn't draw the interior at
            # ground level; it's rendered as an elevated overlay layer instead.
            overlay = getattr(self, "_inside_highrise_floor_overlay", None)
            if overlay is not None:
                try:
                    tx0, ty0, w, h, floor_y0 = overlay[:5]
                    if (
                        int(tx0) <= int(tx) < int(tx0) + int(w)
                        and int(ty0) <= int(ty) < int(ty0) + int(h)
                        and int(ty) >= int(floor_y0) - 1
                    ):
                        outside = int(self.world.peek_tile(int(tx), int(ty0) - 1, default=int(self.T_GRASS)))
                        tile_id = outside
                except Exception:
                    pass

            # Cutaway-roof buildings: don't reveal interiors unless the player is
            # inside that building. Use a non-solid test so alternative floor
            # variants still work (prevents "walk in and disappear" bugs).
            if not bool(self._tile_solid(int(tile_id))):
                inside_key = getattr(self, "_inside_building_key", None)
                try:
                    hit = self._peek_building_at_tile(int(tx), int(ty))
                    if hit is not None:
                        btx0, bty0, bw, bh, roof_kind, floors = hit
                        if inside_key is not None and (int(btx0), int(bty0), int(bw), int(bh)) == tuple(inside_key):
                            pass
                        elif int(tx) in (int(btx0), int(btx0) + int(bw) - 1) or int(ty) in (int(bty0), int(bty0) + int(bh) - 1):
                            pass
                        else:
                            style, _var = self._building_roof_style_var(int(roof_kind))
                            if int(style) == 6 or (int(style) == 1 and int(floors) > 1):
                                tile_id = int(self.T_WALL)
                except Exception:
                    pass

        # When inside a building, only show the reachable connected area.
        # This keeps neighbor apartments hidden unless you can actually enter.
        try:
            inside_key = getattr(self, "_inside_building_key", None)
            visible = getattr(self, "_inside_building_visible", None)
            if isinstance(inside_key, tuple) and len(inside_key) == 4 and isinstance(visible, set) and visible:
                tx0, ty0, w, h = (int(inside_key[0]), int(inside_key[1]), int(inside_key[2]), int(inside_key[3]))
                if int(tx0) <= int(tx) < int(tx0) + int(w) and int(ty0) <= int(ty) < int(ty0) + int(h):
                    if (int(tx), int(ty)) not in visible and not bool(self._tile_solid(int(tile_id))):
                        # Never mask the outer border so doors/walls read correctly.
                        if int(tx) not in (int(tx0), int(tx0) + int(w) - 1) and int(ty) not in (int(ty0), int(ty0) + int(h) - 1):
                            tile_id = int(self.T_WALL)
        except Exception:
            pass

        # RV world-interior: draw the room border as thin lines so the RV doesn't
        # waste a full wall tile thickness on each edge.
        try:
            if bool(getattr(self, "rv_world_interior", False)):
                key = getattr(self, "_rv_world_int_active_key", None)
                if isinstance(key, tuple) and len(key) == 4:
                    rx0, ry0, rw, rh = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
                    if int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh):
                        relx = int(tx) - int(rx0)
                        rely = int(ty) - int(ry0)
                        if int(relx) in (0, int(rw) - 1) or int(rely) in (0, int(rh) - 1):
                            # Draw the actual tile on the border (e.g. steering wheel),
                            # then overlay a thin border line. Previously we forced border
                            # tiles to floor, which made border furniture invisible.
                            draw_id = int(tile_id)
                            if draw_id == int(self.T_WALL):
                                draw_id = int(self.T_FLOOR)
                            surface.fill(self._tile_color(int(draw_id)), rect)
                            line = (10, 10, 12)
                            # Border tiles used to early-return before furniture details were drawn.
                            # If the steering wheel sits on the border, draw its glyph here too.
                            if int(draw_id) == int(self.T_STEER):
                                cx, cy = int(rect.centerx), int(rect.centery)
                                outer = 4  # TILE_SIZE=10
                                wheel = (34, 34, 42)
                                wheel_hi = self._tint(wheel, add=(34, 34, 40))
                                wheel_lo = self._tint(wheel, add=(-18, -18, -18))
                                try:
                                    floor_col = self._tile_color(int(self.T_FLOOR))
                                except Exception:
                                    floor_col = (58, 56, 52)
                                pygame.draw.circle(surface, wheel, (cx, cy), int(outer))
                                pygame.draw.circle(surface, line, (cx, cy), int(outer), 1)
                                pygame.draw.circle(surface, floor_col, (cx, cy), int(max(1, outer - 2)))
                                pygame.draw.line(surface, wheel_lo, (cx, cy), (cx, rect.y + 2), 1)
                                pygame.draw.line(surface, wheel_lo, (cx, cy), (rect.x + 2, cy + 1), 1)
                                pygame.draw.line(surface, wheel_lo, (cx, cy), (rect.right - 3, cy + 1), 1)
                                hub = pygame.Rect(cx - 1, cy - 1, 3, 3)
                                surface.fill(wheel_hi, hub)
                                pygame.draw.rect(surface, line, hub, 1)
                                surface.fill(wheel_lo, pygame.Rect(cx, cy + 2, 1, 2))
                            if int(rely) == 0:
                                surface.fill(line, pygame.Rect(rect.x, rect.y, rect.w, 1))
                            if int(rely) == int(rh) - 1:
                                surface.fill(line, pygame.Rect(rect.x, rect.bottom - 1, rect.w, 1))
                            if int(relx) == 0:
                                surface.fill(line, pygame.Rect(rect.x, rect.y, 1, rect.h))
                            if int(relx) == int(rw) - 1:
                                surface.fill(line, pygame.Rect(rect.right - 1, rect.y, 1, rect.h))
                            return
        except Exception:
            pass

        col = self._tile_color(tile_id)
        surface.fill(col, rect)
        # RV world-interior: keep the interior floor perfectly flat (no noise/grit),
        # so it reads as a single uniform color.
        try:
            if bool(getattr(self, "rv_world_interior", False)) and int(tile_id) == int(self.T_FLOOR):
                key = getattr(self, "_rv_world_int_active_key", None)
                if isinstance(key, tuple) and len(key) == 4:
                    rx0, ry0, rw, rh = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
                    if int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh):
                        return
        except Exception:
            pass

        seed = int(self.seed) ^ (tile_id * 0x9E3779B9) ^ 0xB5297A4D
        h = int(self._hash2_u32(tx, ty, seed))

        # Simple gritty texture pass (cheap pixel-noise), inspired by the reference tone.
        hard = tile_id in (
            self.T_ROAD,
            self.T_HIGHWAY,
            self.T_PAVEMENT,
            self.T_PARKING,
            self.T_COURT,
            self.T_FLOOR,
            self.T_ELEVATOR,
            self.T_BARRICADE,
            self.T_SIDEWALK,
            self.T_BRICK,
            self.T_CONCRETE,
            self.T_BOARDWALK,
            self.T_MOUNTAIN,
        )
        soft = tile_id in (self.T_GRASS, self.T_FOREST, self.T_WATER, self.T_SAND, self.T_MARSH, self.T_WHEAT)

        if hard or soft:
            for j in range(2):
                if ((h >> (j * 3)) & 7) != 0:
                    continue
                ox = int((h >> (8 + j * 6)) % max(1, int(self.TILE_SIZE)))
                oy = int((h >> (12 + j * 6)) % max(1, int(self.TILE_SIZE)))
                dv = -14 if ((h >> (20 + j)) & 1) else 12
                if tile_id in (self.T_GRASS, self.T_FOREST):
                    add = (dv // 4, dv, dv // 4)
                elif tile_id == self.T_WATER:
                    add = (dv // 5, dv // 5, dv)
                else:
                    add = (dv, dv, dv)
                surface.fill(self._tint(col, add=add), pygame.Rect(rect.x + ox, rect.y + oy, 1, 1))

        if tile_id == self.T_SIDEWALK:
            grout = self._tint(col, add=(-22, -18, -10))
            if (tx % 2) == 0:
                surface.fill(grout, pygame.Rect(rect.x, rect.y + 1, 1, rect.h - 2))
            if (ty % 2) == 0:
                surface.fill(grout, pygame.Rect(rect.x + 1, rect.y, rect.w - 2, 1))

        if tile_id == self.T_BRICK:
            mortar = self._tint(col, add=(-30, -22, -20))
            surface.fill(mortar, pygame.Rect(rect.x + 1, rect.y, rect.w - 2, 1))
            surface.fill(mortar, pygame.Rect(rect.x + 1, rect.y + rect.h // 2, rect.w - 2, 1))
            for row in range(2):
                y0 = rect.y + row * (rect.h // 2) + 1
                hgt = (rect.h // 2) - 1
                shift = 0 if ((tx + ty + row) % 2) == 0 else 2
                for x_off in (shift, (shift + 5) % self.TILE_SIZE):
                    surface.fill(mortar, pygame.Rect(rect.x + x_off, y0, 1, hgt))

        if tile_id == self.T_CONCRETE:
            seam = self._tint(col, add=(-18, -18, -22))
            if (tx % 4) == 0:
                surface.fill(seam, pygame.Rect(rect.x, rect.y + 1, 1, rect.h - 2))
            if (ty % 4) == 0:
                surface.fill(seam, pygame.Rect(rect.x + 1, rect.y, rect.w - 2, 1))

        if tile_id == self.T_SAND:
            # Beach speckles + dune hints.
            grain = self._tint(col, add=(18, 14, -8))
            if ((h >> 3) & 3) == 0:
                surface.fill(grain, pygame.Rect(rect.x + 2, rect.y + 2, 1, 1))
            if ((h >> 6) & 3) == 0:
                surface.fill(grain, pygame.Rect(rect.right - 3, rect.y + 3, 1, 1))
            if (ty % 5) == 0:
                dune = self._tint(col, add=(-14, -10, -6))
                surface.fill(dune, pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, 1))

        if tile_id == self.T_MARSH:
            # Mud + shallow puddles.
            mud = self._tint(col, add=(-16, -10, -16))
            if ((h >> 4) & 7) == 0:
                surface.fill(mud, pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, 1))
            if ((h >> 7) & 7) == 0:
                water = (40, 70, 96)
                surface.fill(water, pygame.Rect(rect.x + 2, rect.y + 3, 2, 1))

        if tile_id == self.T_WHEAT:
            # Wheat fields: soft stripes + little stalk specks.
            row = self._tint(col, add=(-26, -18, -10))
            row_hi = self._tint(col, add=(28, 18, 0))
            seed2 = int(self.seed) ^ 0xA52D9E13
            cell = int(self._hash2_u32(int(tx) // 10, int(ty) // 10, seed2))
            vert = (cell & 1) == 0
            if vert:
                # North-south rows.
                if (int(tx) & 1) == 0:
                    surface.fill(row, pygame.Rect(rect.x + 2, rect.y + 1, 1, rect.h - 2))
                else:
                    surface.fill(row, pygame.Rect(rect.x + 6, rect.y + 1, 1, rect.h - 2))
                if (int(ty) % 3) == 0:
                    surface.fill(row_hi, pygame.Rect(rect.x + 1, rect.y + 2, rect.w - 2, 1))
            else:
                # East-west rows.
                if (int(ty) & 1) == 0:
                    surface.fill(row, pygame.Rect(rect.x + 1, rect.y + 2, rect.w - 2, 1))
                else:
                    surface.fill(row, pygame.Rect(rect.x + 1, rect.y + 6, rect.w - 2, 1))
                if (int(tx) % 3) == 0:
                    surface.fill(row_hi, pygame.Rect(rect.x + 2, rect.y + 1, 1, rect.h - 2))

            if ((h >> 2) & 7) == 0:
                stalk = self._tint(col, add=(36, 22, -6))
                ox = 2 + int((h >> 9) % 6)
                oy = 2 + int((h >> 13) % 6)
                surface.fill(stalk, pygame.Rect(rect.x + ox, rect.y + oy, 1, 1))

        if tile_id == self.T_MOUNTAIN:
            # Mountain ground: rocky strata + occasional boulders.
            ridge = self._tint(col, add=(-28, -28, -30))
            ridge_hi = self._tint(col, add=(24, 24, 28))
            seed2 = int(self.seed) ^ 0xC0FFEE11
            cell = int(self._hash2_u32(int(tx) // 14, int(ty) // 14, seed2))
            diag = (cell & 1) == 0
            if diag:
                off = int((h >> 8) % 7) - 3
                for i in range(0, int(rect.w), 3):
                    x = int(rect.x + 1 + i)
                    y = int(rect.y + 2 + ((i + off) % 6))
                    if rect.x <= x < rect.right - 1 and rect.y <= y < rect.bottom:
                        surface.fill(ridge, pygame.Rect(x, y, 2, 1))
            else:
                if (int(ty) % 3) == 0:
                    surface.fill(ridge, pygame.Rect(rect.x + 1, rect.y + 3, rect.w - 2, 1))
                if (int(tx) % 4) == 0:
                    surface.fill(ridge_hi, pygame.Rect(rect.x + 2, rect.y + 1, 1, rect.h - 2))

            if ((h >> 5) & 15) == 0:
                rock = self._tint(col, add=(-40, -40, -42))
                outline = (10, 10, 12)
                ox = 1 + int((h >> 10) % max(1, int(rect.w) - 3))
                oy = 1 + int((h >> 14) % max(1, int(rect.h) - 3))
                rr = pygame.Rect(rect.x + ox, rect.y + oy, 2, 2)
                surface.fill(rock, rr)
                pygame.draw.rect(surface, outline, rr, 1)

        if tile_id == self.T_BOARDWALK:
            # Wood planks.
            plank = self._tint(col, add=(-24, -18, -10))
            if (ty % 2) == 0:
                surface.fill(plank, pygame.Rect(rect.x + 1, rect.y + 2, rect.w - 2, 1))
            if (tx % 4) == 0:
                seam = self._tint(col, add=(-34, -26, -18))
                surface.fill(seam, pygame.Rect(rect.x + 1, rect.y + 1, 1, rect.h - 2))
            if ((h >> 5) & 31) == 0:
                nail = self._tint(col, add=(26, 18, 10))
                surface.fill(nail, pygame.Rect(rect.centerx, rect.centery, 1, 1))

        if tile_id == self.T_BARRICADE:
            # Simple boarded-up door/barricade tile (solid).
            base = self._tint(col, add=(10, 6, 0))
            plank1 = self._tint(base, add=(-18, -14, -10))
            plank2 = self._tint(base, add=(-30, -24, -18))
            nail = self._tint(base, add=(64, 64, 72))
            outline = (10, 10, 12)
            for i, y_off in enumerate((2, 5, 8)):
                rr = pygame.Rect(rect.x + 1, rect.y + int(y_off), rect.w - 2, 2)
                surface.fill(plank1 if (i % 2) == 0 else plank2, rr)
                pygame.draw.rect(surface, outline, rr, 1)
                if rr.w >= 8:
                    surface.fill(nail, pygame.Rect(rr.x + 2, rr.y + 1, 1, 1))
                    surface.fill(nail, pygame.Rect(rr.right - 3, rr.y + 1, 1, 1))

        if tile_id == self.T_PARKING:
            # Painted stall lines + curb edge so parking lots read clearly.
            line = self._tint(col, add=(86, 86, 92))
            line2 = self._tint(col, add=(58, 58, 64))
            if (tx % 3) == 0:
                surface.fill(line, pygame.Rect(rect.x + 1, rect.y + 1, 1, rect.h - 2))
            if (ty % 6) == 0:
                surface.fill(line, pygame.Rect(rect.x + 1, rect.y + 2, rect.w - 2, 1))
            # Occasional wheel-stop / marking block.
            if ((tx + ty + (h & 7)) % 17) == 0:
                surface.fill(line2, pygame.Rect(rect.centerx - 2, rect.centery + 2, 4, 1))

            curb = self._tint(col, add=(-34, -34, -34))
            if int(self.world.peek_tile(tx, ty - 1)) != int(self.T_PARKING):
                surface.fill(curb, pygame.Rect(rect.x, rect.y, rect.w, 1))
            if int(self.world.peek_tile(tx, ty + 1)) != int(self.T_PARKING):
                surface.fill(curb, pygame.Rect(rect.x, rect.bottom - 1, rect.w, 1))
            if int(self.world.peek_tile(tx - 1, ty)) != int(self.T_PARKING):
                surface.fill(curb, pygame.Rect(rect.x, rect.y, 1, rect.h))
            if int(self.world.peek_tile(tx + 1, ty)) != int(self.T_PARKING):
                surface.fill(curb, pygame.Rect(rect.right - 1, rect.y, 1, rect.h))

        if tile_id == self.T_HIGHWAY:
            # Abandoned highway: lane marks + cracks.
            mark = self._tint(col, add=(44, 44, 50))
            left = int(self.world.peek_tile(tx - 1, ty)) == int(self.T_HIGHWAY)
            right = int(self.world.peek_tile(tx + 1, ty)) == int(self.T_HIGHWAY)
            up = int(self.world.peek_tile(tx, ty - 1)) == int(self.T_HIGHWAY)
            down = int(self.world.peek_tile(tx, ty + 1)) == int(self.T_HIGHWAY)
            horiz = (left or right) and not (up or down)
            vert = (up or down) and not (left or right)
            if horiz and (tx % 6) == 0:
                surface.fill((210, 190, 110), pygame.Rect(rect.centerx - 2, rect.centery, 4, 1))
            elif vert and (ty % 6) == 0:
                surface.fill((210, 190, 110), pygame.Rect(rect.centerx, rect.centery - 2, 1, 4))
            # Shoulder edges.
            edge = self._tint(col, add=(32, 32, 36))
            if horiz:
                surface.fill(edge, pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, 1))
                surface.fill(edge, pygame.Rect(rect.x + 1, rect.bottom - 2, rect.w - 2, 1))
            elif vert:
                surface.fill(edge, pygame.Rect(rect.x + 1, rect.y + 1, 1, rect.h - 2))
                surface.fill(edge, pygame.Rect(rect.right - 2, rect.y + 1, 1, rect.h - 2))
            # Cracks.
            if (h & 31) == 0:
                crack = self._tint(col, add=(-30, -30, -30))
                pygame.draw.line(surface, crack, (rect.x + 2, rect.y + 7), (rect.right - 3, rect.y + 3), 1)

        if tile_id == self.T_ROAD:
            mark = self._tint(col, add=(32, 32, 36))
            left = int(self.world.peek_tile(tx - 1, ty)) == int(self.T_ROAD)
            right = int(self.world.peek_tile(tx + 1, ty)) == int(self.T_ROAD)
            up = int(self.world.peek_tile(tx, ty - 1)) == int(self.T_ROAD)
            down = int(self.world.peek_tile(tx, ty + 1)) == int(self.T_ROAD)
            horiz = (left or right) and not (up or down)
            vert = (up or down) and not (left or right)
            if horiz and (tx % 4) == 0:
                surface.fill(mark, pygame.Rect(rect.centerx - 2, rect.centery, 4, 1))
            elif vert and (ty % 4) == 0:
                surface.fill(mark, pygame.Rect(rect.centerx, rect.centery - 2, 1, 4))

        if tile_id in (self.T_PAVEMENT, self.T_SIDEWALK, self.T_BRICK, self.T_CONCRETE, self.T_BOARDWALK):
            curb = self._tint(col, add=(-26, -26, -26))
            if int(self.world.peek_tile(tx, ty - 1)) in (int(self.T_ROAD), int(self.T_HIGHWAY)):
                surface.fill(curb, pygame.Rect(rect.x, rect.y, rect.w, 1))
            if int(self.world.peek_tile(tx - 1, ty)) in (int(self.T_ROAD), int(self.T_HIGHWAY)):
                surface.fill(curb, pygame.Rect(rect.x, rect.y, 1, rect.h))
            curb_hi = self._tint(col, add=(16, 16, 16))
            if int(self.world.peek_tile(tx, ty + 1)) in (int(self.T_ROAD), int(self.T_HIGHWAY)):
                surface.fill(curb_hi, pygame.Rect(rect.x, rect.bottom - 1, rect.w, 1))
            if int(self.world.peek_tile(tx + 1, ty)) in (int(self.T_ROAD), int(self.T_HIGHWAY)):
                surface.fill(curb_hi, pygame.Rect(rect.right - 1, rect.y, 1, rect.h))

        if tile_id in (self.T_FLOOR, self.T_ELEVATOR, self.T_STAIRS_UP, self.T_STAIRS_DOWN):
            shadow = self._tint(col, add=(-18, -18, -18))
            if int(self.world.peek_tile(tx, ty - 1)) == int(self.T_WALL):
                surface.fill(shadow, pygame.Rect(rect.x, rect.y, rect.w, 1))
            if int(self.world.peek_tile(tx - 1, ty)) == int(self.T_WALL):
                surface.fill(shadow, pygame.Rect(rect.x, rect.y, 1, rect.h))

        if tile_id == self.T_ELEVATOR:
            edge = self._tint(col, add=(-34, -34, -34))
            hi = self._tint(col, add=(26, 26, 28))
            pygame.draw.rect(surface, edge, pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, rect.h - 2), 1)
            # Door split line + small top light.
            surface.fill(edge, pygame.Rect(rect.centerx, rect.y + 2, 1, max(1, rect.h - 4)))
            surface.fill(hi, pygame.Rect(rect.x + 2, rect.y + 2, max(1, rect.w - 4), 1))

        if tile_id in (self.T_STAIRS_UP, self.T_STAIRS_DOWN):
            step = self._tint(col, add=(34, 30, 24))
            edge = self._tint(col, add=(-28, -28, -28))
            pygame.draw.rect(surface, edge, pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, rect.h - 2), 1)
            for i in range(3):
                yy = int(rect.y + 2 + i * 2)
                surface.fill(step, pygame.Rect(int(rect.x + 2), int(yy), int(rect.w - 4), 1))
            ink = (230, 230, 240)
            if tile_id == self.T_STAIRS_UP:
                pygame.draw.polygon(surface, ink, [(rect.centerx, rect.y + 2), (rect.centerx - 2, rect.y + 6), (rect.centerx + 2, rect.y + 6)])
            else:
                pygame.draw.polygon(surface, ink, [(rect.centerx, rect.bottom - 3), (rect.centerx - 2, rect.bottom - 7), (rect.centerx + 2, rect.bottom - 7)])

        # World-map furniture (top-down pixel tiles).
        if tile_id in (
            self.T_TABLE,
            self.T_SHELF,
            self.T_CABINET,
            self.T_BED,
            self.T_SOFA,
            self.T_FRIDGE,
            self.T_TV,
            self.T_CHAIR,
            self.T_DOOR,
            self.T_DOOR_HOME,
            self.T_DOOR_LOCKED,
            self.T_DOOR_HOME_LOCKED,
            self.T_DOOR_BROKEN,
            self.T_PC,
            self.T_LAMP,
            self.T_SWITCH,
            self.T_TOILET,
            self.T_SINK,
            self.T_STEER,
        ):
            outline = (10, 10, 12)
            hi = self._tint(col, add=(24, 24, 26))
            lo = self._tint(col, add=(-28, -28, -30))

            # Furniture tiles should read as objects sitting on top of the floor,
            # not as full-tile colored blocks.
            if tile_id not in (self.T_DOOR, self.T_DOOR_HOME, self.T_DOOR_LOCKED, self.T_DOOR_HOME_LOCKED, self.T_DOOR_BROKEN):
                try:
                    floor_col = self._tile_color(int(self.T_FLOOR))
                    floor2 = self._tint(floor_col, add=(-6, -6, -8))
                    surface.fill(floor_col, rect)
                    if ((int(tx) + int(ty) + (int(h) & 3)) % 2) == 0:
                        surface.fill(floor2, pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, 1))
                except Exception:
                    pass

            if tile_id in (self.T_DOOR, self.T_DOOR_LOCKED, self.T_DOOR_BROKEN):
                inner = pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, rect.h - 2)
                pygame.draw.rect(surface, outline, inner, 1)
                panel = inner.inflate(-2, -2)
                if panel.w > 0 and panel.h > 0:
                    if tile_id == self.T_DOOR_BROKEN:
                        # Broken doorway: show a dark gap + splinters (passable).
                        gap = panel.inflate(-2, -2)
                        if gap.w > 0 and gap.h > 0:
                            surface.fill((10, 10, 12), gap)
                            surface.fill((24, 24, 30), pygame.Rect(gap.x + 1, gap.y + 1, max(1, gap.w - 2), 1))
                        # Remaining wood strips.
                        surface.fill(col, pygame.Rect(panel.x, panel.y, panel.w, 1))
                        surface.fill(col, pygame.Rect(panel.x, panel.bottom - 1, panel.w, 1))
                        surface.fill(col, pygame.Rect(panel.x, panel.y, 1, panel.h))
                        surface.fill(col, pygame.Rect(panel.right - 1, panel.y, 1, panel.h))
                        # Splinters.
                        surface.fill(lo, pygame.Rect(panel.centerx - 1, panel.y + 2, 1, max(1, panel.h - 4)))
                        surface.fill(hi, pygame.Rect(panel.centerx, panel.y + 3, 1, max(1, panel.h - 6)))
                        surface.fill(outline, pygame.Rect(panel.centerx - 1, panel.y + 2, 1, 1))
                    else:
                        open_p = 0.0
                        if tile_id == self.T_DOOR:
                            try:
                                open_p = float(getattr(self, "_door_open_anim", {}).get((int(tx), int(ty)), 0.0))
                            except Exception:
                                open_p = 0.0
                            open_p = float(min(1.0, max(0.0, open_p)))

                        if open_p > 0.001:
                            # Draw a small swinging leaf with a darker opening behind it.
                            gap = (12, 12, 14)
                            surface.fill(gap, panel)

                            left_wall = int(self.world.peek_tile(int(tx - 1), int(ty), default=int(self.T_WALL))) == int(self.T_WALL)
                            right_wall = int(self.world.peek_tile(int(tx + 1), int(ty), default=int(self.T_WALL))) == int(self.T_WALL)
                            up_wall = int(self.world.peek_tile(int(tx), int(ty - 1), default=int(self.T_WALL))) == int(self.T_WALL)
                            down_wall = int(self.world.peek_tile(int(tx), int(ty + 1), default=int(self.T_WALL))) == int(self.T_WALL)

                            shrink_w = True
                            if up_wall and down_wall and not (left_wall and right_wall):
                                shrink_w = False
                            elif left_wall and right_wall and not (up_wall and down_wall):
                                shrink_w = True
                            elif up_wall and down_wall:
                                shrink_w = False

                            hinge = (int(tx) ^ int(ty)) & 1
                            min_leaf = 2
                            if shrink_w:
                                leaf_w = max(int(min_leaf), int(round(float(panel.w) * (1.0 - 0.85 * float(open_p)))))
                                leaf = pygame.Rect(panel.x, panel.y, int(leaf_w), panel.h) if hinge == 0 else pygame.Rect(panel.right - int(leaf_w), panel.y, int(leaf_w), panel.h)
                            else:
                                leaf_h = max(int(min_leaf), int(round(float(panel.h) * (1.0 - 0.85 * float(open_p)))))
                                leaf = pygame.Rect(panel.x, panel.y, panel.w, int(leaf_h)) if hinge == 0 else pygame.Rect(panel.x, panel.bottom - int(leaf_h), panel.w, int(leaf_h))

                            surface.fill(col, leaf)
                            surface.fill(hi, pygame.Rect(leaf.x, leaf.y, leaf.w, 1))
                            surface.fill(lo, pygame.Rect(leaf.x, leaf.bottom - 1, leaf.w, 1))
                            if leaf.w > 3 and leaf.h > 3:
                                if shrink_w:
                                    surface.fill(lo, pygame.Rect(leaf.centerx, leaf.y + 1, 1, max(1, leaf.h - 2)))
                                else:
                                    surface.fill(lo, pygame.Rect(leaf.x + 1, leaf.centery, max(1, leaf.w - 2), 1))
                        else:
                            surface.fill(col, panel)
                            surface.fill(hi, pygame.Rect(panel.x, panel.y, panel.w, 1))
                            surface.fill(lo, pygame.Rect(panel.x, panel.bottom - 1, panel.w, 1))
                            surface.fill(lo, pygame.Rect(panel.centerx, panel.y + 1, 1, max(1, panel.h - 2)))
                surface.fill((30, 30, 34), pygame.Rect(inner.right - 2, inner.centery, 1, 1))
                if tile_id == self.T_DOOR_LOCKED:
                    lock = pygame.Rect(inner.centerx - 1, inner.centery - 1, 3, 3)
                    surface.fill((255, 220, 140), lock)
                    pygame.draw.rect(surface, outline, lock, 1)
            elif tile_id in (self.T_DOOR_HOME, self.T_DOOR_HOME_LOCKED):
                inner = pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, rect.h - 2)
                pygame.draw.rect(surface, outline, inner, 1)
                panel = inner.inflate(-2, -2)
                if panel.w > 0 and panel.h > 0:
                    open_p = 0.0
                    if tile_id == self.T_DOOR_HOME:
                        try:
                            open_p = float(getattr(self, "_door_open_anim", {}).get((int(tx), int(ty)), 0.0))
                        except Exception:
                            open_p = 0.0
                        open_p = float(min(1.0, max(0.0, open_p)))

                    if open_p > 0.001:
                        gap = (12, 12, 14)
                        surface.fill(gap, panel)

                        left_wall = int(self.world.peek_tile(int(tx - 1), int(ty), default=int(self.T_WALL))) == int(self.T_WALL)
                        right_wall = int(self.world.peek_tile(int(tx + 1), int(ty), default=int(self.T_WALL))) == int(self.T_WALL)
                        up_wall = int(self.world.peek_tile(int(tx), int(ty - 1), default=int(self.T_WALL))) == int(self.T_WALL)
                        down_wall = int(self.world.peek_tile(int(tx), int(ty + 1), default=int(self.T_WALL))) == int(self.T_WALL)

                        shrink_w = True
                        if up_wall and down_wall and not (left_wall and right_wall):
                            shrink_w = False
                        elif left_wall and right_wall and not (up_wall and down_wall):
                            shrink_w = True
                        elif up_wall and down_wall:
                            shrink_w = False

                        hinge = (int(tx) ^ int(ty)) & 1
                        min_leaf = 2
                        if shrink_w:
                            leaf_w = max(int(min_leaf), int(round(float(panel.w) * (1.0 - 0.85 * float(open_p)))))
                            leaf = pygame.Rect(panel.x, panel.y, int(leaf_w), panel.h) if hinge == 0 else pygame.Rect(panel.right - int(leaf_w), panel.y, int(leaf_w), panel.h)
                        else:
                            leaf_h = max(int(min_leaf), int(round(float(panel.h) * (1.0 - 0.85 * float(open_p)))))
                            leaf = pygame.Rect(panel.x, panel.y, panel.w, int(leaf_h)) if hinge == 0 else pygame.Rect(panel.x, panel.bottom - int(leaf_h), panel.w, int(leaf_h))

                        surface.fill(col, leaf)
                        surface.fill(hi, pygame.Rect(leaf.x, leaf.y, leaf.w, 1))
                        surface.fill(lo, pygame.Rect(leaf.x, leaf.bottom - 1, leaf.w, 1))
                        if leaf.w > 3 and leaf.h > 3:
                            if shrink_w:
                                surface.fill(lo, pygame.Rect(leaf.centerx, leaf.y + 1, 1, max(1, leaf.h - 2)))
                            else:
                                surface.fill(lo, pygame.Rect(leaf.x + 1, leaf.centery, max(1, leaf.w - 2), 1))
                    else:
                        surface.fill(col, panel)
                        surface.fill(hi, pygame.Rect(panel.x, panel.y, panel.w, 1))
                        surface.fill(lo, pygame.Rect(panel.x, panel.bottom - 1, panel.w, 1))
                        surface.fill(lo, pygame.Rect(panel.centerx, panel.y + 1, 1, max(1, panel.h - 2)))
                surface.fill((30, 30, 34), pygame.Rect(inner.right - 2, inner.centery, 1, 1))
                if tile_id == self.T_DOOR_HOME_LOCKED:
                    lock = pygame.Rect(inner.centerx - 1, inner.centery - 1, 3, 3)
                    surface.fill((255, 220, 140), lock)
                    pygame.draw.rect(surface, outline, lock, 1)
            elif tile_id == self.T_SWITCH:
                plate = pygame.Rect(rect.x + 3, rect.y + 3, rect.w - 6, rect.h - 6)
                pygame.draw.rect(surface, col, plate, border_radius=2)
                pygame.draw.rect(surface, outline, plate, 1, border_radius=2)
                on = bool(getattr(self, "home_light_on", True))
                dot = pygame.Rect(plate.centerx - 1, plate.centery - 1, 3, 3)
                surface.fill((120, 200, 140) if on else (220, 90, 70), dot)
                pygame.draw.rect(surface, outline, dot, 1)
            elif tile_id == self.T_STEER:
                # Steering wheel (cockpit). Used in the RV world-interior.
                cx, cy = int(rect.centerx), int(rect.centery)
                outer = 4  # fits TILE_SIZE=10 with a 1px margin
                wheel = (34, 34, 42)
                wheel_hi = self._tint(wheel, add=(34, 34, 40))
                wheel_lo = self._tint(wheel, add=(-18, -18, -18))
                try:
                    floor_col = self._tile_color(int(self.T_FLOOR))
                except Exception:
                    floor_col = (58, 56, 52)

                # Outer ring + inner hole (so it reads as a wheel, not a blob).
                pygame.draw.circle(surface, wheel, (cx, cy), int(outer))
                pygame.draw.circle(surface, outline, (cx, cy), int(outer), 1)
                pygame.draw.circle(surface, floor_col, (cx, cy), int(max(1, outer - 2)))

                # Spokes + hub.
                pygame.draw.line(surface, wheel_lo, (cx, cy), (cx, rect.y + 2), 1)
                pygame.draw.line(surface, wheel_lo, (cx, cy), (rect.x + 2, cy + 1), 1)
                pygame.draw.line(surface, wheel_lo, (cx, cy), (rect.right - 3, cy + 1), 1)
                hub = pygame.Rect(cx - 1, cy - 1, 3, 3)
                surface.fill(wheel_hi, hub)
                pygame.draw.rect(surface, outline, hub, 1)

                # Column hint (bottom).
                surface.fill(wheel_lo, pygame.Rect(cx, cy + 2, 1, 2))
            elif tile_id == self.T_LAMP:
                base = pygame.Rect(rect.centerx - 2, rect.bottom - 3, 4, 2)
                stem = pygame.Rect(rect.centerx, rect.y + 4, 1, rect.h - 7)
                shade = pygame.Rect(rect.centerx - 3, rect.y + 1, 6, 4)
                pygame.draw.rect(surface, outline, base, 1)
                surface.fill(lo, base.inflate(-2, -1))
                surface.fill(outline, stem)
                pygame.draw.rect(surface, (34, 34, 42), shade, border_radius=1)
                pygame.draw.rect(surface, outline, shade, 1, border_radius=1)
                if bool(getattr(self, "home_light_on", True)):
                    glow = shade.inflate(-2, -2)
                    if glow.w > 0 and glow.h > 0:
                        surface.fill((255, 240, 180), glow)
            elif tile_id == self.T_TOILET:
                # Toilet bowl (more readable than a plain white block).
                porcelain = (240, 240, 245)
                porcelain2 = (230, 230, 238)
                seat_col = (200, 200, 210)
                dark = (28, 28, 34)
                water = (64, 126, 190)
                water_hi = (120, 184, 220)

                bowl = pygame.Rect(rect.x + 2, rect.y + 4, rect.w - 4, rect.h - 5)
                pygame.draw.rect(surface, porcelain, bowl, border_radius=2)
                pygame.draw.rect(surface, outline, bowl, 1, border_radius=2)

                tank = pygame.Rect(rect.x + 3, rect.y + 1, rect.w - 6, 4)
                pygame.draw.rect(surface, porcelain2, tank, border_radius=2)
                pygame.draw.rect(surface, outline, tank, 1, border_radius=2)
                # Tiny handle.
                surface.fill((134, 140, 152), pygame.Rect(tank.right - 2, tank.y + 1, 1, 1))

                seat = bowl.inflate(-2, -2)
                if seat.w > 0 and seat.h > 0:
                    pygame.draw.rect(surface, seat_col, seat, border_radius=2)
                    pygame.draw.rect(surface, outline, seat, 1, border_radius=2)
                    hole = seat.inflate(-3, -3)
                    if hole.w > 0 and hole.h > 0:
                        pygame.draw.rect(surface, dark, hole, border_radius=2)
                        water_r = hole.inflate(-2, -2)
                        if water_r.w > 0 and water_r.h > 0:
                            pygame.draw.rect(surface, water, water_r, border_radius=2)
                            surface.fill(water_hi, pygame.Rect(water_r.x + 1, water_r.y + 1, max(1, water_r.w - 2), 1))
            elif tile_id == self.T_PC:
                # Simple 2-tile computer desk: left tile prefers monitor, right tile prefers tower.
                left_is_pc = int(self.world.peek_tile(int(tx - 1), int(ty))) == int(self.T_PC)
                right_is_pc = int(self.world.peek_tile(int(tx + 1), int(ty))) == int(self.T_PC)
                part = "single"
                if right_is_pc and not left_is_pc:
                    part = "left"
                elif left_is_pc and not right_is_pc:
                    part = "right"
                elif left_is_pc and right_is_pc:
                    part = "mid"

                # Desk body (top + front face).
                body = pygame.Rect(rect.x + 1, rect.y + 4, rect.w - 2, rect.h - 5)
                pygame.draw.rect(surface, outline, body, 1)
                surface.fill(hi, pygame.Rect(body.x + 1, body.y + 1, body.w - 2, 1))
                surface.fill(lo, pygame.Rect(body.x + 1, body.bottom - 2, body.w - 2, 1))
                # Legs.
                leg_y0 = int(body.bottom - 3)
                surface.fill(outline, pygame.Rect(body.x + 1, leg_y0, 1, 2))
                surface.fill(outline, pygame.Rect(body.right - 2, leg_y0, 1, 2))

                # Monitor (left side).
                if part in ("left", "single", "mid"):
                    mon = pygame.Rect(rect.x + 2, rect.y + 2, 5, 4)
                    pygame.draw.rect(surface, (34, 34, 42), mon, border_radius=1)
                    pygame.draw.rect(surface, outline, mon, 1, border_radius=1)
                    scr = mon.inflate(-2, -2)
                    surface.fill((14, 14, 18), scr)
                    surface.fill((120, 200, 240), pygame.Rect(scr.x + 1, scr.y + 1, 2, 1))
                    # Tiny stand.
                    surface.fill(outline, pygame.Rect(mon.centerx, mon.bottom, 1, 1))

                # Keyboard + tower (right side).
                if part in ("right", "single", "mid"):
                    kb = pygame.Rect(rect.x + 2, rect.y + 7, rect.w - 4, 2)
                    pygame.draw.rect(surface, (36, 36, 44), kb, border_radius=1)
                    pygame.draw.rect(surface, outline, kb, 1, border_radius=1)
                    if part in ("right", "single"):
                        tower = pygame.Rect(rect.right - 4, rect.y + 2, 3, 6)
                        pygame.draw.rect(surface, (26, 26, 32), tower, border_radius=1)
                        pygame.draw.rect(surface, outline, tower, 1, border_radius=1)
                        surface.fill((120, 200, 140), pygame.Rect(tower.x + 1, tower.y + 2, 1, 1))
            elif tile_id == self.T_FRIDGE:
                box = pygame.Rect(rect.x + 2, rect.y + 1, rect.w - 4, rect.h - 2)
                pygame.draw.rect(surface, col, box, border_radius=2)
                pygame.draw.rect(surface, outline, box, 1, border_radius=2)
                surface.fill(hi, pygame.Rect(box.x + 1, box.y + 1, box.w - 2, 1))
                surface.fill(lo, pygame.Rect(box.x + 1, box.bottom - 2, box.w - 2, 1))
                split_y = int(box.y + max(2, box.h // 3))
                surface.fill(outline, pygame.Rect(box.x + 1, split_y, box.w - 2, 1))
                # Handle.
                surface.fill((210, 210, 220), pygame.Rect(box.right - 2, box.y + 2, 1, max(2, box.h - 5)))
            elif tile_id == self.T_TV:
                frame_r = pygame.Rect(rect.x + 1, rect.y + 2, rect.w - 2, rect.h - 4)
                pygame.draw.rect(surface, (34, 34, 40), frame_r, border_radius=2)
                pygame.draw.rect(surface, outline, frame_r, 1, border_radius=2)
                screen = frame_r.inflate(-2, -3)
                tv_on = bool(getattr(self, "world_tv_states", {}).get((int(tx), int(ty)), False))
                surface.fill((14, 14, 18), screen)
                if tv_on and screen.w > 3 and screen.h > 2:
                    t = int(float(getattr(self, "world_time_s", 0.0)) * 8.0)
                    # Simple animated "show" (doesn't wash out the room).
                    c1 = (120, 200, 240)
                    c2 = (210, 180, 120)
                    for yy in range(screen.y + 1, screen.bottom - 1):
                        if ((yy + t) % 5) == 0:
                            surface.fill(c1, pygame.Rect(screen.x + 1, yy, screen.w - 2, 1))
                        elif ((yy + t) % 7) == 0:
                            surface.fill(c2, pygame.Rect(screen.x + 1, yy, screen.w - 2, 1))
                    surface.fill((240, 240, 250), pygame.Rect(screen.x + 1, screen.y + 1, 2, 1))
                else:
                    surface.fill((60, 110, 140), pygame.Rect(screen.x + 1, screen.y + 1, 2, 1))
                stand = pygame.Rect(rect.centerx - 1, rect.bottom - 2, 2, 1)
                surface.fill(outline, stand)
            elif tile_id == self.T_SOFA:
                left_sofa = int(self.world.peek_tile(int(tx - 1), int(ty))) == int(self.T_SOFA)
                right_sofa = int(self.world.peek_tile(int(tx + 1), int(ty))) == int(self.T_SOFA)
                edge_l = not left_sofa
                edge_r = not right_sofa
                inset_l = 2 if edge_l else 0
                inset_r = 2 if edge_r else 0
                back_w = int(max(1, int(rect.w) - int(inset_l) - int(inset_r)))
                back = pygame.Rect(rect.x + int(inset_l), rect.y + 2, int(back_w), 3)
                seat = pygame.Rect(back.x, rect.y + 5, back.w, 3)
                pygame.draw.rect(surface, col, back, border_radius=2)
                pygame.draw.rect(surface, outline, back, 1, border_radius=2)
                pygame.draw.rect(surface, lo, seat, border_radius=2)
                pygame.draw.rect(surface, outline, seat, 1, border_radius=2)
                surface.fill(hi, pygame.Rect(seat.x + 1, seat.y + 1, max(1, seat.w - 2), 1))
                if edge_l:
                    surface.fill(outline, pygame.Rect(back.x, back.y + 1, 1, back.h + 4))
                if edge_r:
                    surface.fill(outline, pygame.Rect(back.right - 1, back.y + 1, 1, back.h + 4))
            elif tile_id == self.T_BED:
                # Draw as a connected multi-tile object (no seam between tiles).
                left_is_bed = int(self.world.peek_tile(int(tx - 1), int(ty))) == int(self.T_BED)
                right_is_bed = int(self.world.peek_tile(int(tx + 1), int(ty))) == int(self.T_BED)
                inset_l = 0 if left_is_bed else 1
                inset_r = 0 if right_is_bed else 1
                bw = int(rect.w) - int(inset_l) - int(inset_r)
                if bw <= 0:
                    inset_l, inset_r = 1, 1
                    bw = max(1, int(rect.w) - 2)
                body = pygame.Rect(rect.x + int(inset_l), rect.y + 2, int(bw), rect.h - 3)
                surface.fill(col, body)
                surface.fill(hi, pygame.Rect(body.x + 1, body.y + 1, max(1, body.w - 2), 1))
                surface.fill(lo, pygame.Rect(body.x + 1, body.bottom - 2, max(1, body.w - 2), 1))
                # Outline (only on outer edges).
                pygame.draw.line(surface, outline, (body.left, body.top), (body.right - 1, body.top))
                pygame.draw.line(surface, outline, (body.left, body.bottom - 1), (body.right - 1, body.bottom - 1))
                if not left_is_bed:
                    pygame.draw.line(surface, outline, (body.left, body.top), (body.left, body.bottom - 1))
                if not right_is_bed:
                    pygame.draw.line(surface, outline, (body.right - 1, body.top), (body.right - 1, body.bottom - 1))

                # Pillow on the head side (prefer the "outer" end of a 2-tile bed).
                if right_is_bed and not left_is_bed:
                    pillow = pygame.Rect(body.x + 1, body.y + 1, 3, 2)
                elif left_is_bed and not right_is_bed:
                    pillow = pygame.Rect(body.right - 4, body.y + 1, 3, 2)
                else:
                    pillow = pygame.Rect(body.centerx - 1, body.y + 1, 2, 2)
                surface.fill((230, 230, 236), pillow)

                # Legs so the bed doesn't read as a flat block (outer corners only).
                if not left_is_bed:
                    surface.fill(outline, pygame.Rect(body.left + 1, body.bottom, 1, 1))
                if not right_is_bed:
                    surface.fill(outline, pygame.Rect(body.right - 2, body.bottom, 1, 1))
            elif tile_id == self.T_TABLE:
                top = pygame.Rect(rect.x + 1, rect.y + 2, rect.w - 2, 3)
                pygame.draw.rect(surface, col, top, border_radius=2)
                pygame.draw.rect(surface, outline, top, 1, border_radius=2)
                surface.fill(hi, pygame.Rect(top.x + 1, top.y + 1, max(1, top.w - 2), 1))
                surface.fill(lo, pygame.Rect(top.x + 1, top.bottom - 1, max(1, top.w - 2), 1))
                leg_y0 = int(top.bottom)
                leg_h = int(max(2, rect.bottom - 2 - leg_y0))
                surface.fill(outline, pygame.Rect(rect.x + 2, leg_y0, 1, leg_h))
                surface.fill(outline, pygame.Rect(rect.right - 3, leg_y0, 1, leg_h))
            elif tile_id == self.T_CHAIR:
                back = pygame.Rect(rect.x + 2, rect.y + 2, rect.w - 4, 2)
                seat = pygame.Rect(rect.x + 2, rect.y + 5, rect.w - 4, 3)
                pygame.draw.rect(surface, lo, back, border_radius=2)
                pygame.draw.rect(surface, outline, back, 1, border_radius=2)
                pygame.draw.rect(surface, col, seat, border_radius=2)
                pygame.draw.rect(surface, outline, seat, 1, border_radius=2)
                surface.fill(hi, pygame.Rect(seat.x + 1, seat.y + 1, max(1, seat.w - 2), 1))
                surface.fill(outline, pygame.Rect(seat.x + 1, rect.bottom - 2, 1, 1))
                surface.fill(outline, pygame.Rect(seat.right - 2, rect.bottom - 2, 1, 1))
            elif tile_id == self.T_SHELF:  # shelf
                box = pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, rect.h - 2)
                pygame.draw.rect(surface, col, box, border_radius=2)
                pygame.draw.rect(surface, outline, box, 1, border_radius=2)
                surface.fill(lo, pygame.Rect(box.x + 1, box.y + 3, max(1, box.w - 2), 1))
                surface.fill(lo, pygame.Rect(box.x + 1, box.y + 6, max(1, box.w - 2), 1))
                surface.fill(hi, pygame.Rect(box.x + 1, box.bottom - 2, max(1, box.w - 2), 1))
                # Books hint.
                if ((int(tx) + int(ty)) % 3) == 0:
                    surface.fill((200, 120, 120), pygame.Rect(box.x + 2, box.y + 2, 1, 2))
                    surface.fill((120, 200, 140), pygame.Rect(box.x + 4, box.y + 2, 1, 2))
            elif tile_id == self.T_CABINET:
                # Kitchen cabinet (reads differently from bookshelf).
                counter = pygame.Rect(rect.x + 1, rect.y + 2, rect.w - 2, 2)
                body = pygame.Rect(rect.x + 1, rect.y + 4, rect.w - 2, rect.h - 5)
                surface.fill(hi, pygame.Rect(counter.x, counter.y, counter.w, 1))
                surface.fill(col, pygame.Rect(counter.x, counter.y + 1, counter.w, 1))
                pygame.draw.rect(surface, outline, pygame.Rect(counter.x, counter.y, counter.w, 2), 1)
                pygame.draw.rect(surface, col, body, border_radius=2)
                pygame.draw.rect(surface, outline, body, 1, border_radius=2)
                surface.fill(hi, pygame.Rect(body.x + 1, body.y + 1, max(1, body.w - 2), 1))
                surface.fill(lo, pygame.Rect(body.x + 1, body.bottom - 2, max(1, body.w - 2), 1))
                # Doors split + handles.
                surface.fill(outline, pygame.Rect(body.centerx, body.y + 1, 1, max(1, body.h - 2)))
                handle = (210, 210, 220)
                surface.fill(handle, pygame.Rect(body.centerx - 2, body.y + 2, 1, 1))
                surface.fill(handle, pygame.Rect(body.centerx + 1, body.y + 2, 1, 1))
            elif tile_id == self.T_SINK:
                # Bathroom/kitchen sink with a small faucet.
                rim = pygame.Rect(rect.x + 1, rect.y + 3, rect.w - 2, rect.h - 5)
                bowl = rim.inflate(-3, -4)
                steel = (200, 204, 214)
                steel2 = (150, 156, 170)
                water = (120, 170, 230)
                pygame.draw.rect(surface, outline, rim, 1, border_radius=2)
                pygame.draw.rect(surface, steel, bowl, border_radius=2)
                pygame.draw.rect(surface, outline, bowl, 1, border_radius=2)
                # Faucet
                fx = int(rect.centerx)
                surface.fill(steel2, pygame.Rect(fx - 1, rect.y + 1, 2, 3))
                surface.fill(steel2, pygame.Rect(fx - 3, rect.y + 3, 6, 1))
                surface.fill(outline, pygame.Rect(fx - 1, rect.y + 1, 2, 1))
                # Water hint
                surface.fill(water, pygame.Rect(bowl.x + 2, bowl.y + 2, max(1, bowl.w - 4), 1))
            elif tile_id == self.T_GAS_PUMP:
                # Simple gas pump (world-map prop tile).
                pump = pygame.Rect(rect.x + 2, rect.y + 1, rect.w - 4, rect.h - 2)
                red = (200, 70, 70)
                red2 = (150, 46, 46)
                glass = (120, 200, 240)
                pygame.draw.rect(surface, red2, pump, border_radius=2)
                pygame.draw.rect(surface, outline, pump, 1, border_radius=2)
                top = pygame.Rect(pump.x, pump.y, pump.w, 3)
                surface.fill(red, top)
                surface.fill(outline, pygame.Rect(top.x, top.bottom - 1, top.w, 1))
                # Display window.
                win = pygame.Rect(pump.x + 2, pump.y + 3, pump.w - 4, 3)
                pygame.draw.rect(surface, (20, 20, 24), win, border_radius=1)
                pygame.draw.rect(surface, outline, win, 1, border_radius=1)
                surface.fill(glass, pygame.Rect(win.x + 1, win.y + 1, max(1, win.w - 2), 1))
                # Hose.
                surface.fill(outline, pygame.Rect(pump.right - 2, pump.y + 4, 1, pump.h - 6))
                surface.fill(outline, pygame.Rect(pump.right - 3, pump.bottom - 3, 2, 1))
            else:
                pass

        # Proximity outline for interactable world tiles (keyboard-friendly).
        try:
            if (
                not self.inv_open
                and not bool(getattr(self, "world_map_open", False))
                and not bool(getattr(self, "home_ui_open", False))
                and not bool(getattr(self, "world_elevator_ui_open", False))
                and not (str(getattr(self, "player_pose_space", "")) == "world" and str(getattr(self, "player_pose", "")) in ("sleep", "sit"))
                and getattr(self, "mount", None) is None
            ):
                pt = getattr(self, "_draw_player_tile_xy", None)
                if isinstance(pt, tuple) and len(pt) == 2:
                    ptx, pty = int(pt[0]), int(pt[1])
                    if abs(int(tx) - int(ptx)) <= 1 and abs(int(ty) - int(pty)) <= 1:
                        if tile_id in (
                            int(self.T_DOOR),
                            int(self.T_DOOR_HOME),
                            int(self.T_DOOR_LOCKED),
                            int(self.T_DOOR_HOME_LOCKED),
                            int(self.T_BARRICADE),
                            int(self.T_ELEVATOR),
                            int(self.T_STAIRS_UP),
                            int(self.T_STAIRS_DOWN),
                            int(self.T_GAS_PUMP),
                        ):
                            pygame.draw.rect(surface, (120, 100, 60), rect, 1)
                            pygame.draw.rect(surface, (255, 220, 140), rect.inflate(-2, -2), 1)
        except Exception:
            pass

    def _draw_home_move_mode_overlay(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        if not bool(getattr(self, "home_move_mode", False)):
            return
        if getattr(self, "mount", None) is not None:
            return

        ts = int(self.TILE_SIZE)
        cur = getattr(self, "home_move_cursor", (0, 0))
        cx, cy = int(cur[0]), int(cur[1])
        px = int(cx * ts - int(cam_x))
        py = int(cy * ts - int(cam_y))
        r = pygame.Rect(px, py, ts, ts)

        # Ghost placement preview when carrying.
        carry = getattr(self, "home_move_carry", None)
        if isinstance(carry, dict):
            offsets = carry.get("offsets", [])
            home_key = getattr(self, "home_highrise_world_key", None)
            ok = True
            cells: list[tuple[int, int]] = []
            if not (isinstance(offsets, list) and isinstance(home_key, tuple) and len(home_key) == 4):
                ok = False
            else:
                cells = [(int(cx + int(dx)), int(cy + int(dy))) for dx, dy in offsets]
                for tx, ty in cells:
                    hit = self._peek_building_at_tile(int(tx), int(ty))
                    if hit is None:
                        ok = False
                        break
                    btx0, bty0, bw, bh = hit[:4]
                    if (int(btx0), int(bty0), int(bw), int(bh)) != tuple(int(v) for v in home_key):
                        ok = False
                        break
                    if int(self.world.peek_tile(int(tx), int(ty))) != int(self.T_FLOOR):
                        ok = False
                        break

            col = (120, 200, 140) if ok else (220, 90, 70)
            for tx, ty in cells:
                gx = int(tx * ts - int(cam_x))
                gy = int(ty * ts - int(cam_y))
                gr = pygame.Rect(gx, gy, ts, ts)
                ghost = pygame.Surface((ts, ts), pygame.SRCALPHA)
                ghost.fill((int(col[0]), int(col[1]), int(col[2]), 60))
                surface.blit(ghost, gr.topleft)
                pygame.draw.rect(surface, col, gr, 1)

        # Cursor outline + tiny "".
        pygame.draw.rect(surface, (0, 0, 0), r, 2)
        pygame.draw.rect(surface, (255, 220, 140), r.inflate(-2, -2), 1)
        body_col = (255, 220, 140)
        head = pygame.Rect(r.centerx - 1, r.y + 2, 2, 2)
        torso = pygame.Rect(r.centerx - 1, r.y + 4, 2, 3)
        leg_l = pygame.Rect(r.centerx - 2, r.y + 7, 1, 2)
        leg_r = pygame.Rect(r.centerx + 1, r.y + 7, 1, 2)
        surface.fill(body_col, head)
        surface.fill(body_col, torso)
        surface.fill(body_col, leg_l)
        surface.fill(body_col, leg_r)

    def _tile_in_home_world(self, tx: int, ty: int) -> bool:
        tx = int(tx)
        ty = int(ty)
        home_key = getattr(self, "home_highrise_world_key", None)
        if not (isinstance(home_key, tuple) and len(home_key) == 4):
            return False
        hit = self._peek_building_at_tile(int(tx), int(ty))
        if hit is None:
            return False
        btx0, bty0, bw, bh = hit[:4]
        if (int(btx0), int(bty0), int(bw), int(bh)) != tuple(int(v) for v in home_key):
            return False
        home_floor = int(getattr(self, "home_highrise_world_floor", 0) or 0)
        if home_floor > 0:
            found = self._multi_house_at(int(tx), int(ty))
            if found is None:
                return False
            _ch, mh = found
            if int(getattr(mh, "cur_floor", 1)) != int(home_floor):
                return False
        return True

    def _tile_in_rv_world(self, tx: int, ty: int) -> bool:
        if not bool(getattr(self, "rv_world_interior", False)):
            return False
        key = getattr(self, "_rv_world_int_active_key", None)
        if not (isinstance(key, tuple) and len(key) == 4):
            return False
        try:
            rx0, ry0, rw, rh = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
        except Exception:
            return False
        tx = int(tx)
        ty = int(ty)
        return int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh)

    def _world_tile_screen_rect(self, tx: int, ty: int, cam_x: int, cam_y: int) -> pygame.Rect:
        tx = int(tx)
        ty = int(ty)
        ts = int(self.TILE_SIZE)
        x = int(tx) * int(ts) - int(cam_x)
        y = int(ty) * int(ts) - int(cam_y)
        overlay = getattr(self, "_inside_highrise_floor_overlay", None)
        if overlay is not None:
            try:
                tx0, ty0, w, h, floor_y0, offset_px = (
                    int(overlay[0]),
                    int(overlay[1]),
                    int(overlay[2]),
                    int(overlay[3]),
                    int(overlay[4]),
                    int(overlay[5]),
                )
                start_y = int(max(int(ty0), int(floor_y0) - 1))
                if int(offset_px) > 0 and int(tx0) <= int(tx) < int(tx0) + int(w) and int(ty0) <= int(ty) < int(ty0) + int(h) and int(ty) >= int(start_y):
                    y -= int(offset_px)
            except Exception:
                pass
        return pygame.Rect(int(x), int(y), int(ts), int(ts))

    def _screen_to_world_tile(self, mx: int, my: int, cam_x: int, cam_y: int) -> tuple[int, int]:
        mx = int(mx)
        my = int(my)
        ts = int(self.TILE_SIZE)
        if ts <= 0:
            return 0, 0
        tx = int(math.floor((float(cam_x) + float(mx)) / float(ts)))
        ty = int(math.floor((float(cam_y) + float(my)) / float(ts)))
        overlay = getattr(self, "_inside_highrise_floor_overlay", None)
        if overlay is not None:
            try:
                tx0, ty0, w, h, floor_y0, offset_px = (
                    int(overlay[0]),
                    int(overlay[1]),
                    int(overlay[2]),
                    int(overlay[3]),
                    int(overlay[4]),
                    int(overlay[5]),
                )
                start_y = int(max(int(ty0), int(floor_y0) - 1))
                if int(offset_px) > 0:
                    x0 = int(tx0) * int(ts) - int(cam_x)
                    x1 = int(x0 + int(w) * int(ts))
                    y0 = int(start_y) * int(ts) - int(cam_y) - int(offset_px)
                    y1 = int((int(ty0) + int(h)) * int(ts) - int(cam_y) - int(offset_px))
                    if int(x0) <= int(mx) < int(x1) and int(y0) <= int(my) < int(y1):
                        ty = int(math.floor((float(cam_y) + float(my) + float(offset_px)) / float(ts)))
            except Exception:
                pass
        return int(tx), int(ty)

    def _home_furniture_pickup_at(self, tx: int, ty: int) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False
        if isinstance(getattr(self, "home_move_carry", None), dict):
            return False

        tx = int(tx)
        ty = int(ty)
        ptx, pty = self._player_tile()
        if abs(int(tx) - int(ptx)) > 1 or abs(int(ty) - int(pty)) > 1:
            return False
        in_home = bool(self._tile_in_home_world(int(tx), int(ty)))
        in_rv = bool(self._tile_in_rv_world(int(tx), int(ty)))
        space = "rv" if in_rv else "home" if in_home else "world"

        movable = {
            int(self.T_TABLE),
            int(self.T_SHELF),
            int(self.T_CABINET),
            int(self.T_BED),
            int(self.T_SOFA),
            int(self.T_FRIDGE),
            int(self.T_TV),
            int(self.T_CHAIR),
            int(self.T_PC),
            int(self.T_LAMP),
            int(self.T_SWITCH),
            int(self.T_TOILET),
            int(self.T_SINK),
        }
        tid = int(self.world.get_tile(int(tx), int(ty)))
        if tid not in movable:
            return False
        if in_rv:
            fixed = getattr(self, "_rv_world_fixed_furniture", None)
            if isinstance(fixed, set) and (int(tx), int(ty)) in fixed:
                return False

        seen: set[tuple[int, int]] = set()
        stack = [(int(tx), int(ty))]
        cells: list[tuple[int, int]] = []
        while stack and len(cells) < 24:
            cx, cy = stack.pop()
            cx = int(cx)
            cy = int(cy)
            if (cx, cy) in seen:
                continue
            seen.add((cx, cy))
            if space == "rv":
                if not self._tile_in_rv_world(int(cx), int(cy)):
                    continue
            elif space == "home":
                if not self._tile_in_home_world(int(cx), int(cy)):
                    continue
            if int(self.world.get_tile(int(cx), int(cy))) != int(tid):
                continue
            if space == "rv":
                fixed = getattr(self, "_rv_world_fixed_furniture", None)
                if isinstance(fixed, set) and (int(cx), int(cy)) in fixed:
                    return False
            cells.append((int(cx), int(cy)))
            stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])

        if not cells:
            return False

        # Preserve durability for partially-damaged furniture blocks.
        hp = None
        try:
            anchor = min(cells)
            hp_key = self._world_furniture_hp_key(int(anchor[0]), int(anchor[1]))
            hp = self.world_furniture_hp.pop(hp_key, None)
            # Clear any stale per-cell keys too.
            for cx, cy in cells:
                self.world_furniture_hp.pop(self._world_furniture_hp_key(int(cx), int(cy)), None)
        except Exception:
            hp = None

        offsets = [(int(cx - tx), int(cy - ty)) for cx, cy in cells]
        carry: dict[str, object] = {"tid": int(tid), "offsets": offsets, "origin_cells": list(cells), "space": str(space)}
        if hp is not None:
            carry["hp"] = int(hp)
        self.home_move_carry = carry
        for cx, cy in cells:
            if space == "rv":
                base = getattr(self, "_rv_world_floor_base", None)
                base_tid = None
                if isinstance(base, dict):
                    base_tid = base.get((int(cx), int(cy)))
                if base_tid is None:
                    base_tid = int(self.T_FLOOR)
                self._world_set_tile(int(cx), int(cy), int(base_tid))
            elif space == "home":
                self._world_set_tile(int(cx), int(cy), int(self.T_FLOOR))
            else:
                base_tid = int(self._world_guess_base_tile_under_furniture(int(cx), int(cy)))
                self._world_set_tile(int(cx), int(cy), int(base_tid))
        self._set_hint(" | Shift+ | ", seconds=1.6)
        return True

    def _home_furniture_can_place_at(self, anchor_tx: int, anchor_ty: int) -> tuple[bool, list[tuple[int, int]]]:
        carry = getattr(self, "home_move_carry", None)
        if not isinstance(carry, dict):
            return False, []
        tid = int(carry.get("tid", 0))
        offsets = carry.get("offsets", [])
        if not isinstance(offsets, list) or tid <= 0:
            return False, []

        space = str(carry.get("space", "home"))
        if space not in ("home", "rv", "world"):
            space = "world"
        anchor_tx = int(anchor_tx)
        anchor_ty = int(anchor_ty)
        cells = [(int(anchor_tx + int(dx)), int(anchor_ty + int(dy))) for dx, dy in offsets]
        for tx, ty in cells:
            if space == "rv":
                if not self._tile_in_rv_world(int(tx), int(ty)):
                    return False, cells
                base = getattr(self, "_rv_world_floor_base", None)
                if not isinstance(base, dict):
                    return False, cells
                want = base.get((int(tx), int(ty)))
                if want is None:
                    return False, cells
                if int(self.world.peek_tile(int(tx), int(ty))) != int(want):
                    return False, cells
            elif space == "home":
                if not self._tile_in_home_world(int(tx), int(ty)):
                    return False, cells
                if int(self.world.peek_tile(int(tx), int(ty))) != int(self.T_FLOOR):
                    return False, cells
            else:
                base_tid = int(self.world.peek_tile(int(tx), int(ty)))
                if int(base_tid) in self._WORLD_FURNITURE_HP_DEFAULTS:
                    return False, cells
                if int(base_tid) in (
                    int(self.T_DOOR),
                    int(self.T_DOOR_HOME),
                    int(self.T_DOOR_BROKEN),
                    int(self.T_STAIRS_UP),
                    int(self.T_STAIRS_DOWN),
                    int(self.T_ELEVATOR),
                ):
                    return False, cells
                if bool(self._tile_solid(int(base_tid))):
                    return False, cells
        return True, cells

    def _home_furniture_place_at(self, anchor_tx: int, anchor_ty: int) -> bool:
        ok, cells = self._home_furniture_can_place_at(int(anchor_tx), int(anchor_ty))
        if not ok:
            return False
        carry = getattr(self, "home_move_carry", None)
        if not isinstance(carry, dict):
            return False
        tid = int(carry.get("tid", 0))
        if tid <= 0:
            return False
        for tx, ty in cells:
            self._world_set_tile(int(tx), int(ty), int(tid))

        # Restore durability to the placed furniture block (if it was previously damaged).
        hp = carry.get("hp")
        if hp is not None:
            try:
                anchor = min(cells) if cells else (int(anchor_tx), int(anchor_ty))
                self.world_furniture_hp[self._world_furniture_hp_key(int(anchor[0]), int(anchor[1]))] = int(hp)
            except Exception:
                pass
        self.home_move_carry = None
        self._set_hint("", seconds=0.9)
        return True

    def _world_furniture_throw_to(self, tx: int, ty: int) -> bool:
        carry = getattr(self, "home_move_carry", None)
        if not isinstance(carry, dict):
            return False
        tid = int(carry.get("tid", 0))
        offsets = carry.get("offsets", [])
        if tid <= 0 or not isinstance(offsets, list) or not offsets:
            return False

        space = str(carry.get("space", "world"))
        if space not in ("home", "rv", "world"):
            space = "world"

        # Aim at the target tile center.
        tx = int(tx)
        ty = int(ty)
        target = pygame.Vector2((tx + 0.5) * float(self.TILE_SIZE), (ty + 0.5) * float(self.TILE_SIZE))
        start = pygame.Vector2(self.player.pos)
        d = target - start
        if d.length_squared() <= 0.001:
            d = pygame.Vector2(self.player.facing)
        if d.length_squared() <= 0.001:
            d = pygame.Vector2(1, 0)
        d = d.normalize()

        size_bonus = int(min(len(offsets), 6))
        speed = 220.0 + 18.0 * float(size_bonus)
        spawn = start + d * 10.0
        hp = carry.get("hp")
        self.thrown_furniture.append(
            HardcoreSurvivalState._ThrownFurniture(
                pos=pygame.Vector2(spawn),
                vel=pygame.Vector2(d) * float(speed),
                ttl=1.25,
                tid=int(tid),
                offsets=[(int(o[0]), int(o[1])) for o in offsets if isinstance(o, tuple) and len(o) == 2],
                space=str(space),
                hp=(int(hp) if hp is not None else None),
            )
        )
        self.home_move_carry = None
        self.app.play_sfx("swing")
        self._set_hint("", seconds=0.7)
        return True

    def _draw_world_furniture_carry_preview(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        if bool(getattr(self, "home_move_mode", False)):
            return
        carry = getattr(self, "home_move_carry", None)
        if not isinstance(carry, dict):
            return
        if getattr(self, "mount", None) is not None:
            return

        mp = self.app.screen_to_internal(pygame.mouse.get_pos())
        if mp is None:
            return
        mx, my = int(mp[0]), int(mp[1])
        anchor_tx, anchor_ty = self._screen_to_world_tile(int(mx), int(my), int(cam_x), int(cam_y))
        ok, cells = self._home_furniture_can_place_at(int(anchor_tx), int(anchor_ty))
        col = (120, 200, 140) if ok else (220, 90, 70)
        ts = int(self.TILE_SIZE)
        ghost = pygame.Surface((ts, ts), pygame.SRCALPHA)
        ghost.fill((int(col[0]), int(col[1]), int(col[2]), 60))
        for tx, ty in cells:
            r = self._world_tile_screen_rect(int(tx), int(ty), int(cam_x), int(cam_y))
            surface.blit(ghost, r.topleft)
            pygame.draw.rect(surface, col, r, 1)

        # Tiny hint near the cursor (minimal text).
        hint = "//"
        font = self.app.font_s
        w = int(font.size(hint)[0]) + 10
        h = int(font.get_height()) + 6
        bx = int(clamp(int(mx + 14), 4, int(INTERNAL_W - 4 - w)))
        by = int(clamp(int(my + 14), 4, int(INTERNAL_H - 4 - h)))
        panel = pygame.Rect(bx, by, w, h)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=6)
        pygame.draw.rect(surface, (90, 90, 110), panel, 1, border_radius=6)
        draw_text(surface, font, hint, (panel.centerx, panel.centery - 1), pygame.Color(230, 230, 240), anchor="center")

    def _draw_world_context_menu(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        self.world_ctx_open = False
        self.world_ctx_target = None
        self.world_ctx_rects = []
        if bool(getattr(self, "lamp_cfg_open", False)):
            return
        if bool(getattr(self, "home_move_mode", False)):
            return
        if isinstance(getattr(self, "home_move_carry", None), dict):
            return
        if getattr(self, "mount", None) is not None:
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return
        if float(getattr(self, "world_ctx_cooldown_left", 0.0)) > 0.0:
            return
        if float(getattr(self, "speech_left", 0.0)) > 0.0:
            return
        if str(getattr(self, "player_pose_space", "")) == "world" and str(getattr(self, "player_pose", "")) in ("sleep", "sit"):
            return

        tx, ty = self._player_tile()
        # If the player moved after an auto-dismiss, allow the bubble again.
        sup = getattr(self, "world_ctx_suppressed", None)
        if isinstance(sup, dict):
            pt = sup.get("player_tile")
            if isinstance(pt, tuple) and len(pt) == 2 and (int(tx), int(ty)) != (int(pt[0]), int(pt[1])):
                self.world_ctx_suppressed = None

        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        interact = {
            int(self.T_TABLE),
            int(self.T_SOFA),
            int(self.T_CHAIR),
            int(self.T_BED),
            int(self.T_FRIDGE),
            int(self.T_SHELF),
            int(self.T_CABINET),
            int(self.T_TV),
            int(self.T_PC),
            int(self.T_LAMP),
            int(self.T_SWITCH),
            int(self.T_TOILET),
            int(self.T_SINK),
        }
        pri = {
            int(self.T_LAMP): 0,
            int(self.T_FRIDGE): 1,
            int(self.T_SHELF): 1,
            int(self.T_CABINET): 1,
            int(self.T_TABLE): 1,
            int(self.T_SINK): 1,
            int(self.T_BED): 2,
            int(self.T_TOILET): 2,
            int(self.T_SOFA): 3,
            int(self.T_CHAIR): 3,
            int(self.T_PC): 4,
            int(self.T_TV): 4,
            int(self.T_SWITCH): 5,
        }
        chosen: tuple[int, int, int] | None = None
        best = None
        for cx, cy in candidates:
            tid = int(self.world.get_tile(int(cx), int(cy)))
            if tid not in interact:
                continue
            d = max(abs(int(cx) - int(tx)), abs(int(cy) - int(ty)))
            key = (int(pri.get(int(tid), 9)), int(d), int(cy), int(cx))
            if best is None or key < best:
                best = key
                chosen = (int(cx), int(cy), int(tid))
        if chosen is None:
            return

        cx, cy, tid = chosen
        sup = getattr(self, "world_ctx_suppressed", None)
        if isinstance(sup, dict):
            stgt = sup.get("target")
            pt = sup.get("player_tile")
            if (
                isinstance(stgt, tuple)
                and len(stgt) == 3
                and isinstance(pt, tuple)
                and len(pt) == 2
                and (int(tx), int(ty)) == (int(pt[0]), int(pt[1]))
                and (int(cx), int(cy), int(tid)) == (int(stgt[0]), int(stgt[1]), int(stgt[2]))
            ):
                return

        # Outline the whole connected block (2-tile bed/sofa/pc).
        seen: set[tuple[int, int]] = set()
        stack = [(int(cx), int(cy))]
        block: list[tuple[int, int]] = []
        while stack and len(block) < 24:
            sx, sy = stack.pop()
            sx = int(sx)
            sy = int(sy)
            if (sx, sy) in seen:
                continue
            seen.add((sx, sy))
            if int(self.world.get_tile(int(sx), int(sy))) != int(tid):
                continue
            block.append((int(sx), int(sy)))
            stack.extend([(sx + 1, sy), (sx - 1, sy), (sx, sy + 1), (sx, sy - 1)])
        if not block:
            block = [(int(cx), int(cy))]

        tile_rect: pygame.Rect | None = None
        for bx, by in block:
            r = self._world_tile_screen_rect(int(bx), int(by), int(cam_x), int(cam_y))
            tile_rect = r if tile_rect is None else tile_rect.union(r)
        if tile_rect is None:
            return
        # Pixel-perfect outline (no rounded corners).
        pygame.draw.rect(surface, (120, 100, 60), tile_rect.inflate(2, 2), 1)
        pygame.draw.rect(surface, (255, 220, 140), tile_rect, 1)

        # Build options.
        in_owned_space = bool(self._tile_in_home_world(int(cx), int(cy)) or self._tile_in_rv_world(int(cx), int(cy)))
        opts: list[tuple[str, str]] = []
        if int(tid) in (int(self.T_SOFA), int(self.T_CHAIR)):
            opts = [("", "move")]
            if in_owned_space:
                opts.insert(0, ("", "sit"))
        elif int(tid) == int(self.T_BED):
            opts = [("", "move")]
            if in_owned_space:
                opts.insert(0, ("", "sleep"))
        elif int(tid) in (int(self.T_FRIDGE), int(self.T_SHELF), int(self.T_CABINET)):
            opts = [("", "move")]
            if in_owned_space:
                opts.insert(0, ("", "open"))
        elif int(tid) == int(self.T_SINK):
            opts = [("", "move")]
            if in_owned_space:
                opts.insert(0, ("", "water"))
        elif int(tid) == int(self.T_TABLE):
            opts = [("", "move")]
        elif int(tid) == int(self.T_PC):
            opts = [("", "move")]
            if in_owned_space:
                opts.insert(0, ("", "pc"))
        elif int(tid) == int(self.T_STEER):
            opts = [("", "drive")]
        elif int(tid) == int(self.T_TV):
            opts = [("", "move")]
            if in_owned_space:
                tv_on = bool(getattr(self, "world_tv_states", {}).get((int(cx), int(cy)), False))
                opts.insert(0, ("" if tv_on else "", "tv"))
        elif int(tid) == int(self.T_LAMP):
            opts = [("", "move")]
            if in_owned_space:
                opts.insert(0, ("", "lamp_cfg"))
                opts.insert(0, ("" if bool(getattr(self, "home_light_on", True)) else "", "light"))
        elif int(tid) == int(self.T_SWITCH):
            opts = [("", "move")]
            if in_owned_space:
                opts.insert(0, ("", "lamp_cfg"))
                opts.insert(0, ("" if bool(getattr(self, "home_light_on", True)) else "", "light"))
        elif int(tid) == int(self.T_TOILET):
            opts = [("", "move")]
            if in_owned_space:
                opts.insert(0, ("", "poop"))
                opts.insert(0, ("", "pee"))
        if not opts:
            return

        # Compact menu (doesn't cover the whole room).
        btn_w = 32
        btn_h = 14
        gap = 3
        panel_w = int(len(opts) * btn_w + max(0, len(opts) - 1) * gap + 8)
        panel_h = int(btn_h + 8)
        px = int(tile_rect.centerx - panel_w // 2)
        py = int(tile_rect.top - panel_h - 8)
        if py < 4:
            py = int(tile_rect.bottom + 8)
        px = int(clamp(int(px), 4, int(INTERNAL_W - 4 - panel_w)))
        py = int(clamp(int(py), 4, int(INTERNAL_H - 4 - panel_h)))
        panel = pygame.Rect(px, py, panel_w, panel_h)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=5)
        pygame.draw.rect(surface, (90, 90, 110), panel, 1, border_radius=5)

        x0 = int(panel.x + 4)
        y0 = int(panel.y + 4)
        font = self.app.font_s
        rects: list[tuple[pygame.Rect, str]] = []
        for i, (label, action) in enumerate(opts):
            br = pygame.Rect(int(x0 + i * (btn_w + gap)), int(y0), int(btn_w), int(btn_h))
            pygame.draw.rect(surface, (28, 28, 34), br, border_radius=4)
            pygame.draw.rect(surface, (160, 160, 180), br, 1, border_radius=4)
            draw_text(surface, font, str(label), (br.centerx, br.centery - 1), pygame.Color(230, 230, 240), anchor="center")
            rects.append((br, str(action)))

        self.world_ctx_open = True
        self.world_ctx_target = (int(cx), int(cy), int(tid))
        self.world_ctx_rects = rects

    def _blit_sprite_outline(self, surface: pygame.Surface, spr: pygame.Surface, rect: pygame.Rect, *, color: tuple[int, int, int]) -> None:
        r, g, b = (int(color[0]), int(color[1]), int(color[2]))
        key = (id(spr), int(r), int(g), int(b))
        cache: dict[tuple[int, int, int, int], pygame.Surface] = getattr(self, "_sprite_outline_cache", {})
        out = cache.get(key)
        if out is None:
            mask = pygame.mask.from_surface(spr)
            shape = mask.to_surface(setcolor=(r, g, b, 255), unsetcolor=(0, 0, 0, 0))
            out = pygame.Surface((spr.get_width() + 2, spr.get_height() + 2), pygame.SRCALPHA)
            # 1px outline by stamping the silhouette around the sprite.
            out.blit(shape, (0, 1))
            out.blit(shape, (2, 1))
            out.blit(shape, (1, 0))
            out.blit(shape, (1, 2))
            cache[key] = out
            self._sprite_outline_cache = cache
        surface.blit(out, (int(rect.left) - 1, int(rect.top) - 1))
        surface.blit(spr, rect)

    def _draw_hover_tooltip(self, surface: pygame.Surface) -> None:
        tip = getattr(self, "_hover_tooltip", None)
        if tip is None:
            return
        lines, pos = tip
        if not lines:
            return
        mx, my = int(pos[0]), int(pos[1])

        font = self.app.font_s
        pad = 6
        line_h = max(10, int(font.get_height()))
        w = 0
        for ln in lines:
            w = max(w, int(font.size(str(ln))[0]))
        w = int(w + pad * 2)
        h = int(len(lines) * line_h + pad * 2)

        x = mx + 12
        y = my + 12
        if x + w > INTERNAL_W - 4:
            x = max(4, INTERNAL_W - 4 - w)
        if y + h > INTERNAL_H - 4:
            y = max(4, INTERNAL_H - 4 - h)

        panel = pygame.Rect(int(x), int(y), int(w), int(h))
        ui = pygame.Surface((panel.w, panel.h), pygame.SRCALPHA)
        ui.fill((10, 10, 14, 220))
        pygame.draw.rect(ui, (90, 90, 110, 235), ui.get_rect(), 1, border_radius=8)
        surface.blit(ui, panel.topleft)

        for i, ln in enumerate(lines):
            col = pygame.Color(240, 240, 244) if i == 0 else pygame.Color(180, 180, 190)
            draw_text(surface, font, str(ln), (panel.left + pad, panel.top + pad + i * line_h), col, anchor="topleft")

    def _draw_vehicle_props(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
    ) -> None:
        start_cx = start_tx // self.CHUNK_SIZE
        end_cx = end_tx // self.CHUNK_SIZE
        start_cy = start_ty // self.CHUNK_SIZE
        end_cy = end_ty // self.CHUNK_SIZE

        hovered = None  # (d2, spr, rect, lines, (mx,my))
        mouse = None
        if (
            not self.inv_open
            and not bool(getattr(self, "rv_ui_open", False))
            and not bool(getattr(self, "world_map_open", False))
        ):
            mouse = self.app.screen_to_internal(pygame.mouse.get_pos())

        for cy in range(start_cy, end_cy + 1):
            for cx in range(start_cx, end_cx + 1):
                chunk = self.world.peek_chunk(cx, cy)
                if chunk is None:
                    continue

                for car in getattr(chunk, "cars", []):
                    p = pygame.Vector2(getattr(car, "pos", pygame.Vector2(0, 0))) - pygame.Vector2(cam_x, cam_y)
                    sx = iround(float(p.x))
                    sy = iround(float(p.y))
                    if sx < -80 or sx > INTERNAL_W + 80 or sy < -80 or sy > INTERNAL_H + 80:
                        continue
                    mid = str(getattr(car, "model_id", "schoolbus"))
                    steer_state = int(getattr(car, "steer_state", 0))
                    frame = int(getattr(car, "frame", 0)) % 2
                    base = self._CAR_BASE.get((mid, int(steer_state), int(frame)))
                    shadow_base = self._CAR_SHADOW.get((mid, int(steer_state), int(frame)))
                    if base is None:
                        base = self._CAR_BASE.get(("schoolbus", 0, 0))
                        shadow_base = self._CAR_SHADOW.get(("schoolbus", 0, 0))
                        if base is None:
                            continue
                    deg = -math.degrees(float(getattr(car, "heading", 0.0)))
                    spr = rotate_pixel_sprite(base, deg, step_deg=5.0)
                    rect = spr.get_rect(center=(sx, sy))
                    if shadow_base is not None:
                        sh = rotate_pixel_sprite(shadow_base, deg, step_deg=5.0)
                        srect = sh.get_rect(center=(rect.centerx + 2, rect.centery + 6))
                        surface.blit(sh, srect)
                    surface.blit(spr, rect)
                    if mouse is not None:
                        mx, my = int(mouse[0]), int(mouse[1])
                        if rect.collidepoint(mx, my):
                            model = self._CAR_MODELS.get(str(mid))
                            name = model.name if model is not None else str(mid)
                            wpos = pygame.Vector2(getattr(car, "pos", pygame.Vector2(0, 0)))
                            try:
                                pad = 22
                                cmodel = self._CAR_MODELS.get(str(mid)) or self._CAR_MODELS.get("rv")
                                cw, ch = (cmodel.collider if cmodel is not None else (22, 14))
                                chead = float(getattr(car, "heading", 0.0))
                                c = abs(math.cos(float(chead)))
                                s = abs(math.sin(float(chead)))
                                ww = float(cw) * c + float(ch) * s
                                hh = float(cw) * s + float(ch) * c
                                aabb = pygame.Rect(
                                    iround(float(wpos.x) - float(ww) / 2.0),
                                    iround(float(wpos.y) - float(hh) / 2.0),
                                    int(max(2, int(round(float(ww))))),
                                    int(max(2, int(round(float(hh))))),
                                )
                                near = bool(
                                    aabb.inflate(int(pad * 2), int(pad * 2)).collidepoint(
                                        int(round(float(self.player.pos.x))), int(round(float(self.player.pos.y)))
                                    )
                                )
                            except Exception:
                                near = (self.player.pos - wpos).length_squared() <= (22.0 * 22.0)
                            if self.mount is None:
                                prompt = "F " if near else ": F "
                            else:
                                prompt = ""
                            lines = [f"{name}", ": ()", prompt]
                            if hasattr(car, "fuel"):
                                lines.insert(1, f": {int(getattr(car, 'fuel', 0.0))}")
                            d2 = float((mx - sx) * (mx - sx) + (my - sy) * (my - sy))
                            if hovered is None or d2 < float(hovered[0]):
                                hovered = (d2, spr, rect.copy(), lines, (mx, my))

                for b in getattr(chunk, "bikes", []):
                    p = pygame.Vector2(getattr(b, "pos", pygame.Vector2(0, 0))) - pygame.Vector2(cam_x, cam_y)
                    sx = iround(float(p.x))
                    sy = iround(float(p.y))
                    if sx < -40 or sx > INTERNAL_W + 40 or sy < -40 or sy > INTERNAL_H + 40:
                        continue
                    mid = str(getattr(b, "model_id", "bike"))
                    d = str(getattr(b, "dir", "right"))
                    frm = int(getattr(b, "frame", 0)) % 2
                    model = self._TWO_WHEEL_FRAMES.get(mid) or self._TWO_WHEEL_FRAMES.get("bike") or {}
                    frames = model.get(d) or model.get("right") or self._BIKE_FRAMES.get("right", [])
                    if not frames:
                        continue
                    spr = frames[min(int(frm), len(frames) - 1)]
                    _cw, ch = self._two_wheel_collider_px(mid)
                    ground_y = iround(float(sy) + float(ch) / 2.0)
                    rect = spr.get_rect()
                    baseline_y = int(self._sprite_baseline_y(spr))
                    rect.centerx = int(sx)
                    rect.bottom = iround(float(ground_y) + float(rect.h - baseline_y))
                    shadow = self._two_wheel_shadow_rect(rect, d, ground_y=int(ground_y))
                    sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
                    pygame.draw.ellipse(sh, (0, 0, 0, 120), sh.get_rect())
                    surface.blit(sh, shadow.topleft)
                    surface.blit(spr, rect)
                    if mouse is not None:
                        mx, my = int(mouse[0]), int(mouse[1])
                        if rect.collidepoint(mx, my):
                            name = self._two_wheel_name(str(mid))
                            wpos = pygame.Vector2(getattr(b, "pos", pygame.Vector2(0, 0)))
                            near = (self.player.pos - wpos).length_squared() <= (18.0 * 18.0)
                            if self.mount is None:
                                prompt = "F " if near else ": F "
                            else:
                                prompt = ""
                            lines = [f"{name}", ": ()", prompt]
                            if str(mid).startswith("moto"):
                                lines.insert(1, f": {int(getattr(b, 'fuel', 0.0))}")
                            d2 = float((mx - sx) * (mx - sx) + (my - sy) * (my - sy))
                            if hovered is None or d2 < float(hovered[0]):
                                hovered = (d2, spr, rect.copy(), lines, (mx, my))

        if hovered is None or mouse is None:
            return
        _d2, spr, rect, lines, mpos = hovered
        hi = (255, 245, 140)
        self._blit_sprite_outline(surface, spr, rect, color=hi)
        self._hover_tooltip = (list(lines), (int(mpos[0]), int(mpos[1])))

    def _draw_world_props(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
    ) -> None:
        # Mouse hover: outline + tooltip.
        hovered = None  # (d2, prop, sprite|None, rect, sx, sy)
        mouse = None
        if not self.inv_open and not bool(getattr(self, "rv_ui_open", False)) and not bool(
            getattr(self, "world_map_open", False)
        ):
            mouse = self.app.screen_to_internal(pygame.mouse.get_pos())

        # RV world-interior: hide outside props that fall inside the stamped interior area
        # (e.g., streetlamps on the sidewalk shouldn't appear inside the RV).
        rv_hide: tuple[int, int, int, int] | None = None
        if bool(getattr(self, "rv_world_interior", False)):
            key = getattr(self, "_rv_world_int_active_key", None)
            if isinstance(key, tuple) and len(key) == 4:
                try:
                    rv_hide = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
                except Exception:
                    rv_hide = None

        ts = int(self.TILE_SIZE)
        start_cx = start_tx // self.CHUNK_SIZE
        end_cx = end_tx // self.CHUNK_SIZE
        start_cy = start_ty // self.CHUNK_SIZE
        end_cy = end_ty // self.CHUNK_SIZE

        for cy in range(start_cy, end_cy + 1):
            for cx in range(start_cx, end_cx + 1):
                chunk = self.world.peek_chunk(cx, cy)
                if chunk is None:
                    continue
                for pr in getattr(chunk, "props", []):
                    if rv_hide is not None and ts > 0:
                        try:
                            px = float(getattr(getattr(pr, "pos", pygame.Vector2(0, 0)), "x", 0.0))
                            py = float(getattr(getattr(pr, "pos", pygame.Vector2(0, 0)), "y", 0.0))
                            tx = int(math.floor(px / float(ts)))
                            ty = int(math.floor(py / float(ts)))
                            rx0, ry0, rw, rh = rv_hide
                            if int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh):
                                continue
                        except Exception:
                            pass
                    sx = int(round(pr.pos.x - cam_x))
                    sy = int(round(pr.pos.y - cam_y))
                    if sx < -64 or sx > INTERNAL_W + 64 or sy < -64 or sy > INTERNAL_H + 64:
                        continue

                    pdef = self._PROP_DEFS.get(str(getattr(pr, "prop_id", "")))
                    spr = None
                    if pdef is not None:
                        sprites = getattr(pdef, "sprites", ())
                        if sprites:
                            idx = int(getattr(pr, "variant", 0)) % len(sprites)
                            spr = sprites[int(idx)]

                    if spr is not None:
                        rect = spr.get_rect(center=(sx, sy))
                        sw = max(4, int(rect.w) - 6)
                        shadow = pygame.Rect(0, 0, sw, 4)
                        shadow.center = (rect.centerx, rect.bottom - 1)
                        sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
                        pygame.draw.ellipse(sh, (0, 0, 0, 100), sh.get_rect())
                        surface.blit(sh, shadow.topleft)
                        surface.blit(spr, rect)
                    else:
                        rect = pygame.Rect(sx - 4, sy - 4, 8, 8)
                        pygame.draw.rect(surface, (0, 0, 0), rect)
                        pygame.draw.rect(surface, (210, 80, 220), rect.inflate(-2, -2))

                    if mouse is not None:
                        mx, my = int(mouse[0]), int(mouse[1])
                        if rect.collidepoint(mx, my):
                            d2 = float((mx - sx) * (mx - sx) + (my - sy) * (my - sy))
                            if hovered is None or d2 < float(hovered[0]):
                                hovered = (d2, pr, spr if spr is not None else None, rect.copy(), int(sx), int(sy))

        if hovered is None or mouse is None:
            return

        _d2, pr, spr, rect, _sx, _sy = hovered
        hi = (255, 245, 140)
        if spr is not None:
            self._blit_sprite_outline(surface, spr, rect, color=hi)
        else:
            pygame.draw.rect(surface, hi, rect, 1)

        pdef = self._PROP_DEFS.get(str(getattr(pr, "prop_id", "")))
        name = pdef.name if pdef is not None else str(getattr(pr, "prop_id", "prop"))
        cat = pdef.category if pdef is not None else ""
        self._hover_tooltip = ([name, f": {cat}"], (int(mouse[0]), int(mouse[1])))

    def _draw_world_items(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
    ) -> None:
        # Mouse hover: outline + tooltip.
        hovered = None  # (d2, item, sprite|None, rect, sx, sy)
        mouse = None
        if not self.inv_open and not bool(getattr(self, "rv_ui_open", False)) and not bool(getattr(self, "world_map_open", False)):
            mouse = self.app.screen_to_internal(pygame.mouse.get_pos())

        # Proximity highlight: nearest pickup (keyboard-friendly).
        near_item: HardcoreSurvivalState._WorldItem | None = None
        near_spr: pygame.Surface | None = None
        near_rect: pygame.Rect | None = None
        if not self.inv_open and not bool(getattr(self, "rv_ui_open", False)) and not bool(getattr(self, "world_map_open", False)):
            _nchunk, near_item = self._find_nearest_item(radius_px=20.0)

        start_cx = start_tx // self.CHUNK_SIZE
        end_cx = end_tx // self.CHUNK_SIZE
        start_cy = start_ty // self.CHUNK_SIZE
        end_cy = end_ty // self.CHUNK_SIZE

        for cy in range(start_cy, end_cy + 1):
            for cx in range(start_cx, end_cx + 1):
                chunk = self.world.peek_chunk(cx, cy)
                if chunk is None:
                    continue
                for it in chunk.items:
                    # Hide items inside cutaway buildings unless the player is inside.
                    # Otherwise loot can appear "on" the facade/roof when the interior is hidden.
                    y_off = 0
                    try:
                        itx = int(math.floor(float(it.pos.x) / float(self.TILE_SIZE)))
                        ity = int(math.floor(float(it.pos.y) / float(self.TILE_SIZE)))
                        hit = self._peek_building_at_tile(int(itx), int(ity))
                        if hit is not None:
                            btx0, bty0, bw, bh = int(hit[0]), int(hit[1]), int(hit[2]), int(hit[3])
                            inside_key = getattr(self, "_inside_building_key", None)
                            same_building = (
                                isinstance(inside_key, tuple)
                                and len(inside_key) == 4
                                and (int(inside_key[0]), int(inside_key[1]), int(inside_key[2]), int(inside_key[3]))
                                == (int(btx0), int(bty0), int(bw), int(bh))
                            )
                            if not same_building:
                                continue
                            visible = getattr(self, "_inside_building_visible", None)
                            if isinstance(visible, set) and (int(itx), int(ity)) not in visible:
                                continue
                            # Shelf loot: lift the sprite a bit so it reads like "on the shelf".
                            try:
                                for nx, ny in ((itx + 1, ity), (itx - 1, ity), (itx, ity + 1), (itx, ity - 1)):
                                    if int(self.world.peek_tile(int(nx), int(ny))) == int(self.T_SHELF):
                                        y_off = -4
                                        break
                            except Exception:
                                y_off = 0
                    except Exception:
                        pass
                    sx = iround(float(it.pos.x) - float(cam_x))
                    sy = iround(float(it.pos.y) - float(cam_y)) + int(y_off)
                    if sx < -8 or sx > INTERNAL_W + 8 or sy < -8 or sy > INTERNAL_H + 8:
                        continue
                    self._ensure_item_visuals(it.item_id)
                    spr = self._ITEM_SPRITES_WORLD.get(it.item_id) or self._ITEM_SPRITES.get(it.item_id)
                    if spr is not None:
                        rect = spr.get_rect()
                        rect.midbottom = (sx, sy + 6)
                        sw = max(4, rect.w - 8)
                        shadow = pygame.Rect(0, 0, sw, 5)
                        shadow.center = (sx, sy + 4)
                        pygame.draw.ellipse(surface, (0, 0, 0), shadow)  
                        surface.blit(spr, rect)
                    else:
                        icon = self._ITEM_ICONS.get(it.item_id)
                        if icon is None:
                            idef = self._ITEMS.get(it.item_id)
                            col = idef.color if idef is not None else (255, 0, 255)
                            rect = pygame.Rect(sx - 3, sy - 3, 6, 6)
                            pygame.draw.rect(surface, (0, 0, 0), rect)
                            pygame.draw.rect(surface, col, rect.inflate(-2, -2))
                        else:
                            bg = pygame.Rect(sx - 5, sy - 5, 10, 10)
                            pygame.draw.rect(surface, (0, 0, 0), bg, border_radius=3)
                            rect = icon.get_rect(center=(sx, sy))
                            surface.blit(icon, rect)

                    if near_item is not None and it is near_item and rect is not None:
                        near_spr = spr if spr is not None else None
                        near_rect = rect.copy()

                    if mouse is not None and rect is not None:
                        mx, my = int(mouse[0]), int(mouse[1])
                        if rect.collidepoint(mx, my):
                            d2 = float((mx - sx) * (mx - sx) + (my - sy) * (my - sy))
                            if hovered is None or d2 < float(hovered[0]):
                                hovered = (d2, it, spr if spr is not None else None, rect.copy(), int(sx), int(sy))

        if near_item is not None and near_rect is not None:
            hi_near = (120, 200, 140)
            hovered_item = hovered[1] if hovered is not None else None
            if hovered_item is not near_item:
                if near_spr is not None:
                    self._blit_sprite_outline(surface, near_spr, near_rect, color=hi_near)
                else:
                    pygame.draw.rect(surface, (0, 0, 0), near_rect.inflate(6, 6), 1)
                    pygame.draw.rect(surface, hi_near, near_rect.inflate(4, 4), 1)

        if hovered is None or mouse is None:
            return

        _d2, it, spr, rect, _sx, _sy = hovered
        hi = (255, 245, 140)
        if spr is not None:
            self._blit_sprite_outline(surface, spr, rect, color=hi)
        else:
            pygame.draw.rect(surface, (0, 0, 0), rect.inflate(6, 6), 1)
            pygame.draw.rect(surface, hi, rect.inflate(4, 4), 1)

        idef = self._ITEMS.get(it.item_id)
        name = idef.name if idef is not None else str(it.item_id)
        qty = int(getattr(it, "qty", 1))
        kind = str(getattr(idef, "kind", "")) if idef is not None else ""
        kind_map = {
            "food": "",
            "drink": "",
            "med": "",
            "ammo": "",
            "mat": "",
            "gun": "",
        }
        klabel = kind_map.get(kind, "") if kind else ""
        first = f"{name}  x{qty}" if qty > 1 else name
        self._hover_tooltip = ([first, f": {klabel}", "E "], (int(mouse[0]), int(mouse[1])))

    def _draw_rv(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        # When inside the RV interior (world-tile mode), hide the exterior sprite
        # so the stamped interior space is visible and walkable.
        if bool(getattr(self, "rv_world_interior", False)):
            return
        rvp = pygame.Vector2(self.rv.pos) - pygame.Vector2(cam_x, cam_y)        
        moving = self.mount == "rv" and abs(float(self.rv.speed)) > 6.0
        frame = int(self.rv_anim) % 2 if moving else 0
        steer_state = 0
        if abs(float(self.rv.steer)) > 0.08:
            steer_state = 1 if float(self.rv.steer) > 0.0 else -1
        mid = getattr(self.rv, "model_id", "schoolbus")
        base = self._CAR_BASE.get((str(mid), int(steer_state), int(frame)))
        shadow_base = self._CAR_SHADOW.get((str(mid), int(steer_state), int(frame)))
        if base is None:
            base = self._CAR_BASE.get(("schoolbus", int(steer_state), int(frame)))
            shadow_base = self._CAR_SHADOW.get(("schoolbus", int(steer_state), int(frame)))
            if base is None:
                return
        deg = -math.degrees(float(self.rv.heading))
        spr = rotate_pixel_sprite(base, deg, step_deg=5.0)

        rect = spr.get_rect(center=(int(round(rvp.x)), int(round(rvp.y))))
        if shadow_base is not None:
            shadow = rotate_pixel_sprite(shadow_base, deg, step_deg=5.0)        
            srect = shadow.get_rect(center=(rect.centerx + 2, rect.centery + 6))
            surface.blit(shadow, srect)
        surface.blit(spr, rect)

        mouse = None
        if (
            not self.inv_open
            and not bool(getattr(self, "rv_ui_open", False))
            and not bool(getattr(self, "world_map_open", False))
        ):
            mouse = self.app.screen_to_internal(pygame.mouse.get_pos())
        if mouse is not None:
            mx, my = int(mouse[0]), int(mouse[1])
            if rect.collidepoint(mx, my):
                model = self._CAR_MODELS.get(str(mid))
                name = model.name if model is not None else str(mid)
                is_rv_model = str(mid) == "rv"
                try:
                    pad = 22
                    near = bool(
                        self._rv_collider_rect_at()
                        .inflate(int(pad * 2), int(pad * 2))
                        .collidepoint(int(round(float(self.player.pos.x))), int(round(float(self.player.pos.y))))
                    )
                except Exception:
                    near = (self.player.pos - self.rv.pos).length_squared() <= (22.0 * 22.0)
                if self.mount == "rv":
                    prompt = "F   |  H "
                else:
                    if is_rv_model:
                        prompt = "F   |  H " if near else ": F  / H "
                    else:
                        prompt = "F " if near else ": F "
                lines = [f"{name}", f": {int(self.rv.fuel)}", prompt]
                hi = (255, 245, 140)
                self._blit_sprite_outline(surface, spr, rect, color=hi)
                self._hover_tooltip = (lines, (mx, my))

    def _draw_rv_drive_overlay(self, surface: pygame.Surface) -> None:
        # Disabled: RV cabin driving view removed (outside view only).
        return

    def _draw_bike(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        # Pixel-lock two-wheeler drawing to match the pixel-locked camera (reduces jitter).
        try:
            if self.mount == "bike":
                bwx, bwy = getattr(self, "_player_pixel_lock_world_xy")
                bwx = int(bwx)
                bwy = int(bwy)
            else:
                bwx = int(math.floor(float(self.bike.pos.x)))
                bwy = int(math.floor(float(self.bike.pos.y)))
        except Exception:
            bwx = int(math.floor(float(getattr(getattr(self.bike, "pos", None), "x", 0.0))))
            bwy = int(math.floor(float(getattr(getattr(self.bike, "pos", None), "y", 0.0))))

        bp = pygame.Vector2(float(bwx - int(cam_x)), float(bwy - int(cam_y)))
        moving = self.mount == "bike" and self.bike.vel.length_squared() > 0.1
        frame = int(self.bike_anim) % 2 if moving else 0
        d = getattr(self, "bike_dir", "right")
        mid = str(getattr(self.bike, "model_id", "bike"))
        model = self._TWO_WHEEL_FRAMES.get(mid) or self._TWO_WHEEL_FRAMES.get("bike") or {}
        frames = model.get(str(d)) or model.get("right") or self._BIKE_FRAMES.get("right", [])
        if not frames:
            return
        spr = frames[min(int(frame), len(frames) - 1)]
        ground_y = iround(float(bp.y) + float(getattr(self.bike, "h", 10)) / 2.0)
        rect = spr.get_rect()
        baseline_y = int(self._sprite_baseline_y(spr))
        rect.centerx = int(bp.x)
        rect.bottom = int(int(ground_y) + int(rect.h - baseline_y))

        # Soft ground shadow so the two-wheeler doesn't look like it's floating.
        shadow = self._two_wheel_shadow_rect(rect, str(d), ground_y=int(ground_y))
        sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)       
        pygame.draw.ellipse(sh, (0, 0, 0, 130), sh.get_rect())
        surface.blit(sh, shadow.topleft)
        surface.blit(spr, rect)

        mouse = None
        if (
            not self.inv_open
            and not bool(getattr(self, "rv_ui_open", False))
            and not bool(getattr(self, "world_map_open", False))
        ):
            mouse = self.app.screen_to_internal(pygame.mouse.get_pos())
        if mouse is not None:
            mx, my = int(mouse[0]), int(mouse[1])
            if rect.collidepoint(mx, my):
                near = (self.player.pos - self.bike.pos).length_squared() <= (18.0 * 18.0)
                if self.mount == "bike":
                    prompt = "F "
                else:
                    prompt = "F " if near else ": F "
                lines = [self._two_wheel_name(mid), ": ", prompt]
                if str(mid).startswith("moto"):
                    lines.insert(1, f": {int(getattr(self.bike, 'fuel', 0.0))}")
                hi = (255, 245, 140)
                self._blit_sprite_outline(surface, spr, rect, color=hi)
                self._hover_tooltip = (lines, (mx, my))

        if self.mount == "bike":
            rider: pygame.Surface | None = None
            rf = getattr(self, "cyclist_frames", getattr(self, "_CYCLIST_FRAMES", {})).get(d)
            if rf:
                rider = rf[int(frame) % len(rf)]
            else:
                pf = getattr(self, "player_frames", self._PLAYER_FRAMES)
                frames = pf.get(d, pf["down"])
                if frames:
                    if moving and len(frames) > 1:
                        walk = frames[1:]
                        rider = walk[int(self.bike_anim) % len(walk)]     
                    else:
                        rider = frames[0]

            if rider is not None:
                rrect = rider.get_rect()
                seat_from_ground = 4 if d in ("up", "down") else 3
                if str(mid).startswith("moto"):
                    seat_from_ground = max(2, int(seat_from_ground) - 1)
                rrect.midbottom = (rect.centerx, int(int(ground_y) - int(seat_from_ground)))
                surface.blit(rider, rrect)
            else:
                hair = self._PLAYER_PAL["H"]
                skin = self._PLAYER_PAL["S"]
                coat = self._PLAYER_PAL["C"]
                hx = rect.centerx
                hy = rect.centery - 6
                pygame.draw.rect(surface, hair, pygame.Rect(hx - 2, hy - 3, 4, 3))
                pygame.draw.rect(surface, skin, pygame.Rect(hx - 2, hy, 4, 3))
                pygame.draw.rect(surface, coat, pygame.Rect(hx - 3, hy + 3, 6, 4))

    def _roof_surface(self, w_tiles: int, h_tiles: int, alpha: int, *, roof_kind: int = 0) -> pygame.Surface:
        w_tiles = max(1, int(w_tiles))
        h_tiles = max(1, int(h_tiles))
        alpha = int(clamp(int(alpha), 0, 255))
        w_px = w_tiles * self.TILE_SIZE
        h_px = h_tiles * self.TILE_SIZE
        roof_kind = int(roof_kind) & 0xFFFFFFFF
        key = (w_px, h_px, alpha, roof_kind)
        cached = self._roof_cache.get(key)
        if cached is not None:
            return cached

        style = int((roof_kind >> 8) & 0xFF)
        var = int(roof_kind & 0xFF)

        def tint(c: tuple[int, int, int], dv: int) -> tuple[int, int, int]:
            return (
                int(clamp(int(c[0]) + dv, 0, 255)),
                int(clamp(int(c[1]) + dv, 0, 255)),
                int(clamp(int(c[2]) + dv, 0, 255)),
            )

        # Stronger per-building roof palette so city blocks read distinctly.
        dv = (var % 9) - 4
        base_rgb = (28, 28, 34)
        stripe_rgb = (44, 44, 54)
        accent_rgb = (70, 70, 86)
        outline_rgb = (10, 10, 12)
        if style == 1:  # 
            base_rgb = (62, 48, 36)
            stripe_rgb = (82, 60, 44)
            accent_rgb = (110, 80, 58)
        elif style == 2:  # 
            base_rgb = (34, 36, 40)
            stripe_rgb = (52, 54, 60)
            accent_rgb = (90, 92, 98)
        elif style == 3:  # 
            base_rgb = (74, 78, 88)
            stripe_rgb = (106, 110, 122)
            accent_rgb = (170, 174, 186)
        elif style == 4:  # 
            base_rgb = (18, 18, 22)
            stripe_rgb = (34, 34, 40)
            accent_rgb = (66, 66, 78)
        elif style == 5:  # 
            base_rgb = (72, 54, 34)
            stripe_rgb = (98, 72, 44)
            accent_rgb = (134, 100, 62)
        elif style == 6:  # 
            base_rgb = (42, 46, 62)
            stripe_rgb = (62, 66, 86)
            accent_rgb = (104, 110, 142)
        elif style == 7:  # 
            base_rgb = (36, 44, 66)
            stripe_rgb = (56, 66, 98)
            accent_rgb = (232, 200, 120)
        elif style == 8:  # 
            base_rgb = (34, 64, 44)
            stripe_rgb = (52, 92, 62)
            accent_rgb = (200, 170, 110)
        elif style == 9:  # 
            base_rgb = (34, 34, 40)
            stripe_rgb = (62, 52, 52)
            accent_rgb = (220, 140, 90)

        base_rgb = tint(base_rgb, dv)
        stripe_rgb = tint(stripe_rgb, dv)
        accent_rgb = tint(accent_rgb, dv)

        roof = pygame.Surface((w_px, h_px), pygame.SRCALPHA)
        roof.fill((*base_rgb, alpha))

        if style == 2:
            # Flat roof + HVAC units.
            for y in range(0, h_px, 5):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (0, y), (w_px - 1, y), 1)
            unit = (*accent_rgb, alpha)
            for uy in range(6 + (var % 3), h_px - 6, 14):
                for ux in range(6 + ((var >> 2) % 5), w_px - 8, 18):
                    if ((ux + uy + var) % 3) != 0:
                        continue
                    pygame.draw.rect(roof, unit, pygame.Rect(ux, uy, 7, 4), border_radius=1)
            # Long skylight strips (makes supermarkets read big/flat).
            if w_px >= 26 and h_px >= 16:
                glass = (110, 140, 168, alpha)
                frame = (*outline_rgb, alpha)
                for sy in range(8 + (var % 7), h_px - 10, 18):
                    if ((sy + var) % 2) != 0:
                        continue
                    sky = pygame.Rect(6, sy, w_px - 12, 5)
                    roof.fill(glass, sky)
                    pygame.draw.rect(roof, frame, sky, 1, border_radius=1)
        elif style == 3:
            # Medical roof: light + cross marks.
            for y in range(0, h_px, 4):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (0, y), (w_px - 1, y), 1)
            cross = (*accent_rgb, alpha)
            for cy in range(8, h_px - 8, 18):
                for cx in range(8, w_px - 8, 18):
                    if ((cx + cy + var) % 2) != 0:
                        continue
                    roof.fill(cross, pygame.Rect(cx - 1, cy - 3, 2, 7))
                    roof.fill(cross, pygame.Rect(cx - 3, cy - 1, 7, 2))
        elif style == 4:
            # Bars / grid.
            for x in range(0, w_px, 4):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (x, 0), (x, h_px - 1), 1)
            for y in range(0, h_px, 8):
                pygame.draw.line(roof, (*accent_rgb, alpha), (0, y), (w_px - 1, y), 1)
        elif style == 5:
            # Skylights.
            for y in range(0, h_px, 4):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (0, y), (w_px - 1, y), 1)
            sky = (*accent_rgb, alpha)
            for uy in range(6, h_px - 8, 12):
                for ux in range(6, w_px - 10, 20):
                    if ((ux * 3 + uy * 5 + var) % 4) != 0:
                        continue
                    roof.fill(sky, pygame.Rect(ux, uy, 10, 4))
            # Small solar-panel array for schools.
            if w_px >= 26 and h_px >= 18:
                panel = (46, 70, 88, alpha)
                frame = (*outline_rgb, alpha)
                px0 = 6
                py0 = int(h_px - 12)
                for i in range(0, min(4, int((w_px - 12) // 10))):
                    r = pygame.Rect(px0 + i * 10, py0, 8, 4)
                    roof.fill(panel, r)
                    pygame.draw.rect(roof, frame, r, 1, border_radius=1)
        elif style == 1:
            # Two-tone gable shading + shingles.
            ridge_y = int(h_px // 2)
            roof.fill((*tint(base_rgb, -10), alpha), pygame.Rect(0, 0, w_px, ridge_y))
            roof.fill((*tint(base_rgb, 8), alpha), pygame.Rect(0, ridge_y, w_px, h_px - ridge_y))
            # Shingles diagonal.
            for y in range(-w_px, h_px, 4):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (0, y), (w_px - 1, y + w_px - 1), 1)
            # A subtle ridge line to sell "house roof" at small sizes.
            if w_px >= 16 and h_px >= 12:
                ridge = (*tint(accent_rgb, 16), alpha)
                ry = int(h_px // 2)
                pygame.draw.line(roof, ridge, (1, ry), (w_px - 2, ry), 1)
            # Chimney.
            if w_px >= 26 and h_px >= 18:
                cx = 6 if (var & 1) == 0 else (w_px - 11)
                cy = 6 + (var % 5)
                chim = pygame.Rect(int(cx), int(cy), 5, 7)
                roof.fill((*tint(accent_rgb, 26), alpha), chim)
                pygame.draw.rect(roof, (*outline_rgb, alpha), chim, 1)
                roof.fill((*tint(accent_rgb, 42), alpha), pygame.Rect(chim.x + 1, chim.y + 1, chim.w - 2, 1))
        elif style == 6:
            # High-rise: service roof (vents + access hatches).
            for y in range(0, h_px, 6):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (0, y), (w_px - 1, y), 1)
            vent = (*accent_rgb, alpha)
            hatch = (*tint(accent_rgb, 22), alpha)
            for uy in range(6 + (var % 3), h_px - 6, 12):
                for ux in range(6 + ((var >> 2) % 4), w_px - 6, 12):
                    if ((ux + uy + var) % 3) != 0:
                        continue
                    roof.fill(vent, pygame.Rect(ux, uy, 4, 3))
                    roof.fill(vent, pygame.Rect(ux + 1, uy + 1, 2, 1))
            if w_px >= 26 and h_px >= 18:
                hx = int(w_px - 14)
                hy = int(6 + (var % 5))
                pygame.draw.rect(roof, hatch, pygame.Rect(hx, hy, 10, 6), border_radius=1)
                pygame.draw.rect(
                    roof,
                    (*tint(outline_rgb, 24), alpha),
                    pygame.Rect(hx, hy, 10, 6),
                    1,
                    border_radius=1,
                )
            # Elevator core / roof access (makes high-rises instantly recognizable).
            if w_px >= 28 and h_px >= 28:
                cx = int(w_px // 2 - 6)
                cy = int(h_px // 2 - 6)
                core = pygame.Rect(cx, cy, 12, 12)
                roof.fill((*tint(accent_rgb, 30), alpha), core)
                pygame.draw.rect(roof, (*outline_rgb, alpha), core, 1, border_radius=1)
                roof.fill((*tint(accent_rgb, 52), alpha), pygame.Rect(core.x + 3, core.y + 3, core.w - 6, 1))
        elif style == 7:
            # Bookstore: flat roof + small skylights.
            for y in range(0, h_px, 5):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (0, y), (w_px - 1, y), 1)
            if w_px >= 22 and h_px >= 16:
                glass = (110, 140, 168, alpha)
                frame = (*outline_rgb, alpha)
                for uy in range(6 + (var % 4), h_px - 8, 14):
                    for ux in range(6 + ((var >> 2) % 4), w_px - 10, 18):
                        if ((ux + uy + var) % 3) != 0:
                            continue
                        sky = pygame.Rect(int(ux), int(uy), 8, 4)
                        roof.fill(glass, sky)
                        pygame.draw.rect(roof, frame, sky, 1, border_radius=1)
        elif style == 8:
            # Chinese-style tiled roof + ridge line.
            for y in range(0, h_px, 3):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (0, y), (w_px - 1, y), 1)
            if w_px >= 16 and h_px >= 12:
                ry = int(h_px // 2)
                ridge = (*tint(accent_rgb, 18), alpha)
                pygame.draw.line(roof, ridge, (2, ry), (w_px - 3, ry), 1)
                eave = (*tint(accent_rgb, 34), alpha)
                roof.fill(eave, pygame.Rect(1, 1, 2, 2))
                roof.fill(eave, pygame.Rect(w_px - 3, 1, 2, 2))
                roof.fill(eave, pygame.Rect(1, h_px - 3, 2, 2))
                roof.fill(eave, pygame.Rect(w_px - 3, h_px - 3, 2, 2))
        elif style == 9:
            # Gun shop: darker roof with "warning" diagonals + a few vents.
            for x in range(-h_px, w_px + h_px, 6):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (x, 0), (x + h_px, h_px - 1), 1)
            vent = (*accent_rgb, alpha)
            frame = (*outline_rgb, alpha)
            for uy in range(6 + (var % 3), h_px - 6, 14):
                for ux in range(6 + ((var >> 2) % 5), w_px - 10, 18):
                    if ((ux + uy + var) % 3) != 0:
                        continue
                    r = pygame.Rect(int(ux), int(uy), 7, 4)
                    roof.fill(vent, r)
                    pygame.draw.rect(roof, frame, r, 1, border_radius=1)
        else:
            # Default subtle stripes.
            for y in range(0, h_px, 4):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (0, y), (w_px - 1, y), 1)

        # Big visual identifiers per building type so roofs don't all read the same.
        if alpha > 0:
            if style == 3 and w_px >= 22 and h_px >= 22:
                # Hospital: central cross pad.
                cx = int(w_px // 2)
                cy = int(h_px // 2)
                pad = pygame.Rect(int(cx - 8), int(cy - 8), 17, 17)
                pygame.draw.rect(roof, (232, 232, 238, alpha), pad, border_radius=2)
                pygame.draw.rect(roof, (*outline_rgb, alpha), pad, 1, border_radius=2)
                red = (190, 56, 56, alpha)
                roof.fill(red, pygame.Rect(int(cx - 2), int(cy - 7), 5, 15))
                roof.fill(red, pygame.Rect(int(cx - 7), int(cy - 2), 15, 5))
                ring = (210, 210, 220, alpha)
                pygame.draw.circle(roof, ring, (int(cx), int(cy)), 9, 1)
            elif style == 2 and w_px >= 22 and h_px >= 14:
                # Supermarket: bold stripe + logo block.
                band = pygame.Rect(0, int(h_px // 2 - 2), int(w_px), 5)
                roof.fill((34, 92, 56, alpha), band)
                roof.fill((170, 54, 54, alpha), pygame.Rect(0, int(band.y), int(w_px), 1))
                logo = pygame.Rect(int(w_px // 2 - 4), int(h_px // 2 - 4), 8, 8)
                pygame.draw.rect(roof, (232, 190, 88, alpha), logo, border_radius=2)
                pygame.draw.rect(roof, (*outline_rgb, alpha), logo, 1, border_radius=2)
            elif style == 7 and w_px >= 18 and h_px >= 18:
                # Bookstore: simple "book" mark.
                cx = int(w_px // 2)
                cy = int(h_px // 2)
                ink = (232, 200, 120, alpha)
                pygame.draw.rect(roof, ink, pygame.Rect(cx - 8, cy - 5, 7, 10), 1, border_radius=1)
                pygame.draw.rect(roof, ink, pygame.Rect(cx + 1, cy - 5, 7, 10), 1, border_radius=1)
                roof.fill((10, 10, 12, alpha), pygame.Rect(cx - 1, cy - 5, 2, 10))
            elif style == 8 and w_px >= 18 and h_px >= 18:
                # Chinese roof: central ridge ornament.
                cx = int(w_px // 2)
                cy = int(h_px // 2)
                gold = (210, 180, 110, alpha)
                roof.fill(gold, pygame.Rect(cx - 1, cy - 7, 2, 15))
                roof.fill(gold, pygame.Rect(cx - 5, cy - 1, 10, 2))
            elif style == 4 and w_px >= 18 and h_px >= 18:
                # Prison: perimeter wire marks.
                wire = (*tint(stripe_rgb, 28), alpha)
                pygame.draw.rect(roof, wire, pygame.Rect(1, 1, w_px - 2, h_px - 2), 1)
                for x in range(3, w_px - 3, 5):
                    roof.fill(wire, pygame.Rect(x, 1, 1, 1))
                    roof.fill(wire, pygame.Rect(x, h_px - 2, 1, 1))
                for y in range(3, h_px - 3, 5):
                    roof.fill(wire, pygame.Rect(1, y, 1, 1))
                    roof.fill(wire, pygame.Rect(w_px - 2, y, 1, 1))
                # Corner watch-tower blocks.
                tower = (*tint(accent_rgb, 24), alpha)
                for ox, oy in ((2, 2), (w_px - 8, 2), (2, h_px - 8), (w_px - 8, h_px - 8)):
                    if ((ox + oy + var) % 2) != 0:
                        continue
                    r = pygame.Rect(int(ox), int(oy), 6, 6)
                    roof.fill(tower, r)
                    pygame.draw.rect(roof, (*outline_rgb, alpha), r, 1, border_radius=1)
                    roof.fill((*tint(accent_rgb, 54), alpha), pygame.Rect(r.x + 2, r.y + 2, 2, 2))
            elif style == 5 and w_px >= 22 and h_px >= 16:
                # School: a bright gym roof patch.
                gym = pygame.Rect(4, 4, w_px - 8, max(6, h_px // 2 - 2))
                pygame.draw.rect(roof, (*tint(accent_rgb, 34), alpha), gym, border_radius=2)
                pygame.draw.rect(roof, (*outline_rgb, alpha), gym, 1, border_radius=2)
                # Tiny "S" mark to make schools readable even in clusters.
                if gym.w >= 18 and gym.h >= 10:
                    sx = int(gym.centerx)
                    sy = int(gym.centery)
                    ink = (*outline_rgb, alpha)
                    roof.fill(ink, pygame.Rect(sx - 5, sy - 3, 10, 2))
                    roof.fill(ink, pygame.Rect(sx - 5, sy + 1, 10, 2))
                    roof.fill(ink, pygame.Rect(sx - 5, sy - 1, 2, 2))
                    roof.fill(ink, pygame.Rect(sx + 3, sy - 1, 2, 2))

        # Hint storefront/facade signage to make city blocks read more like the reference.
        if alpha > 0 and w_px >= 18 and h_px >= 14:
            face = int(var) & 3  # 0=top,1=bottom,2=left,3=right
            if style in (2, 3):
                sign_rgb = tint(accent_rgb, 26)
                text_rgb = tint(accent_rgb, 44)
            elif style == 6:
                sign_rgb = tint(accent_rgb, 18)
                text_rgb = tint(accent_rgb, 34)
            else:
                sign_rgb = tint(stripe_rgb, 18)
                text_rgb = tint(stripe_rgb, 34)

            sw = int(min(w_px - 6, 34 + (var % 10)))
            sh = 5
            if face == 0:
                sign = pygame.Rect(3, 3, sw, sh)
            elif face == 1:
                sign = pygame.Rect(3, h_px - 3 - sh, sw, sh)
            elif face == 2:
                sign = pygame.Rect(3, 3, sh, int(min(h_px - 6, 26 + (var % 8))))
            else:
                sign = pygame.Rect(w_px - 3 - sh, 3, sh, int(min(h_px - 6, 26 + (var % 8))))
            roof.fill((*sign_rgb, alpha), sign)

            # Tiny pseudo-text pixels.
            if sign.w >= sign.h:
                ty = sign.y + 2
                for x in range(sign.x + 2, sign.right - 2, 3):
                    if ((x + var) % 5) == 0:
                        roof.fill((*text_rgb, alpha), pygame.Rect(x, ty, 2, 1))
            else:
                tx = sign.x + 2
                for y in range(sign.y + 2, sign.bottom - 2, 3):
                    if ((y + var) % 5) == 0:
                        roof.fill((*text_rgb, alpha), pygame.Rect(tx, y, 1, 2))

        # Extra rooftop props for high-rises.
        if style == 6 and w_px >= 20 and h_px >= 20:
            tank = (*accent_rgb, alpha)
            for ox, oy in ((6, 6), (w_px - 11, 6), (6, h_px - 11), (w_px - 11, h_px - 11)):
                if ((ox + oy + var) % 3) != 0:
                    continue
                pygame.draw.rect(roof, tank, pygame.Rect(int(ox), int(oy), 5, 5), border_radius=1)

        # Roof outline + subtle highlight edge so different roof palettes pop.
        if alpha > 0 and w_px >= 3 and h_px >= 3:
            pygame.draw.rect(roof, (*outline_rgb, alpha), roof.get_rect(), 1)
            hi = (*tint(base_rgb, 22), alpha)
            roof.fill(hi, pygame.Rect(1, h_px - 2, w_px - 2, 1))
            roof.fill(hi, pygame.Rect(w_px - 2, 1, 1, h_px - 2))
        self._roof_cache[key] = roof
        return roof

    def _building_roof_style_var(self, roof_kind: int) -> tuple[int, int]:
        roof_kind = int(roof_kind) & 0xFFFFFFFF
        style = int((roof_kind >> 8) & 0xFF)
        var = int(roof_kind & 0xFF)
        return style, var

    def _building_face_height_px(self, *, style: int, w: int, h: int, var: int, floors: int = 0) -> int:
        style = int(style)
        w = int(w)
        h = int(h)
        var = int(var)
        floors = int(floors)
        area = int(w) * int(h)
        # Wall extrusion height: makes building height readable at a glance.
        # High-rises should read "very tall" even at small internal resolution.
        if style == 6:
            # Match requested "layer height" logic: facade height is derived
            # from floor count and player height (each floor  1.5 player).
            max_f = int(max(2, int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
            f = int(floors) if int(floors) > 0 else int(max_f)
            f = int(max(1, min(int(f), int(max_f))))
            floor_h = int(
                clamp(
                    int(round(float(getattr(getattr(self, "player", None), "h", 12)) * 1.5)),
                    14,
                    26,
                )
            )
            desired_total = int(f) * int(floor_h)
            face_h = int(max(0, int(desired_total) - int(self.TILE_SIZE)))
            return int(max(0, int(face_h)))

        if style == 1:
            # Houses: use the same "layer height" logic as high-rises so the
            # first floor reads taller ( 1.5 player height per floor).
            f = int(clamp(int(floors) if int(floors) > 0 else 1, 1, 3))
            floor_h = int(
                clamp(
                    int(round(float(getattr(getattr(self, "player", None), "h", 12)) * 1.5)),
                    14,
                    26,
                )
            )
            desired_total = int(f) * int(floor_h)
            face_h = int(max(0, int(desired_total) - int(self.TILE_SIZE)))
            return int(clamp(int(face_h), 3, 56))

        # All other (usually single-floor) buildings: enforce the same requested
        # "1F height  player height  1.5" rule so shops/schools/etc are not flat.
        f = int(max(1, int(floors))) if int(floors) > 0 else 1
        f = int(clamp(int(f), 1, 3))
        floor_h = int(
            clamp(
                int(round(float(getattr(getattr(self, "player", None), "h", 12)) * 1.5)),
                14,
                26,
            )
        )
        desired_total = int(f) * int(floor_h)
        face_h = int(max(0, int(desired_total) - int(self.TILE_SIZE)))
        return int(clamp(int(face_h), 3, 56))

    def _roof_cut_px(self, *, style: int, w: int, h: int, var: int, floors: int = 0) -> int:
        style = int(style)
        w = int(w)
        h = int(h)
        var = int(var)
        floors = int(floors)
        if not (int(style) == 6 or (int(style) == 1 and int(floors) > 1)):
            return 0

        face_h = int(self._building_face_height_px(style=int(style), w=int(w), h=int(h), var=int(var), floors=int(floors)))
        # Cutaway depth: don't remove the full facade height for high-rises,
        # otherwise apartments become too shallow (hard to fit 1211).
        if int(style) == 6:
            cut = int(max(0, int(round(float(face_h) * 0.55)) - 2))
        else:
            cut = int(max(0, int(face_h) - 2))
        min_vis = 18 if int(style) == 6 else 14
        roof_h_px = int(max(1, (int(h) - 2) * int(self.TILE_SIZE)))
        max_cut = int(max(0, int(roof_h_px) - int(min_vis)))

        ts = int(max(1, int(self.TILE_SIZE)))
        max_cut = int((int(max_cut) // int(ts)) * int(ts))
        cut = int(min(int(cut), int(max_cut)))
        if cut <= 0 or max_cut <= 0:
            return 0
        cut = int(min(int(math.ceil(float(cut) / float(ts))) * int(ts), int(max_cut)))
        return int(max(0, int(cut)))

    def _building_wall_palette(self, *, style: int, var: int) -> tuple[tuple[int, int, int], tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]]:
        style = int(style)
        var = int(var)
        # (front, side, trim, shadow)  tuned for a dirty city feel like the reference.
        front = (88, 84, 78)
        side = (64, 62, 58)
        trim = (140, 140, 146)
        shadow = (14, 14, 18)
        if style == 1:  # 
            front, side, trim = (118, 102, 82), (92, 78, 62), (170, 148, 118)
        elif style == 2:  # /
            front, side, trim = (86, 88, 94), (64, 66, 72), (130, 132, 140)
        elif style == 3:  # 
            front, side, trim = (184, 186, 196), (148, 150, 160), (236, 236, 242)
        elif style == 4:  # 
            front, side, trim = (58, 58, 66), (40, 40, 46), (98, 98, 110)
        elif style == 5:  # 
            front, side, trim = (132, 102, 68), (102, 76, 50), (186, 146, 96)
        elif style == 6:  # 
            front, side, trim = (88, 92, 122), (66, 70, 94), (142, 150, 186)
        elif style == 7:  # 
            front, side, trim = (72, 80, 108), (52, 58, 78), (210, 180, 110)
        elif style == 8:  # 
            front, side, trim = (148, 58, 46), (112, 42, 34), (210, 180, 110)
        dv = (int(var) % 7) - 3
        dv2 = (int(var) % 5) - 2
        front = self._tint(front, add=(dv * 2, dv * 2, dv * 2))
        side = self._tint(side, add=(dv2 * 2, dv2 * 2, dv2 * 2))
        trim = self._tint(trim, add=(dv, dv, dv))
        return front, side, trim, shadow

    def _find_building_exterior_door(self, tx0: int, ty0: int, w: int, h: int) -> tuple[str, list[tuple[int, int]]] | None:
        tx0 = int(tx0)
        ty0 = int(ty0)
        w = int(w)
        h = int(h)
        doors: list[tuple[int, int]] = []
        door_ids = {
            int(self.T_DOOR),
            int(self.T_DOOR_HOME),
            int(self.T_DOOR_LOCKED),
            int(self.T_DOOR_HOME_LOCKED),
            int(self.T_DOOR_BROKEN),
        }
        # Perimeter only (skip interior doors).
        for x in range(tx0, tx0 + w):
            if int(self.world.peek_tile(x, ty0)) in door_ids:
                doors.append((x, ty0))
            if int(self.world.peek_tile(x, ty0 + h - 1)) in door_ids:
                doors.append((x, ty0 + h - 1))
        for y in range(ty0 + 1, ty0 + h - 1):
            if int(self.world.peek_tile(tx0, y)) in door_ids:
                doors.append((tx0, y))
            if int(self.world.peek_tile(tx0 + w - 1, y)) in door_ids:
                doors.append((tx0 + w - 1, y))
        if not doors:
            return None
        side_votes = {"N": 0, "S": 0, "W": 0, "E": 0}
        for x, y in doors:
            if y == ty0:
                side_votes["N"] += 1
            elif y == ty0 + h - 1:
                side_votes["S"] += 1
            elif x == tx0:
                side_votes["W"] += 1
            elif x == tx0 + w - 1:
                side_votes["E"] += 1
        side = max(side_votes.items(), key=lambda kv: kv[1])[0]
        return side, doors

    def _draw_facade_furniture_silhouette(
        self,
        surface: pygame.Surface,
        *,
        kind: str,
        x: int,
        floor_y: int,
        w: int,
        max_h: int,
        seed: int,
        depth: int = 0,
    ) -> None:
        kind = str(kind)
        x = int(x)
        floor_y = int(floor_y)
        w = int(w)
        max_h = int(max_h)
        seed = int(seed) & 0xFFFFFFFF
        depth = int(depth)

        if w <= 2 or max_h <= 2:
            return

        outline = (10, 10, 12)
        shade = int(-58 - depth * 10)
        add = (shade, shade, shade)
        hi_add = (shade + 18, shade + 18, shade + 18)
        lo_add = (shade - 14, shade - 14, shade - 14)

        if kind == "table":
            wood = self._tint((118, 92, 66), add=add)
            wood_hi = self._tint((118, 92, 66), add=hi_add)
            wood_lo = self._tint((118, 92, 66), add=lo_add)

            top_h = 2 if max_h >= 6 else 1
            legs_len = int(clamp(max_h - top_h - 1, 2, 4))
            top_y = int(floor_y - (legs_len + top_h))
            top = pygame.Rect(int(x), int(top_y), int(w), int(top_h))

            surface.fill(wood, top)
            surface.fill(wood_hi, pygame.Rect(top.x, top.y, top.w, 1))
            pygame.draw.rect(surface, outline, top, 1)

            leg_h = int(floor_y - top.bottom)
            if leg_h > 0:
                lx0 = int(x + 2)
                lx1 = int(x + w - 3)
                for lx in (lx0, lx1):
                    if int(x) <= lx < int(x + w):
                        surface.fill(wood_lo, pygame.Rect(lx, top.bottom, 1, leg_h))
                        surface.fill(outline, pygame.Rect(lx, top.bottom, 1, leg_h))
                if leg_h >= 3 and lx1 - lx0 >= 3:
                    yb = int(floor_y - 2)
                    surface.fill(wood_lo, pygame.Rect(int(lx0), yb, int(lx1 - lx0 + 1), 1))

            # Chair silhouette (legs visible).
            if w >= 7 and max_h >= 6 and (seed & 3) == 0:
                seat_c = self._tint((92, 120, 154), add=add)
                seat_hi = self._tint((92, 120, 154), add=hi_add)
                seat_lo = self._tint((92, 120, 154), add=lo_add)
                cw = int(clamp(w - 2, 5, 7))
                cx = int(x + (1 if (seed & 4) == 0 else (w - cw - 1)))
                seat_y = int(floor_y - 3)
                seat_r = pygame.Rect(cx, seat_y, cw, 2)
                surface.fill(seat_c, seat_r)
                surface.fill(seat_hi, pygame.Rect(seat_r.x, seat_r.y, seat_r.w, 1))
                pygame.draw.rect(surface, outline, seat_r, 1)

                back_h = 3
                if (seed & 4) == 0:
                    back = pygame.Rect(seat_r.x, seat_r.y - back_h, 2, back_h)
                else:
                    back = pygame.Rect(seat_r.right - 2, seat_r.y - back_h, 2, back_h)
                surface.fill(seat_lo, back)
                pygame.draw.rect(surface, outline, back, 1)

                leg_h = int(floor_y - seat_r.bottom)
                if leg_h > 0:
                    for lx in (seat_r.x + 1, seat_r.right - 2):
                        surface.fill(seat_lo, pygame.Rect(int(lx), int(seat_r.bottom), 1, leg_h))
                        surface.fill(outline, pygame.Rect(int(lx), int(seat_r.bottom), 1, leg_h))

            return

        if kind == "shelf":
            cab = self._tint((98, 96, 112), add=add)
            cab_hi = self._tint((98, 96, 112), add=hi_add)
            cab_lo = self._tint((98, 96, 112), add=lo_add)

            h = int(clamp(max_h, 4, 8))
            y0 = int(floor_y - h)
            body = pygame.Rect(int(x), int(y0), int(w), int(h))
            surface.fill(cab, body)
            surface.fill(cab_hi, pygame.Rect(body.x, body.y, body.w, 1))
            pygame.draw.rect(surface, outline, body, 1)

            for sy in range(body.y + 2, body.bottom - 2, 2):
                surface.fill(cab_lo, pygame.Rect(body.x + 1, sy, max(1, body.w - 2), 1))

            # Feet.
            surface.fill(cab_lo, pygame.Rect(body.x + 1, floor_y - 1, 1, 1))
            surface.fill(cab_lo, pygame.Rect(body.right - 2, floor_y - 1, 1, 1))

            # Items: small colored pixels on shelves (deterministic).
            if body.w >= 6 and body.h >= 5:
                for i in range(3):
                    # IMPORTANT: don't use screen coordinates here, otherwise it flickers while walking.
                    hh = int(
                        self._hash2_u32(
                            int((seed ^ 0xA1F3C9D7) + i * 131),
                            int((seed >> 8) + i * 313),
                            int(seed ^ 0x9E3779B9),
                        )
                    )
                    ix = int(body.x + 2 + (hh % max(1, body.w - 4)))
                    iy = int(body.y + 2 + ((hh >> 5) % max(1, body.h - 4)))
                    col = (200, 86, 86) if (hh & 1) else (86, 210, 130)
                    col = self._tint(col, add=(shade + 10, shade + 10, shade + 10))
                    surface.fill(col, pygame.Rect(ix, iy, 1, 1))
            return

        if kind == "bed":
            matt = self._tint((156, 150, 170), add=add)
            matt_hi = self._tint((156, 150, 170), add=hi_add)
            matt_lo = self._tint((156, 150, 170), add=lo_add)
            wood = self._tint((118, 92, 66), add=lo_add)

            h = int(clamp(max_h, 4, 7))
            y0 = int(floor_y - h)
            bed = pygame.Rect(int(x), int(y0), int(w), int(h))
            surface.fill(matt, bed)
            surface.fill(matt_hi, pygame.Rect(bed.x, bed.y, bed.w, 1))
            pygame.draw.rect(surface, outline, bed, 1)

            if (seed & 1) == 0:
                hb = pygame.Rect(bed.x, bed.y, 2, bed.h)
            else:
                hb = pygame.Rect(bed.right - 2, bed.y, 2, bed.h)
            surface.fill(wood, hb)
            pygame.draw.rect(surface, outline, hb, 1)

            px = bed.x + 3 if hb.x == bed.x else bed.right - 6
            py = bed.y + 2
            pillow = pygame.Rect(int(px), int(py), 3, 2)
            surface.fill(matt_hi, pillow)
            pygame.draw.rect(surface, outline, pillow, 1)

            if bed.w >= 6 and bed.h >= 5:
                fold_y = bed.y + bed.h // 2
                surface.fill(matt_lo, pygame.Rect(bed.x + 2, fold_y, max(1, bed.w - 4), 1))

            surface.fill(matt_lo, pygame.Rect(bed.x + 1, floor_y - 1, 1, 1))
            surface.fill(matt_lo, pygame.Rect(bed.right - 2, floor_y - 1, 1, 1))
            return

    def _draw_building_facades(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
        *,
        min_ground_y: int | None = None,
        skip_building: tuple[int, int, int, int] | None = None,
    ) -> None:
        # Expand by a full chunk in each direction so facades from large
        # buildings don't pop in/out at the screen edges while walking.
        chunk_pad = 2
        start_cx = start_tx // self.CHUNK_SIZE - chunk_pad
        end_cx = end_tx // self.CHUNK_SIZE + chunk_pad
        start_cy = start_ty // self.CHUNK_SIZE - chunk_pad
        end_cy = end_ty // self.CHUNK_SIZE + chunk_pad
        floor_slice_h = int(clamp(int(round(float(getattr(self.player, "body_h", getattr(self.player, "h", 12))) * 1.5)), 14, 26))
        max_floors = int(max(2, int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))

        forced_slice: tuple[int, int, int, int, int, int] | None = getattr(self, "_inside_highrise_facade_slice", None)
        forced_mh: tuple[int, int, int, int] | None = None
        forced_floor = 1
        forced_floors = 1
        if forced_slice is not None:
            try:
                ftx0, fty0, fw, fh, ffloor, ffloors = forced_slice
                forced_mh = (int(ftx0), int(fty0), int(fw), int(fh))
                forced_floors = int(max(1, int(ffloors)))
                forced_floors = int(min(int(forced_floors), int(max_floors)))
                forced_floor = int(clamp(int(ffloor), 1, int(forced_floors)))
            except Exception:
                forced_mh = None
                forced_floor = 1
                forced_floors = 1

        # Global inside key is authoritative for cutaway/slicing scope.
        inside_key_global = getattr(self, "_inside_building_key", None)
        if not (isinstance(inside_key_global, tuple) and len(inside_key_global) == 4):
            inside_key_global = None

        # If the player is inside a multi-floor building, slice its facade to the current floor.
        inside_mh: tuple[int, int, int, int] | None = None
        inside_mh_floor = 1
        inside_mh_floors = 1
        inside_building: tuple[int, int, int, int] | None = None
        inside_building_style = 0
        inside_building_floors = 1
        try:
            ptx = int(math.floor(self.player.pos.x / self.TILE_SIZE))
            pty = int(math.floor(self.player.pos.y / self.TILE_SIZE))
            p_tile = int(self.world.peek_tile(int(ptx), int(pty)))
            can_be_inside = int(p_tile) in (
                int(self.T_FLOOR),
                int(self.T_DOOR),
                int(self.T_DOOR_HOME),
                int(self.T_ELEVATOR),
                int(self.T_STAIRS_UP),
                int(self.T_STAIRS_DOWN),
            )
            if can_be_inside:
                pchunk = self.world.peek_chunk(int(ptx) // int(self.CHUNK_SIZE), int(pty) // int(self.CHUNK_SIZE))
                if pchunk is not None:
                    for mh in getattr(pchunk, "multi_houses", []):
                        tx0 = int(getattr(mh, "tx0", 0))
                        ty0 = int(getattr(mh, "ty0", 0))
                        w = int(getattr(mh, "w", 0))
                        h = int(getattr(mh, "h", 0))
                        if int(tx0) <= int(ptx) < int(tx0) + int(w) and int(ty0) <= int(pty) < int(ty0) + int(h):
                            inside_mh = (int(tx0), int(ty0), int(w), int(h))
                            inside_mh_floors = int(max(1, int(getattr(mh, "floors", 1))))
                            inside_mh_floors = int(min(int(inside_mh_floors), int(max_floors)))
                            inside_mh_floor = int(clamp(int(getattr(mh, "cur_floor", 1)), 1, int(inside_mh_floors)))
                            break

                    # Fallback for any other multi-floor building footprint (e.g., non-registered 2F houses).
                    for b in getattr(pchunk, "buildings", []):
                        btx0, bty0, bw, bh = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                        if int(btx0) <= int(ptx) < int(btx0) + int(bw) and int(bty0) <= int(pty) < int(bty0) + int(bh):
                            roof_kind = int(b[4]) if len(b) > 4 else 0
                            b_style, _bvar = self._building_roof_style_var(int(roof_kind))
                            b_floors = int(b[5]) if len(b) > 5 else 1
                            if int(b_style) in (1, 6) and int(b_floors) > 1:
                                inside_building = (int(btx0), int(bty0), int(bw), int(bh))
                                inside_building_style = int(b_style)
                                inside_building_floors = int(min(int(b_floors), int(max_floors)))
                            break
        except Exception:
            inside_mh = None
            inside_mh_floor = 1
            inside_mh_floors = 1
            inside_building = None
            inside_building_style = 0
            inside_building_floors = 1
 
        for cy in range(start_cy, end_cy + 1):
            for cx in range(start_cx, end_cx + 1):
                chunk = self.world.peek_chunk(cx, cy)
                if chunk is None:
                    continue
                for b in getattr(chunk, "buildings", []):
                    tx0, ty0, w, h = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                    if skip_building is not None and (int(tx0), int(ty0), int(w), int(h)) == tuple(skip_building):
                        continue
                    roof_kind = int(b[4]) if len(b) > 4 else 0
                    style, var = self._building_roof_style_var(int(roof_kind))

                    floors = int(b[5]) if len(b) > 5 else 0
                    if int(style) == 6:
                        if int(floors) <= 0:
                            floors = int(max_floors)
                        floors = int(min(int(floors), int(max_floors)))
                    face_h = int(self._building_face_height_px(style=style, w=w, h=h, var=var, floors=floors))
                    # Only draw the *front* facade (bottom/S) as requested.
                    # Keep visibility checks stable to avoid popping at edges while walking.
                    bx = int(tx0 * self.TILE_SIZE - cam_x)
                    by = int(ty0 * self.TILE_SIZE - cam_y)
                    bw = int(w * self.TILE_SIZE)
                    bh = int(h * self.TILE_SIZE)
                    # IMPORTANT: facades can extend above the building footprint (face_h),
                    # so cull using an expanded bound, otherwise facades/doors pop or disappear
                    # when the footprint is barely off-screen.
                    ground_y_cull = int(by + bh)
                    top_y_cull = int(min(int(by), int(ground_y_cull - self.TILE_SIZE - max(0, int(face_h)))))
                    bottom_y_cull = int(ground_y_cull)
                    if bx > INTERNAL_W or top_y_cull > INTERNAL_H:
                        continue
                    if (bx + bw) < 0 or bottom_y_cull < 0:
                        continue

                    front, side, trim, shadow = self._building_wall_palette(style=style, var=var)
                    outline = (10, 10, 12)

                    # Door detection (used for storefront detail).
                    door_info = self._find_building_exterior_door(tx0, ty0, w, h)
                    door_side = ""
                    door_tiles: list[tuple[int, int]] = []
                    if door_info is not None:
                        door_side, door_tiles = door_info

                    slice_floor: int | None = None
                    slice_floors = 0
                    if int(style) == 6:
                        if forced_mh is not None and (int(tx0), int(ty0), int(w), int(h)) == forced_mh:
                            slice_floor = int(forced_floor)
                            slice_floors = int(forced_floors)
                    if (
                        inside_mh is not None
                        and int(style) in (1, 6)
                        and inside_key_global is not None
                        and (int(tx0), int(ty0), int(w), int(h)) == tuple(inside_key_global)
                    ):
                        itx0, ity0, iw, ih = inside_mh
                        if (int(itx0), int(ity0), int(iw), int(ih)) == (int(tx0), int(ty0), int(w), int(h)):
                            slice_floor = int(inside_mh_floor)
                            slice_floors = int(inside_mh_floors)
                    if (
                        slice_floor is None
                        and inside_building is not None
                        and int(style) in (1, 6)
                        and int(inside_building_floors) > 1
                        and inside_key_global is not None
                        and (int(tx0), int(ty0), int(w), int(h)) == tuple(inside_key_global)
                    ):
                        btx0, bty0, bw, bh = inside_building
                        if (int(btx0), int(bty0), int(bw), int(bh)) == (int(tx0), int(ty0), int(w), int(h)):
                            slice_floor = 1
                            slice_floors = int(inside_building_floors)

                    door_px: pygame.Rect | None = None
                    if door_tiles and door_side == "S":
                        xs = [p[0] for p in door_tiles]
                        ys = [p[1] for p in door_tiles]
                        dx0 = int(min(xs))
                        dx1 = int(max(xs))
                        dy = int(max(ys))
                        door_px = pygame.Rect(
                            int(dx0 * self.TILE_SIZE - cam_x),
                            int(dy * self.TILE_SIZE - cam_y),
                            int((dx1 - dx0 + 1) * self.TILE_SIZE),
                            int(self.TILE_SIZE + face_h),
                        )

                    ground_y = int(by + bh)
                    # Optional occlusion pass: only draw facades that are "in front"
                    # of a given screen-space y (used to keep vehicles from looking
                    # like they're on top of the building when behind it).
                    if min_ground_y is not None and int(ground_y) <= int(min_ground_y):
                        continue
                    # South (bottom) face: draw the "front facade".
                    # Extend upward for tall facades (high-rises and houses).
                    south_y = int(ground_y - self.TILE_SIZE)
                    south_h = int(self.TILE_SIZE)
                    if int(face_h) > 0:
                        south_y = int(ground_y - self.TILE_SIZE - int(face_h))
                        south_h = int(self.TILE_SIZE + int(face_h))      
                    if int(style) in (1, 6) and slice_floor is not None and int(slice_floors) > 1:
                        floor_h = int(floor_slice_h)
                        floors_total = int(max(1, int(slice_floors)))
                        floor_i = int(clamp(int(slice_floor), 1, int(floors_total)))
                        # Show this floor + all floors below it (same as high-rise),
                        # so on 2F you still see the 1F facade band.
                        south_h = int(max(1, int(floor_h) * int(floor_i)))
                        south_y = int(ground_y - int(south_h))
                    south = pygame.Rect(int(bx), int(south_y), int(bw), int(south_h))
                    pygame.draw.rect(surface, front, south)
                    pygame.draw.rect(surface, outline, south, 1)
                    # Ground shadow under the facade.
                    shadow_h = int(clamp(2 + int(face_h) // 10, 2, 5))
                    if int(south.bottom) == int(ground_y):
                        sh = pygame.Rect(int(south.x + 2), int(south.bottom), int(south.w - 2), int(shadow_h))
                        pygame.draw.rect(surface, shadow, sh)
                    # Lower-half shade for depth (independent of "building height").
                    shade_h = int(max(2, int(south.h) // 2))
                    shade = self._tint(front, add=(-18, -18, -18))
                    surface.fill(shade, pygame.Rect(int(south.x), int(south.bottom - shade_h), int(south.w), int(shade_h)))

                    # Trim line under the roof (or a separator when slicing to a lower floor).
                    if slice_floor is not None and int(slice_floors) > 0 and int(slice_floor) < int(slice_floors):
                        sep = self._tint(trim, add=(-34, -34, -38))
                        surface.fill(sep, pygame.Rect(south.x, south.y + 1, south.w, 1))
                    else:
                        surface.fill(trim, pygame.Rect(south.x, south.y + 1, south.w, 2))

                    # High-rise floor label (for very tall buildings).
                    if int(style) == 6 and int(floors) >= 11:
                        label = f"1234-{int(floors)}"
                        lx = int(south.x + 6)
                        ly = int(south.y + 6)
                        draw_text(surface, self.app.font_s, label, (lx + 1, ly + 1), pygame.Color(12, 12, 16), anchor="topleft")
                        draw_text(surface, self.app.font_s, label, (lx, ly), pygame.Color(240, 240, 240), anchor="topleft")

                    # High-rise floor separators (one line per floor).
                    if int(style) == 6:
                        floors_total = int(max(1, int(floors)))
                        if slice_floor is not None and int(slice_floors) > 0:
                            floors_total = int(max(1, int(slice_floors)))
                        if int(floors_total) > 1:
                            floor_h = int(max(1, int(floor_slice_h)))
                            sep = self._tint(trim, add=(-34, -34, -38))
                            for fi in range(1, int(floors_total)):
                                yy = int(south.bottom - int(fi) * int(floor_h))
                                if int(yy) <= int(south.y) or int(yy) >= int(south.bottom):
                                    continue
                                surface.fill(sep, pygame.Rect(int(south.x + 1), int(yy), max(1, int(south.w - 2)), 1))

                    # Facade details by building type.
                    store_header_bottom = int(south.y + 3)
                    if style in (2, 3, 5, 7):  # shop/hospital/school/bookstore: sign + band
                        sign_h = int(clamp(int(south.h // 3), 5, 7))
                        sign = pygame.Rect(south.x + 3, south.y + 2, south.w - 6, sign_h)
                        if style == 2:
                            base = (78, 118, 176) if ((var >> 1) & 1) == 0 else (176, 132, 78)
                            sign_bg = self._tint(base, add=(-10, -10, -10))
                        elif style == 7:
                            base = (46, 70, 110)
                            sign_bg = self._tint(base, add=(-8, -8, -8))
                        elif style == 5:
                            base = (168, 132, 92)
                            sign_bg = self._tint(base, add=(-18, -14, -10))
                        elif style == 3:
                            sign_bg = self._tint(trim, add=(-4, -4, -4))
                        else:
                            sign_bg = self._tint(trim, add=(-22, -22, -22))
                        pygame.draw.rect(surface, sign_bg, sign, border_radius=2)
                        pygame.draw.rect(surface, outline, sign, 1, border_radius=2)
                        # Tiny pseudo text blocks
                        for xx in range(sign.x + 4 + (var % 3), sign.right - 6, 4):
                            # IMPORTANT: use local x (not screen coordinates) so it doesn't flicker while walking.
                            if (((xx - sign.x) + var) % 5) == 0:
                                continue
                            surface.fill(self._tint(sign_bg, add=(38, 38, 42)), pygame.Rect(xx, sign.y + 2, 2, 1))
                        if style == 3 and sign.w >= 18:
                            # Red cross
                            cx = sign.centerx
                            cy = sign.centery
                            red = (190, 60, 60)
                            surface.fill(red, pygame.Rect(cx - 1, cy - 3, 2, 7))
                            surface.fill(red, pygame.Rect(cx - 3, cy - 1, 7, 2))
                            pygame.draw.rect(surface, outline, pygame.Rect(cx - 3, cy - 3, 7, 7), 1)
                        if style == 7 and sign.w >= 18:
                            # Tiny book icon.
                            cx = sign.centerx
                            cy = sign.centery
                            ink = (232, 200, 120)
                            pygame.draw.rect(surface, ink, pygame.Rect(cx - 6, cy - 3, 5, 7), 1, border_radius=1)
                            pygame.draw.rect(surface, ink, pygame.Rect(cx + 1, cy - 3, 5, 7), 1, border_radius=1)
                            surface.fill(outline, pygame.Rect(cx, cy - 3, 1, 7))

                        # Awning stripes just below sign for shops.
                        store_header_bottom = int(sign.bottom)
                        if style == 2:
                            awn_h = 5 if int(south.h) >= 16 else 4
                            awn = pygame.Rect(south.x + 3, sign.bottom + 1, south.w - 6, awn_h)
                            a1 = (190, 190, 196)
                            a2 = (170, 80, 80)
                            for i in range(awn.w):
                                col = a1 if ((i + var) % 6) < 3 else a2
                                surface.fill(col, pygame.Rect(awn.x + i, awn.y, 1, awn.h))
                            pygame.draw.rect(surface, outline, awn, 1)
                            store_header_bottom = int(awn.bottom)
                            # Small hanging placard on the right.
                            if awn.w >= 34:
                                plac = pygame.Rect(int(awn.right - 14), int(awn.bottom + 2), 10, 10)
                                pygame.draw.rect(surface, self._tint(sign_bg, add=(18, 18, 18)), plac, border_radius=2)
                                pygame.draw.rect(surface, outline, plac, 1, border_radius=2)
                                surface.fill((240, 220, 140), pygame.Rect(plac.x + 3, plac.y + 4, 4, 1))

                    if style == 3:
                        # Hospital: clean stripe band.
                        stripe = (92, 138, 206)
                        sy = int(store_header_bottom + 2)
                        if sy + 2 < south.bottom - 4:
                            surface.fill(stripe, pygame.Rect(int(south.x + 3), int(sy), int(south.w - 6), 2))

                    if style == 5:
                        # School: brick columns.
                        col = self._tint(front, add=(-26, -20, -16))     
                        if south.w >= 26 and south.h >= 14:
                            surface.fill(col, pygame.Rect(int(south.x + 2), int(south.y + 3), 3, int(south.h - 6)))
                            surface.fill(col, pygame.Rect(int(south.right - 5), int(south.y + 3), 3, int(south.h - 6)))
                            # Small banner tabs.
                            surface.fill(self._tint(trim, add=(-30, -30, -30)), pygame.Rect(int(sign.x + 6), int(sign.bottom), 2, 3))
                            surface.fill(self._tint(trim, add=(-30, -30, -30)), pygame.Rect(int(sign.right - 8), int(sign.bottom), 2, 3))

                    if style == 8:
                        # Chinese: red pillars + a small plaque.
                        if south.w >= 24 and south.h >= 14:
                            pillar = self._tint(front, add=(18, 0, 0))
                            surface.fill(pillar, pygame.Rect(int(south.x + 2), int(south.y + 3), 3, int(south.h - 6)))
                            surface.fill(pillar, pygame.Rect(int(south.right - 5), int(south.y + 3), 3, int(south.h - 6)))
                            plaque = pygame.Rect(int(south.centerx - 8), int(south.y + 2), 16, 6)
                            bg = self._tint(trim, add=(-26, -26, -26))
                            pygame.draw.rect(surface, bg, plaque, border_radius=2)
                            pygame.draw.rect(surface, outline, plaque, 1, border_radius=2)
                            ink = self._tint(trim, add=(22, 18, 0))
                            for xx in range(int(plaque.x + 4), int(plaque.right - 4), 3):
                                if ((xx + var) % 4) == 0:
                                    continue
                                surface.fill(ink, pygame.Rect(int(xx), int(plaque.y + 3), 2, 1))

                    if style == 4:
                        # Prison: barred windows.
                        bar = self._tint(trim, add=(-30, -30, -30))      
                        for xx in range(south.x + 6, south.right - 6, 6):
                            surface.fill(bar, pygame.Rect(xx, south.y + 3, 1, south.h - 6))

                    if style in (1, 6):
                        # Residential/high-rise windows.
                        detail_floors = int(floors)
                        if int(style) == 1 and slice_floor is not None and int(slice_floors) > 1:
                            # When inside a multi-floor house we slice to a single floor strip.
                            detail_floors = 1
                        win = self._tint(trim, add=(-40, -40, -46))
                        frame = outline
                        start_x = int(south.x + 6 + (var % 4))
                        if style == 6:
                            # Multiple rows so height reads as "high-rise".
                            step_x = 10
                            step_y = 8
                            y0w = int(south.y + 4)
                            y1w = int(south.bottom - 7)
                            for row_i, yy in enumerate(range(y0w, y1w, step_y)):
                                for col_i, xx in enumerate(range(start_x, south.right - 10, step_x)):
                                    # IMPORTANT: use local indices (not screen coords) so it doesn't flicker.
                                    if ((col_i + row_i + var) % 4) == 0:
                                        continue
                                    r = pygame.Rect(int(xx), int(yy), 6, 4)
                                    pygame.draw.rect(surface, win, r, border_radius=1)
                                    pygame.draw.rect(surface, frame, r, 1, border_radius=1)
                        else:
                            step_x = 12
                            if int(detail_floors) > 1 and south.h >= 18:
                                # Multi-floor house: 23 window rows so the facade reads taller.
                                rows = int(clamp(int(detail_floors), 2, 3))
                                y0w = int(south.y + 4)
                                y1w = int(south.bottom - 18)
                                if y1w <= y0w:
                                    y1w = int(south.y + 4)
                                span = int(max(0, int(y1w - y0w)))
                                for row_i in range(int(rows)):
                                    yy = int(y0w + (span * int(row_i)) / max(1, int(rows - 1)))
                                    for col_i, xx in enumerate(range(start_x, south.right - 10, step_x)):
                                        # IMPORTANT: use local indices (not screen coords) so it doesn't flicker.
                                        if ((col_i + row_i + var) % 4) == 0:
                                            continue
                                        r = pygame.Rect(int(xx), int(yy), 6, 4)
                                        pygame.draw.rect(surface, win, r, border_radius=1)
                                        pygame.draw.rect(surface, frame, r, 1, border_radius=1)
                            else:
                                # Single row for small residential buildings.
                                y1 = int(south.y + 4)
                                for i, xx in enumerate(range(start_x, south.right - 10, step_x)):
                                    # IMPORTANT: use local window index (not screen coordinates) so it doesn't flicker.
                                    if ((i + var) % 3) == 0:
                                        continue
                                    r = pygame.Rect(int(xx), int(y1), 6, 4)
                                    pygame.draw.rect(surface, win, r, border_radius=1)
                                    pygame.draw.rect(surface, frame, r, 1, border_radius=1)

                    # "Front interior" storefront hint (like the reference): show a cutout window strip with
                    # silhouettes of shelves/props synced to the actual interior tiles.
                    if style in (2, 3, 5, 7):
                        open_y = int(store_header_bottom + 1)
                        open_h = int(south.bottom - 2 - open_y)
                        open_x = int(south.x + 4)
                        open_w = int(south.w - 8)
                        if open_w >= int(self.TILE_SIZE * 2) and open_h >= 4:
                            open_rect = pygame.Rect(int(open_x), int(open_y), int(open_w), int(open_h))
                            interior = self._tint(side, add=(-30, -30, -30))
                            if style == 3:
                                interior = self._tint(front, add=(-34, -34, -30))
                            elif style == 5:
                                interior = self._tint(front, add=(-36, -30, -26))
                            pygame.draw.rect(surface, interior, open_rect, border_radius=2)
                            pygame.draw.rect(surface, outline, open_rect, 1, border_radius=2)

                            # Glass highlight + mullions.
                            glass_hi = self._tint(trim, add=(48, 48, 54))
                            surface.fill(
                                glass_hi,
                                pygame.Rect(open_rect.x + 1, open_rect.y + 1, max(1, open_rect.w - 2), 1),
                            )
                            mull = self._tint(interior, add=(18, 18, 18))
                            step = 12 if open_rect.w >= 80 else 10
                            for xx in range(open_rect.x + 8 + (var % 5), open_rect.right - 6, step):
                                surface.fill(mull, pygame.Rect(int(xx), open_rect.y + 2, 1, max(1, open_rect.h - 4)))

                            prev_clip = surface.get_clip()
                            surface.set_clip(open_rect.inflate(-1, -1))

                            # Interior silhouettes near the front wall.
                            if open_rect.h >= 6 and int(w) >= 4 and int(h) >= 4:
                                sample_ys = [int(ty0 + h - 2), int(ty0 + h - 3)]
                                seed = int(self.seed) ^ 0x51F2A1B3
                                for row_i, sy in enumerate(sample_ys):
                                    if not (int(ty0) < int(sy) < int(ty0 + h - 1)):
                                        continue
                                    y_off = int(row_i)
                                    for tx in range(int(tx0 + 1), int(tx0 + w - 1)):
                                        px = int(tx * self.TILE_SIZE - cam_x)
                                        if px + self.TILE_SIZE <= open_rect.x or px >= open_rect.right:
                                            continue
                                        tid = int(self.world.peek_tile(tx, sy))
                                        if tid == int(self.T_FLOOR):
                                            if style != 2:
                                                continue
                                            hh = int(self._hash2_u32(int(tx), int(sy), seed))
                                            if (hh & 15) != 0:
                                                continue
                                            crate = (132, 92, 62) if ((hh >> 4) & 1) else (92, 70, 52)
                                            rr = pygame.Rect(
                                                int(px + 2),
                                                int(open_rect.bottom - 3 - y_off),
                                                max(1, int(self.TILE_SIZE - 4)),
                                                2,
                                            )
                                            surface.fill(crate, rr)
                                            pygame.draw.rect(surface, outline, rr, 1)
                                            if rr.w >= 5:
                                                g1 = (196, 120, 86) if ((hh >> 6) & 1) else (86, 190, 120)
                                                surface.fill(g1, pygame.Rect(rr.x + 2, rr.y, 1, 1))
                                            continue

                                        if tid in (int(self.T_TABLE), int(self.T_SHELF), int(self.T_BED)):
                                            # More detailed facade furniture silhouettes (legs, shelves, pillows).
                                            fh = int(self._hash2_u32(int(tx), int(sy), seed ^ 0x9E3779B9))
                                            floor_y = int(open_rect.bottom - 2 - y_off)
                                            max_h = int(max(3, open_rect.h - 3))
                                            if tid == int(self.T_TABLE):
                                                self._draw_facade_furniture_silhouette(
                                                    surface,
                                                    kind="table",
                                                    x=int(px + 1),
                                                    floor_y=floor_y,
                                                    w=int(self.TILE_SIZE - 2),
                                                    max_h=max_h,
                                                    seed=fh,
                                                    depth=y_off,
                                                )
                                            elif tid == int(self.T_SHELF):
                                                self._draw_facade_furniture_silhouette(
                                                    surface,
                                                    kind="shelf",
                                                    x=int(px + 1),
                                                    floor_y=floor_y,
                                                    w=int(self.TILE_SIZE - 2),
                                                    max_h=max_h,
                                                    seed=fh,
                                                    depth=y_off,
                                                )
                                            else:
                                                self._draw_facade_furniture_silhouette(
                                                    surface,
                                                    kind="bed",
                                                    x=int(px + 1),
                                                    floor_y=floor_y,
                                                    w=int(self.TILE_SIZE - 2),
                                                    max_h=max_h,
                                                    seed=fh,
                                                    depth=y_off,
                                                )
                                            continue

                                            # Keep facade interior silhouettes readable even if minimap hides interiors.
                                            if tid == int(self.T_TABLE):
                                                c = (104, 82, 62)
                                            elif tid == int(self.T_SHELF):
                                                c = (92, 92, 104)
                                            else:
                                                c = (126, 126, 164)
                                            c = self._tint(c, add=(-56, -56, -56))
                                            bh = 3 if tid != int(self.T_BED) else 4
                                            rr = pygame.Rect(
                                                int(px + 1),
                                                int(open_rect.bottom - 2 - bh - y_off),
                                                max(1, int(self.TILE_SIZE - 2)),
                                                int(bh),
                                            )
                                            surface.fill(c, rr)
                                            pygame.draw.rect(surface, outline, rr, 1)
                                            if tid == int(self.T_SHELF) and rr.w >= 6 and rr.h >= 3:
                                                hh = int(self._hash2_u32(int(tx), int(sy), seed ^ 0x9E3779B9))
                                                g1 = (200, 86, 86) if ((hh >> 1) & 1) else (86, 210, 130)
                                                g2 = (210, 200, 120) if ((hh >> 2) & 1) else (140, 140, 220)
                                                surface.fill(g1, pygame.Rect(rr.x + 2, rr.y + 1, 1, 1))
                                                surface.fill(g2, pygame.Rect(rr.right - 3, rr.y + 1, 1, 1))

                            # Type accents for quick read.
                            if style == 5 and open_rect.w >= 22 and open_rect.h >= 7:
                                board = pygame.Rect(open_rect.x + 3, open_rect.y + 2, min(18, open_rect.w - 6), 4)
                                surface.fill((22, 34, 26), board)
                                pygame.draw.rect(surface, outline, board, 1)
                            if style == 3 and open_rect.w >= 18 and open_rect.h >= 7:
                                cx = open_rect.x + 8
                                cy = open_rect.y + 4
                                red = (190, 60, 60)
                                surface.fill(red, pygame.Rect(int(cx - 1), int(cy - 3), 2, 7))
                                surface.fill(red, pygame.Rect(int(cx - 3), int(cy - 1), 7, 2))
                                pygame.draw.rect(surface, outline, pygame.Rect(int(cx - 3), int(cy - 3), 7, 7), 1)

                            surface.set_clip(prev_clip)

                    # Re-draw the exterior door if our *front* facade covers it (south only).
                    if isinstance(door_px, pygame.Rect):
                        # Door visual should not scale with the full facade height (especially for high-rises).
                        # Anchor to the ground (bottom of facade) and clamp size by building type.
                        door_open_w = int(door_px.w)
                        if style == 1:  # house
                            door_w = int(clamp(door_open_w - 10, 10, 14))       
                        elif style in (2, 3, 4, 7):  # shop/hospital/prison/bookstore
                            door_w = int(clamp(door_open_w - 2, 16, 20))        
                        elif style in (5, 8):  # school/chinese
                            door_w = int(clamp(door_open_w - 4, 14, 18))        
                        elif style == 6:  # high-rise lobby
                            door_w = int(clamp(door_open_w - 4, 14, 18))        
                        else:
                            door_w = int(clamp(door_open_w - 6, 12, 18))        

                        if style == 6:
                            # High-rise lobby: keep it single-story (do not scale with the whole facade height).
                            door_h = int(clamp(16 + ((int(var) >> 2) % 3) - 1, 14, 18))
                        elif style == 1:
                            # Houses: keep door height consistent between 1F/2F.
                            door_h = int(self.TILE_SIZE)
                        else:
                            door_h = int(clamp(10 + int(face_h) // 3, 12, 18))
                        door_h = int(min(int(door_h), max(10, int(south.h - 6))))

                        dr = pygame.Rect(0, 0, int(door_w), int(door_h))
                        # Door bottom line should align with the tile baseline (no "floating").
                        dr.midbottom = (int(door_px.centerx), int(south.bottom))
                        min_x = int(south.x + 2)
                        max_x = int(south.right - dr.w - 2)
                        if max_x >= min_x:
                            dr.x = int(clamp(int(dr.x), min_x, max_x))

                        if style == 2:
                            # Shop: glass sliding doors.
                            door_bg = self._tint(trim, add=(-78, -78, -84))     
                            pygame.draw.rect(surface, door_bg, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            hi = self._tint(trim, add=(48, 48, 54))
                            surface.fill(hi, pygame.Rect(dr.x + 2, dr.y + 3, max(1, dr.w - 4), 1))
                            mid = int(dr.centerx)
                            surface.fill(outline, pygame.Rect(mid, dr.y + 2, 1, max(1, dr.h - 4)))
                            handle = (230, 230, 236)
                            surface.fill(handle, pygame.Rect(mid - 3, dr.centery - 1, 1, 2))
                            surface.fill(handle, pygame.Rect(mid + 2, dr.centery - 1, 1, 2))
                        elif style == 7:
                            # Bookstore: glass door + small book decal.
                            door_bg = self._tint(trim, add=(-82, -82, -90))
                            pygame.draw.rect(surface, door_bg, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            hi = self._tint(trim, add=(52, 52, 56))
                            surface.fill(hi, pygame.Rect(dr.x + 2, dr.y + 3, max(1, dr.w - 4), 1))
                            mid = int(dr.centerx)
                            surface.fill(outline, pygame.Rect(mid, dr.y + 2, 1, max(1, dr.h - 4)))
                            ink = (232, 200, 120)
                            bx = int(dr.centerx)
                            by = int(dr.y + 5)
                            pygame.draw.rect(surface, ink, pygame.Rect(bx - 5, by, 4, 6), 1, border_radius=1)
                            pygame.draw.rect(surface, ink, pygame.Rect(bx + 2, by, 4, 6), 1, border_radius=1)
                            surface.fill(outline, pygame.Rect(bx, by, 1, 6))
                        elif style == 3:
                            # Hospital: glass door + red cross.
                            door_bg = self._tint(front, add=(-46, -46, -40))
                            pygame.draw.rect(surface, door_bg, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            hi = self._tint(trim, add=(52, 52, 56))
                            surface.fill(hi, pygame.Rect(dr.x + 2, dr.y + 3, max(1, dr.w - 4), 1))
                            mid = int(dr.centerx)
                            surface.fill(outline, pygame.Rect(mid, dr.y + 2, 1, max(1, dr.h - 4)))
                            red = (190, 60, 60)
                            cx = int(dr.x + min(10, max(6, dr.w // 2)))
                            cy = int(clamp(int(dr.y + dr.h // 2), int(dr.y + 4), int(dr.bottom - 4)))
                            surface.fill(red, pygame.Rect(cx - 1, cy - 3, 2, 7))
                            surface.fill(red, pygame.Rect(cx - 3, cy - 1, 7, 2))
                            pygame.draw.rect(surface, outline, pygame.Rect(cx - 3, cy - 3, 7, 7), 1)
                        elif style == 4:
                            # Prison: heavy gate + bars + caution band.
                            metal = self._tint(front, add=(-22, -22, -28))
                            pygame.draw.rect(surface, metal, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            bar = self._tint(trim, add=(-46, -46, -52))
                            for xx in range(int(dr.x + 2), int(dr.right - 2), 3):
                                surface.fill(bar, pygame.Rect(int(xx), int(dr.y + 2), 1, max(1, int(dr.h - 4))))
                            # Caution stripe at the top of the gate.
                            band = pygame.Rect(int(dr.x + 2), int(dr.y + 2), max(1, int(dr.w - 4)), 4)
                            a = (210, 190, 90)
                            bcol = (50, 50, 56)
                            for i in range(int(band.w)):
                                col = a if ((i + var) % 6) < 3 else bcol
                                surface.fill(col, pygame.Rect(int(band.x + i), int(band.y), 1, int(band.h)))
                            pygame.draw.rect(surface, outline, band, 1)
                        elif style == 5:
                            # School: wooden double doors.
                            wood = self._tint(front, add=(-36, -26, -18))
                            pygame.draw.rect(surface, wood, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            for xx in range(int(dr.x + 3), int(dr.right - 3), 4):
                                surface.fill(self._tint(wood, add=(18, 12, 6)), pygame.Rect(int(xx), int(dr.y + 2), 1, max(1, int(dr.h - 4))))
                            mid = int(dr.centerx)
                            surface.fill(outline, pygame.Rect(mid, dr.y + 2, 1, max(1, dr.h - 4)))
                            knob = (18, 18, 22)
                            surface.fill(knob, pygame.Rect(mid - 3, dr.centery, 1, 1))
                            surface.fill(knob, pygame.Rect(mid + 2, dr.centery, 1, 1))
                        elif style == 8:
                            # Chinese: red double door + gold studs.
                            red = self._tint(front, add=(10, -4, -6))
                            pygame.draw.rect(surface, red, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            mid = int(dr.centerx)
                            surface.fill(outline, pygame.Rect(mid, dr.y + 2, 1, max(1, dr.h - 4)))
                            gold = (210, 180, 110)
                            for yy in range(int(dr.y + 4), int(dr.bottom - 4), 4):
                                surface.fill(gold, pygame.Rect(int(mid - 3), int(yy), 1, 1))
                                surface.fill(gold, pygame.Rect(int(mid + 2), int(yy), 1, 1))
                            surface.fill(gold, pygame.Rect(int(mid - 3), int(dr.centery), 1, 1))
                            surface.fill(gold, pygame.Rect(int(mid + 2), int(dr.centery), 1, 1))
                        elif style == 1:
                            # Residential: simple wood door + small window.
                            wood = self._tint(front, add=(-34, -22, -14))
                            pygame.draw.rect(surface, wood, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            winr = pygame.Rect(int(dr.centerx - 3), int(dr.y + 4), 6, 4)
                            pygame.draw.rect(surface, self._tint(trim, add=(-30, -30, -34)), winr, border_radius=1)
                            pygame.draw.rect(surface, outline, winr, 1, border_radius=1)
                            pygame.draw.circle(surface, (18, 18, 22), (dr.right - 4, dr.centery), 1)
                            # Doormat.
                            mat = pygame.Rect(int(dr.x + 1), int(dr.bottom - 4), max(1, int(dr.w - 2)), 2)
                            surface.fill(self._tint(front, add=(-44, -44, -44)), mat)
                        elif style == 6:
                            # High-rise lobby: big glass door.
                            door_bg = self._tint(trim, add=(-86, -86, -92))
                            pygame.draw.rect(surface, door_bg, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            hi = self._tint(trim, add=(52, 52, 56))
                            surface.fill(hi, pygame.Rect(dr.x + 2, dr.y + 3, max(1, dr.w - 4), 1))
                            for xx in range(int(dr.x + 3), int(dr.right - 3), 4):
                                surface.fill(outline, pygame.Rect(int(xx), int(dr.y + 2), 1, max(1, int(dr.h - 4))))
                        else:
                            # Default: simple door.
                            door_bg = self._tint(front, add=(-34, -30, -24))
                            pygame.draw.rect(surface, door_bg, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            surface.fill(self._tint(door_bg, add=(18, 14, 10)), pygame.Rect(dr.x + 2, dr.y + 2, max(1, dr.w - 4), 3))
                            pygame.draw.circle(surface, (18, 18, 22), (dr.right - 4, dr.y + dr.h // 2), 1)

                        # Threshold shadow for depth.
                        surface.fill(self._tint(front, add=(-26, -26, -30)), pygame.Rect(dr.x + 1, dr.bottom - 2, max(1, dr.w - 2), 1))

    def _draw_roofs(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
    ) -> None:
        inside_key: tuple[int, int, int, int] | None = getattr(self, "_inside_building_key", None)

        start_cx = start_tx // self.CHUNK_SIZE
        end_cx = end_tx // self.CHUNK_SIZE
        start_cy = start_ty // self.CHUNK_SIZE
        end_cy = end_ty // self.CHUNK_SIZE

        for cy in range(start_cy, end_cy + 1):
            for cx in range(start_cx, end_cx + 1):
                chunk = self.world.peek_chunk(cx, cy)
                if chunk is None:
                    continue
                for b in chunk.buildings:
                    tx0, ty0, w, h = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                    roof_kind = int(b[4]) if len(b) > 4 else 0
                    style, var = self._building_roof_style_var(int(roof_kind))
                    floors = int(b[5]) if len(b) > 5 else 0
                    if int(style) == 6:
                        max_floors = int(max(2, int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
                        if int(floors) <= 0:
                            floors = int(max_floors)
                        floors = int(min(int(floors), int(max_floors)))
                    face_h = int(self._building_face_height_px(style=style, w=w, h=h, var=var, floors=floors))
                    if inside_key is not None and (int(tx0), int(ty0), int(w), int(h)) == inside_key:
                        # When the player is inside a building, hide that building's roof completely.
                        continue
                    alpha = 255
                    rw = max(1, int(w) - 2)
                    rh = max(1, int(h) - 2)
                    roof = self._roof_surface(rw, rh, alpha, roof_kind=roof_kind)
                    roof_draw = roof
                    cut = int(self._roof_cut_px(style=int(style), w=int(w), h=int(h), var=int(var), floors=int(floors)))
                    if cut > 0:
                        roof_draw = roof.subsurface(pygame.Rect(0, 0, int(roof.get_width()), int(roof.get_height() - cut)))
                    roof_lift = 0
                    if cut > 0:
                        roof_lift = int(max(0, int(face_h) - int(cut) - 2))

                    sx = (int(tx0) + 1) * self.TILE_SIZE - int(cam_x)
                    sy = (int(ty0) + 1) * self.TILE_SIZE - int(cam_y)
                    # Slight roof offset to reveal the "front" (bottom/right) walls like MiniDayZ.
                    roof_off_x = -2
                    roof_off_y = -2
                    rx = int(sx + roof_off_x)
                    ry = int(sy + roof_off_y - int(roof_lift))
                    if rx > INTERNAL_W or ry > INTERNAL_H:
                        continue
                    if rx + roof_draw.get_width() < 0 or ry + roof_draw.get_height() < 0:
                        continue
                    if inside_key is None or (int(tx0), int(ty0), int(w), int(h)) != inside_key:
                        sh = pygame.Surface((roof_draw.get_width(), roof_draw.get_height()), pygame.SRCALPHA)
                        sh.fill((0, 0, 0, 70))
                        surface.blit(sh, (int(rx + 2), int(ry + 2)))
                    surface.blit(roof_draw, (int(rx), int(ry)))

    def _draw_zombies(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        *,
        corpses: bool = True,
        alive: bool = True,
    ) -> None:
        for z in self.zombies:
            p = pygame.Vector2(z.pos) - pygame.Vector2(cam_x, cam_y)
            sx = iround(float(p.x))
            sy = iround(float(p.y))

            kind = str(getattr(z, "kind", "walker"))
            by_kind = self._MONSTER_FRAMES.get(kind) or self._MONSTER_FRAMES.get("walker")
            if not by_kind:
                continue
            d = str(getattr(z, "dir", "down"))
            frames = by_kind.get(d) or by_kind.get("down")
            if not frames:
                continue

            # Corpse rendering (do not despawn immediately).
            is_corpse = int(getattr(z, "hp", 0)) <= 0 and float(getattr(z, "corpse_left", 0.0)) > 0.0
            if bool(is_corpse):
                if not bool(corpses):
                    continue
                spr = frames[0]
                sx2 = int(sx)
                sy2 = int(sy)
                ground_y = iround(float(sy2) + float(getattr(z, "h", 0)) / 2.0)

                total = float(getattr(z, "corpse_total", 0.0)) or float(getattr(self, "_ZOMBIE_CORPSE_TOTAL_S", 14.0))
                left = float(getattr(z, "corpse_left", 0.0))
                fade = float(clamp(left / max(1e-6, float(total)), 0.0, 1.0))
                alpha = int(round(255.0 * (fade**0.45)))

                fall_s = float(getattr(self, "_ZOMBIE_FALL_S", 0.22))
                t_dead = float(getattr(z, "death_t", 0.0))
                corpse_surf: pygame.Surface
                if fall_s > 1e-6 and t_dead < fall_s:
                    t = float(clamp(t_dead / float(fall_s), 0.0, 1.0))
                    sx_scale = 1.0 + 0.18 * t
                    sy_scale = 1.0 - 0.58 * t
                    ww = max(1, int(round(float(spr.get_width()) * float(sx_scale))))
                    hh = max(1, int(round(float(spr.get_height()) * float(sy_scale))))
                    corpse_surf = pygame.transform.scale(spr, (int(ww), int(hh)))
                else:
                    corpse_surf = pygame.transform.rotate(spr, 90)

                corpse_surf = corpse_surf.copy()
                # Darken as it "rots", keep alpha shape.
                mul = int(round(140.0 + 115.0 * float(fade)))
                corpse_surf.fill((mul, mul, mul, 255), special_flags=pygame.BLEND_RGBA_MULT)
                corpse_surf.set_alpha(alpha)

                rect = corpse_surf.get_rect()
                rect.midbottom = (int(sx2), int(ground_y))
                # Corpse shadow: anchor to the *opaque* pixel bounds so it stays glued to the body
                # even after rotate/scale (surfaces include transparent margins).
                try:
                    br = corpse_surf.get_bounding_rect()  # local to corpse_surf
                    body_rect = br.move(int(rect.left), int(rect.top))
                except Exception:
                    body_rect = rect
                shadow = pygame.Rect(0, 0, max(6, int(body_rect.w) - 2), 4)
                shadow.center = (int(body_rect.centerx), int(body_rect.centery + max(1, int(body_rect.h) // 6)))
                pygame.draw.ellipse(surface, (0, 0, 0), shadow)
                surface.blit(corpse_surf, rect)
                continue

            if not bool(alive):
                continue

            moving = z.vel.length_squared() > 1.0
            idx = 0 if not moving else 1 + (int(float(getattr(z, "anim", 0.0))) % 2)
            idx = max(0, min(int(idx), len(frames) - 1))
            spr = frames[idx]

            # Wobble when walking: visual-only sway (doesn't affect collisions).
            wob_x = 0
            wob_y = 0
            if moving:
                phase = float(getattr(z, "anim", 0.0))
                if kind == "walker":
                    freq = 2.2
                    sway_amp = 2.2
                    bob_amp = 1.2
                elif kind == "screamer":
                    freq = 2.4
                    sway_amp = 2.0
                    bob_amp = 1.1
                else:
                    freq = 2.8
                    sway_amp = 1.4
                    bob_amp = 0.8
                sway = int(round(math.sin(phase * float(freq)) * float(sway_amp)))
                bob = int(round(math.cos(phase * float(freq)) * float(bob_amp)))
                if d in ("left", "right"):
                    wob_y = int(sway)
                    wob_x = int(bob)
                else:
                    wob_x = int(sway)
                    wob_y = int(bob)
            sx2 = int(sx + wob_x)
            sy2 = int(sy + wob_y)

            rect = spr.get_rect()
            rect.midbottom = (int(sx2), iround(float(sy2) + float(z.h) / 2.0))

            shadow = pygame.Rect(0, 0, max(6, rect.w - 4), 4)
            shadow.center = (int(sx2), iround(float(sy2) + float(z.h) / 2.0 - 1.0))
            pygame.draw.ellipse(surface, (0, 0, 0), shadow)
            surface.blit(spr, rect)

            if self._debug:
                mdef = self._MONSTER_DEFS.get(kind, self._MONSTER_DEFS["walker"])
                max_hp = max(1, int(mdef.hp) + 6)
                hp = int(clamp(int(z.hp), 0, max_hp))
                bar = pygame.Rect(rect.left, rect.top - 4, rect.w, 3)
                pygame.draw.rect(surface, (10, 10, 14), bar)
                fill_w = int((bar.w - 1) * (hp / max(1, max_hp)))
                if fill_w > 0:
                    pygame.draw.rect(surface, (220, 90, 90), pygame.Rect(bar.x + 1, bar.y + 1, fill_w, bar.h - 1))

    def _draw_bullets(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        for b in self.bullets:
            p = pygame.Vector2(b.pos) - pygame.Vector2(cam_x, cam_y)
            x = iround(float(p.x))
            y = iround(float(p.y))
            if 0 <= x < INTERNAL_W and 0 <= y < INTERNAL_H:
                surface.set_at((x, y), (250, 250, 250))

    def _draw_thrown_furniture(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None: 
        thrown = getattr(self, "thrown_furniture", None) 
        if not isinstance(thrown, list) or not thrown: 
            return 
        for tf in thrown: 
            if not isinstance(tf, HardcoreSurvivalState._ThrownFurniture): 
                continue 
            p = pygame.Vector2(getattr(tf, "pos", pygame.Vector2(0, 0))) - pygame.Vector2(cam_x, cam_y) 
            x = iround(float(p.x)) 
            y = iround(float(p.y)) 
            if not (0 <= x < INTERNAL_W and 0 <= y < INTERNAL_H): 
                continue 
            tid = int(getattr(tf, "tid", 0)) 
            spr = getattr(tf, "sprite", None) 
            if not isinstance(spr, pygame.Surface): 
                spr = self._furniture_sprite(int(tid), getattr(tf, "offsets", []), scale_div=1) 
                try: 
                    setattr(tf, "sprite", spr) 
                except Exception: 
                    pass 
            if spr is None: 
                continue 
            surface.blit(spr, spr.get_rect(center=(int(x), int(y)))) 
 
    def _draw_inventory_ui(self, surface: pygame.Surface) -> None: 
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA) 
        overlay.fill((0, 0, 0, 170)) 
        surface.blit(overlay, (0, 0))

        _grid, panel, footer, x0, y0, cols, _rows, slot, gap = self._inv_layout()

        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=10)
        pygame.draw.rect(surface, (80, 80, 96), panel, 2, border_radius=10)
        draw_text(surface, self.app.font_m, "", (panel.centerx, panel.top + 14), pygame.Color(240, 240, 240), anchor="center")

        dragging = bool(getattr(self, "_inv_dragging", False))
        drag_from = int(getattr(self, "_inv_drag_from_idx", -1))
        drag_over = getattr(self, "_inv_drag_over_idx", None)
        hover_idx = getattr(self, "_inv_hover_idx", None)

        for i, st in enumerate(self.inventory.slots):
            cx = i % cols
            cy = i // cols
            r = pygame.Rect(x0 + cx * (slot + gap), y0 + cy * (slot + gap), slot, slot)
            selected = i == int(self.inv_index)
            hovered = hover_idx is not None and int(hover_idx) == int(i)
            drop_target = dragging and drag_over is not None and int(drag_over) == int(i) and int(i) != int(drag_from)

            bg = (44, 44, 52) if selected else (26, 26, 32)
            border = (220, 220, 240) if selected else (90, 90, 110)
            pygame.draw.rect(surface, bg, r, border_radius=6)
            pygame.draw.rect(surface, border, r, 2, border_radius=6)
            if drop_target:
                pygame.draw.rect(surface, (90, 210, 140), r, 3, border_radius=6)
            elif hovered and not selected:
                pygame.draw.rect(surface, (235, 210, 90), r, 2, border_radius=6)

            if st is None:
                continue
            if dragging and int(i) == int(drag_from):
                continue

            self._ensure_item_visuals(st.item_id)
            img: pygame.Surface | None = None
            spr = self._ITEM_SPRITES.get(st.item_id)
            if spr is not None:
                img = spr
                max_w = r.w - 4
                max_h = r.h - 4
                if img.get_width() > max_w or img.get_height() > max_h:
                    scale = min(max_w / max(1, img.get_width()), max_h / max(1, img.get_height()))
                    iw = max(1, int(round(img.get_width() * scale)))
                    ih = max(1, int(round(img.get_height() * scale)))
                    img = pygame.transform.scale(img, (iw, ih))
            else:
                icon = self._ITEM_ICONS.get(st.item_id)
                if icon is None:
                    idef = self._ITEMS.get(st.item_id)
                    col = idef.color if idef is not None else (255, 0, 255)
                    icon_rect = pygame.Rect(0, 0, 10, 10)
                    icon_rect.center = r.center
                    pygame.draw.rect(surface, col, icon_rect)
                else:
                    img = icon
                    if img.get_width() <= 8:
                        img = pygame.transform.scale(img, (img.get_width() * 2, img.get_height() * 2))
            if img is not None:
                surface.blit(img, img.get_rect(center=r.center))
            draw_text(surface, self.app.font_s, str(int(st.qty)), (r.right - 2, r.bottom - 2), pygame.Color(240, 240, 240), anchor="topright")

        # Drag ghost.
        if dragging and 0 <= int(drag_from) < len(self.inventory.slots):
            st = self.inventory.slots[int(drag_from)]
            if st is not None:
                self._ensure_item_visuals(st.item_id)
                img: pygame.Surface | None = None
                spr = self._ITEM_SPRITES.get(st.item_id)
                if spr is not None:
                    img = spr
                else:
                    img = self._ITEM_ICONS.get(st.item_id)
                if img is not None:
                    pos = getattr(self, "_inv_drag_pos", None)
                    if pos is None:
                        pos = self.app.screen_to_internal(pygame.mouse.get_pos()) or (panel.centerx, panel.centery)
                    ghost = img
                    if ghost.get_width() < 18:
                        ghost = pygame.transform.scale(ghost, (ghost.get_width() * 2, ghost.get_height() * 2))
                    ghost = ghost.copy()
                    ghost.set_alpha(190)
                    surface.blit(ghost, ghost.get_rect(center=(int(pos[0]), int(pos[1]))))

        # Footer (name / desc / help) with clipping + ellipsis to avoid overlap.
        def ellipsize(text: str, font: pygame.font.Font, max_w: int) -> str:
            text = str(text)
            if max_w <= 0 or font.size(text)[0] <= max_w:
                return text
            suffix = ""
            lo = 0
            hi = len(text)
            while lo < hi:
                mid = (lo + hi) // 2
                cand = text[:mid].rstrip() + suffix
                if font.size(cand)[0] <= max_w:
                    lo = mid + 1
                else:
                    hi = mid
            return text[: max(0, lo - 1)].rstrip() + suffix

        info_idx: int | None = None
        try:
            if hover_idx is not None:
                hi = int(hover_idx)
                if 0 <= hi < len(self.inventory.slots) and self.inventory.slots[hi] is not None:
                    info_idx = int(hi)
        except Exception:
            info_idx = None
        if info_idx is None:
            info_idx = int(self.inv_index)

        sel = self.inventory.slots[int(info_idx)] if 0 <= int(info_idx) < len(self.inventory.slots) else None
        name_line = ""
        desc_line = ""
        if sel is not None:
            idef = self._ITEMS.get(sel.item_id)
            name = idef.name if idef is not None else sel.item_id
            prefix = "[H] " if hover_idx is not None and int(info_idx) == int(hover_idx) and int(info_idx) != int(self.inv_index) else ""
            name_line = f"{prefix}{name} x{int(sel.qty)}"
            parts: list[str] = []
            base_desc = str(getattr(idef, "desc", "")).strip() if idef is not None else ""
            if base_desc:
                parts.append(base_desc)
            meta = getattr(sel, "meta", None)
            if isinstance(meta, dict) and meta:
                if str(sel.item_id) == "flashlight":
                    ch = meta.get("charge")
                    if isinstance(ch, (int, float)):
                        parts.append(f"Charge: {int(round(100.0 * clamp(float(ch), 0.0, 1.0)))}%")
            desc_line = " | ".join([p for p in parts if p])

        help_line = " |  |  |  | Q  | Tab "

        pygame.draw.rect(surface, (14, 14, 18), footer, border_radius=8)
        pygame.draw.rect(surface, (70, 70, 86), footer, 1, border_radius=8)
        prev_clip = surface.get_clip()
        surface.set_clip(footer)
        try:
            pad = 6
            max_w = int(footer.w - pad * 2)
            x = int(footer.left + pad)
            y = int(footer.top + 4)
            draw_text(surface, self.app.font_s, ellipsize(name_line, self.app.font_s, max_w), (x, y), pygame.Color(210, 210, 220), anchor="topleft")
            y += int(self.app.font_s.get_height() + 1)
            if desc_line:
                draw_text(surface, self.app.font_s, ellipsize(desc_line, self.app.font_s, max_w), (x, y), pygame.Color(200, 200, 210), anchor="topleft")
            draw_text(
                surface,
                self.app.font_s,
                ellipsize(help_line, self.app.font_s, max_w),
                (x, footer.bottom - self.app.font_s.get_height() - 2),
                pygame.Color(160, 160, 175),
                anchor="topleft",
            )
        finally:
            surface.set_clip(prev_clip)

        # Context menu.
        if bool(getattr(self, "_inv_ctx_open", False)) and 0 <= int(getattr(self, "_inv_ctx_idx", -1)) < len(self.inventory.slots):
            idx = int(getattr(self, "_inv_ctx_idx", -1))
            st = self.inventory.slots[idx]
            if st is None:
                self._inv_ctx_open = False
                self._inv_ctx_idx = -1
                self._inv_ctx_rect = None
                self._inv_ctx_buttons = []
                return

            idef = self._ITEMS.get(st.item_id)
            primary_label = self._inv_primary_label(idef) if idef is not None else ""
            buttons: list[tuple[str, str]] = []
            if primary_label:
                buttons.append((str(primary_label), "primary"))
            buttons.append(("", "drop"))

            mouse_int = self.app.screen_to_internal(pygame.mouse.get_pos())
            mx, my = (int(mouse_int[0]), int(mouse_int[1])) if mouse_int is not None else (0, 0)

            cx = idx % cols
            cy = idx // cols
            slot_r = pygame.Rect(x0 + cx * (slot + gap), y0 + cy * (slot + gap), slot, slot)

            pad = 6
            btn_h = int(self.app.font_s.get_height() + 8)
            menu_w = 0
            for label, _act in buttons:
                menu_w = max(menu_w, int(self.app.font_s.size(label)[0]))
            menu_w = int(clamp(menu_w + pad * 2, 76, 150))
            menu_h = int(len(buttons) * btn_h + pad * 2)

            menu_x = int(slot_r.right + 8)
            if menu_x + menu_w > int(panel.right - 6):
                menu_x = int(slot_r.left - 8 - menu_w)
            menu_y = int(slot_r.top)
            menu_r = pygame.Rect(int(menu_x), int(menu_y), int(menu_w), int(menu_h))

            # Clamp inside the panel and keep it above the footer.
            menu_r.left = int(clamp(menu_r.left, int(panel.left + 6), int(panel.right - 6 - menu_r.w)))
            menu_r.top = int(clamp(menu_r.top, int(panel.top + 24), int(footer.top - 6 - menu_r.h)))

            pygame.draw.rect(surface, (24, 24, 30), menu_r, border_radius=8)
            pygame.draw.rect(surface, (120, 120, 140), menu_r, 2, border_radius=8)

            btn_rects: list[tuple[pygame.Rect, str]] = []
            y = int(menu_r.top + pad)
            for label, act in buttons:
                br = pygame.Rect(int(menu_r.left + pad), int(y), int(menu_r.w - pad * 2), int(btn_h))
                hot = br.collidepoint(int(mx), int(my))
                pygame.draw.rect(surface, (55, 55, 70) if hot else (35, 35, 46), br, border_radius=6)
                pygame.draw.rect(surface, (180, 180, 200) if hot else (90, 90, 110), br, 1, border_radius=6)
                draw_text(surface, self.app.font_s, str(label), (br.centerx, br.centery), pygame.Color(240, 240, 240), anchor="center")
                btn_rects.append((br, str(act)))
                y += int(btn_h)

            self._inv_ctx_rect = menu_r
            self._inv_ctx_buttons = btn_rects
        else:
            self._inv_ctx_rect = None
            self._inv_ctx_buttons = []

    def _draw_sprite_gallery_ui(self, surface: pygame.Surface) -> None:
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 210))
        surface.blit(overlay, (0, 0))

        panel = pygame.Rect(10, 10, INTERNAL_W - 20, INTERNAL_H - 20)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (90, 90, 110), panel, 2, border_radius=12)

        page = int(getattr(self, "_gallery_page", 0)) % 2
        title = "Sprite Gallery: Cars" if page == 0 else "Sprite Gallery: Bike"
        draw_text(surface, self.app.font_m, title, (panel.centerx, panel.top + 12), pygame.Color(240, 240, 240), anchor="center")

        if page == 0:
            ids = list(self._CAR_MODELS.keys())
            if not ids:
                draw_text(surface, self.app.font_s, "No car models", (panel.centerx, panel.centery), pygame.Color(200, 200, 210), anchor="center")
            else:
                maxw = 1
                maxh = 1
                for mid in ids:
                    base = self._CAR_BASE.get((str(mid), 0, 0))
                    if base is None:
                        continue
                    maxw = max(maxw, int(base.get_width()))
                    maxh = max(maxh, int(base.get_height()))

                scale = 3
                cols = 3
                cell_pad = 10
                label_h = 14
                cell_w = maxw * scale + cell_pad
                cell_h = maxh * scale + label_h + cell_pad
                rows = int((len(ids) + cols - 1) // cols)
                grid_w = cols * cell_w
                grid_h = rows * cell_h
                x0 = int(panel.centerx - grid_w // 2)
                y0 = int(panel.top + 30)
                if y0 + grid_h > panel.bottom - 16:
                    y0 = max(int(panel.top + 30), int(panel.bottom - 16 - grid_h))

                for idx, mid in enumerate(ids):
                    base = self._CAR_BASE.get((str(mid), 0, 0))
                    if base is None:
                        continue
                    spr = pygame.transform.scale(base, (int(base.get_width()) * scale, int(base.get_height()) * scale))
                    cx = idx % cols
                    cy = idx // cols
                    cell_x = x0 + cx * cell_w
                    cell_y = y0 + cy * cell_h
                    bg = pygame.Rect(cell_x + 4, cell_y + 2, cell_w - 8, maxh * scale + 4)
                    pygame.draw.rect(surface, (24, 24, 30), bg, border_radius=10)
                    pygame.draw.rect(surface, (50, 50, 64), bg, 1, border_radius=10)
                    x = cell_x + (cell_w - spr.get_width()) // 2
                    y = cell_y + 4
                    surface.blit(spr, (x, y))
                    draw_text(surface, self.app.font_s, str(mid), (cell_x + cell_w // 2, cell_y + maxh * scale + 8), pygame.Color(200, 200, 210), anchor="midtop")
        else:
            dirs = ["up", "down", "left", "right"]
            scale = 5
            cell = 18 * scale
            x0 = int(panel.centerx - (len(dirs) * cell) // 2)
            y0 = int(panel.top + 34)

            for di, d in enumerate(dirs):
                for fi in range(2):
                    b = self._BIKE_FRAMES.get(d, self._BIKE_FRAMES["right"])[fi]
                    rider_frames = getattr(self, "cyclist_frames", getattr(self, "_CYCLIST_FRAMES", {})).get(d)
                    if rider_frames is None:
                        pf = getattr(self, "player_frames", self._PLAYER_FRAMES)
                        rider_frames = pf.get(d, pf["down"])[:2]
                    r = rider_frames[fi % len(rider_frames)]

                    bs = pygame.transform.scale(b, (int(b.get_width()) * scale, int(b.get_height()) * scale))
                    rs = pygame.transform.scale(r, (int(r.get_width()) * scale, int(r.get_height()) * scale))
                    x = x0 + di * cell + (cell - bs.get_width()) // 2
                    y = y0 + fi * cell + (cell - bs.get_height()) // 2
                    surface.blit(bs, (x, y))
                    rr = rs.get_rect()
                    off = (5 if d in ("up", "down") else 4) * scale
                    rr.midbottom = (x + bs.get_width() // 2, y + bs.get_height() // 2 + off)
                    surface.blit(rs, rr)

                draw_text(surface, self.app.font_s, d, (x0 + di * cell + cell // 2, y0 + 2 * cell - 10), pygame.Color(200, 200, 210), anchor="center")

        draw_text(surface, self.app.font_s, "Tab//  | F2/Esc ", (panel.centerx, panel.bottom - 8), pygame.Color(160, 160, 175), anchor="center")

    def _draw_rv_interior_ui(self, surface: pygame.Surface) -> None:
        # Removed: full-screen RV interior UI.
        return
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)     
        overlay.fill((0, 0, 0, 190))
        surface.blit(overlay, (0, 0))

        panel = pygame.Rect(16, 14, INTERNAL_W - 32, INTERNAL_H - 28)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (90, 90, 110), panel, 2, border_radius=12)

        label = "" if str(getattr(self.rv, "model_id", "rv")) == "rv" else ""
        draw_text(surface, self.app.font_m, f"{label}", (panel.centerx, panel.top + 14), pygame.Color(240, 240, 240), anchor="center")

        # Floor plan (tile map).
        tile_px = 14
        map_w = int(self._RV_INT_W) * tile_px
        map_h = int(self._RV_INT_H) * tile_px
        map_x = int(panel.centerx - map_w // 2)
        map_y = int(panel.top + 28)
        map_rect = pygame.Rect(map_x, map_y, map_w, map_h)
        pygame.draw.rect(surface, (24, 24, 30), map_rect.inflate(8, 8), border_radius=10)
        pygame.draw.rect(surface, (60, 60, 76), map_rect.inflate(8, 8), 2, border_radius=10)

        layout = self._vehicle_int_layout()
        for y, row in enumerate(layout):
            for x, ch in enumerate(row[: int(self._RV_INT_W)]):
                tid = int(self._RV_INT_LEGEND.get(ch, int(self.T_FLOOR)))
                tdef = self._TILES.get(tid)
                col = tdef.color if tdef is not None else (255, 0, 255)
                if tid == int(self.T_FLOOR):
                    col = (62, 60, 56)
                elif tid == int(self.T_WALL):
                    col = (22, 22, 26)
                r = pygame.Rect(map_x + x * tile_px, map_y + y * tile_px, tile_px, tile_px)
                pygame.draw.rect(surface, col, r)
                pygame.draw.rect(surface, (10, 10, 14), r, 1)
                # Tiny glyph for special tiles.
                if ch == "D":
                    pygame.draw.line(surface, (240, 220, 140), (r.left + 3, r.centery), (r.right - 3, r.centery), 2)
                elif ch == "B":
                    pygame.draw.rect(surface, (240, 240, 240), pygame.Rect(r.left + 3, r.top + 3, r.w - 6, 3))
                elif ch == "S":
                    pygame.draw.rect(surface, (200, 200, 210), pygame.Rect(r.left + 3, r.top + 3, r.w - 6, r.h - 6), 1)
                elif ch == "T":
                    pygame.draw.rect(surface, (12, 12, 16), pygame.Rect(r.left + 3, r.top + 5, r.w - 6, r.h - 10))
                elif ch == "V":
                    g = pygame.Rect(r.left + 3, r.top + 4, r.w - 6, r.h - 8)
                    pygame.draw.rect(surface, (90, 140, 190), g, 1)
                    pygame.draw.line(surface, (180, 210, 240), (g.left + 1, g.top + 1), (g.right - 2, g.top + 1), 1)
                elif ch == "R":
                    pygame.draw.circle(surface, (34, 34, 42), (r.centerx, r.centery), 4, 1)
                    pygame.draw.circle(surface, (34, 34, 42), (r.centerx, r.centery), 1)

        focus = str(getattr(self, "rv_ui_focus", "map"))
        cx, cy = self.rv_ui_map
        if 0 <= int(cx) < int(self._RV_INT_W) and 0 <= int(cy) < int(self._RV_INT_H):
            cur_r = pygame.Rect(map_x + int(cx) * tile_px, map_y + int(cy) * tile_px, tile_px, tile_px)
            col = (240, 240, 240) if focus == "map" else (130, 130, 150)
            pygame.draw.rect(surface, col, cur_r, 2)

        # Inventories.
        slot = 22
        gap = 4

        pcols = max(1, int(self.inventory.cols))
        prows = int(math.ceil(len(self.inventory.slots) / pcols))
        pgrid_w = pcols * slot + (pcols - 1) * gap
        pgrid_h = prows * slot + (prows - 1) * gap

        scols = max(1, int(self.rv_storage.cols))
        srows = int(math.ceil(len(self.rv_storage.slots) / scols))
        sgrid_w = scols * slot + (scols - 1) * gap
        sgrid_h = srows * slot + (srows - 1) * gap

        inv_y = map_rect.bottom + 22
        left_x = panel.left + 14
        right_x = panel.right - 14 - sgrid_w

        draw_text(surface, self.app.font_s, "", (left_x, inv_y - 14), pygame.Color(200, 200, 210), anchor="topleft")
        draw_text(surface, self.app.font_s, "", (right_x, inv_y - 14), pygame.Color(200, 200, 210), anchor="topleft")

        def draw_inv(inv: HardcoreSurvivalState._Inventory, *, x0: int, y0: int, cols: int, sel_idx: int, focused: bool) -> None:
            for i, st in enumerate(inv.slots):
                cx = i % cols
                cy = i // cols
                r = pygame.Rect(x0 + cx * (slot + gap), y0 + cy * (slot + gap), slot, slot)
                selected = focused and i == int(sel_idx)
                bg = (44, 44, 52) if selected else (26, 26, 32)
                border = (220, 220, 240) if selected else (90, 90, 110)
                pygame.draw.rect(surface, bg, r, border_radius=6)
                pygame.draw.rect(surface, border, r, 2, border_radius=6)
                if st is None:
                    continue
                self._ensure_item_visuals(st.item_id)
                img: pygame.Surface | None = None
                spr = self._ITEM_SPRITES.get(st.item_id)
                if spr is not None:
                    img = spr
                    max_w = r.w - 4
                    max_h = r.h - 4
                    if img.get_width() > max_w or img.get_height() > max_h:
                        scale = min(max_w / max(1, img.get_width()), max_h / max(1, img.get_height()))
                        iw = max(1, int(round(img.get_width() * scale)))
                        ih = max(1, int(round(img.get_height() * scale)))
                        img = pygame.transform.scale(img, (iw, ih))
                else:
                    icon = self._ITEM_ICONS.get(st.item_id)
                    if icon is None:
                        idef = self._ITEMS.get(st.item_id)
                        col = idef.color if idef is not None else (255, 0, 255)
                        icon_rect = pygame.Rect(0, 0, 10, 10)
                        icon_rect.center = r.center
                        pygame.draw.rect(surface, col, icon_rect)
                    else:
                        img = icon
                        if img.get_width() <= 8:
                            img = pygame.transform.scale(img, (img.get_width() * 2, img.get_height() * 2))
                if img is not None:
                    surface.blit(img, img.get_rect(center=r.center))
                draw_text(surface, self.app.font_s, str(int(st.qty)), (r.right - 2, r.bottom - 2), pygame.Color(240, 240, 240), anchor="topright")

        draw_inv(self.inventory, x0=left_x, y0=inv_y, cols=pcols, sel_idx=int(self.rv_ui_player_index), focused=(focus == "player"))
        draw_inv(self.rv_storage, x0=right_x, y0=inv_y, cols=scols, sel_idx=int(self.rv_ui_storage_index), focused=(focus == "storage"))

        # Description / help.
        desc = ""
        if focus == "map":
            ch = self._rv_ui_char_at(int(cx), int(cy))
            if ch == "D":
                desc = "Enter "
            elif ch == "B":
                desc = "Enter /"
            elif ch == "S":
                desc = "Enter "
            elif ch == "T":
                desc = "/"
            elif ch == "C":
                desc = ""
            else:
                desc = ""
        elif focus == "player":
            st = self.inventory.slots[int(self.rv_ui_player_index)]
            if st is None:
                desc = ""
            else:
                idef = self._ITEMS.get(st.item_id)
                name = idef.name if idef is not None else st.item_id
                desc = f"{name} x{int(st.qty)}Enter "
        else:
            st = self.rv_storage.slots[int(self.rv_ui_storage_index)]
            if st is None:
                desc = ""
            else:
                idef = self._ITEMS.get(st.item_id)
                name = idef.name if idef is not None else st.item_id
                desc = f"{name} x{int(st.qty)}Enter "

        if self.rv_ui_status:
            draw_text(surface, self.app.font_s, self.rv_ui_status, (panel.centerx, panel.bottom - 24), pygame.Color(255, 220, 140), anchor="center")
        draw_text(surface, self.app.font_s, desc, (panel.centerx, panel.bottom - 12), pygame.Color(200, 200, 210), anchor="center")
        draw_text(surface, self.app.font_s, "Tab | Enter/ | Esc", (panel.centerx, panel.bottom - 2), pygame.Color(160, 160, 175), anchor="center")

    def _draw_home_storage_ui(self, surface: pygame.Surface) -> None:
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 190))
        surface.blit(overlay, (0, 0))

        panel = pygame.Rect(16, 14, INTERNAL_W - 32, INTERNAL_H - 28)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (90, 90, 110), panel, 2, border_radius=12)

        storage = self._home_ui_storage_inv()
        storage_label = self._home_ui_storage_label()
        draw_text(surface, self.app.font_m, self._home_ui_storage_title(), (panel.centerx, panel.top + 14), pygame.Color(240, 240, 240), anchor="center")

        focus = str(getattr(self, "home_ui_focus", "storage"))
        slot = 22
        gap = 4

        pcols = max(1, int(self.inventory.cols))
        prows = int(math.ceil(len(self.inventory.slots) / pcols))
        pgrid_w = pcols * slot + (pcols - 1) * gap
        pgrid_h = prows * slot + (prows - 1) * gap

        scols = max(1, int(storage.cols))
        srows = int(math.ceil(len(storage.slots) / scols))
        sgrid_w = scols * slot + (scols - 1) * gap
        sgrid_h = srows * slot + (srows - 1) * gap

        inv_y = panel.top + 46
        left_x = panel.left + 14
        right_x = panel.right - 14 - sgrid_w

        content_h = max(pgrid_h, sgrid_h) + 20
        inv_y = int(clamp(inv_y, panel.top + 42, panel.bottom - 52 - content_h))

        draw_text(surface, self.app.font_s, "", (left_x, inv_y - 14), pygame.Color(200, 200, 210), anchor="topleft")
        draw_text(surface, self.app.font_s, storage_label, (right_x, inv_y - 14), pygame.Color(200, 200, 210), anchor="topleft")

        def draw_inv(
            inv: HardcoreSurvivalState._Inventory,
            *,
            x0: int,
            y0: int,
            cols: int,
            sel_idx: int,
            focused: bool,
        ) -> None:
            for i, st in enumerate(inv.slots):
                cx = i % cols
                cy = i // cols
                r = pygame.Rect(x0 + cx * (slot + gap), y0 + cy * (slot + gap), slot, slot)
                selected = focused and i == int(sel_idx)
                bg = (44, 44, 52) if selected else (26, 26, 32)
                border = (220, 220, 240) if selected else (90, 90, 110)
                pygame.draw.rect(surface, bg, r, border_radius=6)
                pygame.draw.rect(surface, border, r, 2, border_radius=6)
                if st is None:
                    continue
                self._ensure_item_visuals(st.item_id)
                img: pygame.Surface | None = None
                spr = self._ITEM_SPRITES.get(st.item_id)
                if spr is not None:
                    img = spr
                    max_w = r.w - 4
                    max_h = r.h - 4
                    if img.get_width() > max_w or img.get_height() > max_h:
                        scale = min(max_w / max(1, img.get_width()), max_h / max(1, img.get_height()))
                        iw = max(1, int(round(img.get_width() * scale)))
                        ih = max(1, int(round(img.get_height() * scale)))
                        img = pygame.transform.scale(img, (iw, ih))
                else:
                    icon = self._ITEM_ICONS.get(st.item_id)
                    if icon is None:
                        idef = self._ITEMS.get(st.item_id)
                        col = idef.color if idef is not None else (255, 0, 255)
                        icon_rect = pygame.Rect(0, 0, 10, 10)
                        icon_rect.center = r.center
                        pygame.draw.rect(surface, col, icon_rect)
                    else:
                        img = icon
                        if img.get_width() <= 8:
                            img = pygame.transform.scale(img, (img.get_width() * 2, img.get_height() * 2))
                if img is not None:
                    surface.blit(img, img.get_rect(center=r.center))
                draw_text(surface, self.app.font_s, str(int(st.qty)), (r.right - 2, r.bottom - 2), pygame.Color(240, 240, 240), anchor="topright")

        draw_inv(
            self.inventory,
            x0=left_x,
            y0=inv_y,
            cols=pcols,
            sel_idx=int(getattr(self, "home_ui_player_index", 0)),
            focused=(focus == "player"),
        )
        draw_inv(
            storage,
            x0=right_x,
            y0=inv_y,
            cols=scols,
            sel_idx=int(getattr(self, "home_ui_storage_index", 0)),
            focused=(focus == "storage"),
        )

        desc = ""
        if focus == "player":
            st = self.inventory.slots[int(getattr(self, "home_ui_player_index", 0))]
            if st is None:
                desc = ""
            else:
                idef = self._ITEMS.get(st.item_id)
                name = idef.name if idef is not None else st.item_id
                desc = f": {name} x{int(st.qty)} (Enter  {storage_label})"
        else:
            st = storage.slots[int(getattr(self, "home_ui_storage_index", 0))]
            if st is None:
                desc = f"{storage_label}"
            else:
                idef = self._ITEMS.get(st.item_id)
                name = idef.name if idef is not None else st.item_id
                desc = f"{storage_label}: {name} x{int(st.qty)} (Enter  )"

        if getattr(self, "home_ui_status", ""):
            draw_text(surface, self.app.font_s, str(self.home_ui_status), (panel.centerx, panel.bottom - 24), pygame.Color(255, 220, 140), anchor="center")
        draw_text(surface, self.app.font_s, desc, (panel.centerx, panel.bottom - 12), pygame.Color(200, 200, 210), anchor="center")
        draw_text(surface, self.app.font_s, f"Tab  /{storage_label} | Enter  | Esc ", (panel.centerx, panel.bottom - 2), pygame.Color(160, 160, 175), anchor="center")

    def draw(self, surface: pygame.Surface) -> None:
        surface.fill((0, 0, 0))
        # Updated by player draw routines; used for speech-bubble dialogs.
        self._last_player_screen_rect = None
        if getattr(self, "house_interior", False):
            self._hover_tooltip = None
            self._draw_house_interior_scene(surface)
            self._draw_day_night_overlay(surface, in_rv=True)
            self._draw_weather_effects(surface, in_rv=True)
            self._draw_survival_ui(surface)
            if getattr(self, "world_map_open", False):
                self._draw_world_map_ui(surface)
                return
            self._draw_hover_tooltip(surface)
            if self.inv_open:
                self._draw_inventory_ui(surface)
            if getattr(self, "_gallery_open", False):
                self._draw_sprite_gallery_ui(surface)
            self._draw_speech_bubble(surface)
            self._draw_dialog(surface)
            self._draw_conversation(surface)
            return
        if getattr(self, "sch_interior", False):
            self._hover_tooltip = None
            self._draw_sch_interior_scene(surface)
            self._draw_day_night_overlay(surface, in_rv=True)
            self._draw_weather_effects(surface, in_rv=True)
            self._draw_survival_ui(surface)
            if getattr(self, "world_map_open", False):
                self._draw_world_map_ui(surface)
                return
            self._draw_hover_tooltip(surface)
            if getattr(self, "sch_elevator_ui_open", False):
                self._draw_sch_elevator_ui(surface)
            elif self.inv_open:
                self._draw_inventory_ui(surface)
            if getattr(self, "_gallery_open", False):
                self._draw_sprite_gallery_ui(surface)
            self._draw_speech_bubble(surface)
            self._draw_dialog(surface)
            self._draw_conversation(surface)
            return
        if getattr(self, "hr_interior", False):
            self._hover_tooltip = None
            self._draw_hr_interior_scene(surface)
            self._draw_day_night_overlay(surface, in_rv=True)
            self._draw_weather_effects(surface, in_rv=True)
            self._draw_survival_ui(surface)
            if getattr(self, "world_map_open", False):
                self._draw_world_map_ui(surface)
                return
            if getattr(self, "home_ui_open", False):
                self._draw_home_storage_ui(surface)
                return
            self._draw_hover_tooltip(surface)
            if bool(getattr(self, "hr_travel_active", False)):
                self._draw_hr_travel_ui(surface)
                return
            if getattr(self, "hr_elevator_ui_open", False):
                self._draw_hr_elevator_ui(surface)
            elif self.inv_open:
                self._draw_inventory_ui(surface)
            if getattr(self, "_gallery_open", False):
                self._draw_sprite_gallery_ui(surface)
            self._draw_speech_bubble(surface)
            self._draw_dialog(surface)
            self._draw_conversation(surface)
            return
        cam_x = int(getattr(self, "cam_x", 0))
        cam_y = int(getattr(self, "cam_y", 0))

        # Hover tooltip is populated during world draws (items / vehicles).
        self._hover_tooltip = None

        # High-rise 1F draw mask: used by _draw_world_tile to hide the
        # non-floor "back" filler area while inside.
        prev_inside_key = getattr(self, "_inside_building_key", None)
        self._inside_highrise_draw_mask = None
        self._inside_highrise_floor_overlay = None
        self._inside_highrise_facade_slice = None
        self._inside_building_key = None
        self._inside_building_visible = None
        self._draw_player_tile_xy = None
        try:
            ptx = int(math.floor(self.player.pos.x / self.TILE_SIZE))
            pty = int(math.floor(self.player.pos.y / self.TILE_SIZE))
            self._draw_player_tile_xy = (int(ptx), int(pty))
            p_tile = int(self.world.peek_tile(int(ptx), int(pty)))
            # Robust "inside building" detection: any non-solid tile can be an
            # interior floor variant (prevents the player from disappearing under
            # roofs when a stamp uses a different floor tile id).
            can_be_inside = not bool(self._tile_solid(int(p_tile)))
            if can_be_inside:
                pchunk = self.world.peek_chunk(int(ptx) // int(self.CHUNK_SIZE), int(pty) // int(self.CHUNK_SIZE))
                if pchunk is None:
                    pchunk = self.world.get_chunk(int(ptx) // int(self.CHUNK_SIZE), int(pty) // int(self.CHUNK_SIZE))
                if pchunk is not None:
                    hit = self._peek_building_at_tile(int(ptx), int(pty))
                    if hit is None:
                        self._inside_building_key = None
                    else:
                        tx0, ty0, w, h, roof_kind, floors = hit
                        self._inside_building_key = (int(tx0), int(ty0), int(w), int(h))

                        style, var = self._building_roof_style_var(int(roof_kind))
                        if int(style) == 6:
                            max_floors = int(max(2, int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
                            if int(floors) <= 0:
                                floors = int(max_floors)
                            floors = int(min(int(floors), int(max_floors)))
                            cut_px = int(self._roof_cut_px(style=int(style), w=int(w), h=int(h), var=int(var), floors=int(floors)))
                            ts = int(max(1, int(self.TILE_SIZE)))
                            cut_tiles = int(cut_px) // ts
                            core_h = int(max(2, int(h) - 2 - int(cut_tiles)))
                            min_core_h = int(max(6, int(getattr(self, "HIGHRISE_MIN_FLOOR_TILES", 9))))
                            core_h = int(min(int(max(int(core_h), int(min_core_h))), int(max(2, int(h) - 2))))
                            top_cut = int(max(0, (int(h) - 2) - int(core_h)))
                            floor_y0 = int(ty0 + 1 + int(top_cut))
                            self._inside_highrise_draw_mask = (int(tx0), int(ty0), int(w), int(h), int(floor_y0))

                            # High-rise upper floors: draw the interior as an
                            # elevated layer so the floor aligns to the facade
                            # band of the current floor.
                            floor_slice_h = int(
                                clamp(
                                    int(round(float(getattr(self.player, "body_h", getattr(self.player, "h", 12))) * 1.5)),
                                    14,
                                    26,
                                )
                            )
                            cur_floor = 1
                            floors_total = int(max(1, int(min(int(floors), int(max_floors)))))

                            # multi_house records live on the origin chunk; scan around it.
                            origin_cx = int(tx0) // int(self.CHUNK_SIZE)
                            origin_cy = int(ty0) // int(self.CHUNK_SIZE)
                            mh_found = False
                            for oy in (-1, 0, 1):
                                for ox in (-1, 0, 1):
                                    c2 = self.world.peek_chunk(int(origin_cx + ox), int(origin_cy + oy))
                                    if c2 is None:
                                        continue
                                    for mh in getattr(c2, "multi_houses", []):
                                        if (
                                            int(getattr(mh, "tx0", -999999)) == int(tx0)
                                            and int(getattr(mh, "ty0", -999999)) == int(ty0)
                                            and int(getattr(mh, "w", -1)) == int(w)
                                            and int(getattr(mh, "h", -1)) == int(h)
                                        ):
                                            cur_floor = int(max(1, int(getattr(mh, "cur_floor", 1))))
                                            floors_total = int(
                                                max(1, int(min(int(getattr(mh, "floors", floors_total)), int(max_floors))))
                                            )
                                            mh_found = True
                                            break
                                    if mh_found:
                                        break
                                if mh_found:
                                    break

                            cur_floor = int(clamp(int(cur_floor), 1, int(floors_total)))
                            if int(floors_total) > 1:
                                self._inside_highrise_facade_slice = (
                                    int(tx0),
                                    int(ty0),
                                    int(w),
                                    int(h),
                                    int(cur_floor),
                                    int(floors_total),
                                )
                            if int(floors_total) > 1 and int(cur_floor) > 1:
                                offset = int(cur_floor - 1) * int(floor_slice_h)
                                offset_max = int(max(0, int(floors_total - 1) * int(floor_slice_h)))
                                if offset > offset_max:
                                    offset = int(offset_max)
                                self._inside_highrise_floor_overlay = (
                                    int(tx0),
                                    int(ty0),
                                    int(w),
                                    int(h),
                                    int(floor_y0),
                                    int(offset),
                                    int(floor_slice_h),
                                )

            # Stabilize inside-building detection across frames, but only for a
            # very short miss to avoid dragging cutaway state onto neighboring buildings.
            try:
                if isinstance(prev_inside_key, tuple) and len(prev_inside_key) == 4:
                    if self._inside_building_key is None:
                        miss_n = int(getattr(self, "_inside_building_miss_frames", 0) or 0) + 1
                        self._inside_building_miss_frames = int(miss_n)
                        if int(miss_n) <= 1:
                            bx0, by0, bw, bh = (
                                int(prev_inside_key[0]),
                                int(prev_inside_key[1]),
                                int(prev_inside_key[2]),
                                int(prev_inside_key[3]),
                            )
                            if int(bw) > 0 and int(bh) > 0 and int(bx0) <= int(ptx) < int(bx0) + int(bw) and int(by0) <= int(pty) < int(by0) + int(bh):
                                self._inside_building_key = (int(bx0), int(by0), int(bw), int(bh))
                    else:
                        self._inside_building_miss_frames = 0
            except Exception:
                self._inside_building_miss_frames = 0
        except Exception:
            self._inside_highrise_draw_mask = None
            self._inside_highrise_floor_overlay = None
            self._inside_highrise_facade_slice = None
            self._inside_building_key = None
            self._inside_building_visible = None
            self._draw_player_tile_xy = None

        # When inside a cutaway building, only reveal the connected area the
        # player can actually reach (prevents seeing neighbors through roofs).
        try:
            inside_key = getattr(self, "_inside_building_key", None)
            pt = getattr(self, "_draw_player_tile_xy", None)
            if isinstance(inside_key, tuple) and len(inside_key) == 4 and isinstance(pt, tuple) and len(pt) == 2:
                tx0, ty0, w, h = (int(inside_key[0]), int(inside_key[1]), int(inside_key[2]), int(inside_key[3]))
                ptx, pty = int(pt[0]), int(pt[1])
                if int(w) > 0 and int(h) > 0 and int(tx0) <= int(ptx) < int(tx0) + int(w) and int(ty0) <= int(pty) < int(ty0) + int(h):
                    # Reveal only the reachable connected component. This keeps
                    # other apartments hidden in high-rises unless you can enter them.
                    passable: set[tuple[int, int]] = set()
                    stack = [(int(ptx), int(pty))]
                    seen: set[tuple[int, int]] = set()
                    while stack and len(passable) < int(w) * int(h):
                        sx, sy = stack.pop()
                        sx = int(sx)
                        sy = int(sy)
                        if (sx, sy) in seen:
                            continue
                        seen.add((sx, sy))
                        if not (int(tx0) <= int(sx) < int(tx0) + int(w) and int(ty0) <= int(sy) < int(ty0) + int(h)):
                            continue
                        tid = int(self.world.peek_tile(int(sx), int(sy)))
                        if bool(self._tile_solid(int(tid))):
                            continue
                        passable.add((sx, sy))
                        stack.extend([(sx + 1, sy), (sx - 1, sy), (sx, sy + 1), (sx, sy - 1)])

                    visible: set[tuple[int, int]] = set(passable)
                    # Include adjacent furniture/doors so rooms look complete.
                    for sx, sy in tuple(passable):
                        for ox, oy in ((0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)):
                            nx, ny = int(sx + ox), int(sy + oy)
                            if not (int(tx0) <= int(nx) < int(tx0) + int(w) and int(ty0) <= int(ny) < int(ty0) + int(h)):
                                continue
                            visible.add((nx, ny))

                    self._inside_building_visible = visible
        except Exception:
            self._inside_building_visible = None

        # High-rise upper floors: shift the camera up slightly so the elevated
        # interior/player doesn't leave the screen on very high floors.
        overlay_tmp = getattr(self, "_inside_highrise_floor_overlay", None)
        cam_y_draw = int(cam_y)
        if overlay_tmp is not None:
            try:
                offset_px = int(overlay_tmp[5])
                if offset_px > 0:
                    target_y = int(INTERNAL_H // 3)
                    lift = int(max(0, int(offset_px) - int((INTERNAL_H // 2) - int(target_y))))
                    cam_y_draw = int(cam_y_draw - int(lift))
            except Exception:
                cam_y_draw = int(cam_y)
        self._last_cam_draw = (int(cam_x), int(cam_y_draw))

        start_tx = int(math.floor(cam_x / self.TILE_SIZE)) - 1
        start_ty = int(math.floor(cam_y_draw / self.TILE_SIZE)) - 1
        end_tx = int(math.floor((cam_x + INTERNAL_W) / self.TILE_SIZE)) + 1
        end_ty = int(math.floor((cam_y_draw + INTERNAL_H) / self.TILE_SIZE)) + 1

        for ty in range(start_ty, end_ty + 1):
            py = ty * self.TILE_SIZE - cam_y_draw
            if py >= INTERNAL_H:
                break
            for tx in range(start_tx, end_tx + 1):
                px = tx * self.TILE_SIZE - cam_x
                if px >= INTERNAL_W:
                    break
                tile = self.world.peek_tile(tx, ty)
                rect = pygame.Rect(int(px), int(py), self.TILE_SIZE, self.TILE_SIZE)
                self._draw_world_tile(surface, rect, tx=tx, ty=ty, tile_id=int(tile))

        # Include a small off-screen margin so facade extrusions (face_h) don't pop at screen edges.
        self._draw_building_facades(surface, cam_x, cam_y_draw, start_tx - 3, end_tx + 3, start_ty - 3, end_ty + 3)
        self._draw_vehicle_props(surface, cam_x, cam_y_draw, start_tx, end_tx, start_ty, end_ty)
        self._draw_story_traffic(surface, cam_x, cam_y_draw)
        self._draw_world_props(surface, cam_x, cam_y_draw, start_tx, end_tx, start_ty, end_ty)
        self._draw_world_items(surface, cam_x, cam_y_draw, start_tx, end_tx, start_ty, end_ty)
        # Corpses are "on the ground": draw them under vehicles so they don't appear on top of the RV.
        self._draw_zombies(surface, cam_x, cam_y_draw, corpses=True, alive=False)
        self._draw_rv(surface, cam_x, cam_y_draw)
        self._draw_bike(surface, cam_x, cam_y_draw)
        self._draw_story_npcs(surface, cam_x, cam_y_draw)
        self._draw_zombies(surface, cam_x, cam_y_draw, corpses=False, alive=True)
        self._draw_bullets(surface, cam_x, cam_y_draw)
        self._draw_thrown_furniture(surface, cam_x, cam_y_draw)
        overlay = getattr(self, "_inside_highrise_floor_overlay", None)
        if self.mount is None and overlay is None:
            self._draw_player(surface, cam_x, cam_y_draw)
        self._draw_hit_fx(surface, cam_x, cam_y_draw)
        # Occlude the player/mount by front facades when behind buildings.
        # NOTE: On high-rise upper floors the player is drawn with an extra
        # vertical offset; we run the occlusion pass after the offset draw.
        if overlay is None or self.mount is not None:
            self._occlude_mounted_vehicle_with_facades(
                surface,
                cam_x,
                cam_y_draw,
                start_tx - 3,
                end_tx + 3,
                start_ty - 3,
                end_ty + 3,
            )
        if overlay is not None:
            try:
                tx0, ty0, w, h, floor_y0, offset_px, floor_h = overlay  
                tx0 = int(tx0)
                ty0 = int(ty0)
                w = int(w)
                h = int(h)
                floor_y0 = int(floor_y0)
                offset_px = int(offset_px)
                floor_h = int(floor_h)
                if w > 0 and h > 0 and offset_px > 0:
                    ts = int(self.TILE_SIZE)

                    # Elevated interior tile layer.
                    start_y = int(max(int(ty0), int(floor_y0) - 1))
                    end_y = int(ty0 + h)
                    end_x = int(tx0 + w)
                    for ty in range(start_y, end_y):
                        py = int(ty) * int(ts) - int(cam_y_draw) - int(offset_px)
                        if py >= INTERNAL_H:
                            continue
                        if py + ts < 0:
                            continue
                        for tx in range(int(tx0), int(end_x)):
                            px = int(tx) * int(ts) - int(cam_x)
                            if px >= INTERNAL_W:
                                continue
                            if px + ts < 0:
                                continue
                            tile = self.world.peek_tile(int(tx), int(ty))
                            rect = pygame.Rect(int(px), int(py), int(ts), int(ts))
                            self._draw_world_tile(surface, rect, tx=int(tx), ty=int(ty), tile_id=int(tile), apply_mask=False)

                    if self.mount is None:
                        self._draw_player(surface, int(cam_x), int(cam_y_draw) + int(offset_px))
                        # Occlude the elevated player with the current-floor facade band.
                        try:
                            bx = int(tx0) * int(ts) - int(cam_x)
                            by = int(ty0) * int(ts) - int(cam_y_draw)
                            ground_y = int(by + int(h) * int(ts))
                            south_h = int(max(1, int(floor_h)))
                            south_y = int(ground_y - int(offset_px) - int(south_h))
                            clip = pygame.Rect(int(bx - 3), int(south_y - 3), int(w) * int(ts) + 6, int(south_h) + 6)
                            prev_clip = surface.get_clip()
                            surface.set_clip(clip)
                            try:
                                self._draw_building_facades(
                                    surface,
                                    int(cam_x),
                                    int(cam_y_draw),
                                    int(tx0) - 3,
                                    int(tx0) + int(w) + 3,
                                    int(ty0) - 3,
                                    int(ty0) + int(h) + 3,
                                )
                            finally:
                                surface.set_clip(prev_clip)
                        except Exception:
                            pass
                        self._occlude_mounted_vehicle_with_facades(
                            surface,
                            int(cam_x),
                            int(cam_y_draw),
                            int(start_tx - 3),
                            int(end_tx + 3),
                            int(start_ty - 3),
                            int(end_ty + 3),
                            entity_cam_y=int(cam_y_draw) + int(offset_px),
                        )
            except Exception:
                pass
        self._draw_roofs(surface, cam_x, cam_y_draw, start_tx, end_tx, start_ty, end_ty)
        self._draw_world_lighting(surface, cam_x, cam_y_draw, start_tx, end_tx, start_ty, end_ty)
        self._draw_weather_effects(surface, in_rv=False)
        self._draw_wanted_helicopter_overlay(surface)
        self._draw_home_move_mode_overlay(surface, cam_x, cam_y_draw)
        self._draw_survival_ui(surface)
        if getattr(self, "world_map_open", False):
            self._draw_world_map_ui(surface)
            return
        if getattr(self, "world_elevator_ui_open", False):
            self._draw_world_elevator_ui(surface)
            return
        if getattr(self, "home_ui_open", False):
            self._draw_home_storage_ui(surface)
            return

        self._draw_world_furniture_carry_preview(surface, cam_x, cam_y_draw)
        self._draw_world_context_menu(surface, cam_x, cam_y_draw)
        self._draw_lamp_cfg_ui(surface, cam_x, cam_y_draw)
        self._draw_toilet_task_ui(surface)
        self._draw_work_task_ui(surface)
        self._draw_hover_tooltip(surface)
        self._draw_speech_bubble(surface)
        self._draw_dialog(surface)
        self._draw_conversation(surface)

        if self._debug:
            self._draw_debug(surface, cam_x, cam_y_draw)
        if self.inv_open:
            self._draw_inventory_ui(surface)
        if getattr(self, "_gallery_open", False):
            self._draw_sprite_gallery_ui(surface)

        self._draw_pause_menu(surface)

    def _occlude_mounted_vehicle_with_facades(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
        *,
        entity_cam_y: int | None = None,
    ) -> None:
        entity_cam_y_i = int(cam_y) if entity_cam_y is None else int(entity_cam_y)
        skip_building: tuple[int, int, int, int] | None = None
        if entity_cam_y is not None:
            overlay = getattr(self, "_inside_highrise_floor_overlay", None)
            if overlay is not None:
                try:
                    tx0, ty0, w, h = overlay[:4]
                    skip_building = (int(tx0), int(ty0), int(w), int(h))
                except Exception:
                    skip_building = None
        mount = getattr(self, "mount", None)
        if mount is None:
            if not hasattr(self, "player") or self.player is None:
                return
            rect = self.player.rect_at(self.player.pos).move(-int(cam_x), -int(entity_cam_y_i)).inflate(18, 18)
            ground_y = int(round((float(self.player.pos.y) - float(entity_cam_y_i)) + float(self.player.h) / 2.0))
        elif mount == "bike":
            if not hasattr(self, "bike") or self.bike is None:
                return
            w = int(getattr(self.bike, "w", 14))
            h = int(getattr(self.bike, "h", 10))
            rect = self.bike.rect().move(-int(cam_x), -int(entity_cam_y_i)).inflate(36, 46)
            ground_y = int(round((float(self.bike.pos.y) - float(entity_cam_y_i)) + float(h) / 2.0))
        elif mount == "rv":
            if not hasattr(self, "rv") or self.rv is None:
                return
            rect = self.rv.rect().move(-int(cam_x), -int(entity_cam_y_i)).inflate(72, 62)
            ground_y = int(round((float(self.rv.pos.y) - float(entity_cam_y_i)) + float(self.rv.h) / 2.0))
        else:
            return

        clip = rect.clip(pygame.Rect(0, 0, INTERNAL_W, INTERNAL_H))
        if clip.w <= 0 or clip.h <= 0:
            return
        prev_clip = surface.get_clip()
        surface.set_clip(clip)
        try:
            self._draw_building_facades(
                surface,
                int(cam_x),
                int(cam_y),
                int(start_tx),
                int(end_tx),
                int(start_ty),
                int(end_ty),
                min_ground_y=int(ground_y) + 1,
                skip_building=skip_building,
            )
        finally:
            surface.set_clip(prev_clip)

    def _draw_player_held_item( 
        self, 
        surface: pygame.Surface, 
        player_rect: pygame.Rect, 
        *, 
        direction: str, 
        step: int, 
        idle: bool, 
        run: bool, 
        height_delta: int, 
    ) -> None: 
        if self.gun is not None: 
            return 
        if getattr(self, "mount", None) is not None: 
            return 
        if float(getattr(self, "punch_left", 0.0)) > 0.0: 
            return 
 
        held = getattr(self, "held_item", None) 
        item_id = "" 
        is_melee = False 
        if isinstance(held, HardcoreSurvivalState._ItemStack) and int(getattr(held, "qty", 0)) > 0:
            item_id = str(getattr(held, "item_id", ""))
        else:
            mid = str(getattr(self, "melee_weapon_id", "") or "")
            if mid:
                idef = self._ITEMS.get(mid)
                if idef is not None and str(getattr(idef, "kind", "")) == "melee":
                    item_id = str(mid)
                    is_melee = True
        if not item_id:
            return
        # Melee weapons are drawn on the scaled surface (draw_scaled_overlay) so
        # rotation stays stable after upscaling. Skip the internal draw to avoid
        # double-rendering.
        if bool(is_melee):
            return

        self._ensure_item_visuals(item_id)
        spr = self._ITEM_SPRITES_WORLD.get(item_id) or self._ITEM_SPRITES.get(item_id)
        if spr is None:
            return

        img = spr
        # Flip some small tools so the "held" side matches the player's hand.
        flipped = False
        if item_id in ("cup", "cup_water") and str(direction) == "left":
            img = flip_x_pixel_sprite(img)
            flipped = True

        d = str(direction)
        nodes = HardcoreSurvivalState._survivor_skeleton_nodes(
            str(d),
            int(step),
            idle=bool(idle),
            height_delta=int(height_delta),
            run=bool(run),
        )
        hand = nodes.get("r_hand")
        r = img.get_rect()
        if isinstance(hand, tuple) and len(hand) == 2:
            hx = int(player_rect.left + int(hand[0]))
            hy = int(player_rect.top + int(hand[1]))
            if bool(is_melee):
                # Melee weapons: rotate with aim like guns (xiaotou-style stable rotation),
                # and keep the grip locked to the hand.
                aim = pygame.Vector2(getattr(self, "aim_dir", pygame.Vector2(1, 0)))
                if aim.length_squared() <= 0.001:
                    aim = pygame.Vector2(getattr(self.player, "facing", pygame.Vector2(1, 0)))
                if aim.length_squared() <= 0.001:
                    aim = pygame.Vector2(1, 0)
                aim = aim.normalize()

                flip = float(aim.x) < 0.0
                src = img
                if flip:
                    src = flip_x_pixel_sprite(src)
                deg = -math.degrees(math.atan2(float(aim.y), float(aim.x)))
                if flip:
                    deg -= 180.0
                # Melee item sprites are generated diagonally by default.
                baseline = 31.0
                deg = float(deg) - float(baseline)

                step_deg = 3.0
                qdeg = int(round(round(float(deg) / float(step_deg)) * float(step_deg))) % 360
                rot = rotate_weapon_sprite(src, deg, step_deg=float(step_deg), outline_diagonal=True)

                gx, gy = _sprite_grip_point(src)
                center_local = pygame.Vector2(float(src.get_width()) * 0.5, float(src.get_height()) * 0.5)
                offset_local = pygame.Vector2(float(gx), float(gy)) - center_local
                offset_rot = _rotate_vec_screen_ccw(offset_local, float(qdeg))
                grip = pygame.Vector2(int(hx), int(hy)) + aim * 2.0
                draw_center = grip - offset_rot

                rr = rot.get_rect(center=(int(iround(float(draw_center.x))), int(iround(float(draw_center.y)))))
                surface.blit(rot, rr)
                return

            hold: tuple[int, int] | None = None
            if item_id in ("cup", "cup_water"):
                # Anchor at the handle center so it actually sits in the hand.
                hold = (9, 7)
                if flipped:
                    hold = (int(img.get_width() - 1 - int(hold[0])), int(hold[1]))
            elif bool(is_melee):
                # Anchor near the grip end (our melee icons are diagonal).
                hold = (3, 9)
                if flipped:
                    hold = (int(img.get_width() - 1 - int(hold[0])), int(hold[1]))

            if hold is not None:
                r.topleft = (int(hx - int(hold[0])), int(hy - int(hold[1])))
            else:
                if d == "left":
                    r.midright = (int(hx), int(hy))
                elif d == "right":
                    r.midleft = (int(hx), int(hy))
                elif d == "up":
                    r.midbottom = (int(hx), int(hy))
                else:
                    r.midtop = (int(hx), int(hy))
        else:
            # Fallback: old offsets if skeleton nodes are unavailable.
            if d == "left":
                r.midright = (int(player_rect.left + 2), int(player_rect.centery + 4))
            elif d == "right":
                r.midleft = (int(player_rect.right - 2), int(player_rect.centery + 4))
            elif d == "up":
                r.midbottom = (int(player_rect.centerx), int(player_rect.top + 6))
            else:
                r.midtop = (int(player_rect.centerx), int(player_rect.bottom - 2))

        surface.blit(img, r) 
 
    def _furniture_sprite(self, tid: int, offsets: object, *, scale_div: int = 1) -> pygame.Surface | None: 
        tid = int(tid) 
        if tid <= 0: 
            return None 
        scale_div = int(max(1, int(scale_div))) 
        offs: list[tuple[int, int]] = [] 
        if isinstance(offsets, list): 
            for o in offsets: 
                if not (isinstance(o, tuple) and len(o) == 2): 
                    continue 
                try: 
                    offs.append((int(o[0]), int(o[1]))) 
                except Exception: 
                    continue 
        if not offs: 
            offs = [(0, 0)] 
        key = (int(tid), tuple(sorted(offs)), int(scale_div)) 
        cached = _FURNITURE_SPR_CACHE.get(key) 
        if cached is not None: 
            return cached 
 
        ts = int(max(1, int(self.TILE_SIZE))) 
        minx = min(int(dx) for dx, _dy in offs) 
        maxx = max(int(dx) for dx, _dy in offs) 
        miny = min(int(dy) for _dx, dy in offs) 
        maxy = max(int(dy) for _dx, dy in offs) 
        w = int(max(1, (int(maxx) - int(minx) + 1) * int(ts))) 
        h = int(max(1, (int(maxy) - int(miny) + 1) * int(ts))) 
        surf = pygame.Surface((int(w), int(h)), pygame.SRCALPHA) 
 
        # Use far-away "virtual" coords to avoid any interior visibility masks. 
        base_tx = 1_000_000 
        base_ty = 1_000_000 
        for dx, dy in offs: 
            rx = int(dx - minx) * int(ts) 
            ry = int(dy - miny) * int(ts) 
            rect = pygame.Rect(int(rx), int(ry), int(ts), int(ts)) 
            self._draw_world_tile(surf, rect, tx=int(base_tx + dx), ty=int(base_ty + dy), tile_id=int(tid), apply_mask=False) 
 
        if int(scale_div) > 1: 
            nw = max(1, int(round(float(surf.get_width()) / float(scale_div)))) 
            nh = max(1, int(round(float(surf.get_height()) / float(scale_div)))) 
            surf = pygame.transform.scale(surf, (int(nw), int(nh))) 
 
        _FURNITURE_SPR_CACHE[key] = surf 
        return surf 
 
    def _draw_player_back_carry(self, surface: pygame.Surface, player_rect: pygame.Rect, *, direction: str) -> None: 
        if not bool(self._world_furniture_carry_active()): 
            return 
        carry = getattr(self, "home_move_carry", None) 
        if not isinstance(carry, dict):
            return
        tid = int(carry.get("tid", 0))
        if tid <= 0:
            return
        offsets = carry.get("offsets", []) 
        spr = self._furniture_sprite(int(tid), offsets, scale_div=2) 
        if spr is None: 
            return 
        r = spr.get_rect() 
        d = str(direction) 
        if d == "down": 
            r.midtop = (int(player_rect.centerx), int(player_rect.top + 1)) 
        elif d == "up": 
            r.midbottom = (int(player_rect.centerx), int(player_rect.bottom - 10)) 
        elif d == "left": 
            r.midright = (int(player_rect.left + 3), int(player_rect.centery)) 
        else: 
            r.midleft = (int(player_rect.right - 3), int(player_rect.centery)) 
        surface.blit(spr, r) 
 
    def _draw_player(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None: 
        # Draw the player at integer world coords (pixel-lock) so diagonal motion
        # doesn't produce 1px jitter from float -> int rounding differences.
        try:
            pwx, pwy = getattr(self, "_player_pixel_lock_world_xy")
            pwx = int(pwx)
            pwy = int(pwy)
        except Exception:
            pwx, pwy = self._compute_player_pixel_lock_world_xy()
        px = int(pwx - int(cam_x))
        py = int(pwy - int(cam_y))
        p = pygame.Vector2(float(px), float(py))

        pose = str(getattr(self, "player_pose", "")).strip()
        pose_space = str(getattr(self, "player_pose_space", "")).strip()
        pose_anchor = getattr(self, "player_pose_anchor", None)
        use_pose = bool(pose and pose_space == "world" and pose_anchor is not None)
        if use_pose:
            ap = pygame.Vector2(float(pose_anchor[0]) - float(cam_x), float(pose_anchor[1]) - float(cam_y))
            ax = iround(float(ap.x))
            ay = iround(float(ap.y))
            if pose == "sleep":
                frame = int(float(getattr(self, "player_pose_phase", 0.0)) * 2.0) % 2
                spr = self._get_pose_sprite("sleep", frame=frame)
                shadow = pygame.Rect(0, 0, 18, 7)
                shadow.center = (ax, ay + 4)
                sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
                pygame.draw.ellipse(sh, (0, 0, 0, 100), sh.get_rect())
                surface.blit(sh, shadow.topleft)
                rect = spr.get_rect(center=(ax, ay + 2))
                surface.blit(spr, rect)
                self._last_player_screen_rect = pygame.Rect(rect)
                return
            if pose == "sit":
                spr = self._get_pose_sprite("sit", direction=str(getattr(self.player, "dir", "down")), frame=0)
                shadow = pygame.Rect(0, 0, 16, 6)
                shadow.center = (ax, ay + 7)
                sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
                pygame.draw.ellipse(sh, (0, 0, 0, 115), sh.get_rect())
                surface.blit(sh, shadow.topleft)
                rect = spr.get_rect(center=(ax, ay + 5))
                surface.blit(spr, rect)
                self._last_player_screen_rect = pygame.Rect(rect)
                return

        face = pygame.Vector2(self.player.facing)
        if self.gun is not None:
            face = pygame.Vector2(self.aim_dir)
        if face.length_squared() <= 0.001:
            face = pygame.Vector2(0, 1)
        punch_left = float(getattr(self, "punch_left", 0.0))
        if punch_left > 0.0:
            pd = pygame.Vector2(getattr(self, "punch_dir", face))
            if pd.length_squared() > 0.001:
                face = pd.normalize()

        prev_d = str(getattr(self.player, "dir", "down"))
        ax = abs(float(face.x))
        ay = abs(float(face.y))
        bias = 1.25
        if ax <= 1e-6 and ay <= 1e-6:
            d = prev_d
        elif prev_d in ("up", "down"):
            # Stick to vertical unless X is clearly dominant.
            if ax > ay * float(bias):
                d = "right" if float(face.x) >= 0.0 else "left"
            else:
                d = "down" if float(face.y) >= 0.0 else "up"
        elif prev_d in ("left", "right"):
            # Stick to horizontal unless Y is clearly dominant.
            if ay > ax * float(bias):
                d = "down" if float(face.y) >= 0.0 else "up"
            else:
                d = "right" if float(face.x) >= 0.0 else "left"
        else:
            # Fallback: choose the dominant axis.
            if ay >= ax:
                d = "down" if float(face.y) >= 0.0 else "up"
            else:
                d = "right" if float(face.x) >= 0.0 else "left"
        self.player.dir = d

        height_delta = 0
        av = getattr(self, "avatar", None)
        if av is not None:
            hidx = int(getattr(av, "height", 1))
            height_delta = 1 if hidx == 0 else -1 if hidx == 2 else 0

        pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
        pf_run = getattr(self, "player_frames_run", None)
        is_run = bool(getattr(self, "player_sprinting", False))
        pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
        frames = pf.get(d, pf["down"])
        moving = self.player.vel.length_squared() > 1.0
        walk_idx = 0
        idle_anim = True
        if not moving or len(frames) <= 1:
            spr = frames[0]
        else:
            idle_anim = False
            walk = frames[1:]
            phase = (float(self.player.walk_phase) % math.tau) / math.tau
            idx = int(phase * len(walk)) % len(walk)
            walk_idx = int(idx)
            spr = walk[idx]
        rect = spr.get_rect()
        rect.midbottom = (px, iround(float(p.y) + float(self.player.h) / 2.0))
        surface.blit(spr, rect)
        self._last_player_screen_rect = pygame.Rect(rect)
        self._draw_player_back_carry(surface, rect, direction=str(d))
        self._draw_player_held_item(
            surface,
            rect,
            direction=str(d),
            step=int(walk_idx),
            idle=bool(idle_anim),
            run=bool(is_run),
            height_delta=int(height_delta),
        )

        # Guns are drawn on the scaled surface (draw_scaled_overlay) for stable
        # pixel rotation. Keep the internal path only as an opt-in debug mode.
        if self.gun is not None and bool(getattr(self, "_draw_gun_internal", False)):
            aim = pygame.Vector2(self.aim_dir)
            if aim.length_squared() <= 0.001:
                aim = pygame.Vector2(1, 0)
            aim = aim.normalize()
            sk = self._survivor_skeleton_nodes(
                d,
                int(walk_idx),
                idle=bool(idle_anim),
                height_delta=int(height_delta),
                run=bool(is_run),
            )
            hand_node = sk.get("r_hand")
            if hand_node is not None:
                hx, hy = hand_node
                base_hand = pygame.Vector2(int(rect.left + hx), int(rect.top + hy))
            else:
                base_hand = pygame.Vector2(rect.centerx, rect.centery + 3)
            hand = base_hand + aim * 4.0
            gun_id = str(getattr(self.gun, "gun_id", "pistol"))
            try:
                self._ensure_item_visuals(gun_id)
            except Exception:
                pass
            base = self._ITEM_SPRITES.get(gun_id) or self._ITEM_SPRITES_WORLD.get(gun_id) or self._GUN_HAND_SPRITES.get(gun_id)
            if base is not None:
                flip = float(aim.x) < 0.0
                if flip:
                    base = flip_x_pixel_sprite(base)
                deg = -math.degrees(math.atan2(float(aim.y), float(aim.x)))
                if flip:
                    deg -= 180.0
                if float(self.gun.reload_left) > 0.0 and float(self.gun.reload_total) > 0.0:
                    p = 1.0 - float(self.gun.reload_left) / max(1e-6, float(self.gun.reload_total))
                    deg += float(p) * 360.0
                step_deg = 2.0
                qdeg = int(round(round(float(deg) / float(step_deg)) * float(step_deg))) % 360
                gun_spr = rotate_weapon_sprite(base, deg, step_deg=float(step_deg), outline_diagonal=False)
                gx, gy = _sprite_grip_point(base)
                center_local = pygame.Vector2(float(base.get_width()) * 0.5, float(base.get_height()) * 0.5)
                offset_local = pygame.Vector2(float(gx), float(gy)) - center_local
                offset_rot = _rotate_vec_screen_ccw(offset_local, float(qdeg))
                grip = pygame.Vector2(int(round(hand.x)), int(round(hand.y)))
                draw_center = grip - offset_rot
                grect = gun_spr.get_rect(center=(int(iround(float(draw_center.x))), int(iround(float(draw_center.y)))))
                surface.blit(gun_spr, grect)
            else:
                tip = hand + aim * 12.0
                col = (240, 240, 240) if self.gun.reload_left <= 0.0 else (200, 200, 220)
                pygame.draw.line(surface, col, (int(hand.x), int(hand.y)), (int(tip.x), int(tip.y)), 2)

            if getattr(self, "muzzle_flash_left", 0.0) > 0.0 and self.gun.reload_left <= 0.0:
                muzzle = hand + aim * 13.0
                r = 3 if self.muzzle_flash_left > 0.03 else 2
                pygame.draw.circle(surface, (255, 240, 190), (int(round(muzzle.x)), int(round(muzzle.y))), r)
                pygame.draw.circle(surface, (255, 200, 120), (int(round(muzzle.x)), int(round(muzzle.y))), max(1, r - 1))

        if punch_left > 0.0: 
            swing_id = str(getattr(self, "_melee_swing_id", "fist") or "fist") 
            mdef = self._MELEE_DEFS.get(swing_id) or self._MELEE_DEFS.get("fist") 
            total = float(getattr(mdef, "total_s", self._PUNCH_TOTAL_S)) if mdef is not None else float(self._PUNCH_TOTAL_S) 
            t = 1.0 - float(punch_left) / max(1e-6, total) 
            ext = math.sin(float(clamp(t, 0.0, 1.0)) * math.pi)
            # Keep the fist close to the body (match 12x16 sprite scale).
            reach = 1.0 + ext * 4.0

            pdir = pygame.Vector2(getattr(self, "punch_dir", pygame.Vector2(1, 0)))
            if pdir.length_squared() <= 0.001:
                pdir = pygame.Vector2(1, 0)
            pdir = pdir.normalize()

            height_delta = 0
            av = getattr(self, "avatar", None)
            if av is not None:
                hidx = int(getattr(av, "height", 1))
                height_delta = 1 if hidx == 0 else -1 if hidx == 2 else 0

            sk = self._survivor_skeleton_nodes(
                d,
                int(walk_idx),
                idle=bool(idle_anim),
                height_delta=int(height_delta),
                run=bool(is_run),
            )
            # Pick a sane punch anchor from the skeleton:
            # - left/right punches use the hand on that side
            # - up/down punches alternate left/right hand (feels more natural)
            lh = sk.get("l_hand")
            rh = sk.get("r_hand")
            base_hand: pygame.Vector2
            if lh is not None and rh is not None:
                lhx, lhy = int(lh[0]), int(lh[1])
                rhx, rhy = int(rh[0]), int(rh[1])
                left_pt = (lhx, lhy) if lhx <= rhx else (rhx, rhy)
                right_pt = (lhx, lhy) if lhx >= rhx else (rhx, rhy)
                if abs(float(pdir.x)) >= abs(float(pdir.y)) and float(pdir.x) != 0.0:
                    # Horizontal punch: choose the hand on the punch side.
                    if float(pdir.x) < 0.0:
                        hx, hy = left_pt
                    else:
                        hx, hy = right_pt
                    base_hand = pygame.Vector2(int(rect.left + hx), int(rect.top + hy))
                else:
                    # Vertical punch: alternate which hand "leads".
                    use_right = bool(getattr(self, "punch_hand", 0))
                    hx, hy = (right_pt if use_right else left_pt)
                    base_hand = pygame.Vector2(int(rect.left + hx), int(rect.top + hy))
            else:
                hand_key = "r_hand"
                hand_node = sk.get(hand_key)
                if hand_node is not None:
                    hx, hy = hand_node
                    base_hand = pygame.Vector2(int(rect.left + hx), int(rect.top + hy))
                else:
                    base_hand = pygame.Vector2(rect.centerx, rect.centery + 3)

            outline = (10, 10, 12) 
            skin = tuple(getattr(self, "_PLAYER_PAL", {}).get("S", (220, 190, 160))) 
 
            use_weapon = bool(swing_id and swing_id != "fist") 
            weapon_img: pygame.Surface | None = None 
            if use_weapon: 
                idef = self._ITEMS.get(str(swing_id)) 
                if idef is None or str(getattr(idef, "kind", "")) != "melee": 
                    use_weapon = False 
                else: 
                    self._ensure_item_visuals(str(swing_id)) 
                    weapon_img = self._ITEM_SPRITES_WORLD.get(str(swing_id)) or self._ITEM_SPRITES.get(str(swing_id)) 
                    if weapon_img is None: 
                        use_weapon = False 
 
            if not use_weapon: 
                fist = base_hand + pdir * float(reach) 
                fx = int(round(float(fist.x))) 
                fy = int(round(float(fist.y))) 
                # Arm connection: keep it straight (old-school punch look).
                bx0 = int(round(float(base_hand.x)))
                by0 = int(round(float(base_hand.y)))
                pygame.draw.line(surface, skin, (bx0, by0), (int(fx), int(fy)), 1)
                fr = pygame.Rect(int(fx - 1), int(fy - 1), 3, 3) 
                surface.fill(skin, fr) 
                pygame.draw.rect(surface, outline, fr, 1) 
            else: 
                # Weapon swing: rotate the equipped melee sprite (/) instead of drawing a punch fist. 
                # Draw on the scaled surface (draw_scaled_overlay) for stable pixel rotation.
                # Keep the internal swing draw only as an opt-in debug mode.
                if not bool(getattr(self, "_draw_melee_internal", False)):
                    return
                weapon_len = float(getattr(mdef, "visual_len", 10.0)) if mdef is not None else 10.0
                weapon_reach = 2.0 + float(ext) * float(max(6.0, float(weapon_len) * 0.85))

                # Arm connection (short): draw to the grip area so it doesn't look like a punch.
                step_n = int(clamp(int(round(float(weapon_reach))), 0, 8))
                for s in range(1, int(step_n)):
                    bx = int(round(float(base_hand.x) + float(pdir.x) * float(s)))
                    by = int(round(float(base_hand.y) + float(pdir.y) * float(s)))
                    if 0 <= bx < INTERNAL_W and 0 <= by < INTERNAL_H:
                        surface.set_at((bx, by), skin)

                # Forward chop: rotate around the grip, through the aim direction.
                dir_sign = 1.0 if bool(getattr(self, "punch_hand", 0)) else -1.0
                aim_deg = -math.degrees(math.atan2(float(pdir.y), float(pdir.x)))
                swing_phase = float(clamp(t, 0.0, 1.0))

                arc = 110.0
                desired = float(aim_deg) + float(dir_sign) * float(arc) * (0.5 - float(swing_phase))
                baseline = 31.0
                rot_deg = float(desired) - float(baseline)

                step_deg = 3.0
                qdeg = int(round(round(float(rot_deg) / float(step_deg)) * float(step_deg))) % 360
                rot = (
                    rotate_weapon_sprite(weapon_img, rot_deg, step_deg=float(step_deg), outline_diagonal=True)
                    if weapon_img is not None
                    else None
                )
                if rot is not None and weapon_img is not None:
                    gx, gy = _sprite_grip_point(weapon_img)
                    center_local = pygame.Vector2(float(weapon_img.get_width()) * 0.5, float(weapon_img.get_height()) * 0.5)
                    offset_local = pygame.Vector2(float(gx), float(gy)) - center_local
                    offset_rot = _rotate_vec_screen_ccw(offset_local, float(qdeg))

                    grip = base_hand + pdir * float(2.0 + ext * 3.0)
                    draw_center = grip - offset_rot
                    cx2 = int(iround(float(draw_center.x)))
                    cy2 = int(iround(float(draw_center.y)))
                    surface.blit(rot, rot.get_rect(center=(int(cx2), int(cy2))))
                    # Tiny motion trail.
                    tx2 = int(clamp(int(cx2 - int(round(float(pdir.x)))), 0, INTERNAL_W - 1))
                    ty2 = int(clamp(int(cy2 - int(round(float(pdir.y)))), 0, INTERNAL_H - 1))
                    surface.set_at((tx2, ty2), outline)

                # Small hand pixel at the grip.
                hx2 = int(round(float(base_hand.x)))
                hy2 = int(round(float(base_hand.y)))
                hr = pygame.Rect(int(hx2 - 1), int(hy2 - 1), 3, 3)
                surface.fill(skin, hr)
                pygame.draw.rect(surface, outline, hr, 1)

    def draw_scaled_overlay(self, surface: pygame.Surface) -> None:
        # Post-scale overlay hook (called from App.blit_scaled). We draw weapons
        # here so rotation happens at screen pixel resolution (xiaotou-style),
        # keeping diagonal angles stable and non-jaggy after upscaling.
        if bool(getattr(self, "house_interior", False)) or bool(getattr(self, "hr_interior", False)) or bool(getattr(self, "sch_interior", False)):
            return
        if getattr(self, "mount", None) is not None:
            return
        if bool(getattr(self, "world_map_open", False)) or bool(getattr(self, "inv_open", False)) or bool(getattr(self, "pause_open", False)):
            return

        player_rect = getattr(self, "_last_player_screen_rect", None)
        if not isinstance(player_rect, pygame.Rect):
            return
        app = getattr(self, "app", None)
        if app is None:
            return

        sx = float(getattr(app, "view_scale_x", 1.0))
        sy = float(getattr(app, "view_scale_y", 1.0))
        if sx <= 1e-6 or sy <= 1e-6:
            return
        s = float(min(sx, sy))

        def scale_sprite(img: pygame.Surface) -> pygame.Surface:
            if abs(float(sx) - 1.0) < 1e-6 and abs(float(sy) - 1.0) < 1e-6:
                return img
            tw = int(max(1, int(round(float(img.get_width()) * float(sx)))))
            th = int(max(1, int(round(float(img.get_height()) * float(sy)))))
            # Upscaling: keep crisp edges. Downscaling: smooth a bit.
            if float(sx) >= 1.0 and float(sy) >= 1.0:
                return _scale_cached(img, (tw, th))
            return _smoothscale_cached(img, (tw, th))

        # Aim direction.
        aim = pygame.Vector2(getattr(self, "aim_dir", pygame.Vector2(1, 0)))
        if aim.length_squared() <= 0.001:
            aim = pygame.Vector2(getattr(getattr(self, "player", None), "facing", pygame.Vector2(1, 0)))
        if aim.length_squared() <= 0.001:
            aim = pygame.Vector2(1, 0)
        aim = aim.normalize()

        # Compute hand position (INTERNAL pixels) from the same skeleton nodes used by _draw_player().
        d = str(getattr(getattr(self, "player", None), "dir", "down") or "down")
        height_delta = 0
        av = getattr(self, "avatar", None)
        if av is not None:
            try:
                hidx = int(getattr(av, "height", 1))
                height_delta = 1 if hidx == 0 else -1 if hidx == 2 else 0
            except Exception:
                height_delta = 0

        pf_walk = getattr(self, "player_frames", getattr(self, "_PLAYER_FRAMES", {}))
        pf_run = getattr(self, "player_frames_run", None)
        is_run = bool(getattr(self, "player_sprinting", False))
        pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
        frames = (pf.get(d) if isinstance(pf, dict) else None) or (pf_walk.get("down") if isinstance(pf_walk, dict) else None) or ()
        moving = bool(getattr(getattr(self, "player", None), "vel", pygame.Vector2(0, 0)).length_squared() > 1.0)
        walk_idx = 0
        idle_anim = True
        if moving and len(frames) > 1:
            idle_anim = False
            walk = frames[1:]
            if walk:
                phase = (float(getattr(getattr(self, "player", None), "walk_phase", 0.0)) % math.tau) / math.tau
                walk_idx = int(phase * len(walk)) % len(walk)

        sk = self._survivor_skeleton_nodes(
            d,
            int(walk_idx),
            idle=bool(idle_anim),
            height_delta=int(height_delta),
            run=bool(is_run),
        )
        hand_node = sk.get("r_hand")
        if hand_node is not None:
            hx, hy = int(hand_node[0]), int(hand_node[1])
            base_hand = pygame.Vector2(int(player_rect.left + hx), int(player_rect.top + hy))
        else:
            base_hand = pygame.Vector2(int(player_rect.centerx), int(player_rect.centery + 3))

        def blit_rotated_weapon(
            *,
            sprite: pygame.Surface,
            grip_internal: pygame.Vector2,
            deg: float,
            step_deg: float,
            baseline_deg: float = 0.0,
            outline_diagonal: bool = True,
            flip_x: bool = False,
        ) -> None:
            # Match the pre-overlay (internal-surface) weapon behavior:
            # - If aiming left, flip the sprite and rotate relative to that flip so
            #   guns/melee don't end up upside-down.
            src = sprite
            if bool(flip_x):
                try:
                    src = flip_x_pixel_sprite(sprite)
                except Exception:
                    src = sprite
                deg = float(deg) - 180.0

            step_deg_f = float(step_deg) if step_deg else 2.0
            step_deg_f = float(clamp(step_deg_f, 0.5, 45.0))
            rot_deg = float(deg) - float(baseline_deg)
            qdeg = int(round(round(float(rot_deg) / float(step_deg_f)) * float(step_deg_f))) % 360

            src_s = scale_sprite(src)
            rot = rotate_weapon_texture(src_s, float(rot_deg), step_deg=float(step_deg_f), outline_diagonal=bool(outline_diagonal))
            if rot is None:
                return

            grip_px = pygame.Vector2(float(grip_internal.x) * sx, float(grip_internal.y) * sy)

            # Keep the grip/pivot stable by computing it on the *unscaled* source
            # sprite (same as the old internal draw), then scaling the offset.
            gx, gy = _sprite_grip_point(src)
            sw0 = max(1, int(src.get_width()))
            sh0 = max(1, int(src.get_height()))
            sx_eff = float(src_s.get_width()) / float(sw0)
            sy_eff = float(src_s.get_height()) / float(sh0)
            ox = (float(gx) - float(sw0) * 0.5) * float(sx_eff)
            oy = (float(gy) - float(sh0) * 0.5) * float(sy_eff)
            offset_rot = _rotate_vec_screen_ccw(pygame.Vector2(float(ox), float(oy)), float(qdeg))
            draw_center = pygame.Vector2(float(grip_px.x), float(grip_px.y)) - offset_rot
            rr = rot.get_rect(center=(int(round(draw_center.x)), int(round(draw_center.y))))
            surface.blit(rot, rr)

        # Gun held.
        gun = getattr(self, "gun", None)
        if gun is not None:
            gun_id = str(getattr(gun, "gun_id", "pistol") or "pistol")
            try:
                self._ensure_item_visuals(gun_id)
            except Exception:
                pass
            # In-hand weapons should not be larger than the player sprite.
            # Use the pre-scaled "world" sprite for hand display (matches the
            # original small-pixel look and keeps guns from looking oversized).
            base = (getattr(self, "_ITEM_SPRITES_WORLD", {}) or {}).get(gun_id) or (getattr(self, "_ITEM_SPRITES", {}) or {}).get(gun_id)
            if base is None:
                return

            hand = pygame.Vector2(base_hand) + aim * 4.0
            deg = -math.degrees(math.atan2(float(aim.y), float(aim.x)))
            flip = float(aim.x) < 0.0
            if float(getattr(gun, "reload_left", 0.0)) > 0.0 and float(getattr(gun, "reload_total", 0.0)) > 0.0:
                p = 1.0 - float(getattr(gun, "reload_left", 0.0)) / max(1e-6, float(getattr(gun, "reload_total", 0.0)))
                deg += float(p) * 360.0
            blit_rotated_weapon(sprite=base, grip_internal=hand, deg=float(deg), step_deg=2.0, baseline_deg=0.0, outline_diagonal=False, flip_x=bool(flip))

            # Muzzle flash (scaled).
            if float(getattr(self, "muzzle_flash_left", 0.0)) > 0.0 and float(getattr(gun, "reload_left", 0.0)) <= 0.0:
                muzzle = hand + aim * 13.0
                mx = int(round(float(muzzle.x) * sx))
                my = int(round(float(muzzle.y) * sy))
                r = 3 if float(getattr(self, "muzzle_flash_left", 0.0)) > 0.03 else 2
                r = max(1, int(round(float(r) * s)))
                pygame.draw.circle(surface, (255, 240, 190), (mx, my), int(r))
                pygame.draw.circle(surface, (255, 200, 120), (mx, my), max(1, int(r) - 1))
            return

        # Melee swing (only when not holding a gun).
        punch_left = float(getattr(self, "punch_left", 0.0))
        swing_id = str(getattr(self, "_melee_swing_id", "fist") or "fist")
        if punch_left > 0.0 and swing_id and swing_id != "fist":
            try:
                self._ensure_item_visuals(str(swing_id))
            except Exception:
                pass
            spr = (getattr(self, "_ITEM_SPRITES_WORLD", {}) or {}).get(str(swing_id)) or (getattr(self, "_ITEM_SPRITES", {}) or {}).get(str(swing_id))
            if spr is None:
                return

            mdef = (getattr(self, "_MELEE_DEFS", {}) or {}).get(str(swing_id)) or (getattr(self, "_MELEE_DEFS", {}) or {}).get("fist")
            total = float(getattr(mdef, "total_s", getattr(self, "_PUNCH_TOTAL_S", 0.26))) if mdef is not None else float(getattr(self, "_PUNCH_TOTAL_S", 0.26))
            t = 1.0 - float(punch_left) / max(1e-6, float(total))
            swing_phase = float(clamp(float(t), 0.0, 1.0))
            ext = math.sin(swing_phase * math.pi)

            pdir = pygame.Vector2(getattr(self, "punch_dir", aim))
            if pdir.length_squared() <= 0.001:
                pdir = pygame.Vector2(aim)
            if pdir.length_squared() <= 0.001:
                pdir = pygame.Vector2(1, 0)
            pdir = pdir.normalize()

            # Forward chop: from "pulled back" to "through" the aim direction.
            aim_deg = -math.degrees(math.atan2(float(pdir.y), float(pdir.x)))
            side = -1.0 if bool(getattr(self, "punch_hand", 0)) else 1.0
            start = float(aim_deg) - 78.0 + side * 6.0
            end = float(aim_deg) + 18.0 + side * 2.0
            u = 0.5 - 0.5 * math.cos(swing_phase * math.pi)
            rot_deg = float(start + (end - start) * u)

            grip = pygame.Vector2(base_hand) + pdir * float(2.0 + ext * 4.0)
            no_outline = str(swing_id) == "melee_machete"
            blit_rotated_weapon(
                sprite=spr,
                grip_internal=grip,
                deg=float(rot_deg),
                step_deg=3.0,
                baseline_deg=31.0,
                outline_diagonal=not bool(no_outline),
                flip_x=bool(float(pdir.x) < 0.0),
            )
            return

        # Idle melee held (rotate with aim, like guns).
        mid = str(getattr(self, "melee_weapon_id", "") or "")
        if not mid:
            return
        idef = (getattr(self, "_ITEMS", {}) or {}).get(str(mid))
        if idef is None or str(getattr(idef, "kind", "")) != "melee":
            return
        try:
            self._ensure_item_visuals(str(mid))
        except Exception:
            pass
        spr = (getattr(self, "_ITEM_SPRITES_WORLD", {}) or {}).get(str(mid)) or (getattr(self, "_ITEM_SPRITES", {}) or {}).get(str(mid))
        if spr is None:
            return

        hand = pygame.Vector2(base_hand) + aim * 3.0
        deg = -math.degrees(math.atan2(float(aim.y), float(aim.x)))
        no_outline = str(mid) == "melee_machete"
        blit_rotated_weapon(
            sprite=spr,
            grip_internal=hand,
            deg=float(deg),
            step_deg=3.0,
            baseline_deg=31.0,
            outline_diagonal=not bool(no_outline),
            flip_x=bool(float(aim.x) < 0.0),
        )

    def _draw_sun_moon_widget(self, surface: pygame.Surface, *, tday: float) -> None:
        rect = pygame.Rect(0, 0, 116, 22)
        rect.topright = (INTERNAL_W - 6, 34)
        pygame.draw.rect(surface, (18, 18, 22), rect, border_radius=8)
        pygame.draw.rect(surface, (70, 70, 86), rect, 2, border_radius=8)

        horizon_y = rect.bottom - 6
        pygame.draw.line(surface, (40, 40, 50), (rect.left + 6, horizon_y), (rect.right - 7, horizon_y), 1)

        amp = 9
        track_w = rect.w - 16
        sun_x = rect.left + 8 + int(round(float(track_w) * float(tday)))
        h_sun = float(math.sin((float(tday) - 0.25) * math.tau))
        sun_y = int(round(horizon_y - h_sun * float(amp)))

        moon_t = (float(tday) + 0.5) % 1.0
        moon_x = rect.left + 8 + int(round(float(track_w) * float(moon_t)))
        moon_y = int(round(horizon_y + h_sun * float(amp)))

        if h_sun > 0.0:
            pygame.draw.circle(surface, (240, 220, 140), (sun_x, sun_y), 4)
            pygame.draw.circle(surface, (0, 0, 0), (sun_x, sun_y), 4, 1)
            for dx, dy in ((-6, 0), (6, 0), (0, -6), (0, 6), (-4, -4), (4, -4), (-4, 4), (4, 4)):
                surface.set_at((int(clamp(sun_x + dx, rect.left + 2, rect.right - 3)), int(clamp(sun_y + dy, rect.top + 2, rect.bottom - 3))), (240, 220, 140))
        else:
            pygame.draw.circle(surface, (220, 220, 230), (moon_x, moon_y), 4)
            pygame.draw.circle(surface, (0, 0, 0), (moon_x, moon_y), 4, 1)
            cut_x = moon_x + 2
            cut_y = moon_y - 1
            pygame.draw.circle(surface, (18, 18, 22), (cut_x, cut_y), 4)

    def _draw_minimap(self, surface: pygame.Surface) -> pygame.Rect | None:
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "sch_interior", False))
            or bool(getattr(self, "house_interior", False))
        ):
            return None

        # Keep the minimap panel size similar (player-centric).
        radius = 15  # tiles
        scale = 3  # px per tile
        tiles = int(radius) * 2 + 1
        map_px = int(tiles) * int(scale)
        pad = 6
        label_h = 12

        panel = pygame.Rect(0, 0, map_px + pad * 2 + 2, map_px + pad * 2 + label_h + 2)
        panel.topright = (INTERNAL_W - 6, 60)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (70, 70, 86), panel, 2, border_radius=12)

        tx = int(math.floor(self.player.pos.x / self.TILE_SIZE))
        ty = int(math.floor(self.player.pos.y / self.TILE_SIZE))

        # Refresh POI cache periodically (used for edge indicators when POIs are off-screen).
        try:
            now = float(time.monotonic())
            last = float(getattr(self, "_poi_cache_t", 0.0))
            if (now - last) >= 0.70:
                cache = getattr(self, "_poi_cache", None)
                if not isinstance(cache, dict):
                    cache = {}
                    self._poi_cache = cache
                scanned = getattr(self, "_poi_scanned_chunks", None)
                if not isinstance(scanned, set):
                    scanned = set()
                    self._poi_scanned_chunks = scanned

                style_to_kind = {2: "market", 3: "hospital", 4: "prison", 5: "school", 7: "bookstore", 9: "gunshop"}
                for (ccx, ccy), chunk in getattr(self.world, "chunks", {}).items():
                    key = (int(ccx), int(ccy))
                    if key in scanned:
                        continue
                    scanned.add(key)
                    for b in getattr(chunk, "buildings", []):
                        if len(b) < 5:
                            continue
                        roof_kind = int(b[4])
                        style = int((roof_kind >> 8) & 0xFF)
                        kind = style_to_kind.get(int(style))
                        if kind is None:
                            continue
                        tx0, ty0, bw, bh = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                        c_tx = int(tx0 + max(1, int(bw)) // 2)
                        c_ty = int(ty0 + max(1, int(bh)) // 2)
                        cache.setdefault(str(kind), []).append((int(c_tx), int(c_ty)))

                self._poi_cache_t = float(now)
        except Exception:
            pass
        season = int(self._season_index())
        key = (int(tx), int(ty), int(radius), int(scale), int(season))

        cached_key = getattr(self, "_minimap_cache_key", None)
        cached_scaled: pygame.Surface | None = getattr(self, "_minimap_cache_scaled", None)
        size_ok = isinstance(cached_scaled, pygame.Surface) and cached_scaled.get_size() == (map_px, map_px)
        need_rebuild = (cached_key != key) or (not size_ok)
        if need_rebuild:
            moving = False
            if getattr(self, "mount", None) == "rv" and getattr(self, "rv", None) is not None:
                moving = self.rv.vel.length_squared() > 0.1
            elif getattr(self, "mount", None) == "bike" and getattr(self, "bike", None) is not None:
                moving = self.bike.vel.length_squared() > 0.1
            else:
                moving = self.player.vel.length_squared() > 0.1

            # Throttle minimap rebuilds while moving to avoid stutter.
            now = float(time.monotonic())
            last_t = float(getattr(self, "_minimap_cache_t", 0.0))
            min_interval = 0.12 if moving else 0.0
            if size_ok and min_interval > 0.0 and (now - last_t) < float(min_interval):
                pass
            else:
                base = pygame.Surface((tiles, tiles))
                base.lock()
                for oy in range(-int(radius), int(radius) + 1):
                    wy = int(ty) + int(oy)
                    py = int(oy) + int(radius)
                    for ox in range(-int(radius), int(radius) + 1):
                        wx = int(tx) + int(ox)
                        px = int(ox) + int(radius)
                        tid = self.world.peek_tile(wx, wy)
                        base.set_at((px, py), self._minimap_color(tid))
                base.unlock()
                cached_scaled = pygame.transform.scale(base, (map_px, map_px))
                self._minimap_cache_key = key
                self._minimap_cache_scaled = cached_scaled
                self._minimap_cache_t = float(now)

        draw_text(surface, self.app.font_s, "", (panel.left + pad, panel.top + 3), pygame.Color(200, 200, 210), anchor="topleft")

        home = getattr(self, "home_highrise_door", None)
        if isinstance(home, tuple) and len(home) == 2:
            hx, hy = int(home[0]), int(home[1])
            dx = float(hx - int(tx))
            dy = float(hy - int(ty))
            dist = float(math.hypot(dx, dy))
            if dist < 1000.0:
                dist_text = f" {int(round(dist))}m"
            else:
                dist_text = f" {dist / 1000.0:.1f}km"
            draw_text(surface, self.app.font_s, dist_text, (panel.right - pad, panel.top + 3), pygame.Color(255, 220, 140), anchor="topright")

        map_x0 = panel.left + pad
        map_y0 = panel.top + pad + label_h
        if isinstance(cached_scaled, pygame.Surface):
            surface.blit(cached_scaled, (map_x0, map_y0))

        # POI icons (public buildings) inside the minimap view.
        # (Do not reveal interiors; we only show a symbol per building footprint.)
        start_tx = int(tx) - int(radius)
        start_ty = int(ty) - int(radius)
        end_tx = int(tx) + int(radius)
        end_ty = int(ty) + int(radius)
        start_cx = int(start_tx) // int(self.CHUNK_SIZE)
        end_cx = int(end_tx) // int(self.CHUNK_SIZE)
        start_cy = int(start_ty) // int(self.CHUNK_SIZE)
        end_cy = int(end_ty) // int(self.CHUNK_SIZE)
        style_to_kind = {2: "market", 3: "hospital", 4: "prison", 5: "school", 7: "bookstore", 9: "gunshop"}
        seen_gunshop = False
        seen_bookstore = False
        drawn_pois = 0
        for ccy in range(int(start_cy), int(end_cy) + 1):
            for ccx in range(int(start_cx), int(end_cx) + 1):
                # Cached minimap frames may skip rebuilding tile colors, so ensure nearby chunks exist.
                chunk = self.world.peek_chunk(int(ccx), int(ccy))
                if chunk is None:
                    chunk = self.world.get_chunk(int(ccx), int(ccy))
                for b in getattr(chunk, "buildings", []):
                    if len(b) < 5:
                        continue
                    btx0, bty0, bw, bh = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                    roof_kind = int(b[4])
                    style = int((roof_kind >> 8) & 0xFF)
                    kind = style_to_kind.get(int(style))
                    if kind is None:
                        continue
                    if kind == "gunshop":
                        seen_gunshop = True
                    elif kind == "bookstore":
                        seen_bookstore = True
                    x1 = int(btx0 + max(1, int(bw)) - 1)
                    y1 = int(bty0 + max(1, int(bh)) - 1)
                    if x1 < int(start_tx) or int(btx0) > int(end_tx) or y1 < int(start_ty) or int(bty0) > int(end_ty):
                        continue
                    # Place the icon at the nearest point of the building to the player
                    # so it shows up even if the building is only partially in view.
                    icon_tx = int(clamp(float(tx), float(btx0), float(x1)))
                    icon_ty = int(clamp(float(ty), float(bty0), float(y1)))
                    mx = int(map_x0 + (int(icon_tx) - int(start_tx)) * int(scale) + int(scale) // 2)
                    my = int(map_y0 + (int(icon_ty) - int(start_ty)) * int(scale) + int(scale) // 2)
                    # Use the same icon scale as the big-map legend so symbols match.
                    self._draw_world_map_icon(surface, mx, my, str(kind), scale=2)
                    drawn_pois += 1
                    if drawn_pois >= 16:
                        break
                if drawn_pois >= 16:
                    break
            if drawn_pois >= 16:
                break

        # Border for the map area.
        pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(map_x0 - 1, map_y0 - 1, map_px + 2, map_px + 2), 1)

        # Player marker.
        cx = int(map_x0 + int(radius) * int(scale) + int(scale) // 2)
        cy = int(map_y0 + int(radius) * int(scale) + int(scale) // 2)
        pygame.draw.circle(surface, (240, 240, 244), (cx, cy), 3)
        pygame.draw.circle(surface, (0, 0, 0), (cx, cy), 3, 1)

        # Home marker (inside map) or arrow (off-screen).
        if isinstance(home, tuple) and len(home) == 2:
            hx, hy = int(home[0]), int(home[1])
            dx_t = int(hx - int(tx))
            dy_t = int(hy - int(ty))
            if abs(dx_t) <= int(radius) and abs(dy_t) <= int(radius):
                mx = int(map_x0 + (dx_t + int(radius)) * int(scale) + int(scale) // 2)
                my = int(map_y0 + (dy_t + int(radius)) * int(scale) + int(scale) // 2)
                pygame.draw.circle(surface, (255, 220, 140), (mx, my), 4)
                pygame.draw.circle(surface, (0, 0, 0), (mx, my), 4, 1)
                surface.fill((255, 245, 190), pygame.Rect(int(mx - 1), int(my - 1), 2, 2))
            else:
                m = max(abs(dx_t), abs(dy_t))
                if m <= 0:
                    ux = 0.0
                    uy = 0.0
                else:
                    ux = float(dx_t) / float(m)
                    uy = float(dy_t) / float(m)
                    l = float(math.hypot(ux, uy))
                    if l > 1e-6:
                        ux /= l
                        uy /= l
                inset = float(radius) - 0.8
                tip_x = float(map_x0) + (float(radius) + ux * inset) * float(scale) + float(scale) * 0.5
                tip_y = float(map_y0) + (float(radius) + uy * inset) * float(scale) + float(scale) * 0.5
                base_x = tip_x - ux * 8.0
                base_y = tip_y - uy * 8.0
                px = -uy
                py = ux
                left = (base_x + px * 4.0, base_y + py * 4.0)
                right = (base_x - px * 4.0, base_y - py * 4.0)
                tip = (tip_x, tip_y)
                pygame.draw.polygon(surface, (255, 220, 140), [tip, left, right])
                pygame.draw.polygon(surface, (0, 0, 0), [tip, left, right], 1)
                lx = int(round(base_x + px * 5.0))
                ly = int(round(base_y + py * 5.0))
                draw_text(surface, self.app.font_s, "", (lx, ly), pygame.Color(240, 240, 244), anchor="center")

        def draw_edge_arrow(
            *,
            dx_t: int,
            dy_t: int,
            color: tuple[int, int, int],
            label: str | None = None,
        ) -> None:
            m = max(abs(int(dx_t)), abs(int(dy_t)))
            if m <= 0:
                return
            ux = float(dx_t) / float(m)
            uy = float(dy_t) / float(m)
            l = float(math.hypot(ux, uy))
            if l > 1e-6:
                ux /= l
                uy /= l
            inset = float(radius) - 0.8
            tip_x = float(map_x0) + (float(radius) + ux * inset) * float(scale) + float(scale) * 0.5
            tip_y = float(map_y0) + (float(radius) + uy * inset) * float(scale) + float(scale) * 0.5
            base_x = tip_x - ux * 7.0
            base_y = tip_y - uy * 7.0
            px = -uy
            py = ux
            left = (base_x + px * 3.5, base_y + py * 3.5)
            right = (base_x - px * 3.5, base_y - py * 3.5)
            tip = (tip_x, tip_y)
            pygame.draw.polygon(surface, tuple(color), [tip, left, right])
            pygame.draw.polygon(surface, (0, 0, 0), [tip, left, right], 1)
            if label:
                lx = int(round(base_x + px * 5.0))
                ly = int(round(base_y + py * 5.0))
                draw_text(surface, self.app.font_s, label, (lx, ly), pygame.Color(240, 240, 240), anchor="center")

        def draw_edge_poi(*, kind: str, dx_t: int, dy_t: int, color: tuple[int, int, int]) -> None:
            # Arrow + the same POI icon used in the world-map legend.
            m = max(abs(int(dx_t)), abs(int(dy_t)))
            if m <= 0:
                return
            ux = float(dx_t) / float(m)
            uy = float(dy_t) / float(m)
            l = float(math.hypot(ux, uy))
            if l > 1e-6:
                ux /= l
                uy /= l
            inset = float(radius) - 0.8
            tip_x = float(map_x0) + (float(radius) + ux * inset) * float(scale) + float(scale) * 0.5
            tip_y = float(map_y0) + (float(radius) + uy * inset) * float(scale) + float(scale) * 0.5

            base_x = tip_x - ux * 9.0
            base_y = tip_y - uy * 9.0
            px = -uy
            py = ux
            left = (base_x + px * 4.0, base_y + py * 4.0)
            right = (base_x - px * 4.0, base_y - py * 4.0)
            tip = (tip_x, tip_y)
            pygame.draw.polygon(surface, tuple(color), [tip, left, right])
            pygame.draw.polygon(surface, (0, 0, 0), [tip, left, right], 1)
            self._draw_world_map_icon(surface, int(round(tip_x)), int(round(tip_y)), str(kind), scale=2)

        # POI edge indicators: show direction to nearest gunshop/bookstore even when outside the minimap window.
        cache = getattr(self, "_poi_cache", None)
        if isinstance(cache, dict):
            def nearest_dxdy(kind: str) -> tuple[int, int] | None:
                pts = cache.get(str(kind))
                if not isinstance(pts, list) or not pts:
                    return None
                best_d2 = 1e30
                best: tuple[int, int] | None = None
                for px, py in pts:
                    dx = int(px) - int(tx)
                    dy = int(py) - int(ty)
                    d2 = float(dx * dx + dy * dy)
                    if d2 < best_d2:
                        best_d2 = d2
                        best = (dx, dy)
                return best

            if not bool(seen_gunshop):
                dd = nearest_dxdy("gunshop")
                if dd is not None and (abs(int(dd[0])) > int(radius) or abs(int(dd[1])) > int(radius)):
                    draw_edge_poi(kind="gunshop", dx_t=int(dd[0]), dy_t=int(dd[1]), color=(220, 140, 90))
            if not bool(seen_bookstore):
                dd = nearest_dxdy("bookstore")
                if dd is not None and (abs(int(dd[0])) > int(radius) or abs(int(dd[1])) > int(radius)):
                    draw_edge_poi(kind="bookstore", dx_t=int(dd[0]), dy_t=int(dd[1]), color=(232, 200, 120))

        # Player-made markers from the big map (dot inside radius, arrow when off-screen).
        markers = getattr(self, "world_map_markers", None)
        if isinstance(markers, list) and markers:
            inside: list[tuple[int, int, tuple[int, int, int], str]] = []
            outside: list[tuple[int, int, float, tuple[int, int, int], str]] = []
            for m in markers:
                mx_t = int(getattr(m, "tx", 0))
                my_t = int(getattr(m, "ty", 0))
                dx_t = int(mx_t - int(tx))
                dy_t = int(my_t - int(ty))
                col = tuple(getattr(m, "color", (255, 220, 140)))
                lab = str(getattr(m, "label", ""))
                if abs(int(dx_t)) <= int(radius) and abs(int(dy_t)) <= int(radius):
                    inside.append((dx_t, dy_t, col, lab))
                else:
                    d2 = float(dx_t * dx_t + dy_t * dy_t)
                    outside.append((dx_t, dy_t, d2, col, lab))

            def is_work_marker(label: str) -> bool:
                label = str(label or "")
                return label in ("", "") or label.startswith("")

            work_inside = [t for t in inside if is_work_marker(str(t[3]))]
            other_inside = [t for t in inside if not is_work_marker(str(t[3]))]

            # Always show the work marker more clearly (so the guidance doesn't "disappear").
            for dx_t, dy_t, col, _lab in work_inside[:1]:
                mx = int(map_x0 + (int(dx_t) + int(radius)) * int(scale) + int(scale) // 2)
                my = int(map_y0 + (int(dy_t) + int(radius)) * int(scale) + int(scale) // 2)
                pygame.draw.circle(surface, (255, 220, 140), (mx, my), 4)
                pygame.draw.circle(surface, (0, 0, 0), (mx, my), 4, 1)
                pygame.draw.circle(surface, tuple(col), (mx, my), 3)
                surface.fill((255, 245, 190), pygame.Rect(int(mx - 1), int(my - 1), 2, 2))
                draw_text(surface, self.app.font_s, "", (mx + 10, my - 8), pygame.Color(240, 240, 240), anchor="topleft")

            for dx_t, dy_t, col, _lab in other_inside[:23]:
                mx = int(map_x0 + (int(dx_t) + int(radius)) * int(scale) + int(scale) // 2)
                my = int(map_y0 + (int(dy_t) + int(radius)) * int(scale) + int(scale) // 2)
                pygame.draw.circle(surface, tuple(col), (mx, my), 2)
                pygame.draw.circle(surface, (0, 0, 0), (mx, my), 2, 1)

            work_outside = [t for t in outside if is_work_marker(str(t[4]))]
            other_outside = [t for t in outside if not is_work_marker(str(t[4]))]

            work_outside.sort(key=lambda t: t[2])
            other_outside.sort(key=lambda t: t[2])

            # Reserve one arrow slot for the work marker if it's off-screen.
            if work_outside:
                dx_t, dy_t, _d2, col, _lab = work_outside[0]
                draw_edge_arrow(dx_t=int(dx_t), dy_t=int(dy_t), color=tuple(col), label="")
                remaining = 2
            else:
                remaining = 3
            for dx_t, dy_t, _d2, col, lab in other_outside[: int(remaining)]:
                draw_edge_arrow(dx_t=int(dx_t), dy_t=int(dy_t), color=tuple(col), label=str(lab) if lab else None)

        return panel

    def _toggle_world_map(self, *, open: bool | None = None) -> None:
        if open is None:
            open = not bool(getattr(self, "world_map_open", False))
        self.world_map_open = bool(open)
        if not self.world_map_open:
            return

        # Close other overlays when opening the big map.
        self.inv_open = False
        self.rv_ui_open = False
        self.hr_elevator_ui_open = False
        self._gallery_open = False
        self.world_map_center = self._player_tile()
        self._world_map_cache_key = None
        self.world_map_dragging = False

    def _world_map_tile_from_point(self, x: int, y: int) -> tuple[int, int] | None:
        rect = getattr(self, "_world_map_draw_rect", None)
        if not isinstance(rect, pygame.Rect):
            return None
        if not rect.collidepoint(int(x), int(y)):
            return None
        scale = max(1, int(getattr(self, "world_map_scale", 1)))
        start_tx, start_ty = getattr(self, "_world_map_start_tile", (0, 0))
        tx = int(start_tx) + int((int(x) - int(rect.x)) // scale)
        ty = int(start_ty) + int((int(y) - int(rect.y)) // scale)
        return int(tx), int(ty)

    def _add_world_map_marker(self, tx: int, ty: int) -> None:
        tx = int(tx)
        ty = int(ty)
        markers = getattr(self, "world_map_markers", None)
        if not isinstance(markers, list):
            self.world_map_markers = []
            markers = self.world_map_markers
        # Replace any marker on the same tile.
        self.world_map_markers = [m for m in markers if not (int(m.tx) == tx and int(m.ty) == ty)]

        idx = int(getattr(self, "world_map_marker_next", 0))
        self.world_map_marker_next = idx + 1
        label = chr(ord("A") + (idx % 26)) if idx < 26 else str(idx + 1)
        palette = [(255, 220, 140), (140, 220, 255), (220, 140, 255), (220, 255, 140)]
        color = palette[idx % len(palette)]
        self.world_map_markers.append(HardcoreSurvivalState._MapMarker(tx=tx, ty=ty, label=label, color=color))
        self._set_hint(f" {label}", seconds=1.2)

    def _remove_world_map_marker_near(self, tx: int, ty: int) -> None:
        tx = int(tx)
        ty = int(ty)
        markers = getattr(self, "world_map_markers", None)
        if not isinstance(markers, list) or not markers:
            return
        best_i = -1
        best_d2 = 999999
        for i, m in enumerate(markers):
            d2 = (int(m.tx) - tx) ** 2 + (int(m.ty) - ty) ** 2
            if d2 < best_d2:
                best_d2 = int(d2)
                best_i = int(i)
        if best_i < 0 or best_d2 > 36:
            return
        label = str(getattr(markers[best_i], "label", "?"))
        try:
            del markers[best_i]
        except Exception:
            self.world_map_markers = [m for i, m in enumerate(markers) if i != best_i]
        self._set_hint(f" {label}", seconds=1.0)

    def _draw_world_map_icon(self, surface: pygame.Surface, cx: int, cy: int, kind: str, *, scale: int) -> None:
        scale = max(1, int(scale))
        s = int(max(5, min(15, 3 + scale * 3)))
        half = s // 2
        x = int(cx)
        y = int(cy)

        if kind == "hospital":
            col = (220, 70, 70)
            w = max(1, int(round(s / 5)))
            pygame.draw.line(surface, (0, 0, 0), (x, y - half), (x, y + half), w + 2)
            pygame.draw.line(surface, (0, 0, 0), (x - half, y), (x + half, y), w + 2)
            pygame.draw.line(surface, col, (x, y - half), (x, y + half), w)
            pygame.draw.line(surface, col, (x - half, y), (x + half, y), w)
            return

        if kind == "market":
            col = (220, 200, 120)
            r = pygame.Rect(0, 0, s, s)
            r.center = (x, y)
            pygame.draw.rect(surface, (0, 0, 0), r)
            pygame.draw.rect(surface, col, r.inflate(-2, -2))
            # Handle
            pygame.draw.line(surface, (0, 0, 0), (r.left + 2, r.top + 3), (r.right - 3, r.top + 3), 2)
            pygame.draw.line(surface, col, (r.left + 2, r.top + 3), (r.right - 3, r.top + 3), 1)
            return

        if kind == "gunshop":
            col = (220, 140, 90)
            r = pygame.Rect(0, 0, s, s)
            r.center = (x, y)
            pygame.draw.rect(surface, (0, 0, 0), r)
            pygame.draw.rect(surface, (60, 60, 72), r.inflate(-2, -2))
            # Tiny pistol silhouette that still reads at small sizes.
            body_w = max(3, int(r.w) - 4)
            body_h = max(2, int(r.h) // 3)
            body = pygame.Rect(0, 0, int(body_w), int(body_h))
            body.center = (int(r.centerx), int(r.centery) - 1)
            barrel_w = max(2, int(body.w) // 3)
            barrel = pygame.Rect(int(body.right) - 1, int(body.top), int(barrel_w), 1)
            grip_w = max(2, int(body.w) // 4)
            grip_h = max(3, int(r.h) - int(body.h) - 2)
            grip = pygame.Rect(0, 0, int(grip_w), int(grip_h))
            grip.midtop = (int(body.centerx), int(body.bottom) - 1)

            pygame.draw.rect(surface, col, body)
            pygame.draw.rect(surface, col, barrel)
            pygame.draw.rect(surface, col, grip)
            pygame.draw.rect(surface, (0, 0, 0), body, 1)
            pygame.draw.rect(surface, (0, 0, 0), barrel, 1)
            pygame.draw.rect(surface, (0, 0, 0), grip, 1)
            return

        if kind == "bookstore":
            col = (232, 200, 120)
            r = pygame.Rect(0, 0, s, s)
            r.center = (x, y)
            pygame.draw.rect(surface, (0, 0, 0), r)
            pygame.draw.rect(surface, (80, 100, 150), r.inflate(-2, -2))
            # Book
            bx = int(r.centerx)
            by = int(r.centery)
            pygame.draw.rect(surface, col, pygame.Rect(bx - 5, by - 4, 4, 8), 1, border_radius=1)
            pygame.draw.rect(surface, col, pygame.Rect(bx + 1, by - 4, 4, 8), 1, border_radius=1)
            surface.fill((0, 0, 0), pygame.Rect(bx, by - 4, 1, 8))
            return

        if kind == "chinese":
            col = (210, 180, 110)
            r = pygame.Rect(0, 0, s, s)
            r.center = (x, y)
            pygame.draw.rect(surface, (0, 0, 0), r)
            pygame.draw.rect(surface, (150, 60, 50), r.inflate(-2, -2))
            # Roof + pillars
            pygame.draw.line(surface, col, (r.left + 2, r.top + 3), (r.right - 3, r.top + 3), 1)
            pygame.draw.line(surface, col, (r.left + 3, r.top + 2), (r.right - 4, r.top + 2), 1)
            surface.fill(col, pygame.Rect(r.left + 3, r.top + 4, 1, max(1, s - 7)))
            surface.fill(col, pygame.Rect(r.right - 4, r.top + 4, 1, max(1, s - 7)))
            return

        if kind == "school":
            col = (110, 170, 240)
            r = pygame.Rect(0, 0, s, s)
            r.center = (x, y)
            pygame.draw.rect(surface, (0, 0, 0), r)
            pygame.draw.rect(surface, col, r.inflate(-2, -2))
            # Flag
            pygame.draw.line(surface, (0, 0, 0), (r.centerx - 2, r.top + 1), (r.centerx - 2, r.top + 5), 1)
            pygame.draw.rect(surface, (0, 0, 0), pygame.Rect(r.centerx - 1, r.top + 1, 3, 2))
            pygame.draw.rect(surface, (250, 240, 200), pygame.Rect(r.centerx, r.top + 2, 1, 1))
            return

        if kind == "prison":
            col = (150, 150, 160)
            r = pygame.Rect(0, 0, s, s)
            r.center = (x, y)
            pygame.draw.rect(surface, (0, 0, 0), r)
            pygame.draw.rect(surface, col, r.inflate(-2, -2))
            for i in range(r.left + 2, r.right - 2, 3):
                pygame.draw.line(surface, (0, 0, 0), (i, r.top + 2), (i, r.bottom - 3), 1)
            return

        if kind == "highrise":
            col = (210, 210, 220)
            w = max(3, s // 2)
            h = s + max(2, s // 3)
            r = pygame.Rect(0, 0, w, h)
            r.center = (x, y)
            pygame.draw.rect(surface, (0, 0, 0), r)
            pygame.draw.rect(surface, col, r.inflate(-2, -2))
            # Windows
            for wy in range(r.top + 3, r.bottom - 2, 3):
                surface.fill((0, 0, 0), pygame.Rect(r.centerx, wy, 1, 1))
            return

    def _draw_world_map_pois(
        self,
        surface: pygame.Surface,
        *,
        draw_x: int,
        draw_y: int,
        start_tx: int,
        start_ty: int,
        view_w: int,
        view_h: int,
        scale: int,
    ) -> None:
        scale = max(1, int(scale))
        start_tx = int(start_tx)
        start_ty = int(start_ty)
        view_w = int(max(1, view_w))
        view_h = int(max(1, view_h))

        end_tx = start_tx + view_w - 1
        end_ty = start_ty + view_h - 1
        start_cx = start_tx // self.CHUNK_SIZE
        end_cx = end_tx // self.CHUNK_SIZE
        start_cy = start_ty // self.CHUNK_SIZE
        end_cy = end_ty // self.CHUNK_SIZE

        style_to_kind = {
            2: "market",
            9: "gunshop",
            3: "hospital",
            4: "prison",
            5: "school",
            6: "highrise",
            7: "bookstore",
            8: "chinese",
        }

        for cy in range(int(start_cy), int(end_cy) + 1):
            for cx in range(int(start_cx), int(end_cx) + 1):
                chunk = self.world.peek_chunk(cx, cy)
                if chunk is None:
                    continue
                for b in getattr(chunk, "buildings", []):
                    if len(b) < 5:
                        continue
                    tx0, ty0, w, h = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                    roof_kind = int(b[4])
                    style = int((roof_kind >> 8) & 0xFF)
                    kind = style_to_kind.get(int(style))
                    if kind is None:
                        continue

                    c_tx = int(tx0 + max(1, w) // 2)
                    c_ty = int(ty0 + max(1, h) // 2)
                    if not (start_tx <= c_tx <= end_tx and start_ty <= c_ty <= end_ty):
                        continue
                    mx = int(draw_x + (c_tx - start_tx) * scale + scale // 2)
                    my = int(draw_y + (c_ty - start_ty) * scale + scale // 2)
                    self._draw_world_map_icon(surface, mx, my, str(kind), scale=scale)

    def _draw_world_map_legend(self, surface: pygame.Surface, *, map_area: pygame.Rect) -> None:
        legend = pygame.Rect(0, 0, 162, 132)
        legend.bottomright = (int(map_area.right) - 8, int(map_area.bottom) - 8)

        ui = pygame.Surface((legend.w, legend.h), pygame.SRCALPHA)
        ui.fill((12, 12, 16, 210))
        pygame.draw.rect(ui, (90, 90, 110, 220), ui.get_rect(), 1, border_radius=10)
        surface.blit(ui, legend.topleft)

        draw_text(surface, self.app.font_s, "", (legend.left + 10, legend.top + 6), pygame.Color(240, 240, 240), anchor="topleft")

        # Clickable toggle button (hide legend).
        btn = pygame.Rect(0, 0, 14, 12)
        btn.topright = (legend.right - 8, legend.top + 6)
        pygame.draw.rect(surface, (24, 24, 30), btn, border_radius=4)
        pygame.draw.rect(surface, (90, 90, 110), btn, 1, border_radius=4)
        draw_text(surface, self.app.font_s, "x", (btn.centerx, btn.centery - 1), pygame.Color(210, 210, 220), anchor="center")
        self._world_map_legend_toggle_rect = btn.copy()

        # Icons (fixed size independent of zoom).
        icon_scale = 2
        x0 = legend.left + 12
        y = legend.top + 22
        step = 14

        entries: list[tuple[str, str]] = [
            ("hospital", ""),
            ("market", ""),
            ("gunshop", ""),
            ("bookstore", ""),
            ("school", ""),
            ("prison", ""),
            ("highrise", ""),
            ("chinese", ""),
        ]
        for kind, label in entries:
            self._draw_world_map_icon(surface, x0 + 6, y + 6, kind, scale=icon_scale)
            draw_text(surface, self.app.font_s, label, (x0 + 18, y + 1), pygame.Color(210, 210, 220), anchor="topleft")
            y += step

        # Player / home / RV / markers.
        y2 = legend.top + 22
        x1 = legend.left + 92
        pygame.draw.circle(surface, (240, 240, 244), (x1 + 6, y2 + 6), 3)
        pygame.draw.circle(surface, (0, 0, 0), (x1 + 6, y2 + 6), 3, 1)
        draw_text(surface, self.app.font_s, "", (x1 + 16, y2 + 1), pygame.Color(210, 210, 220), anchor="topleft")

        y2 += step
        pygame.draw.circle(surface, (255, 220, 140), (x1 + 6, y2 + 6), 3)
        pygame.draw.circle(surface, (0, 0, 0), (x1 + 6, y2 + 6), 3, 1)
        draw_text(surface, self.app.font_s, "", (x1 + 16, y2 + 1), pygame.Color(210, 210, 220), anchor="topleft")

        y2 += step
        pygame.draw.circle(surface, (140, 220, 255), (x1 + 6, y2 + 6), 3)
        pygame.draw.circle(surface, (0, 0, 0), (x1 + 6, y2 + 6), 3, 1)
        draw_text(surface, self.app.font_s, "", (x1 + 16, y2 + 1), pygame.Color(210, 210, 220), anchor="topleft")

        y2 += step
        pygame.draw.circle(surface, (220, 140, 255), (x1 + 6, y2 + 6), 3)
        pygame.draw.circle(surface, (0, 0, 0), (x1 + 6, y2 + 6), 3, 1)
        draw_text(surface, self.app.font_s, "", (x1 + 16, y2 + 1), pygame.Color(210, 210, 220), anchor="topleft")

    def _handle_world_map_key(self, key: int) -> None:
        key = int(key)
        if key in (pygame.K_ESCAPE, pygame.K_m, pygame.K_TAB):
            self.world_map_open = False
            return
        if key in (pygame.K_l,):
            self.world_map_legend_open = not bool(getattr(self, "world_map_legend_open", True))
            return

        mods = int(pygame.key.get_mods())
        fast = bool(mods & pygame.KMOD_SHIFT)
        step = 40 if fast else 14
        cx, cy = getattr(self, "world_map_center", (0, 0))
        cx = int(cx)
        cy = int(cy)

        if key in (pygame.K_LEFT, pygame.K_a):
            cx -= step
        elif key in (pygame.K_RIGHT, pygame.K_d):
            cx += step
        elif key in (pygame.K_UP, pygame.K_w):
            cy -= step
        elif key in (pygame.K_DOWN, pygame.K_s):
            cy += step
        elif key in (pygame.K_HOME, pygame.K_0):
            cx, cy = self._player_tile()
        elif key in (pygame.K_EQUALS, pygame.K_KP_PLUS):
            self.world_map_scale = int(clamp(int(getattr(self, "world_map_scale", 1))) + 1, 1, 4)
        elif key in (pygame.K_MINUS, pygame.K_KP_MINUS):
            self.world_map_scale = int(clamp(int(getattr(self, "world_map_scale", 1))) - 1, 1, 4)
        else:
            return

        self.world_map_center = (int(cx), int(cy))
        self._world_map_cache_key = None

    def _handle_world_map_mouse(self, event: pygame.event.Event) -> None:
        if event.type == pygame.MOUSEWHEEL:
            dy = int(getattr(event, "y", 0))
            if dy != 0:
                self.world_map_scale = int(clamp(int(getattr(self, "world_map_scale", 1)) + (1 if dy > 0 else -1), 1, 4))
                self._world_map_cache_key = None
            return

        if event.type == pygame.MOUSEBUTTONUP:
            btn = int(getattr(event, "button", 0))
            if btn == 3:
                self.world_map_dragging = False
            return

        if event.type not in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEMOTION):
            return
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return
        ix = int(internal[0])
        iy = int(internal[1])

        if event.type == pygame.MOUSEBUTTONDOWN and int(getattr(event, "button", 0)) == 1:
            toggle = getattr(self, "_world_map_legend_toggle_rect", None)
            if isinstance(toggle, pygame.Rect) and toggle.collidepoint(ix, iy):
                self.world_map_legend_open = not bool(getattr(self, "world_map_legend_open", True))
                return

        if event.type == pygame.MOUSEMOTION:
            if not bool(getattr(self, "world_map_dragging", False)):
                return
            scale = max(1, int(getattr(self, "world_map_scale", 1)))
            sx, sy = getattr(self, "world_map_drag_start", (ix, iy))
            cx0, cy0 = getattr(self, "world_map_drag_center", getattr(self, "world_map_center", (0, 0)))
            dx = int(ix) - int(sx)
            dy = int(iy) - int(sy)
            tcx = int(cx0) - int(round(float(dx) / float(scale)))
            tcy = int(cy0) - int(round(float(dy) / float(scale)))
            self.world_map_center = (int(tcx), int(tcy))
            self._world_map_cache_key = None
            return

        tx_ty = self._world_map_tile_from_point(ix, iy)
        if tx_ty is None:
            return
        tx, ty = tx_ty

        btn = int(getattr(event, "button", 0))
        if btn == 1:
            self._add_world_map_marker(tx, ty)
        elif btn == 3:
            mods = int(pygame.key.get_mods())
            if mods & pygame.KMOD_CTRL:
                self._remove_world_map_marker_near(tx, ty)
                return
            self.world_map_dragging = True
            self.world_map_drag_start = (int(ix), int(iy))
            self.world_map_drag_center = tuple(getattr(self, "world_map_center", (0, 0)))
        elif btn in (4, 5):
            self.world_map_scale = int(clamp(int(getattr(self, "world_map_scale", 1)) + (1 if btn == 4 else -1), 1, 4))
            self._world_map_cache_key = None

    def _draw_world_map_ui(self, surface: pygame.Surface) -> None:
        panel = pygame.Rect(10, 10, INTERNAL_W - 20, INTERNAL_H - 20)
        pygame.draw.rect(surface, (12, 12, 16), panel, border_radius=12)
        pygame.draw.rect(surface, (90, 90, 110), panel, 2, border_radius=12)

        title = ""
        draw_text(surface, self.app.font_m, title, (panel.centerx, panel.top + 12), pygame.Color(240, 240, 240), anchor="center")
        hint = "    Ctrl+    WASD/  L   M/Esc"
        draw_text(surface, self.app.font_s, hint, (panel.centerx, panel.bottom - 10), pygame.Color(170, 170, 180), anchor="center")

        map_area = pygame.Rect(panel.left + 10, panel.top + 26, panel.w - 20, panel.h - 44)
        pygame.draw.rect(surface, (18, 18, 22), map_area, border_radius=10)
        pygame.draw.rect(surface, (40, 40, 50), map_area, 1, border_radius=10)

        scale = max(1, int(getattr(self, "world_map_scale", 1)))
        view_w = max(1, map_area.w // scale)
        view_h = max(1, map_area.h // scale)
        cx, cy = getattr(self, "world_map_center", (0, 0))
        cx = int(cx)
        cy = int(cy)
        start_tx = int(cx - view_w // 2)
        start_ty = int(cy - view_h // 2)

        season = int(self._season_index())
        key = (start_tx, start_ty, view_w, view_h, int(scale), int(season))
        cached_scaled: pygame.Surface | None = getattr(self, "_world_map_cache_scaled", None)
        if getattr(self, "_world_map_cache_key", None) != key or cached_scaled is None:
            base = pygame.Surface((view_w, view_h))
            base.lock()
            for py in range(view_h):
                wy = start_ty + py
                for px in range(view_w):
                    wx = start_tx + px
                    tid = self.world.peek_tile(wx, wy)
                    base.set_at((px, py), self._minimap_color(tid))
            base.unlock()
            cached_scaled = pygame.transform.scale(base, (view_w * scale, view_h * scale))
            self._world_map_cache_key = key
            self._world_map_cache_scaled = cached_scaled

        draw_x = int(map_area.x + (map_area.w - cached_scaled.get_width()) // 2)
        draw_y = int(map_area.y + (map_area.h - cached_scaled.get_height()) // 2)
        self._world_map_draw_rect = pygame.Rect(draw_x, draw_y, cached_scaled.get_width(), cached_scaled.get_height())
        self._world_map_start_tile = (start_tx, start_ty)
        surface.blit(cached_scaled, (draw_x, draw_y))

        # POI icons (public buildings): hospital/market/school/etc.
        self._draw_world_map_pois(
            surface,
            draw_x=int(draw_x),
            draw_y=int(draw_y),
            start_tx=int(start_tx),
            start_ty=int(start_ty),
            view_w=int(view_w),
            view_h=int(view_h),
            scale=int(scale),
        )

        def draw_marker(tx: int, ty: int, col: tuple[int, int, int], label: str | None = None, *, r: int = 3) -> None:
            if not (start_tx <= int(tx) < start_tx + view_w and start_ty <= int(ty) < start_ty + view_h):
                return
            mx = int(draw_x + (int(tx) - start_tx) * scale + scale // 2)
            my = int(draw_y + (int(ty) - start_ty) * scale + scale // 2)
            rr = int(max(2, int(r)))
            pygame.draw.circle(surface, col, (mx, my), rr)
            pygame.draw.circle(surface, (0, 0, 0), (mx, my), rr, 1)
            if label:
                draw_text(surface, self.app.font_s, label, (mx + 6, my - 6), pygame.Color(240, 240, 240), anchor="topleft")

        # Player + key landmarks.
        ptx, pty = self._player_tile()
        draw_marker(ptx, pty, (240, 240, 244), None)

        rtx = int(math.floor(self.rv.pos.x / self.TILE_SIZE))
        rty = int(math.floor(self.rv.pos.y / self.TILE_SIZE))
        draw_marker(rtx, rty, (140, 220, 255), "")

        home = getattr(self, "home_highrise_door", None)
        if isinstance(home, tuple) and len(home) == 2:
            draw_marker(int(home[0]), int(home[1]), (255, 220, 140), "", r=4)

        for m in getattr(self, "world_map_markers", []):
            draw_marker(int(getattr(m, "tx", 0)), int(getattr(m, "ty", 0)), tuple(getattr(m, "color", (255, 220, 140))), str(getattr(m, "label", "")))

        # Story NPCs (pre-apocalypse only).
        if bool(getattr(self, "story_enabled", False)) and bool(self._story_is_pre_apocalypse()):
            npcs = getattr(self, "npcs", None)
            if isinstance(npcs, list) and npcs:
                for npc in npcs:
                    if not isinstance(npc, dict):
                        continue
                    try:
                        pos = pygame.Vector2(npc.get("pos", pygame.Vector2(0, 0)))
                    except Exception:
                        continue
                    ntx = int(math.floor(float(pos.x) / float(self.TILE_SIZE)))
                    nty = int(math.floor(float(pos.y) / float(self.TILE_SIZE)))
                    script = str(npc.get("script", "") or "")
                    col = (255, 220, 140) if script else (170, 170, 190)
                    name = str(npc.get("name", "") or "")
                    label = name if int(scale) >= 4 and name else None
                    draw_marker(int(ntx), int(nty), col, label, r=3)

        # Legend (icon key): bottom-right, toggleable.
        self._world_map_legend_toggle_rect = None
        if bool(getattr(self, "world_map_legend_open", True)):
            self._draw_world_map_legend(surface, map_area=map_area)
        else:
            btn = pygame.Rect(0, 0, 58, 14)
            btn.bottomright = (int(map_area.right) - 8, int(map_area.bottom) - 8)
            ui = pygame.Surface((btn.w, btn.h), pygame.SRCALPHA)
            ui.fill((12, 12, 16, 210))
            pygame.draw.rect(ui, (90, 90, 110, 220), ui.get_rect(), 1, border_radius=8)
            surface.blit(ui, btn.topleft)
            draw_text(surface, self.app.font_s, "(L)", (btn.centerx, btn.centery - 1), pygame.Color(210, 210, 220), anchor="center")
            self._world_map_legend_toggle_rect = btn.copy()

    def _draw_survival_ui(self, surface: pygame.Surface) -> None:
        day = int(self.world_time_s / max(1e-6, self.DAY_LENGTH_S)) + 1
        season = self.SEASONS[self._season_index()]
        _daylight, tday = self._daylight_amount()
        hh = int(tday * 24) % 24
        mm = int(tday * 24 * 60) % 60
        w = self.WEATHER_NAMES.get(str(getattr(self, "weather_kind", "clear")), "?")
        info = f"DAY {day}  {season}  {hh:02d}:{mm:02d}  {w}"
        draw_text(surface, self.app.font_s, info, (6, 6), pygame.Color(230, 230, 240), anchor="topleft")
        try:
            wl = int(getattr(self, "wanted_level", 0))
        except Exception:
            wl = 0
        if wl > 0 and bool(getattr(self, "story_enabled", False)) and bool(self._story_is_pre_apocalypse()):
            draw_text(surface, self.app.font_s, f" {wl}", (INTERNAL_W - 6, 44), pygame.Color(255, 170, 170), anchor="topright")

        def stat_line(y: int, label: str, value: float, *, fg: tuple[int, int, int]) -> None:
            value = float(clamp(value, 0.0, 100.0))
            draw_text(surface, self.app.font_s, f"{label} {int(round(value)):3d}", (6, y), pygame.Color(220, 220, 230), anchor="topleft")
            bar = pygame.Rect(56, y + 4, 74, 6)
            pygame.draw.rect(surface, (10, 10, 14), bar)
            pygame.draw.rect(surface, (70, 70, 86), bar, 1)
            fill_w = int((bar.w - 2) * (value / 100.0))
            if fill_w > 0:
                pygame.draw.rect(surface, fg, pygame.Rect(bar.x + 1, bar.y + 1, fill_w, bar.h - 2))

        stat_line(20, "HP", float(self.player.hp), fg=(220, 90, 90))    
        try:
            bleed_rate = float(self._bleed_total_rate())
            if bleed_rate > 0.0 and isinstance(getattr(self, "bleed_wounds", None), dict) and self.bleed_wounds:
                parts = [self._BODY_PART_NAMES.get(str(p), str(p)) for p in self.bleed_wounds.keys()]
                txt = " " + "/".join(parts[:3])
                draw_text(surface, self.app.font_s, txt, (140, 20), pygame.Color(220, 90, 90), anchor="topleft")
        except Exception:
            pass
        stat_line(32, "", self.player.hunger, fg=(210, 170, 90))      
        stat_line(44, "", self.player.thirst, fg=(120, 170, 230))     
        stat_line(56, "", self.player.condition, fg=(120, 210, 140))  
        stat_line(68, "", self.player.morale, fg=(200, 160, 240))
        stat_line(80, "", self.player.stamina, fg=(240, 240, 240))

        if self.gun is None:
            draw_text(surface, self.app.font_s, "", (INTERNAL_W - 6, 6), pygame.Color(200, 200, 210), anchor="topright")
        else:
            gdef = self._gun_effective_def(self.gun)
            if gdef is None:
                draw_text(surface, self.app.font_s, "", (INTERNAL_W - 6, 6), pygame.Color(200, 200, 210), anchor="topright")
            else:
                reserve = self.inventory.count(gdef.ammo_item)
                extra = " " if self.gun.reload_left > 0.0 else ""
                draw_text(
                    surface,
                    self.app.font_s,
                    f"{gdef.name}{(' [' + self._gun_mod_label(self.gun) + ']') if self._gun_mod_label(self.gun) else ''} {int(self.gun.mag)}/{reserve}{extra}",
                    (INTERNAL_W - 6, 6),
                    pygame.Color(230, 230, 240),
                    anchor="topright",
                )
        draw_text(surface, self.app.font_s, f" {int(self.rv.fuel)}", (INTERNAL_W - 6, 20), pygame.Color(180, 180, 190), anchor="topright")
        if self.mount == "bike" and str(getattr(self.bike, "model_id", "bike")).startswith("moto"):
            draw_text(
                surface,
                self.app.font_s,
                f" {int(getattr(self.bike, 'fuel', 0.0))}",
                (INTERNAL_W - 6, 32),
                pygame.Color(180, 180, 190),
                anchor="topright",
            )
        self._draw_sun_moon_widget(surface, tday=float(tday))

        minimap_rect = self._draw_minimap(surface)
        self.minimap_rect = minimap_rect if isinstance(minimap_rect, pygame.Rect) else None

        _chunk, it = self._find_nearest_item(radius_px=20.0)
        if it is not None:
            idef = self._ITEMS.get(it.item_id)
            name = idef.name if idef is not None else it.item_id
            draw_text(surface, self.app.font_s, f"E {name} x{int(it.qty)}", (6, 96), pygame.Color(220, 220, 230), anchor="topleft")

        held = getattr(self, "held_item", None)
        if isinstance(held, HardcoreSurvivalState._ItemStack) and str(getattr(held, "item_id", "")) == "flashlight":
            pct = int(round(float(self._flashlight_charge()) * 100.0))
            on = bool(getattr(self, "flashlight_on", False))
            col = pygame.Color(230, 230, 240) if on else pygame.Color(180, 180, 190)
            if int(pct) <= 15:
                col = pygame.Color(230, 120, 120)
            draw_text(surface, self.app.font_s, f"T :{'' if on else ''}  {pct}%  X ", (6, 108), col, anchor="topleft")

        if self.hint_text:
            draw_text(surface, self.app.font_s, self.hint_text, (INTERNAL_W // 2, INTERNAL_H - 30), pygame.Color(255, 220, 140), anchor="center")

        y0 = 34
        if isinstance(minimap_rect, pygame.Rect):
            y0 = max(int(y0), int(minimap_rect.bottom + 6))

        # RV mode toggle buttons (life vs drive).
        self._rv_mode_btn_rects = {}
        if str(getattr(self.rv, "model_id", "rv")) == "rv" and self.mount in (None, "rv"):
            near_rv_btn = bool(self._can_access_rv())
            if near_rv_btn or bool(getattr(self, "rv_world_interior", False)) or self.mount == "rv":
                btn_w = 54
                btn_h = 16
                gap = 4
                bx = int(INTERNAL_W - 6 - btn_w)
                by = int(y0)
                life_selected = bool(getattr(self, "rv_world_interior", False))
                drive_selected = self.mount == "rv"
                r_life = pygame.Rect(bx, by, int(btn_w), int(btn_h))
                r_drive = pygame.Rect(bx, by + int(btn_h + gap), int(btn_w), int(btn_h))
                draw_button(surface, self.app.font_s, "", r_life, selected=bool(life_selected), disabled=bool(life_selected))
                draw_button(surface, self.app.font_s, "", r_drive, selected=bool(drive_selected), disabled=bool(drive_selected))
                self._rv_mode_btn_rects = {"life": r_life.copy(), "drive": r_drive.copy()}
                y0 = int(r_drive.bottom + 6)

        if self.mount is not None:
            if self.mount == "rv":
                mid = str(getattr(self.rv, "model_id", "rv"))
                model = self._CAR_MODELS.get(mid)
                kind = model.name if model is not None else mid
            else:
                kind = self._two_wheel_name(getattr(self.bike, "model_id", "bike"))
            draw_text(surface, self.app.font_s, f"F ({kind})", (INTERNAL_W - 6, int(y0)), pygame.Color(220, 220, 230), anchor="topright")
            if self.mount == "rv":
                draw_text(surface, self.app.font_s, "H ", (INTERNAL_W - 6, int(y0 + 12)), pygame.Color(220, 220, 230), anchor="topright")
                draw_text(surface, self.app.font_s, "V ", (INTERNAL_W - 6, int(y0 + 24)), pygame.Color(180, 180, 190), anchor="topright")
        else:
            y = int(y0)
            near_rv = bool(self._can_access_rv())
            if near_rv:
                mid = str(getattr(self.rv, "model_id", "rv"))
                model = self._CAR_MODELS.get(mid)
                name = model.name if model is not None else mid
                draw_text(surface, self.app.font_s, f"F ({name})", (INTERNAL_W - 6, y), pygame.Color(220, 220, 230), anchor="topright")
                y += 12
                if str(mid) == "rv":
                    draw_text(surface, self.app.font_s, "H ", (INTERNAL_W - 6, y), pygame.Color(220, 220, 230), anchor="topright")
                    y += 12
                draw_text(surface, self.app.font_s, "V ", (INTERNAL_W - 6, y), pygame.Color(180, 180, 190), anchor="topright")
                y += 12
            if (self.player.pos - self.bike.pos).length_squared() <= (18.0 * 18.0):
                draw_text(surface, self.app.font_s, f"F ({self._two_wheel_name(getattr(self.bike, 'model_id', 'bike'))})", (INTERNAL_W - 6, y), pygame.Color(220, 220, 230), anchor="topright")
        draw_text(
            surface,
            self.app.font_s,
            "WASD  Shift  E    R  J  Tab(//)  Esc",
            (6, INTERNAL_H - 14),
            pygame.Color(170, 170, 180),
            anchor="topleft",
        )

    def _draw_debug(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        tx = int(math.floor(self.player.pos.x / self.TILE_SIZE))
        ty = int(math.floor(self.player.pos.y / self.TILE_SIZE))
        cx = tx // self.CHUNK_SIZE
        cy = ty // self.CHUNK_SIZE
        chunk = self.world.get_chunk(cx, cy)
        info = f"seed {self.seed}  tile {tx},{ty}  chunk {cx},{cy}  town {chunk.town_kind or '-'}"
        draw_text(surface, self.app.font_s, info, (6, INTERNAL_H - 6), pygame.Color(180, 180, 190), anchor="topleft")

        # Player skeleton overlay (helps tuning side-walk + gun anchors).
        p = self.player.pos - pygame.Vector2(cam_x, cam_y)
        px = int(round(p.x))
        py = int(round(p.y))

        face = pygame.Vector2(self.player.facing)
        if self.gun is not None:
            face = pygame.Vector2(self.aim_dir)
        if face.length_squared() <= 0.001:
            face = pygame.Vector2(0, 1)

        if abs(face.y) >= abs(face.x):
            d = "down" if face.y >= 0 else "up"
        else:
            d = "right" if face.x >= 0 else "left"

        pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
        pf_run = getattr(self, "player_frames_run", None)
        is_run = bool(getattr(self, "player_sprinting", False))
        pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
        frames = pf.get(d, pf["down"])
        moving = self.player.vel.length_squared() > 1.0
        bob = 0
        walk_idx = 0
        idle_anim = True
        if moving and len(frames) > 1:
            idle_anim = False
            walk = frames[1:]
            phase = (float(self.player.walk_phase) % math.tau) / math.tau
            walk_idx = int(phase * len(walk)) % len(walk)
            spr = walk[walk_idx]
            if is_run and walk_idx in (1, 4):
                bob = 1
        else:
            spr = frames[0]

        rect = spr.get_rect()
        rect.midbottom = (px, iround(float(p.y) + float(self.player.h) / 2.0))
        rect.y += bob

        height_delta = 0
        av = getattr(self, "avatar", None)
        if av is not None:
            hidx = int(getattr(av, "height", 1))
            height_delta = 1 if hidx == 0 else -1 if hidx == 2 else 0

        sk = self._survivor_skeleton_nodes(
            d,
            int(walk_idx),
            idle=bool(idle_anim),
            height_delta=int(height_delta),
            run=bool(is_run),
        )
        line_col = (255, 0, 200)
        node_col = (255, 240, 120)
        for a, b in self._SURVIVOR_SKELETON_BONES:
            pa = sk.get(a)
            pb = sk.get(b)
            if pa is None or pb is None:
                continue
            ax, ay = pa
            bx, by = pb
            pygame.draw.line(surface, line_col, (rect.left + ax, rect.top + ay), (rect.left + bx, rect.top + by), 1)

        for key in ("head", "chest", "hip", "l_knee", "r_knee", "l_foot", "r_foot", "r_hand"):
            pt = sk.get(key)
            if pt is None:
                continue
            x, y = pt
            pygame.draw.rect(surface, node_col, pygame.Rect(rect.left + x - 1, rect.top + y - 1, 3, 3), 1)


class SettingsState(State):
    def on_enter(self) -> None:
        self.items = ["", ""]
        self.index = 0
        self.item_rects: list[pygame.Rect] = []

    def _activate(self) -> None:
        if self.index == 0:
            self.app.set_config(show_grid=not self.app.config.show_grid)
        else:
            self.app.set_state(MainMenuState(self.app))

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            if event.key in (pygame.K_ESCAPE,):
                self.app.set_state(MainMenuState(self.app))
                return

            if event.key in (pygame.K_UP, pygame.K_w):
                self.index = (self.index - 1) % len(self.items)
            elif event.key in (pygame.K_DOWN, pygame.K_s):
                self.index = (self.index + 1) % len(self.items)
            elif event.key in (pygame.K_LEFT, pygame.K_a):
                if self.index == 0:
                    self.app.set_config(show_grid=not self.app.config.show_grid)
            elif event.key in (pygame.K_RIGHT, pygame.K_d):
                if self.index == 0:
                    self.app.set_config(show_grid=not self.app.config.show_grid)
            elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                self._activate()
            return

        if event.type not in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONDOWN):
            return
        if not hasattr(event, "pos"):
            return

        internal = self.app.screen_to_internal(event.pos)
        if internal is None:
            return

        for i, rect in enumerate(self.item_rects):
            if rect.collidepoint(internal):
                self.index = i
                if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
                    self._activate()
                break

    def draw(self, surface: pygame.Surface) -> None:
        surface.fill((16, 16, 20))
        draw_text(surface, self.app.font_l, "", (INTERNAL_W // 2, 30), pygame.Color(240, 240, 240), anchor="center")

        self.item_rects = []
        y0 = 80
        for i, label in enumerate(self.items):
            selected = i == self.index
            value = ""
            if label == "":
                value = "" if self.app.config.show_grid else ""
            text = f"{label}  {value}".rstrip()
            rect = pygame.Rect(0, 0, 220, 22)
            rect.center = (INTERNAL_W // 2, y0 + i * 28)
            self.item_rects.append(draw_button(surface, self.app.font_m, text, rect, selected=selected))

        draw_text(
            surface,
            self.app.font_s,
            "Esc",
            (INTERNAL_W // 2, INTERNAL_H - 22),
            pygame.Color(170, 170, 180),
            anchor="center",
        )


class CharacterSelectState(State):
    def on_enter(self) -> None:
        self.index = 0
        self.dot_rects: list[pygame.Rect] = []
        self.btn_back_rect = pygame.Rect(0, 0, 0, 0)
        self.btn_ok_rect = pygame.Rect(0, 0, 0, 0)
        self.panel_rect = pygame.Rect(0, 0, 0, 0)

    def _confirm(self) -> None:
        self.app.set_state(MapSelectState(self.app, character=CHARS[self.index]))

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            if event.key in (pygame.K_ESCAPE,):
                self.app.set_state(MainMenuState(self.app))
            elif event.key in (pygame.K_LEFT, pygame.K_a):
                self.index = (self.index - 1) % len(CHARS)
            elif event.key in (pygame.K_RIGHT, pygame.K_d):
                self.index = (self.index + 1) % len(CHARS)
            elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                self._confirm()
            elif pygame.K_1 <= event.key <= pygame.K_9:
                n = event.key - pygame.K_1
                if 0 <= n < len(CHARS):
                    self.index = n
            return

        if event.type not in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONDOWN):
            return
        if not hasattr(event, "pos"):
            return

        internal = self.app.screen_to_internal(event.pos)
        if internal is None:
            return

        for i, r in enumerate(self.dot_rects):
            if r.collidepoint(internal):
                self.index = i
                break

        if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
            if self.btn_back_rect.collidepoint(internal):
                self.app.set_state(MainMenuState(self.app))
                return
            if self.btn_ok_rect.collidepoint(internal) or self.panel_rect.collidepoint(internal):
                self._confirm()

    def draw(self, surface: pygame.Surface) -> None:
        surface.fill((14, 14, 18))
        draw_text(surface, self.app.font_l, "", (INTERNAL_W // 2, 18), pygame.Color(240, 240, 240), anchor="center")
        draw_text(
            surface,
            self.app.font_s,
            "/ | Enter/ | Esc",
            (INTERNAL_W // 2, 34),
            pygame.Color(180, 180, 190),
            anchor="center",
        )

        char_def = CHARS[self.index]
        panel = pygame.Rect(10, 44, INTERNAL_W - 20, 88)
        self.panel_rect = panel.copy()
        pygame.draw.rect(surface, (24, 24, 30), panel, border_radius=8)
        pygame.draw.rect(surface, (50, 50, 60), panel, 2, border_radius=8)

        spr_scale = 4
        spr = pygame.transform.scale(
            char_def.sprite,
            (char_def.sprite.get_width() * spr_scale, char_def.sprite.get_height() * spr_scale),
        )
        spr_pos = (panel.left + 10, panel.top + 10)
        surface.blit(spr, spr_pos)

        tx = spr_pos[0] + spr.get_width() + 10
        ty = panel.top + 8

        def ellipsize(text: str, font: pygame.font.Font, max_w: int) -> str:
            text = str(text)
            if max_w <= 0 or font.size(text)[0] <= max_w:
                return text
            suffix = "..."
            lo = 0
            hi = len(text)
            while lo < hi:
                mid = (lo + hi) // 2
                cand = text[:mid].rstrip() + suffix
                if font.size(cand)[0] <= max_w:
                    lo = mid + 1
                else:
                    hi = mid
            return text[: max(0, lo - 1)].rstrip() + suffix

        draw_text(surface, self.app.font_m, f"{char_def.name}", (tx, ty), pygame.Color(240, 240, 240))
        max_desc_w = int(panel.right - 10 - int(tx))
        desc = ellipsize(char_def.desc, self.app.font_s, int(max_desc_w))
        draw_text(surface, self.app.font_s, desc, (tx, ty + 18), pygame.Color(180, 180, 190))

        stats = [
            f": {char_def.base_hp}",
            f": {int(char_def.move_speed)}",
            f": {WEAPON_DEFS[char_def.start_weapon].name}",
        ]
        for i, line in enumerate(stats):
            draw_text(surface, self.app.font_s, line, (tx, ty + 34 + i * 14), pygame.Color(200, 200, 210))

        self.dot_rects = []
        dot_w, dot_h, dot_gap = 14, 8, 10
        total_w = len(CHARS) * dot_w + max(0, (len(CHARS) - 1) * dot_gap)
        start_x = (INTERNAL_W - total_w) // 2
        dots_y = panel.bottom + 6
        for i in range(len(CHARS)):
            c = (240, 240, 240) if i == self.index else (90, 90, 100)
            r = pygame.Rect(start_x + i * (dot_w + dot_gap), dots_y, dot_w, dot_h)
            self.dot_rects.append(r)
            pygame.draw.rect(surface, c, r)

        self.btn_back_rect = pygame.Rect(0, 0, 120, 22)
        self.btn_back_rect.center = (INTERNAL_W // 2 - 70, 160)
        self.btn_ok_rect = pygame.Rect(0, 0, 120, 22)
        self.btn_ok_rect.center = (INTERNAL_W // 2 + 70, 160)
        draw_button(surface, self.app.font_m, "", self.btn_back_rect)
        draw_button(surface, self.app.font_m, "", self.btn_ok_rect)


class MapSelectState(State):
    def __init__(self, app: App, *, character: CharacterDef) -> None:
        super().__init__(app)
        self.character = character

    def on_enter(self) -> None:
        self.index = 0
        self.dot_rects: list[pygame.Rect] = []
        self.btn_back_rect = pygame.Rect(0, 0, 0, 0)
        self.btn_ok_rect = pygame.Rect(0, 0, 0, 0)
        self.panel_rect = pygame.Rect(0, 0, 0, 0)

    def _confirm(self) -> None:
        self.app.set_state(GameState(self.app, character=self.character, map_def=MAPS[self.index]))

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            if event.key in (pygame.K_ESCAPE,):
                self.app.set_state(CharacterSelectState(self.app))
            elif event.key in (pygame.K_LEFT, pygame.K_a):
                self.index = (self.index - 1) % len(MAPS)
            elif event.key in (pygame.K_RIGHT, pygame.K_d):
                self.index = (self.index + 1) % len(MAPS)
            elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                self._confirm()
            elif pygame.K_1 <= event.key <= pygame.K_9:
                n = event.key - pygame.K_1
                if 0 <= n < len(MAPS):
                    self.index = n
            return

        if event.type not in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONDOWN):
            return
        if not hasattr(event, "pos"):
            return

        internal = self.app.screen_to_internal(event.pos)
        if internal is None:
            return

        for i, r in enumerate(self.dot_rects):
            if r.collidepoint(internal):
                self.index = i
                break

        if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
            if self.btn_back_rect.collidepoint(internal):
                self.app.set_state(CharacterSelectState(self.app))
                return
            if self.btn_ok_rect.collidepoint(internal) or self.panel_rect.collidepoint(internal):
                self._confirm()

    def draw(self, surface: pygame.Surface) -> None:
        surface.fill((14, 14, 18))
        draw_text(surface, self.app.font_l, "", (INTERNAL_W // 2, 18), pygame.Color(240, 240, 240), anchor="center")
        draw_text(surface, self.app.font_s, f"{self.character.name}", (INTERNAL_W // 2, 34), pygame.Color(180, 180, 190), anchor="center")

        m = MAPS[self.index]
        panel = pygame.Rect(10, 44, INTERNAL_W - 20, 88)
        self.panel_rect = panel.copy()
        pygame.draw.rect(surface, (24, 24, 30), panel, border_radius=8)
        pygame.draw.rect(surface, (50, 50, 60), panel, 2, border_radius=8)

        preview = pygame.Surface((panel.width - 20, 38))
        preview.fill(m.base_color)
        rng = random.Random(hash(m.id) & 0xFFFF)
        for _ in range(140):
            x = rng.randrange(0, preview.get_width())
            y = rng.randrange(0, preview.get_height())
            preview.set_at((x, y), m.accent_color)
        surface.blit(preview, (panel.left + 10, panel.top + 10))

        draw_text(surface, self.app.font_m, m.name, (panel.left + 10, panel.top + 52), pygame.Color(240, 240, 240))
        draw_text(surface, self.app.font_s, m.desc, (panel.left + 10, panel.top + 68), pygame.Color(180, 180, 190))

        self.dot_rects = []
        dot_w, dot_h, dot_gap = 14, 8, 10
        total_w = len(MAPS) * dot_w + max(0, (len(MAPS) - 1) * dot_gap)
        start_x = (INTERNAL_W - total_w) // 2
        dots_y = panel.bottom + 6
        for i in range(len(MAPS)):
            c = (240, 240, 240) if i == self.index else (90, 90, 100)
            r = pygame.Rect(start_x + i * (dot_w + dot_gap), dots_y, dot_w, dot_h)
            self.dot_rects.append(r)
            pygame.draw.rect(surface, c, r)

        self.btn_back_rect = pygame.Rect(0, 0, 120, 22)
        self.btn_back_rect.center = (INTERNAL_W // 2 - 70, 160)
        self.btn_ok_rect = pygame.Rect(0, 0, 120, 22)
        self.btn_ok_rect.center = (INTERNAL_W // 2 + 70, 160)
        draw_button(surface, self.app.font_m, "", self.btn_back_rect)
        draw_button(surface, self.app.font_m, "", self.btn_ok_rect)


class GameState(State):
    def __init__(self, app: App, *, character: CharacterDef, map_def: MapDef) -> None:
        super().__init__(app)
        self.character = character
        self.map_def = map_def

        self.player = Player(character)
        self.enemies: list[Enemy] = []
        self.projectiles: list[Projectile] = []
        self.swings: list[Swing] = []
        self.weapon_drops: list[WeaponDrop] = []
        self.damage_texts: list[DamageText] = []
        self.explosions: list[ExplosionFx] = []

        self.elapsed_s = 0.0
        self.kills = 0

        self.spawn_cd = 0.0
        self.rng = random.Random(time.time_ns() & 0xFFFFFFFF)
        self.background = self._make_background(map_def)

        self.paused = False
        self.pause_index = 0

        self.level_up_options: list[Upgrade] | None = None
        self.level_up_index = 0
        self.level_up_rects: list[pygame.Rect] = []
        self.pause_item_rects: list[pygame.Rect] = []
        self.grid_btn_rect = pygame.Rect(0, 0, 0, 0)
        self.grid_btn_hover = False

    def on_enter(self) -> None:
        self.player.weapons = [WeaponInstance(WEAPON_DEFS[self.character.start_weapon])]
        self._arrange_weapon_angles()
        c = self.player.center()
        self.weapon_drops = [WeaponDrop("pistol", pygame.Vector2(c.x + 24, c.y))]

    def _arrange_weapon_angles(self) -> None:
        n = len(self.player.weapons)
        if n <= 0:
            return
        for idx, w in enumerate(self.player.weapons):
            w.angle = (idx * (math.tau / n)) % math.tau

    def _make_background(self, map_def: MapDef) -> pygame.Surface:
        bg = pygame.Surface((INTERNAL_W, INTERNAL_H))
        bg.fill(map_def.base_color)
        rng = random.Random(hash(map_def.id) & 0xFFFF)
        for _ in range(2200):
            x = rng.randrange(0, INTERNAL_W)
            y = rng.randrange(0, INTERNAL_H)
            bg.set_at((x, y), map_def.accent_color)
        return bg

    def closest_enemy_to(self, p: pygame.Vector2) -> Enemy | None:
        closest: Enemy | None = None
        best_d2 = 1e18
        for e in self.enemies:
            d2 = (e.center() - p).length_squared()
            if d2 < best_d2:
                best_d2 = d2
                closest = e
        return closest

    def add_damage_text(
        self,
        pos: pygame.Vector2,
        amount: float,
        *,
        color: tuple[int, int, int] = (240, 240, 240),
    ) -> None:
        self.damage_texts.append(DamageText(pos, amount, color=pygame.Color(*color)))

    def _explode(self, pos: pygame.Vector2, proj: Projectile) -> None:
        radius = float(proj.aoe_radius)
        if radius <= 0.0:
            return
        base_damage = float(proj.damage) * float(proj.aoe_damage_mult)
        kb = float(proj.knockback)
        self.explosions.append(ExplosionFx(pos, radius=radius, color=(255, 170, 90)))

        for e in self.enemies:
            d = e.center() - pos
            dist = d.length()
            if dist > radius:
                continue
            t = 1.0 if radius <= 0.001 else clamp(1.0 - dist / radius, 0.0, 1.0)
            dmg = base_damage * (0.6 + 0.4 * t)
            e.hp -= dmg
            self.add_damage_text(e.center(), dmg, color=(255, 210, 160))
            if kb > 0.0:
                if d.length_squared() > 0.01:
                    e.vel += d.normalize() * kb * (0.5 + 0.8 * t)
                else:
                    e.vel += pygame.Vector2(1, 0) * kb * 0.5

    def _spawn_enemy(self) -> None:
        enemy_id = self.rng.choice(self.map_def.enemy_pool)
        enemy_def = ENEMY_DEFS[enemy_id]

        side = self.rng.randrange(4)
        if side == 0:
            pos = pygame.Vector2(-enemy_def.size - 2, self.rng.randrange(0, INTERNAL_H - enemy_def.size))
        elif side == 1:
            pos = pygame.Vector2(INTERNAL_W + 2, self.rng.randrange(0, INTERNAL_H - enemy_def.size))
        elif side == 2:
            pos = pygame.Vector2(self.rng.randrange(0, INTERNAL_W - enemy_def.size), -enemy_def.size - 2)
        else:
            pos = pygame.Vector2(self.rng.randrange(0, INTERNAL_W - enemy_def.size), INTERNAL_H + 2)

        self.enemies.append(Enemy(enemy_def, pos))

    def _game_over(self) -> None:
        self.app.set_state(
            GameOverState(
                self.app,
                character=self.character,
                map_def=self.map_def,
                level=self.player.level,
                kills=self.kills,
                elapsed_s=self.elapsed_s,
            )
        )

    def _add_weapon(self, weapon_id: str) -> bool:
        if len(self.player.weapons) >= 6:
            return False
        self.player.weapons.append(WeaponInstance(WEAPON_DEFS[weapon_id]))
        self._arrange_weapon_angles()
        return True

    def _upgrade_weapon(self, weapon: WeaponInstance) -> None:
        weapon.level += 1

    def _generate_upgrades(self) -> list[Upgrade]:
        p = self.player
        pool: list[Upgrade] = []

        def add(u: Upgrade, weight: int = 1) -> None:
            for _ in range(weight):
                pool.append(u)

        def vitality(pl: Player, _g: GameState) -> None:
            pl.max_hp += 12
            pl.hp = min(pl.max_hp, pl.hp + 12)

        def power(pl: Player, _g: GameState) -> None:
            pl.damage_mult *= 1.10

        def haste(pl: Player, _g: GameState) -> None:
            pl.cooldown_mult *= 0.90

        def agility(pl: Player, _g: GameState) -> None:
            pl.move_speed *= 1.10

        def regen(pl: Player, _g: GameState) -> None:
            pl.regen += 0.25

        def xp_gain(pl: Player, _g: GameState) -> None:
            pl.xp_mult *= 1.15

        def heal(pl: Player, _g: GameState) -> None:
            pl.hp = min(pl.max_hp, pl.hp + pl.max_hp * 0.30)

        add(Upgrade(" +10%", "", power), weight=4)
        add(Upgrade(" -10%", "", haste), weight=4)
        add(Upgrade(" +12", "", vitality), weight=3)
        add(Upgrade(" +10%", "", agility), weight=3)
        add(Upgrade(" +0.25/s", "", regen), weight=2)
        add(Upgrade(" +15%", "", xp_gain), weight=2)
        add(Upgrade(" 30%", " 30% ", heal), weight=2)

        if p.weapons:
            w = self.rng.choice(p.weapons)

            def up_weapon(_pl: Player, g: GameState, ww: WeaponInstance = w) -> None:
                g._upgrade_weapon(ww)

            add(Upgrade(f"{w.weapon_def.name} +1", "/", up_weapon), weight=5)

        picked: list[Upgrade] = []
        seen: set[str] = set()
        for _ in range(200):
            if len(picked) >= 3 or not pool:
                break
            u = self.rng.choice(pool)
            if u.title in seen:
                continue
            seen.add(u.title)
            picked.append(u)

        while len(picked) < 3:
            picked.append(Upgrade("", "demo", lambda _pl, _g: None))
        return picked

    def _level_up(self) -> None:
        self.level_up_options = self._generate_upgrades()
        self.level_up_index = 0

    def _pick_level_up(self) -> None:
        if self.level_up_options is None:
            return
        choice = self.level_up_options[self.level_up_index]
        choice.apply(self.player, self)
        self.level_up_options = None

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            if self.level_up_options is not None:
                if event.key in (pygame.K_LEFT, pygame.K_a):
                    self.level_up_index = (self.level_up_index - 1) % 3
                elif event.key in (pygame.K_RIGHT, pygame.K_d):
                    self.level_up_index = (self.level_up_index + 1) % 3
                elif event.key in (pygame.K_1, pygame.K_2, pygame.K_3):
                    self.level_up_index = event.key - pygame.K_1
                    self._pick_level_up()
                elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                    self._pick_level_up()
                return

            if event.key in (pygame.K_ESCAPE,):
                self.paused = not self.paused
                self.pause_index = 0
                return

            if not self.paused:
                return

            if event.key in (pygame.K_UP, pygame.K_w):
                self.pause_index = (self.pause_index - 1) % 2
            elif event.key in (pygame.K_DOWN, pygame.K_s):
                self.pause_index = (self.pause_index + 1) % 2
            elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                if self.pause_index == 0:
                    self.paused = False
                else:
                    self.app.set_state(MainMenuState(self.app))
            return

        if event.type not in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONDOWN):
            return
        if not hasattr(event, "pos"):
            return

        internal = self.app.screen_to_internal(event.pos)
        if internal is None:
            return

        self.grid_btn_hover = self.grid_btn_rect.collidepoint(internal)
        if (
            event.type == pygame.MOUSEBUTTONDOWN
            and getattr(event, "button", 0) == 1
            and self.grid_btn_hover
        ):
            self.app.set_config(show_grid=not self.app.config.show_grid)
            return

        if self.level_up_options is not None:
            for i, rect in enumerate(self.level_up_rects):
                if rect.collidepoint(internal):
                    self.level_up_index = i
                    if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
                        self._pick_level_up()
                    break
            return

        if not self.paused:
            return

        for i, rect in enumerate(self.pause_item_rects):
            if rect.collidepoint(internal):
                self.pause_index = i
                if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
                    if i == 0:
                        self.paused = False
                    else:
                        self.app.set_state(MainMenuState(self.app))
                break

    def update(self, dt: float) -> None:
        if self.paused or self.level_up_options is not None:
            return

        self.elapsed_s += dt

        p = self.player
        keys = pygame.key.get_pressed()
        move = pygame.Vector2(0, 0)
        if keys[pygame.K_a] or keys[pygame.K_LEFT]:
            move.x -= 1
        if keys[pygame.K_d] or keys[pygame.K_RIGHT]:
            move.x += 1
        if keys[pygame.K_w] or keys[pygame.K_UP]:
            move.y -= 1
        if keys[pygame.K_s] or keys[pygame.K_DOWN]:
            move.y += 1
        if move.length_squared() > 0:
            move = move.normalize()
            p.last_move_dir = pygame.Vector2(move)

        p.update_visual(dt, move)
        p.pos += move * p.move_speed * dt
        p.pos.x = clamp(p.pos.x, 0, INTERNAL_W - p.w)
        p.pos.y = clamp(p.pos.y, 0, INTERNAL_H - p.h)

        pr_pick = p.rect()
        for drop in list(self.weapon_drops):
            drop.bob_t += dt
            if drop.rect().colliderect(pr_pick):
                if self._add_weapon(drop.weapon_id):
                    self.weapon_drops.remove(drop)

        p.invuln_s = max(0.0, p.invuln_s - dt)
        p.hurt_s = max(0.0, p.hurt_s - dt)
        if p.regen > 0:
            p.hp = min(p.max_hp, p.hp + p.regen * dt)

        for w in p.weapons:
            w.update(dt, p, self)

        cap = 90
        self.spawn_cd -= dt
        if self.spawn_cd <= 0.0 and len(self.enemies) < cap:
            self._spawn_enemy()
            base = 0.7
            accel = min(0.55, self.elapsed_s * 0.01 + (p.level - 1) * 0.01)
            self.spawn_cd = max(0.12, base - accel)

        pr = p.rect()
        for e in self.enemies:
            e.update_visual(dt)
            to_p = (p.center() - e.center())
            v = pygame.Vector2(0, 0)
            if to_p.length_squared() > 0.01:
                v = to_p.normalize() * e.enemy_def.speed

            e.pos += (v + e.vel) * dt
            drag = math.pow(0.82, dt * 60.0)
            e.vel *= drag
            if e.vel.length_squared() < 0.01:
                e.vel.update(0.0, 0.0)
            if e.rect().colliderect(pr) and p.invuln_s <= 0.0:
                p.hp -= e.enemy_def.contact_damage
                p.invuln_s = 0.45
                p.hurt_s = 0.20
                if to_p.length_squared() > 0.01:
                    p.pos += to_p.normalize() * 10
                    p.pos.x = clamp(p.pos.x, 0, INTERNAL_W - p.w)
                    p.pos.y = clamp(p.pos.y, 0, INTERNAL_H - p.h)

        for s in list(self.swings):
            s.ttl_s -= dt
            if s.ttl_s <= 0:
                self.swings.remove(s)
                continue
            for e in self.enemies:
                if e.uid in s.hit_uids:
                    continue
                if s.rect.colliderect(e.rect()):
                    s.hit_uids.add(e.uid)
                    e.hp -= s.damage
                    self.add_damage_text(e.center(), s.damage, color=(255, 240, 200))

        for proj in list(self.projectiles):
            proj.ttl_s -= dt
            if proj.ttl_s <= 0:
                self.projectiles.remove(proj)
                continue

            proj.pos += proj.vel * dt
            if proj.pos.x < -10 or proj.pos.x > INTERNAL_W + 10 or proj.pos.y < -10 or proj.pos.y > INTERNAL_H + 10:
                self.projectiles.remove(proj)
                continue

            r = proj.rect()
            for e in self.enemies:
                if e.uid in proj.hit_uids:
                    continue
                if r.colliderect(e.rect()):
                    proj.hit_uids.add(e.uid)
                    if proj.aoe_radius > 0.0:
                        self._explode(e.center(), proj)
                        if proj in self.projectiles:
                            self.projectiles.remove(proj)
                        break
                    dmg = proj.damage
                    e.hp -= dmg
                    self.add_damage_text(e.center(), dmg, color=(255, 255, 255))
                    if proj.knockback > 0.0:
                        d = pygame.Vector2(proj.vel)
                        if d.length_squared() > 0.01:
                            d = d.normalize()
                        else:
                            d = pygame.Vector2(1, 0)
                        kb = proj.knockback * (1.25 if e.enemy_def.id == "slime" else 1.0)
                        e.vel += d * kb
                    if proj.pierce > 0:
                        proj.pierce -= 1
                    else:
                        self.projectiles.remove(proj)
                    break

        for t in list(self.damage_texts):
            t.ttl_s -= dt
            if t.ttl_s <= 0:
                self.damage_texts.remove(t)
                continue
            t.vel.y += 70.0 * dt
            t.pos += t.vel * dt

        for fx in list(self.explosions):
            fx.ttl_s -= dt
            if fx.ttl_s <= 0:
                self.explosions.remove(fx)

        for e in list(self.enemies):
            if e.hp > 0:
                continue
            self.enemies.remove(e)
            self.kills += 1
            p.xp += e.enemy_def.xp_value * p.xp_mult
            if len(self.weapon_drops) < 12 and self.rng.random() < 0.18:
                weapon_id = self.rng.choice(tuple(WEAPON_DEFS.keys()))
                self.weapon_drops.append(WeaponDrop(weapon_id, pygame.Vector2(e.center())))

        if p.hp <= 0:
            self._game_over()
            return

        if p.xp >= p.xp_to_next:
            p.xp -= p.xp_to_next
            p.level += 1
            p.xp_to_next = p.xp_to_next * 1.20 + 3.0
            self._level_up()

    def draw(self, surface: pygame.Surface) -> None:
        surface.blit(self.background, (0, 0))

        for drop in self.weapon_drops:
            weapon_def = WEAPON_DEFS.get(drop.weapon_id)
            color = (200, 200, 200) if weapon_def is None else weapon_def.color
            bob = math.sin(drop.bob_t * 4.0) * 1.5
            cx, cy = int(drop.pos.x), int(drop.pos.y + bob)
            if weapon_def is not None and weapon_def.sprite is not None:
                spr = weapon_def.sprite
                r = spr.get_rect(center=(cx, cy))
                bg = r.inflate(4, 4)
                pygame.draw.rect(surface, (20, 20, 24), bg)
                pygame.draw.rect(surface, (0, 0, 0), bg, 1)
                surface.blit(spr, r)
            else:
                r = pygame.Rect(0, 0, 8, 8)
                r.center = (cx, cy)
                pygame.draw.rect(surface, color, r)
                pygame.draw.rect(surface, (0, 0, 0), r, 1)

        for e in self.enemies:
            if e.sprite is not None:
                surface.blit(e.sprite, (int(e.pos.x), int(e.pos.y)))
            else:
                pygame.draw.rect(surface, e.enemy_def.color, e.rect())

        for proj in self.projectiles:
            r = proj.rect()
            pygame.draw.rect(surface, proj.color, r)
            pygame.draw.rect(surface, (0, 0, 0), r, 1)
            if proj.vel.length_squared() > 0.01:
                speed2 = proj.vel.length_squared()
                tail_len = 3.0
                if proj.aoe_radius > 0.0:
                    tail_len = 7.0
                elif proj.pierce >= 3 or speed2 >= 600.0 * 600.0:
                    tail_len = 10.0
                elif proj.size <= 1:
                    tail_len = 4.0
                tail = proj.vel.normalize() * -tail_len
                pygame.draw.line(
                    surface,
                    (255, 255, 255),
                    (int(proj.pos.x), int(proj.pos.y)),
                    (int(proj.pos.x + tail.x), int(proj.pos.y + tail.y)),       
                    1,
                )

        p = self.player
        ppos = (int(p.pos.x + p.draw_offset.x), int(p.pos.y + p.draw_offset.y))
        spr = p.sprite
        if p.hurt_s > 0.0:
            img = spr.copy()
            img.fill((140, 20, 20), special_flags=pygame.BLEND_RGB_ADD)
            surface.blit(img, ppos)
        elif p.invuln_s > 0.0 and int(p.invuln_s * 20) % 2 == 0:
            img = spr.copy()
            img.fill((90, 10, 10), special_flags=pygame.BLEND_RGB_ADD)
            surface.blit(img, ppos)
        else:
            surface.blit(spr, ppos)
        fx = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)     
        for boom in self.explosions:
            t = clamp(boom.ttl_s / 0.22, 0.0, 1.0)
            a0 = int(120 * t)
            a1 = int(220 * t)
            x, y = int(boom.pos.x), int(boom.pos.y)
            r = max(1, int(boom.radius))
            pygame.draw.circle(fx, (boom.color.r, boom.color.g, boom.color.b, a0), (x, y), r)
            pygame.draw.circle(fx, (255, 255, 255, a1), (x, y), max(1, int(r * 0.35)))
        for w in p.weapons:
            if w.weapon_def.kind != "melee" or len(w.trail) < 2:
                continue
            for i in range(1, len(w.trail)):
                p0, age0 = w.trail[i - 1]
                p1, age1 = w.trail[i]
                age = max(age0, age1)
                a = int(220 * (1.0 - age / 0.18))
                if a <= 0:
                    continue
                x0, y0 = int(p0.x), int(p0.y)
                x1, y1 = int(p1.x), int(p1.y)
                pygame.draw.line(fx, (255, 255, 255, max(0, a // 4)), (x0, y0), (x1, y1), 6)
                pygame.draw.line(fx, (255, 255, 255, a), (x0, y0), (x1, y1), 3)
        surface.blit(fx, (0, 0))

        for w in p.weapons:
            if w.weapon_def.kind == "melee":
                if w.sword_poly:
                    d = w.sword_tip - w.sword_base
                    if d.length_squared() > 0.01:
                        d = d.normalize()
                        pygame.draw.line(surface, (160, 120, 80), w.sword_base, w.sword_base + d * 3, 3)
                    pygame.draw.polygon(surface, w.weapon_def.color, w.sword_poly)
                    pygame.draw.polygon(surface, (0, 0, 0), w.sword_poly, 1)
                else:
                    pygame.draw.rect(surface, w.weapon_def.color, w.orbit_rect)
                    pygame.draw.rect(surface, (0, 0, 0), w.orbit_rect, 1)
            elif w.weapon_def.kind == "gun":
                center = pygame.Vector2(w.orbit_rect.centerx, w.orbit_rect.centery)
                ang = w.aim_angle + (w.reload_spin if w.reload_left > 0.0 else 0.0)
                aim_dir = pygame.Vector2(math.cos(w.aim_angle), math.sin(w.aim_angle))
                if aim_dir.length_squared() <= 0.0001:
                    aim_dir = pygame.Vector2(1, 0)
                spr = w.weapon_def.sprite
                if spr is not None:
                    flip = float(aim_dir.x) < 0.0
                    if flip:
                        spr = flip_x_pixel_sprite(spr)
                    deg = -math.degrees(ang)
                    if flip:
                        deg -= 180.0
                    step = 15.0 if w.reload_left > 0.0 else 5.0
                    rot = rotate_pixel_sprite_crisp(spr, deg, step_deg=step) 
                    kick = 0.0
                    if w.muzzle_flash_s > 0.0 and w.reload_left <= 0.0:
                        flash_total = 0.10 if w.weapon_def.aoe_radius > 0.0 else 0.06
                        t = clamp(w.muzzle_flash_s / max(0.001, flash_total), 0.0, 1.0)
                        kick = 2.0 * t
                    draw_center = center - aim_dir * kick
                    surface.blit(rot, rot.get_rect(center=(int(round(draw_center.x)), int(round(draw_center.y)))))

                    if w.muzzle_flash_s > 0.0 and w.reload_left <= 0.0:
                        flash_total = 0.10 if w.weapon_def.aoe_radius > 0.0 else 0.06
                        t = clamp(w.muzzle_flash_s / max(0.001, flash_total), 0.0, 1.0)
                        tip_dist = max(6.0, spr.get_width() * 0.5 - 1.0)
                        tip = draw_center + aim_dir * tip_dist
                        x, y = int(round(tip.x)), int(round(tip.y))
                        rad = 1 + int(2 * t)
                        core = (255, 255, 255)
                        glow = (255, 220, 120) if w.weapon_def.aoe_radius <= 0.0 else (255, 160, 90)
                        pygame.draw.circle(surface, glow, (x, y), rad)
                        pygame.draw.circle(surface, core, (x, y), max(1, rad - 1))
                else:
                    pygame.draw.rect(surface, w.weapon_def.color, w.orbit_rect) 
                    pygame.draw.rect(surface, (0, 0, 0), w.orbit_rect, 1)       

                if w.reload_left > 0.0 and w.reload_total > 0.0:
                    t = 1.0 - (w.reload_left / max(0.001, w.reload_total))
                    t = clamp(t, 0.0, 1.0)
                    bar = pygame.Rect(0, 0, 16, 3)
                    bar.center = (int(center.x), int(center.y - 9))
                    pygame.draw.rect(surface, (10, 10, 12), bar)
                    fill = pygame.Rect(bar.x + 1, bar.y + 1, int((bar.w - 2) * t), bar.h - 2)
                    pygame.draw.rect(surface, (120, 220, 140), fill)
                    pygame.draw.rect(surface, (0, 0, 0), bar, 1)
            else:
                pygame.draw.rect(surface, w.weapon_def.color, w.orbit_rect)
                pygame.draw.rect(surface, (0, 0, 0), w.orbit_rect, 1)

        for t in self.damage_texts:
            x, y = int(t.pos.x), int(t.pos.y)
            draw_text(surface, self.app.font_s, t.text, (x + 1, y + 1), pygame.Color(0, 0, 0), anchor="center")
            draw_text(surface, self.app.font_s, t.text, (x, y), t.color, anchor="center")

        self._draw_ui(surface)
        if self.paused:
            self._draw_pause(surface)
        if self.level_up_options is not None:
            self._draw_level_up(surface)

    def _draw_ui(self, surface: pygame.Surface) -> None:
        p = self.player

        hp_w, hp_h = 150, 8
        x, y = 10, 10
        pygame.draw.rect(surface, (20, 20, 24), pygame.Rect(x, y, hp_w, hp_h))
        fill = int(hp_w * (p.hp / max(1, p.max_hp)))
        pygame.draw.rect(surface, (220, 70, 70), pygame.Rect(x, y, fill, hp_h))
        pygame.draw.rect(surface, (70, 70, 80), pygame.Rect(x, y, hp_w, hp_h), 1)
        draw_text(surface, self.app.font_s, f"HP {int(p.hp)}/{p.max_hp}", (x + hp_w + 8, y - 2), pygame.Color(230, 230, 240))

        xp_w, xp_h = 220, 6
        x2, y2 = 10, 22
        pygame.draw.rect(surface, (20, 20, 24), pygame.Rect(x2, y2, xp_w, xp_h))
        fill2 = int(xp_w * (p.xp / max(1.0, p.xp_to_next)))
        pygame.draw.rect(surface, (90, 190, 120), pygame.Rect(x2, y2, fill2, xp_h))
        pygame.draw.rect(surface, (70, 70, 80), pygame.Rect(x2, y2, xp_w, xp_h), 1)
        draw_text(surface, self.app.font_s, f"Lv {p.level}", (x2 + xp_w + 8, y2 - 3), pygame.Color(230, 230, 240))

        draw_text(surface, self.app.font_s, f"{self.map_def.name}", (INTERNAL_W - 10, 10), pygame.Color(230, 230, 240), anchor="topright")
        draw_text(surface, self.app.font_s, f" {format_time(self.elapsed_s)}", (INTERNAL_W - 10, 26), pygame.Color(200, 200, 210), anchor="topright")       
        draw_text(surface, self.app.font_s, f" {self.kills}", (INTERNAL_W - 10, 42), pygame.Color(200, 200, 210), anchor="topright")
        self.grid_btn_rect = pygame.Rect(0, 0, 84, 18)
        self.grid_btn_rect.topright = (INTERNAL_W - 10, 54)
        draw_button(
            surface,
            self.app.font_s,
            f":{'' if self.app.config.show_grid else ''}",
            self.grid_btn_rect,
            selected=self.grid_btn_hover or self.app.config.show_grid,
        )

        wx = 10
        wy = INTERNAL_H - 18
        for w in p.weapons[:6]:
            pygame.draw.rect(surface, w.weapon_def.color, pygame.Rect(wx, wy, 12, 8))
            pygame.draw.rect(surface, (0, 0, 0), pygame.Rect(wx, wy, 12, 8), 1)
            draw_text(surface, self.app.font_s, f"{w.level}", (wx + 6, wy - 12), pygame.Color(240, 240, 240), anchor="center")
            wx += 18

    def _draw_pause(self, surface: pygame.Surface) -> None:
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 160))
        surface.blit(overlay, (0, 0))

        draw_text(surface, self.app.font_l, "", (INTERNAL_W // 2, 40), pygame.Color(240, 240, 240), anchor="center")

        self.pause_item_rects = []
        items = ["", ""]
        y0 = 84
        for i, label in enumerate(items):
            rect = pygame.Rect(0, 0, 200, 22)
            rect.center = (INTERNAL_W // 2, y0 + i * 30)
            self.pause_item_rects.append(draw_button(surface, self.app.font_m, label, rect, selected=(i == self.pause_index)))

        draw_text(surface, self.app.font_s, "/ | Enter/ | Esc", (INTERNAL_W // 2, INTERNAL_H - 12), pygame.Color(180, 180, 190), anchor="center")

    def _draw_level_up(self, surface: pygame.Surface) -> None:
        if self.level_up_options is None:
            return
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))

        draw_text(surface, self.app.font_l, "", (INTERNAL_W // 2, 18), pygame.Color(240, 240, 240), anchor="center")

        card_w, card_h = INTERNAL_W - 20, 36
        x = 10
        y0 = 38
        gap = 8
        self.level_up_rects = []
        for i, u in enumerate(self.level_up_options):
            y = y0 + i * (card_h + gap)
            rect = pygame.Rect(x, y, card_w, card_h)
            self.level_up_rects.append(rect)
            bg = (34, 34, 42) if i == self.level_up_index else (24, 24, 30)
            pygame.draw.rect(surface, bg, rect, border_radius=8)
            border = (90, 90, 110) if i == self.level_up_index else (60, 60, 74)
            pygame.draw.rect(surface, border, rect, 2, border_radius=8)

            draw_text(surface, self.app.font_m, u.title, (rect.left + 10, rect.top + 4), pygame.Color(240, 240, 240))
            draw_text(surface, self.app.font_s, u.desc, (rect.left + 10, rect.top + 22), pygame.Color(200, 200, 210))
            draw_text(surface, self.app.font_s, f"[{i+1}]", (rect.right - 12, rect.centery), pygame.Color(160, 160, 170), anchor="center")

        draw_text(surface, self.app.font_s, " 1/2/3 ", (INTERNAL_W // 2, INTERNAL_H - 12), pygame.Color(180, 180, 190), anchor="center")


class GameOverState(State):
    def __init__(self, app: App, *, character: CharacterDef, map_def: MapDef, level: int, kills: int, elapsed_s: float) -> None:
        super().__init__(app)
        self.character = character
        self.map_def = map_def
        self.level = level
        self.kills = kills
        self.elapsed_s = elapsed_s
        self.index = 0
        self.item_rects: list[pygame.Rect] = []

    def _activate(self) -> None:
        if self.index == 0:
            self.app.set_state(GameState(self.app, character=self.character, map_def=self.map_def))
        else:
            self.app.set_state(MainMenuState(self.app))

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            if event.key in (pygame.K_UP, pygame.K_w):
                self.index = (self.index - 1) % 2
            elif event.key in (pygame.K_DOWN, pygame.K_s):
                self.index = (self.index + 1) % 2
            elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                self._activate()
            return

        if event.type not in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONDOWN):
            return
        if not hasattr(event, "pos"):
            return

        internal = self.app.screen_to_internal(event.pos)
        if internal is None:
            return

        for i, rect in enumerate(self.item_rects):
            if rect.collidepoint(internal):
                self.index = i
                if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
                    self._activate()
                break

    def draw(self, surface: pygame.Surface) -> None:
        surface.fill((10, 10, 14))
        draw_text(surface, self.app.font_l, "", (INTERNAL_W // 2, 26), pygame.Color(240, 240, 240), anchor="center")
        draw_text(
            surface,
            self.app.font_s,
            f"{self.character.name}  {self.map_def.name}",
            (INTERNAL_W // 2, 46),
            pygame.Color(180, 180, 190),
            anchor="center",
        )
        draw_text(surface, self.app.font_s, f"{format_time(self.elapsed_s)}", (INTERNAL_W // 2, 62), pygame.Color(200, 200, 210), anchor="center")
        draw_text(surface, self.app.font_s, f"{self.kills}  {self.level}", (INTERNAL_W // 2, 78), pygame.Color(200, 200, 210), anchor="center")

        self.item_rects = []
        items = ["", ""]
        y0 = 112
        for i, label in enumerate(items):
            rect = pygame.Rect(0, 0, 200, 22)
            rect.center = (INTERNAL_W // 2, y0 + i * 30)
            self.item_rects.append(draw_button(surface, self.app.font_m, label, rect, selected=(i == self.index)))

        draw_text(surface, self.app.font_s, "/ | Enter/", (INTERNAL_W // 2, INTERNAL_H - 12), pygame.Color(170, 170, 180), anchor="center")


def main() -> int:
    try:
        smoke = "--smoke-test" in sys.argv
        if smoke:
            # Headless(ish) smoke test: render a few frames then exit.
            os.environ.setdefault("SDL_VIDEODRIVER", "dummy")
            os.environ.setdefault("SDL_AUDIODRIVER", "dummy")
        App().run(max_frames=10 if smoke else None)
        return 0
    except Exception as exc:
        try:
            pygame.quit()
        except Exception:
            pass
        print("Fatal error:", exc, file=sys.stderr)
        return 1


if __name__ == "__main__":
    raise SystemExit(main())
