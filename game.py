from __future__ import annotations

from array import array
import json
import math
import os
import random
import sys
import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import Callable, Sequence

import pygame

BASE_INTERNAL_W = 480
BASE_INTERNAL_H = 270

# Internal render resolution (dynamically extended on ultrawide windows).
INTERNAL_W = BASE_INTERNAL_W
INTERNAL_H = BASE_INTERNAL_H
FPS = 60
GRID_MARKS = (10, 50, 100, 200, 300, 400)

SETTINGS_PATH = Path(__file__).with_name("settings.json")


def pick_ui_font_path() -> str | None:
    candidates = [
        "Microsoft YaHei",
        "MicrosoftYaHei",
        "msyh",
        "SimHei",
        "simhei",
        "SimSun",
        "simsun",
        "NSimSun",
        "PingFang SC",
        "Noto Sans CJK SC",
        "Source Han Sans CN",
    ]
    for name in candidates:
        try:
            path = pygame.font.match_font(name)
        except Exception:
            path = None
        if path:
            return path

    windir = os.environ.get("WINDIR") or os.environ.get("SystemRoot")
    if windir:
        fonts_dir = Path(windir) / "Fonts"
        for filename in ("msyh.ttc", "msyh.ttf", "simhei.ttf", "simsun.ttc", "simsun.ttf"):
            p = fonts_dir / filename
            if p.exists():
                return str(p)
    return None


def clamp(value: float, low: float, high: float) -> float:
    return low if value < low else high if value > high else value


def iround(x: float) -> int:
    # Python's round() uses bankers rounding (ties to even) which can cause
    # visible 1px jitter when positions sit on .5 boundaries (e.g. odd-sized
    # sprites/colliders). Use a "round half away from zero" instead.
    x = float(x)
    if x >= 0.0:
        return int(math.floor(x + 0.5))
    return int(math.ceil(x - 0.5))


def format_time(seconds: float) -> str:
    seconds = max(0, int(seconds))
    return f"{seconds // 60:02d}:{seconds % 60:02d}"


def draw_text(
    surface: pygame.Surface,
    font: pygame.font.Font,
    text: str,
    pos: tuple[int, int],
    color: pygame.Color,
    *,
    anchor: str = "topleft",  # topleft | center | topright
) -> pygame.Rect:
    img = font.render(text, False, color)
    rect = img.get_rect()
    if anchor == "center":
        rect.center = pos
    elif anchor == "topright":
        rect.topright = pos
    else:
        rect.topleft = pos
    surface.blit(img, rect)
    return rect


def draw_button(
    surface: pygame.Surface,
    font: pygame.font.Font,
    label: str,
    rect: pygame.Rect,
    *,
    selected: bool = False,
    disabled: bool = False,
) -> pygame.Rect:
    if disabled:
        bg = (18, 18, 22)
        border = (50, 50, 60)
        text = pygame.Color(120, 120, 130)
    else:
        bg = (34, 34, 42) if selected else (24, 24, 30)
        border = (110, 110, 130) if selected else (70, 70, 86)
        text = pygame.Color(240, 240, 240) if selected else pygame.Color(200, 200, 210)

    pygame.draw.rect(surface, bg, rect, border_radius=6)
    pygame.draw.rect(surface, border, rect, 2, border_radius=6)
    draw_text(surface, font, label, rect.center, text, anchor="center")
    return rect


def sprite_from_pixels(pixels: Sequence[str], palette: dict[str, tuple[int, int, int]]) -> pygame.Surface:
    height = len(pixels)
    width = max((len(row) for row in pixels), default=0)
    surf = pygame.Surface((width, height), pygame.SRCALPHA)
    for y, row in enumerate(pixels):
        for x, ch in enumerate(row):
            if ch == " ":
                continue
            color = palette.get(ch)
            if color is None:
                continue
            surf.set_at((x, y), color)
    return surf


_BLEED_CACHE: dict[int, pygame.Surface] = {} 
_ROTATE_CACHE: dict[tuple[int, int], pygame.Surface] = {} 
_ROTATE_CRISP_CACHE: dict[tuple[int, int, int], pygame.Surface] = {} 
_FLIPX_CACHE: dict[int, pygame.Surface] = {} 
_PALETTE_CACHE: dict[int, tuple[tuple[int, int, int], ...]] = {} 


def _alpha_bleed(sprite: pygame.Surface, *, passes: int = 2) -> pygame.Surface:
    cached = _BLEED_CACHE.get(id(sprite))
    if cached is not None and cached.get_size() == sprite.get_size():
        return cached

    surf = sprite.copy()
    w, h = surf.get_size()
    passes = max(0, int(passes))
    if passes <= 0 or w <= 0 or h <= 0:
        _BLEED_CACHE[id(sprite)] = surf
        return surf

    for _ in range(passes):
        base = surf.copy()
        for y in range(h):
            for x in range(w):
                _r, _g, _b, a = base.get_at((x, y))
                if a != 0:
                    continue
                found: tuple[int, int, int] | None = None
                for dy in (-1, 0, 1):
                    ny = y + dy
                    if ny < 0 or ny >= h:
                        continue
                    for dx in (-1, 0, 1):
                        if dx == 0 and dy == 0:
                            continue
                        nx = x + dx
                        if nx < 0 or nx >= w:
                            continue
                        nr, ng, nb, na = base.get_at((nx, ny))
                        if na != 0:
                            found = (nr, ng, nb)
                            break
                    if found is not None:
                        break
                if found is not None:
                    surf.set_at((x, y), (*found, 0))

    _BLEED_CACHE[id(sprite)] = surf
    return surf


def _clamp_alpha(sprite: pygame.Surface, *, threshold: int = 150) -> pygame.Surface:
    w, h = sprite.get_size()
    if w <= 0 or h <= 0:
        return sprite
    threshold = int(clamp(int(threshold), 1, 254))
    for y in range(h):
        for x in range(w):
            r, g, b, a = sprite.get_at((x, y))
            if a == 0:
                continue
            if a < threshold:
                sprite.set_at((x, y), (0, 0, 0, 0))
            else:
                sprite.set_at((x, y), (r, g, b, 255))
    return sprite


def flip_x_pixel_sprite(sprite: pygame.Surface) -> pygame.Surface:
    cached = _FLIPX_CACHE.get(id(sprite))
    if cached is not None:
        return cached
    try:
        flipped = pygame.transform.flip(sprite, True, False)
    except Exception:
        flipped = sprite
    _FLIPX_CACHE[id(sprite)] = flipped
    return flipped


def rotate_pixel_sprite(sprite: pygame.Surface, deg: float, *, step_deg: float = 5.0) -> pygame.Surface: 
    step_deg = float(step_deg) if step_deg else 5.0
    step_deg = float(clamp(step_deg, 1.0, 45.0))
    qdeg = int(round(float(deg) / step_deg) * step_deg) % 360
    key = (id(sprite), qdeg)
    cached = _ROTATE_CACHE.get(key)
    if cached is not None:
        return cached

    src = _alpha_bleed(sprite, passes=2)
    rot = pygame.transform.rotate(src, qdeg)
    rot = _clamp_alpha(rot, threshold=150)
    _ROTATE_CACHE[key] = rot 
    return rot 


def _sprite_palette_rgb(sprite: pygame.Surface, *, max_colors: int = 64) -> tuple[tuple[int, int, int], ...]: 
    cached = _PALETTE_CACHE.get(id(sprite)) 
    if cached is not None: 
        return cached 
    w, h = sprite.get_size() 
    if w <= 0 or h <= 0: 
        _PALETTE_CACHE[id(sprite)] = () 
        return () 
    max_colors = int(clamp(int(max_colors), 1, 512)) 
    out: list[tuple[int, int, int]] = [] 
    seen: set[tuple[int, int, int]] = set() 
    for y in range(h): 
        for x in range(w): 
            r, g, b, a = sprite.get_at((x, y)) 
            if a == 0: 
                continue 
            c = (int(r), int(g), int(b)) 
            if c in seen: 
                continue 
            seen.add(c) 
            out.append(c) 
            if len(out) >= max_colors: 
                _PALETTE_CACHE[id(sprite)] = tuple(out) 
                return _PALETTE_CACHE[id(sprite)] 
    _PALETTE_CACHE[id(sprite)] = tuple(out) 
    return _PALETTE_CACHE[id(sprite)] 


def _quantize_rgb_to_palette(sprite: pygame.Surface, palette: tuple[tuple[int, int, int], ...]) -> pygame.Surface: 
    if not palette: 
        return sprite 
    w, h = sprite.get_size() 
    if w <= 0 or h <= 0: 
        return sprite 
    cache: dict[tuple[int, int, int], tuple[int, int, int]] = {} 
    for y in range(h): 
        for x in range(w): 
            r, g, b, a = sprite.get_at((x, y)) 
            if a == 0: 
                continue 
            src = (int(r), int(g), int(b)) 
            dst = cache.get(src) 
            if dst is None: 
                br, bg, bb = palette[0] 
                best_d2 = (src[0] - br) * (src[0] - br) + (src[1] - bg) * (src[1] - bg) + (src[2] - bb) * (src[2] - bb) 
                for pr, pg, pb in palette[1:]: 
                    d2 = (src[0] - pr) * (src[0] - pr) + (src[1] - pg) * (src[1] - pg) + (src[2] - pb) * (src[2] - pb) 
                    if d2 < best_d2: 
                        br, bg, bb = pr, pg, pb 
                        best_d2 = d2 
                dst = (int(br), int(bg), int(bb)) 
                cache[src] = dst 
            sprite.set_at((x, y), (int(dst[0]), int(dst[1]), int(dst[2]), 255)) 
    return sprite 


def rotate_pixel_sprite_crisp(sprite: pygame.Surface, deg: float, *, step_deg: float = 5.0, upscale: int = 4) -> pygame.Surface: 
    step_deg = float(step_deg) if step_deg else 5.0 
    step_deg = float(clamp(step_deg, 1.0, 45.0)) 
    qdeg = int(round(float(deg) / step_deg) * step_deg) % 360 
    upscale = int(clamp(int(upscale), 2, 12)) 
    key = (id(sprite), qdeg, int(upscale)) 
    cached = _ROTATE_CRISP_CACHE.get(key) 
    if cached is not None: 
        return cached 
    w, h = sprite.get_size() 
    if w <= 0 or h <= 0: 
        _ROTATE_CRISP_CACHE[key] = sprite 
        return sprite 
    src = _alpha_bleed(sprite, passes=2) 
    try: 
        up = pygame.transform.scale(src, (int(w * upscale), int(h * upscale))) 
    except Exception: 
        up = src 
        upscale = 1 
    rot_up = pygame.transform.rotate(up, qdeg) 

    if upscale > 1: 
        rw, rh = rot_up.get_size() 
        dw = max(1, int(round(float(rw) / float(upscale)))) 
        dh = max(1, int(round(float(rh) / float(upscale)))) 
        rot = pygame.transform.scale(rot_up, (int(dw), int(dh))) 
    else: 
        rot = rot_up 

    rot = _clamp_alpha(rot, threshold=150) 
    pal = _sprite_palette_rgb(sprite, max_colors=64) 
    rot = _quantize_rgb_to_palette(rot, pal) 
    _ROTATE_CRISP_CACHE[key] = rot 
    return rot 


def _make_sound(samples: array, *, volume: float = 0.35) -> pygame.mixer.Sound | None:
    if pygame.mixer.get_init() is None:
        return None
    try:
        snd = pygame.mixer.Sound(buffer=samples.tobytes())
        snd.set_volume(float(volume))
        return snd
    except Exception:
        return None


def _sfx_shot(rate: int) -> pygame.mixer.Sound | None:
    dur_s = 0.085
    n = max(1, int(rate * dur_s))
    out = array("h")
    max_amp = 32767
    for i in range(n):
        t = i / rate
        env = math.exp(-t * 55.0)
        noise = random.uniform(-1.0, 1.0) * 0.65
        thump = math.sin(math.tau * 120.0 * t) * 0.35
        click = (1.0 if i < 18 else 0.0) * 0.8
        v = (noise + thump + click) * env
        v = clamp(v, -1.0, 1.0)
        out.append(int(v * max_amp))
    return _make_sound(out, volume=0.32)


def _sfx_swing(rate: int) -> pygame.mixer.Sound | None:
    dur_s = 0.14
    n = max(1, int(rate * dur_s))
    out = array("h")
    max_amp = 32767
    for i in range(n):
        t = i / rate
        u = t / max(1e-6, dur_s)
        env = math.exp(-t * 28.0) * (1.0 if u < 1.0 else 0.0)
        sweep = 1400.0 + (260.0 - 1400.0) * u
        tone = math.sin(math.tau * sweep * t) * 0.25
        noise = random.uniform(-1.0, 1.0) * 0.45
        v = (tone + noise) * env
        v = clamp(v, -1.0, 1.0)
        out.append(int(v * max_amp))
    return _make_sound(out, volume=0.26)


def _sfx_hit(rate: int) -> pygame.mixer.Sound | None:
    # Short "thump" for melee hits.
    dur_s = 0.075
    n = max(1, int(rate * dur_s))
    out = array("h")
    max_amp = 32767
    for i in range(n):
        t = i / rate
        u = t / max(1e-6, dur_s)
        env = math.exp(-t * 75.0) * (1.0 if u < 1.0 else 0.0)
        thump = math.sin(math.tau * 90.0 * t) * 0.45
        noise = random.uniform(-1.0, 1.0) * 0.35
        v = (thump + noise) * env
        v = clamp(v, -1.0, 1.0)
        out.append(int(v * max_amp))
    return _make_sound(out, volume=0.34)


class SFX:
    def __init__(self) -> None:
        self.enabled = pygame.mixer.get_init() is not None
        self.shot: pygame.mixer.Sound | None = None
        self.swing: pygame.mixer.Sound | None = None
        self.hit: pygame.mixer.Sound | None = None
        if not self.enabled:
            return
        rate = pygame.mixer.get_init()[0] if pygame.mixer.get_init() else 22050
        self.shot = _sfx_shot(int(rate))
        self.swing = _sfx_swing(int(rate))
        self.hit = _sfx_hit(int(rate))

    def play(self, name: str) -> None:
        if not self.enabled:
            return
        snd = getattr(self, name, None)
        if snd is not None:
            try:
                snd.play()
            except Exception:
                return


@dataclass
class GameConfig:
    scale: int = 2
    fullscreen: bool = True
    show_grid: bool = True
    # Lighting (tile radius + intensity/opacity scale).
    lamp_world_radius_tiles: int = 3
    lamp_world_intensity: float = 1.0
    lamp_world_halo: float = 0.35
    lamp_hr_radius_tiles: int = 5
    lamp_hr_intensity: float = 1.0
    lamp_hr_halo: float = 0.35

    @classmethod
    def load(cls) -> "GameConfig":
        try:
            data = json.loads(SETTINGS_PATH.read_text(encoding="utf-8"))
            return cls(
                scale=int(data.get("scale", 2)),
                fullscreen=bool(data.get("fullscreen", True)),
                show_grid=bool(data.get("show_grid", True)),
                lamp_world_radius_tiles=int(data.get("lamp_world_radius_tiles", 5)),
                lamp_world_intensity=float(data.get("lamp_world_intensity", 1.0)),
                lamp_world_halo=float(data.get("lamp_world_halo", data.get("lamp_world_opacity", 0.35))),
                lamp_hr_radius_tiles=int(data.get("lamp_hr_radius_tiles", 5)),
                lamp_hr_intensity=float(data.get("lamp_hr_intensity", 1.0)),
                lamp_hr_halo=float(data.get("lamp_hr_halo", data.get("lamp_hr_opacity", 0.35))),
            )
        except Exception:
            return cls()

    def save(self) -> None:
        SETTINGS_PATH.write_text(
            json.dumps(
                {
                    "scale": int(self.scale),
                    "fullscreen": bool(self.fullscreen),
                    "show_grid": bool(self.show_grid),
                    "lamp_world_radius_tiles": int(self.lamp_world_radius_tiles),
                    "lamp_world_intensity": float(self.lamp_world_intensity),
                    "lamp_world_halo": float(self.lamp_world_halo),
                    "lamp_hr_radius_tiles": int(self.lamp_hr_radius_tiles),
                    "lamp_hr_intensity": float(self.lamp_hr_intensity),
                    "lamp_hr_halo": float(self.lamp_hr_halo),
                },
                ensure_ascii=False,
                indent=2,
            ),
            encoding="utf-8",
        )


@dataclass(frozen=True)
class CharacterDef:
    id: str
    name: str
    desc: str
    sprite: pygame.Surface
    base_hp: int
    move_speed: float
    start_weapon: str
    regen: float = 0.0
    damage_mult: float = 1.0
    cooldown_mult: float = 1.0
    frames: tuple[pygame.Surface, ...] | None = None
    skeleton_frames: tuple[dict[str, tuple[int, int]], ...] | None = None


@dataclass(frozen=True)
class MapDef:
    id: str
    name: str
    desc: str
    base_color: tuple[int, int, int]
    accent_color: tuple[int, int, int]
    enemy_pool: tuple[str, ...]


@dataclass(frozen=True)
class EnemyDef:
    id: str
    name: str
    color: tuple[int, int, int]
    hp: int
    speed: float
    size: int
    contact_damage: int
    xp_value: int
    frames: tuple[pygame.Surface, ...] | None = None


@dataclass(frozen=True)
class WeaponDef:
    id: str
    name: str
    desc: str
    kind: str  # melee | orbit | gun
    color: tuple[int, int, int]
    cooldown_s: float
    damage: int
    proj_speed: float = 0.0
    proj_size: int = 2
    pierce: int = 0
    magazine: int = 0
    reload_s: float = 0.0
    proj_ttl_s: float = 2.5
    spread_rad: float = 0.0
    knockback: float = 0.0
    aoe_radius: float = 0.0
    aoe_damage_mult: float = 1.0
    recoil_per_shot: float = 0.0
    recoil_decay: float = 0.0
    recoil_max: float = 0.0
    shots_per_fire: int = 1
    sprite: pygame.Surface | None = None


@dataclass(frozen=True)
class Upgrade:
    title: str
    desc: str
    apply: Callable[["Player", "GameState"], None]


class Player:
    def __init__(self, char_def: CharacterDef) -> None:
        self.char_def = char_def
        self.frames = char_def.frames or (char_def.sprite,)
        self.skeleton_frames = char_def.skeleton_frames or ()
        self._flip_cache: dict[int, pygame.Surface] = {}
        self.facing = 1
        self.anim_time = 0.0
        self.anim_index = 0
        self.draw_offset = pygame.Vector2(0, 0)
        self.sprite = self.frames[0]
        self.w = self.sprite.get_width()
        self.h = self.sprite.get_height()

        self.skeleton_nodes: dict[str, tuple[int, int]] = self._current_skeleton_nodes()

        self.pos = pygame.Vector2(INTERNAL_W // 2 - self.w // 2, INTERNAL_H // 2 - self.h // 2)
        self.max_hp = int(char_def.base_hp)
        self.hp = float(self.max_hp)
        self.regen = float(char_def.regen)

        self.move_speed = float(char_def.move_speed)
        self.damage_mult = float(char_def.damage_mult)
        self.cooldown_mult = float(char_def.cooldown_mult)
        self.xp_mult = 1.0

        self.level = 1
        self.xp = 0.0
        self.xp_to_next = 12.0

        self.invuln_s = 0.0
        self.hurt_s = 0.0
        self.last_move_dir = pygame.Vector2(1, 0)

        self.weapons: list[WeaponInstance] = []

    def _base_frame(self, index: int) -> pygame.Surface:
        if not self.frames:
            return self.char_def.sprite
        idx = max(0, min(int(index), len(self.frames) - 1))
        return self.frames[idx]

    def _current_skeleton_nodes(self) -> dict[str, tuple[int, int]]:
        if not self.skeleton_frames:
            return {}
        idx = max(0, min(int(self.anim_index), len(self.skeleton_frames) - 1))
        nodes = self.skeleton_frames[idx]
        if self.facing >= 0:
            return dict(nodes)
        w = self._base_frame(idx).get_width()
        return {name: (w - 1 - x, y) for name, (x, y) in nodes.items()}

    def _frame_for_facing(self, index: int) -> pygame.Surface:
        base = self._base_frame(index)
        if self.facing >= 0:
            return base
        cached = self._flip_cache.get(index)
        if cached is None or cached.get_size() != base.get_size():
            cached = pygame.transform.flip(base, True, False)
            self._flip_cache[index] = cached
        return cached

    def update_visual(self, dt: float, move_dir: pygame.Vector2) -> None:
        if move_dir.length_squared() > 0.0001:
            if move_dir.x < -0.1:
                self.facing = -1
            elif move_dir.x > 0.1:
                self.facing = 1

            if len(self.frames) >= 3:
                self.anim_time += dt * (7.0 + self.move_speed * 0.02)
                step = int(self.anim_time) % 2
                self.anim_index = 1 + step
            elif len(self.frames) == 2:
                self.anim_time += dt * (6.0 + self.move_speed * 0.02)
                self.anim_index = int(self.anim_time) % 2
            else:
                self.anim_index = 0
            self.draw_offset.y = -1 if self.anim_index == 1 else 0
        else:
            self.anim_time = 0.0
            self.anim_index = 0
            self.draw_offset.update(0.0, 0.0)

        self.sprite = self._frame_for_facing(self.anim_index)
        self.w = self.sprite.get_width()
        self.h = self.sprite.get_height()
        self.skeleton_nodes = self._current_skeleton_nodes()

    def rect(self) -> pygame.Rect:
        return pygame.Rect(int(self.pos.x), int(self.pos.y), self.w, self.h)

    def center(self) -> pygame.Vector2:
        r = self.rect()
        return pygame.Vector2(r.centerx, r.centery)

    def orbit_center(self) -> pygame.Vector2:
        chest = self.skeleton_nodes.get("chest")
        if chest is not None:
            cx, cy = chest
            return pygame.Vector2(int(self.pos.x) + cx, int(self.pos.y) + cy) + self.draw_offset
        return self.center() + self.draw_offset

    def hand_pos(self) -> pygame.Vector2:
        hand = self.skeleton_nodes.get("r_hand")
        if hand is not None:
            hx, hy = hand
            return pygame.Vector2(int(self.pos.x) + hx, int(self.pos.y) + hy) + self.draw_offset
        return self.orbit_center()


class Enemy:
    _next_uid = 1

    def __init__(self, enemy_def: EnemyDef, pos: pygame.Vector2) -> None:
        self.enemy_def = enemy_def
        self.pos = pos
        self.hp = float(enemy_def.hp)
        self.size = int(enemy_def.size)
        self.uid = Enemy._next_uid
        Enemy._next_uid += 1
        self.anim_time = random.random() * 10.0
        self.vel = pygame.Vector2(0, 0)

        self.frames: tuple[pygame.Surface, ...] | None = None
        self.sprite: pygame.Surface | None = None
        if enemy_def.frames:
            scaled: list[pygame.Surface] = []
            for frame in enemy_def.frames:
                if frame.get_size() == (self.size, self.size):
                    scaled.append(frame)
                else:
                    scaled.append(pygame.transform.scale(frame, (self.size, self.size)))
            self.frames = tuple(scaled)
            self.sprite = self.frames[0] if self.frames else None

    def rect(self) -> pygame.Rect:
        return pygame.Rect(int(self.pos.x), int(self.pos.y), self.size, self.size)

    def center(self) -> pygame.Vector2:
        r = self.rect()
        return pygame.Vector2(r.centerx, r.centery)

    def update_visual(self, dt: float) -> None:
        if not self.frames or len(self.frames) <= 1:
            return
        self.anim_time += dt
        rate = 4.5 if self.enemy_def.id == "slime" else 6.0
        idx = int(self.anim_time * rate) % len(self.frames)
        self.sprite = self.frames[idx]


class Projectile:
    def __init__(
        self,
        pos: pygame.Vector2,
        vel: pygame.Vector2,
        *,
        size: int,
        color: tuple[int, int, int],
        damage: float,
        pierce: int = 0,
        knockback: float = 0.0,
        aoe_radius: float = 0.0,
        aoe_damage_mult: float = 1.0,
        ttl_s: float = 3.0,
    ) -> None:
        self.pos = pygame.Vector2(pos)
        self.vel = pygame.Vector2(vel)
        self.size = int(size)
        self.color = color
        self.damage = float(damage)
        self.pierce = int(pierce)
        self.knockback = float(knockback)
        self.aoe_radius = float(aoe_radius)
        self.aoe_damage_mult = float(aoe_damage_mult)
        self.ttl_s = float(ttl_s)
        self.hit_uids: set[int] = set()

    def rect(self) -> pygame.Rect:
        return pygame.Rect(int(self.pos.x), int(self.pos.y), self.size, self.size)


class Swing:
    def __init__(self, rect: pygame.Rect, damage: float, ttl_s: float = 0.12) -> None:
        self.rect = rect
        self.damage = float(damage)
        self.ttl_s = float(ttl_s)
        self.hit_uids: set[int] = set()


class WeaponInstance:
    def __init__(self, weapon_def: WeaponDef) -> None:
        self.weapon_def = weapon_def
        self.level = 1
        self.cooldown_left = 0.0
        self.angle = random.random() * math.tau
        self.orbit_radius = 18.0
        self.orbit_speed = 2.6
        self.size = 8
        self.orbit_rect = pygame.Rect(0, 0, self.size, self.size)
        self.aim_angle = 0.0
        self.ammo = max(0, int(weapon_def.magazine))
        self.reload_left = 0.0
        self.reload_total = 0.0
        self.reload_spin = 0.0
        self.recoil = 0.0
        self.muzzle_flash_s = 0.0
        self.swinging = False
        self.swing_t = 0.0
        self.swing_duration_s = 0.16
        self.swing_a0 = 0.0
        self.swing_a1 = 0.0
        self.swing_hit_uids: set[int] = set()
        self.sword_poly: list[tuple[int, int]] = []
        self.sword_base = pygame.Vector2(0, 0)
        self.sword_tip = pygame.Vector2(0, 0)
        self.trail: list[tuple[pygame.Vector2, float]] = []

    def level_bonus(self) -> float:
        return 1.0 + 0.25 * (self.level - 1)

    def cooldown_bonus(self) -> float:
        return 0.92 ** (self.level - 1)

    def damage(self, player: Player) -> float:
        return float(self.weapon_def.damage) * self.level_bonus() * player.damage_mult

    def cooldown_s(self, player: Player) -> float:
        return max(0.08, float(self.weapon_def.cooldown_s) * self.cooldown_bonus() * player.cooldown_mult)

    def update(self, dt: float, player: Player, game: "GameState") -> None:
        if self.weapon_def.kind == "melee":
            self.cooldown_left -= dt

            if self.trail:
                updated: list[tuple[pygame.Vector2, float]] = []
                for pos, age in self.trail:
                    age += dt
                    if age <= 0.18:
                        updated.append((pos, age))
                self.trail = updated

            length = float(12 + max(0, self.level - 1) * 2)
            thickness = float(4 + max(0, self.level - 1) // 2)
            hand = player.hand_pos()

            if not self.swinging and self.cooldown_left <= 0.0:
                self.swinging = True
                self.swing_t = 0.0
                self.swing_hit_uids.clear()
                self.cooldown_left = self.cooldown_s(player)
                game.app.play_sfx("swing")

                base = 0.0 if player.facing >= 0 else math.pi
                arc = 1.08
                self.swing_a0 = base - arc
                self.swing_a1 = base + arc

            if self.swinging:
                self.swing_t += dt
                t = 1.0 if self.swing_duration_s <= 0 else clamp(self.swing_t / self.swing_duration_s, 0.0, 1.0)
                t = t * t * (3.0 - 2.0 * t)
                ang = self.swing_a0 + (self.swing_a1 - self.swing_a0) * t
                if self.swing_t >= self.swing_duration_s:
                    self.swinging = False
            else:
                ang = 0.12 if player.facing >= 0 else math.pi - 0.12

            d = pygame.Vector2(math.cos(ang), math.sin(ang))
            if d.length_squared() <= 0.001:
                d = pygame.Vector2(1, 0 if player.facing >= 0 else -1)
            perp = pygame.Vector2(-d.y, d.x)
            half = thickness * 0.5

            base = pygame.Vector2(hand)
            tip = base + d * length
            p1 = base + perp * half
            p2 = base - perp * half
            p3 = tip - perp * half
            p4 = tip + perp * half

            self.sword_base = base
            self.sword_tip = tip
            self.sword_poly = [(int(p1.x), int(p1.y)), (int(p2.x), int(p2.y)), (int(p3.x), int(p3.y)), (int(p4.x), int(p4.y))]

            min_x = int(min(p1.x, p2.x, p3.x, p4.x))
            min_y = int(min(p1.y, p2.y, p3.y, p4.y))
            max_x = int(max(p1.x, p2.x, p3.x, p4.x))
            max_y = int(max(p1.y, p2.y, p3.y, p4.y))
            self.orbit_rect = pygame.Rect(min_x, min_y, max(1, max_x - min_x + 1), max(1, max_y - min_y + 1))

            if self.swinging:
                if not self.trail or (self.trail[-1][0] - tip).length_squared() > 1.0:
                    self.trail.append((pygame.Vector2(tip), 0.0))

                for e in game.enemies:
                    if e.uid in self.swing_hit_uids:
                        continue
                    if not self.orbit_rect.colliderect(e.rect()):
                        continue
                    self.swing_hit_uids.add(e.uid)
                    dmg = self.damage(player)
                    e.hp -= dmg
                    game.add_damage_text(e.center(), dmg, color=(255, 240, 200))

                    knock = 180.0 if e.enemy_def.id == "slime" else 90.0
                    away = (e.center() - player.center())
                    if away.length_squared() > 0.01:
                        e.vel += away.normalize() * knock
                    else:
                        rand = pygame.Vector2(random.uniform(-1, 1), random.uniform(-1, 1))
                        if rand.length_squared() <= 0.001:
                            rand = pygame.Vector2(1, 0)
                        e.vel += rand.normalize() * knock
            return
        c = player.orbit_center()
        offset = pygame.Vector2(math.cos(self.angle), math.sin(self.angle)) * self.orbit_radius
        pos = c + offset

        if self.weapon_def.kind == "gun":
            self.muzzle_flash_s = max(0.0, self.muzzle_flash_s - dt)
            size = int(10 + max(0, self.level - 1) // 2)
            self.orbit_rect.size = (size, size)
            self.orbit_rect.center = (int(pos.x), int(pos.y))

            target = game.closest_enemy_to(pos)
            if target is not None:
                aim = (target.center() - pos)
                if aim.length_squared() > 0.01:
                    aim = aim.normalize()
                else:
                    aim = pygame.Vector2(1, 0)
            else:
                aim = pygame.Vector2(player.last_move_dir)
                if aim.length_squared() <= 0.01:
                    aim = pygame.Vector2(1, 0)
                else:
                    aim = aim.normalize()
            self.aim_angle = math.atan2(aim.y, aim.x)

            if self.weapon_def.recoil_decay > 0:
                self.recoil = max(0.0, self.recoil - float(self.weapon_def.recoil_decay) * dt)

            mag = max(1, int(self.weapon_def.magazine + max(0, self.level - 1) // 3))
            reload_s = max(0.35, float(self.weapon_def.reload_s) * (0.96 ** max(0, self.level - 1)))

            if self.reload_left > 0.0:
                self.reload_left = max(0.0, self.reload_left - dt)
                self.reload_spin = (self.reload_spin + dt * 11.0) % math.tau
                if self.reload_left <= 0.0:
                    self.ammo = mag
                    self.reload_total = 0.0
                    self.reload_spin = 0.0
                    self.cooldown_left = max(self.cooldown_left, 0.06)
                return

            self.cooldown_left -= dt
            if self.cooldown_left > 0.0:
                return

            if self.ammo <= 0:
                self.reload_total = reload_s
                self.reload_left = reload_s
                self.reload_spin = 0.0
                return

            spread = float(self.weapon_def.spread_rad) + float(self.recoil)
            base_kb = float(self.weapon_def.knockback)
            if base_kb <= 0.0:
                base_kb = 70.0 + float(self.weapon_def.damage) * 4.0
            knock = base_kb * (1.0 + 0.10 * max(0, self.level - 1))

            bullet_speed = max(10.0, float(self.weapon_def.proj_speed))
            shots = max(1, int(self.weapon_def.shots_per_fire))
            for _ in range(shots):
                a = self.aim_angle
                if spread > 0:
                    a += random.uniform(-spread, spread)
                d = pygame.Vector2(math.cos(a), math.sin(a))
                if d.length_squared() <= 0.001:
                    d = pygame.Vector2(1, 0)

                game.projectiles.append(
                    Projectile(
                        pos,
                        d * bullet_speed,
                        size=max(1, int(self.weapon_def.proj_size)),
                        color=self.weapon_def.color,
                        damage=self.damage(player),
                        pierce=int(self.weapon_def.pierce),
                        knockback=knock,
                        aoe_radius=float(self.weapon_def.aoe_radius),
                        aoe_damage_mult=float(self.weapon_def.aoe_damage_mult),
                        ttl_s=float(self.weapon_def.proj_ttl_s),
                    )
                )
            game.app.play_sfx("shot")
            self.muzzle_flash_s = 0.06 if self.weapon_def.aoe_radius <= 0.0 else 0.10
            if self.weapon_def.recoil_per_shot > 0 and self.weapon_def.recoil_max > 0:
                self.recoil = min(float(self.weapon_def.recoil_max), self.recoil + float(self.weapon_def.recoil_per_shot))

            self.ammo -= 1
            self.cooldown_left = self.cooldown_s(player)
            if self.ammo <= 0:
                self.reload_total = reload_s
                self.reload_left = reload_s
                self.reload_spin = 0.0
            return

        size = int(self.size + max(0, self.level - 1))
        self.orbit_rect.size = (size, size)
        self.orbit_rect.center = (int(pos.x), int(pos.y))

        self.cooldown_left -= dt
        if self.cooldown_left > 0:
            return

        for e in game.enemies:
            if self.orbit_rect.colliderect(e.rect()):
                dmg = self.damage(player)
                e.hp -= dmg
                game.add_damage_text(e.center(), dmg, color=(220, 240, 255))
                self.cooldown_left = self.cooldown_s(player)
                break


@dataclass
class WeaponPickup:
    weapon_id: str
    pos: pygame.Vector2
    bob_t: float = 0.0

    def rect(self) -> pygame.Rect:
        return pygame.Rect(int(self.pos.x), int(self.pos.y), 10, 10)

    def level_bonus(self) -> float:
        return 1.0 + 0.25 * (self.level - 1)

    def cooldown_bonus(self) -> float:
        return 0.92 ** (self.level - 1)

    def damage(self, player: Player) -> float:
        return float(self.weapon_def.damage) * self.level_bonus() * player.damage_mult

    def cooldown_s(self, player: Player) -> float:
        return max(0.08, float(self.weapon_def.cooldown_s) * self.cooldown_bonus() * player.cooldown_mult)

    def update(self, dt: float, player: Player, game: "GameState") -> None:     
        if self.weapon_def.kind == "melee":
            self.cooldown_left -= dt

            if self.trail:
                updated: list[tuple[pygame.Vector2, float]] = []
                for pos, age in self.trail:
                    age += dt
                    if age <= 0.18:
                        updated.append((pos, age))
                self.trail = updated

            length = float(12 + max(0, self.level - 1) * 2)
            thickness = float(4 + max(0, self.level - 1) // 2)
            hand = player.hand_pos()

            if not self.swinging and self.cooldown_left <= 0.0:
                self.swinging = True
                self.swing_t = 0.0
                self.swing_hit_uids.clear()
                self.cooldown_left = self.cooldown_s(player)

                base = 0.0 if player.facing >= 0 else math.pi
                arc = 1.08
                self.swing_a0 = base - arc
                self.swing_a1 = base + arc

            if self.swinging:
                self.swing_t += dt
                t = 1.0 if self.swing_duration_s <= 0 else clamp(self.swing_t / self.swing_duration_s, 0.0, 1.0)
                t = t * t * (3.0 - 2.0 * t)
                ang = self.swing_a0 + (self.swing_a1 - self.swing_a0) * t
                if self.swing_t >= self.swing_duration_s:
                    self.swinging = False
            else:
                ang = 0.12 if player.facing >= 0 else math.pi - 0.12

            d = pygame.Vector2(math.cos(ang), math.sin(ang))
            if d.length_squared() <= 0.001:
                d = pygame.Vector2(1, 0 if player.facing >= 0 else -1)
            perp = pygame.Vector2(-d.y, d.x)
            half = thickness * 0.5

            base = pygame.Vector2(hand)
            tip = base + d * length
            p1 = base + perp * half
            p2 = base - perp * half
            p3 = tip - perp * half
            p4 = tip + perp * half

            self.sword_base = base
            self.sword_tip = tip
            self.sword_poly = [(int(p1.x), int(p1.y)), (int(p2.x), int(p2.y)), (int(p3.x), int(p3.y)), (int(p4.x), int(p4.y))]

            min_x = int(min(p1.x, p2.x, p3.x, p4.x))
            min_y = int(min(p1.y, p2.y, p3.y, p4.y))
            max_x = int(max(p1.x, p2.x, p3.x, p4.x))
            max_y = int(max(p1.y, p2.y, p3.y, p4.y))
            self.orbit_rect = pygame.Rect(min_x, min_y, max(1, max_x - min_x + 1), max(1, max_y - min_y + 1))

            if self.swinging:
                if not self.trail or (self.trail[-1][0] - tip).length_squared() > 1.0:
                    self.trail.append((pygame.Vector2(tip), 0.0))

                for e in game.enemies:
                    if e.uid in self.swing_hit_uids:
                        continue
                    if not self.orbit_rect.colliderect(e.rect()):
                        continue
                    self.swing_hit_uids.add(e.uid)
                    e.hp -= self.damage(player)

                    knock = 180.0 if e.enemy_def.id == "slime" else 90.0
                    away = (e.center() - player.center())
                    if away.length_squared() > 0.01:
                        e.vel += away.normalize() * knock
                    else:
                        rand = pygame.Vector2(random.uniform(-1, 1), random.uniform(-1, 1))
                        if rand.length_squared() <= 0.001:
                            rand = pygame.Vector2(1, 0)
                        e.vel += rand.normalize() * knock
            return

        self.angle = (self.angle + dt * self.orbit_speed) % math.tau
        c = player.orbit_center()
        offset = pygame.Vector2(math.cos(self.angle), math.sin(self.angle)) * self.orbit_radius
        pos = c + offset

        size = int(self.size + max(0, self.level - 1))
        self.orbit_rect.size = (size, size)
        self.orbit_rect.center = (int(pos.x), int(pos.y))

        self.cooldown_left -= dt
        if self.cooldown_left > 0:
            return

        for e in game.enemies:
            if self.orbit_rect.colliderect(e.rect()):
                e.hp -= self.damage(player)
                self.cooldown_left = self.cooldown_s(player)
                break


@dataclass
class WeaponDrop:
    weapon_id: str
    pos: pygame.Vector2
    bob_t: float = 0.0

    def rect(self) -> pygame.Rect:
        return pygame.Rect(int(self.pos.x) - 4, int(self.pos.y) - 4, 8, 8)


class DamageText:
    def __init__(self, pos: pygame.Vector2, amount: float, *, color: pygame.Color) -> None:
        self.pos = pygame.Vector2(pos)
        self.vel = pygame.Vector2(random.uniform(-10.0, 10.0), random.uniform(-28.0, -40.0))
        self.amount = float(amount)
        self.text = str(max(0, int(round(amount))))
        self.color = color
        self.ttl_s = 0.60


class ExplosionFx:
    def __init__(self, pos: pygame.Vector2, *, radius: float, color: tuple[int, int, int]) -> None:
        self.pos = pygame.Vector2(pos)
        self.radius = float(radius)
        self.color = pygame.Color(*color)
        self.ttl_s = 0.22


def make_defs() -> tuple[list[CharacterDef], list[MapDef], dict[str, EnemyDef], dict[str, WeaponDef]]:
    palette = {
        "K": (16, 16, 16),
        "W": (240, 240, 240),
        "G": (96, 192, 96),
        "B": (96, 160, 220),
        "Y": (220, 200, 80),
        "P": (180, 120, 220),
        "S": (220, 180, 140),
        "D": (34, 34, 44),
        "M": (120, 130, 150),
        "L": (170, 180, 205),
        "H": (235, 235, 245),
        "O": (70, 70, 82),
        "R": (240, 120, 80),
    }

    warrior_frames = (
        sprite_from_pixels(
            [
                "    KKK     ",
                "   KWWWWK   ",
                "   KWOOWK   ",
                "   KSSSSK   ",
                "   KSSSSK   ",
                "   KWWWWK   ",
                "  KKWWWWKK  ",
                "  KWWYYWWK  ",
                "   KWWWWK   ",
                "   KWWWWK   ",
                "   KYY YYK  ",
                "   KY   YK  ",
                "   KY   YK  ",
                "  KYY  YYK  ",
            ],
            palette,
        ),
        sprite_from_pixels(
            [
                "    KKK     ",
                "   KWWWWK   ",
                "   KWOOWK   ",
                "   KSSSSK   ",
                "   KSSSSK   ",
                "   KWWWWK   ",
                "  KKWWWWKK  ",
                "  KWWYYWWK  ",
                "   KWWWWK   ",
                "   KWWWWK   ",
                "   KYY YYK  ",
                "   KYY  YK  ",
                "   KY  YYK  ",
                "  KYY   K   ",
            ],
            palette,
        ),
        sprite_from_pixels(
            [
                "    KKK     ",
                "   KWWWWK   ",
                "   KWOOWK   ",
                "   KSSSSK   ",
                "   KSSSSK   ",
                "   KWWWWK   ",
                "  KKWWWWKK  ",
                "  KWWYYWWK  ",
                "   KWWWWK   ",
                "   KWWWWK   ",
                "   KYY YYK  ",
                "   KY  YYK  ",
                "   KYY  YK  ",
                "  K   YYK   ",
            ],
            palette,
        ),
    )
    warrior = warrior_frames[0]
    warrior_skeleton = (
        {
            "head": (5, 3),
            "chest": (5, 7),
            "hip": (5, 10),
            "l_hand": (3, 8),
            "r_hand": (7, 8),
            "l_foot": (4, 13),
            "r_foot": (7, 13),
        },
        {
            "head": (5, 3),
            "chest": (5, 7),
            "hip": (5, 10),
            "l_hand": (3, 8),
            "r_hand": (7, 8),
            "l_foot": (4, 13),
            "r_foot": (8, 12),
        },
        {
            "head": (5, 3),
            "chest": (5, 7),
            "hip": (5, 10),
            "l_hand": (3, 8),
            "r_hand": (7, 8),
            "l_foot": (5, 12),
            "r_foot": (7, 13),
        },
    )
    mage = sprite_from_pixels(
        [
            "    PP      ",
            "   PPPP     ",
            "   PSSP     ",
            "   PWWP     ",
            "  PPPPPP    ",
            "  PWWWWP    ",
            "  PWWWWP    ",
            "   PBBP     ",
            "   PBBP     ",
            "    BB      ",
            "    BB      ",
            "            ",
        ],
        palette,
    )
    dragonkin = sprite_from_pixels(
        [
            "   GGGG     ",
            "  GGGGGG    ",
            "  GSSSSG    ",
            "  GKKKKG    ",
            "  GGGGGG    ",
            "  GGGGGG    ",
            "  GGYYGG    ",
            "   GYYG     ",
            "   G  G     ",
            "  GG  GG    ",
            "  G    G    ",
            "            ",
        ],
        palette,
    )
    undead = sprite_from_pixels(
        [
            "   GGGG     ",
            "  GWWWWG    ",
            "  GWKKWG    ",
            "  GWWWWG    ",
            "  GGGGGG    ",
            "  GWWWWG    ",
            "  GWWWWG    ",
            "   GWWG     ",
            "   G  G     ",
            "  GG  GG    ",
            "  G    G    ",
            "            ",
        ],
        palette,
    )
    elf = sprite_from_pixels(
        [
            "   G  G     ",
            "  GGGGGG    ",
            "  GSSSSG    ",
            "  GWWWWG    ",
            "  GGGGGG    ",
            "  GWWWWG    ",
            "  GWWWWG    ",
            "   GGGG     ",
            "   G  G     ",
            "  GG  GG    ",
            "  G    G    ",
            "            ",
        ],
        palette,
    )

    chars = [
        CharacterDef(
            id="warrior",
            name="战士",
            desc="高生命，近战起手。",
            sprite=warrior,
            base_hp=120,
            move_speed=92.0,
            start_weapon="sword",
            regen=0.25,
            damage_mult=1.05,
            frames=warrior_frames,
            skeleton_frames=warrior_skeleton,
        ),
        CharacterDef(
            id="mage",
            name="法师",
            desc="低生命，远程爆发。",
            sprite=mage,
            base_hp=90,
            move_speed=90.0,
            start_weapon="sword",
            regen=0.15,
            cooldown_mult=0.92,
        ),
        CharacterDef(
            id="dragonkin",
            name="龙族",
            desc="坚韧，火焰压制。",
            sprite=dragonkin,
            base_hp=130,
            move_speed=86.0,
            start_weapon="sword",
            regen=0.22,
            damage_mult=1.08,
        ),
        CharacterDef(
            id="undead",
            name="不死族",
            desc="强回复，拖时间更强。",
            sprite=undead,
            base_hp=110,
            move_speed=88.0,
            start_weapon="sword",
            regen=0.45,
            damage_mult=0.95,
        ),
        CharacterDef(
            id="elf",
            name="精灵族",
            desc="敏捷，射速优秀。",
            sprite=elf,
            base_hp=95,
            move_speed=104.0,
            start_weapon="sword",
            regen=0.18,
            cooldown_mult=0.90,
        ),
    ]

    maps = [
        MapDef(
            id="grass",
            name="草原",
            desc="绿意盎然，史莱姆来袭。",
            base_color=(56, 120, 64),
            accent_color=(84, 180, 96),
            enemy_pool=("slime", "slime", "runner"),
        ),
        MapDef(
            id="ocean",
            name="海洋",
            desc="潮汐拍岸，鱼群缠斗。",
            base_color=(20, 70, 120),
            accent_color=(60, 140, 200),
            enemy_pool=("fish", "fish", "puffer"),
        ),
        MapDef(
            id="grave",
            name="墓地",
            desc="阴森幽暗，亡者苏醒。",
            base_color=(38, 38, 44),
            accent_color=(120, 120, 140),
            enemy_pool=("skeleton", "skeleton", "wraith"),
        ),
    ]

    def squish_frame(base: pygame.Surface, sx: float, sy: float) -> pygame.Surface:
        w, h = base.get_size()
        sw = max(1, int(round(w * sx)))
        sh = max(1, int(round(h * sy)))
        scaled = pygame.transform.scale(base, (sw, sh))
        out = pygame.Surface((w, h), pygame.SRCALPHA)
        out.fill((0, 0, 0, 0))
        out.blit(scaled, scaled.get_rect(center=(w // 2, h // 2)))
        return out

    slime_base = sprite_from_pixels(
        [
            "   KKKK   ",
            "  KGGGGK  ",
            " KGGGGGGK ",
            " KGGW WGGK",
            " KGGGGGGK ",
            "  KGGGGK  ",
            "   KGGK   ",
            "    KK    ",
            "          ",
            "          ",
        ],
        palette,
    )
    slime_frames = (
        slime_base,
        squish_frame(slime_base, 1.10, 0.92),
        squish_frame(slime_base, 0.92, 1.10),
    )
    runner = sprite_from_pixels(
        [
            "  K  K  ",
            "  KYYK  ",
            " KYYYYK ",
            " KYYWYYK",
            "  KYYYYK",
            "   KYYK ",
            "   K  K ",
            "        ",
        ],
        palette,
    )
    fish = sprite_from_pixels(
        [
            "          ",
            "   KKKK   ",
            "  KBBBBKK ",
            " KBBBBBBKK",
            "KBBBBWBBKK",
            " KBBBBBBKK",
            "  KBBBBKK ",
            "   KKKK   ",
            "          ",
            "          ",
        ],
        palette,
    )
    puffer = sprite_from_pixels(
        [
            "     K      ",
            "   KKKKK    ",
            "  KKYYYYKK  ",
            " KKYYYYYYKK ",
            "KKYYYYYYYYKK",
            "KKYYWYYWYYKK",
            "KKYYYYYYYYKK",
            " KKYYYYYYKK ",
            "  KKYYYYKK  ",
            "   KKKKK    ",
            "     K      ",
            "            ",
        ],
        palette,
    )
    skeleton = sprite_from_pixels(
        [
            "   KKKK   ",
            "  KWWWWK  ",
            " KWWKKWWK ",
            " KWWWWWWK ",
            "  KWWWWK  ",
            "   KWWK   ",
            "  KWWWWK  ",
            "  KW  WK  ",
            "   K  K   ",
            "  K    K  ",
        ],
        palette,
    )
    wraith = sprite_from_pixels(
        [
            "   KKK   ",
            "  KPPPK  ",
            " KPPPPPK ",
            " KPW WPK ",
            " KPPPPPK ",
            "  KPPPK  ",
            "  KPPPK  ",
            "  KPKPK  ",
            "   K K   ",
        ],
        palette,
    )

    enemies = {
        "slime": EnemyDef("slime", "史莱姆", (90, 210, 120), hp=18, speed=34.0, size=10, contact_damage=10, xp_value=3, frames=slime_frames),
        "runner": EnemyDef("runner", "野兔", (200, 220, 120), hp=12, speed=58.0, size=8, contact_damage=8, xp_value=3, frames=(runner,)),
        "fish": EnemyDef("fish", "小鱼", (90, 180, 230), hp=16, speed=40.0, size=10, contact_damage=10, xp_value=3, frames=(fish,)),
        "puffer": EnemyDef("puffer", "河豚", (220, 210, 110), hp=28, speed=26.0, size=12, contact_damage=14, xp_value=5, frames=(puffer,)),
        "skeleton": EnemyDef("skeleton", "骷髅", (210, 210, 220), hp=20, speed=36.0, size=10, contact_damage=12, xp_value=4, frames=(skeleton,)),
        "wraith": EnemyDef("wraith", "幽魂", (170, 120, 220), hp=14, speed=62.0, size=9, contact_damage=10, xp_value=4, frames=(wraith,)),
    }

    pistol_sprite = sprite_from_pixels(
        [
            "     DDDDDDD",
            "DDDDDLLLLLDDD",
            "DDLLHHHHHLLDD",
            "DDLLLMMMMMLDD",
            "   DOOOODDD",
            "   DOOOOD",
            "    DDDD",
        ],
        palette,
    )
    uzi_sprite = sprite_from_pixels(
        [
            "      DDDDDDDDDDD",
            "DDDDDDLLLLLLLLLDDD",
            "DDLLHHHHHHHHHLLDD",
            "DDLLLMMMMMMMMMLDD",
            "   DOOOOODDD",
            "   DOOOOOD",
            "    DDDD",
        ],
        palette,
    )
    ak47_sprite = sprite_from_pixels(
        [
            "      DDDDDDDDDDDDDDDD",
            "DDDDDDLLLLLLLLLLLLLLLDDD",
            "DDLLHHHHHHHHHHHHHHLLDD",
            "DDLLLMMMMMMMMMMMMMMLDD",
            "DDDDDOOOOODDDDDDD",
            "    OOOO",
            "    OOO",
            "    DDD",
        ],
        palette,
    )
    scar_sprite = sprite_from_pixels(
        [
            "   DDDDDDDDDDDDDDDDDDD",
            "DDDDDLLLLLLLLLLLLLLLLDDDD",
            "DDLLHHHHHHHHHHHHHHLLDD",
            "DDLLLMMMMMMMMMMMMMMLDD",
            "DDDDDOOOO OOOODDDD",
            "     OOOO",
            "     OOOO",
            "      DDD",
        ],
        palette,
    )
    sniper_sprite = sprite_from_pixels(
        [
            "        HHHH",
            "DDDDDDDLLLLLLLLLLLLLLLLLLDDDD",
            "DDLLHHHHHHHHHHHHHHHHHHLLDD",
            "DDLLLMMMMMMMMMMMMMMMMMMLDD",
            "      OOOO",
            "      OOO",
            "       DDD",
        ],
        palette,
    )
    rocket_sprite = sprite_from_pixels(
        [
            "       RRRR",
            "DDDDDDDLLLLLLLLLLLLDDDDRR",
            "DDLLHHHHHHHHHHHHLLDDRRR",
            "DDLLLMMMMMMMMMMMMLDDDD",
            "    OOOO",
            "    OOO",
            "     DDD",
        ],
        palette,
    )

    weapons = {
        "sword": WeaponDef("sword", "短剑", "近战挥砍。", "melee", (220, 220, 220), cooldown_s=0.45, damage=10),
        "wand": WeaponDef("wand", "法杖", "环绕法杖，触碰造成伤害。", "orbit", (120, 170, 240), cooldown_s=0.35, damage=7, proj_speed=240, proj_size=3),
        "bow": WeaponDef("bow", "弓", "环绕武器，触碰造成伤害。", "orbit", (220, 190, 120), cooldown_s=0.30, damage=6, proj_speed=290, proj_size=2),
        "fireball": WeaponDef("fireball", "火球", "环绕火球，触碰造成伤害。", "orbit", (240, 120, 80), cooldown_s=0.65, damage=12, proj_speed=210, proj_size=4),
        "spear": WeaponDef("spear", "骨矛", "环绕骨矛，触碰造成伤害。", "orbit", (235, 235, 255), cooldown_s=0.75, damage=9, proj_speed=320, proj_size=3, pierce=2),
        "dagger": WeaponDef("dagger", "匕首", "环绕匕首，触碰造成伤害。", "orbit", (200, 200, 200), cooldown_s=0.22, damage=4, proj_speed=330, proj_size=2),
        "pistol": WeaponDef(
            "pistol",
            "手枪",
            "稳健点射；换弹时武器旋转。",
            "gun",
            (230, 230, 200),
            cooldown_s=0.20,
            damage=7,
            proj_speed=380,
            proj_size=2,
            magazine=8,
            reload_s=1.10,
            proj_ttl_s=1.4,
            spread_rad=0.06,
            knockback=160.0,
            recoil_per_shot=0.030,
            recoil_decay=0.20,
            recoil_max=0.18,
            sprite=pistol_sprite,
        ),
        "uzi": WeaponDef(
            "uzi",
            "Uzi",
            "高射速扫射；后坐力更大。",
            "gun",
            (190, 230, 230),
            cooldown_s=0.060,
            damage=3,
            proj_speed=420,
            proj_size=1,
            magazine=28,
            reload_s=1.60,
            proj_ttl_s=1.1,
            spread_rad=0.14,
            knockback=85.0,
            recoil_per_shot=0.050,
            recoil_decay=0.18,
            recoil_max=0.36,
            sprite=uzi_sprite,
        ),
        "ak47": WeaponDef(
            "ak47",
            "AK47",
            "中距离连发，伤害与稳定性均衡。",
            "gun",
            (230, 190, 140),
            cooldown_s=0.11,
            damage=5,
            proj_speed=450,
            proj_size=2,
            magazine=30,
            reload_s=1.85,
            proj_ttl_s=1.4,
            spread_rad=0.10,
            knockback=120.0,
            recoil_per_shot=0.040,
            recoil_decay=0.20,
            recoil_max=0.30,
            sprite=ak47_sprite,
        ),
        "scarl": WeaponDef(
            "scarl",
            "SCAR-L",
            "更稳更准的步枪，单发更强。",
            "gun",
            (200, 230, 170),
            cooldown_s=0.12,
            damage=6,
            proj_speed=470,
            proj_size=2,
            magazine=20,
            reload_s=1.95,
            proj_ttl_s=1.5,
            spread_rad=0.08,
            knockback=135.0,
            recoil_per_shot=0.034,
            recoil_decay=0.22,
            recoil_max=0.26,
            sprite=scar_sprite,
        ),
        "sniper": WeaponDef(
            "sniper",
            "狙击步枪",
            "超高伤害与穿透；射速慢，换弹慢。",
            "gun",
            (230, 230, 240),
            cooldown_s=0.85,
            damage=28,
            proj_speed=700,
            proj_size=2,
            pierce=3,
            magazine=5,
            reload_s=2.60,
            proj_ttl_s=1.8,
            spread_rad=0.01,
            knockback=260.0,
            recoil_per_shot=0.018,
            recoil_decay=0.45,
            recoil_max=0.07,
            sprite=sniper_sprite,
        ),
        "rocket": WeaponDef(
            "rocket",
            "火箭筒",
            "爆炸范围伤害与强击退；弹匣小。",
            "gun",
            (240, 120, 80),
            cooldown_s=1.25,
            damage=18,
            proj_speed=220,
            proj_size=4,
            magazine=1,
            reload_s=2.35,
            proj_ttl_s=2.4,
            spread_rad=0.04,
            knockback=320.0,
            aoe_radius=28.0,
            aoe_damage_mult=1.35,
            recoil_per_shot=0.020,
            recoil_decay=0.30,
            recoil_max=0.10,
            sprite=rocket_sprite,
        ),
    }

    return chars, maps, enemies, weapons


CHARS, MAPS, ENEMY_DEFS, WEAPON_DEFS = make_defs()


class State:
    def __init__(self, app: "App") -> None:
        self.app = app

    def on_enter(self) -> None:
        pass

    def handle_event(self, event: pygame.event.Event) -> None:
        pass

    def update(self, dt: float) -> None:
        pass

    def draw(self, surface: pygame.Surface) -> None:
        pass


class App:
    def __init__(self) -> None:
        try:
            pygame.mixer.pre_init(22050, -16, 1, 256)
        except Exception:
            pass
        pygame.init()
        pygame.font.init()
        try:
            if pygame.mixer.get_init() is None:
                pygame.mixer.init(22050, -16, 1, 256)
            pygame.mixer.set_num_channels(16)
        except Exception:
            pass
        self.sfx = SFX()

        self.config = GameConfig.load()
        self.config.scale = int(clamp(self.config.scale, 1, 6))
        self.config.lamp_world_radius_tiles = int(clamp(int(self.config.lamp_world_radius_tiles), 2, 18))
        self.config.lamp_hr_radius_tiles = int(clamp(int(self.config.lamp_hr_radius_tiles), 2, 18))
        self.config.lamp_world_intensity = float(clamp(float(self.config.lamp_world_intensity), 0.0, 3.0))
        self.config.lamp_hr_intensity = float(clamp(float(self.config.lamp_hr_intensity), 0.0, 3.0))
        self.config.lamp_world_halo = float(clamp(float(self.config.lamp_world_halo), 0.0, 1.5))
        self.config.lamp_hr_halo = float(clamp(float(self.config.lamp_hr_halo), 0.0, 1.5))

        self.clock = pygame.time.Clock()
        self.render = pygame.Surface((INTERNAL_W, INTERNAL_H))
        self._scaled: pygame.Surface | None = None
        self._grid_overlay: pygame.Surface | None = None
        self._grid_overlay_key: tuple[int, int, int, int] | None = None

        pygame.display.set_caption("幸存者 Demo (pygame)")
        self._apply_display()

        font_path = pick_ui_font_path()
        self.font_s = pygame.font.Font(font_path, 12) if font_path else pygame.font.Font(None, 12)
        self.font_m = pygame.font.Font(font_path, 16) if font_path else pygame.font.Font(None, 16)
        self.font_l = pygame.font.Font(font_path, 28) if font_path else pygame.font.Font(None, 28)

        self.state: State = StartScreenState(self)
        self.state.on_enter()

    def play_sfx(self, name: str) -> None:
        self.sfx.play(name)

    def _apply_display(self) -> None:
        if self.config.fullscreen:
            # 桌面全屏：窗口最大化（保留桌面环境/任务栏/边框），不使用独占全屏
            self.screen = pygame.display.set_mode(
                (BASE_INTERNAL_W * self.config.scale, BASE_INTERNAL_H * self.config.scale),
                pygame.RESIZABLE,
            )
            self._maximize_window()
        else:
            self.screen = pygame.display.set_mode((BASE_INTERNAL_W * self.config.scale, BASE_INTERNAL_H * self.config.scale))
        self._scaled = None
        self._update_view_transform()

    def _maximize_window(self) -> None:
        if sys.platform != "win32":
            return
        try:
            import ctypes

            pygame.event.pump()
            hwnd = pygame.display.get_wm_info().get("window")
            if not hwnd:
                return
            SW_MAXIMIZE = 3
            ctypes.windll.user32.ShowWindow(int(hwnd), SW_MAXIMIZE)
        except Exception:
            return

    def _update_view_transform(self) -> None:
        global INTERNAL_W, INTERNAL_H
        sw, sh = self.screen.get_size()
        sw = max(1, int(sw))
        sh = max(1, int(sh))
        base_w = int(BASE_INTERNAL_W)
        base_h = int(BASE_INTERNAL_H)

        # Prefer integer scaling to keep pixels perfect. When the window is
        # larger than the base size, extend the internal resolution to fill
        # the extra space (more world shown, no stretching).
        fit_scale = min(sw / max(1, base_w), sh / max(1, base_h))
        if fit_scale >= 1.0:
            scale_i = int(max(1, int(fit_scale)))
            scale = float(scale_i)
            internal_w = int(max(base_w, int(sw // scale_i)))
            internal_h = int(max(base_h, int(sh // scale_i)))
        else:
            scale = float(fit_scale)
            internal_w = int(base_w)
            internal_h = int(base_h)

        if int(INTERNAL_W) != int(internal_w) or int(INTERNAL_H) != int(internal_h):
            INTERNAL_W = int(internal_w)
            INTERNAL_H = int(internal_h)
            self.render = pygame.Surface((int(INTERNAL_W), int(INTERNAL_H)))
            self._scaled = None
            self._grid_overlay = None
            self._grid_overlay_key = None

        dest_w = max(1, int(round(INTERNAL_W * scale)))
        dest_h = max(1, int(round(INTERNAL_H * scale)))
        offset_x = max(0, (sw - dest_w) // 2)
        offset_y = max(0, (sh - dest_h) // 2)
        dest_size = (dest_w, dest_h)

        self.view_scale_x = dest_w / max(1, INTERNAL_W)
        self.view_scale_y = dest_h / max(1, INTERNAL_H)
        self.view_offset = (offset_x, offset_y)
        self.view_rect = pygame.Rect(offset_x, offset_y, dest_w, dest_h)
        if self._scaled is None or self._scaled.get_size() != dest_size:
            self._scaled = pygame.Surface(dest_size)

        if not self.config.show_grid:
            self._grid_overlay = None
            self._grid_overlay_key = None
            return

        if self._grid_overlay is not None and self._grid_overlay_key == (dest_size[0], dest_size[1], int(INTERNAL_W), int(INTERNAL_H)):
            return

        overlay = pygame.Surface(dest_size, pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 0))
        w, h = dest_size
        cell_px = min(self.view_scale_x, self.view_scale_y)
        alpha = 18 if cell_px <= 2.5 else 26 if cell_px <= 4.5 else 34
        minor = (0, 0, 0, alpha)

        if w > 1 and h > 1:
            # Draw the full INTERNAL_W x INTERNAL_H grid.
            for x_cell in range(INTERNAL_W + 1):
                x = (x_cell * (w - 1)) // INTERNAL_W
                pygame.draw.line(overlay, minor, (x, 0), (x, h - 1))
            for y_cell in range(INTERNAL_H + 1):
                y = (y_cell * (h - 1)) // INTERNAL_H
                pygame.draw.line(overlay, minor, (0, y), (w - 1, y))

        # Major marker lines for quick counting (10/50/100/200/300).
        major_alpha = min(120, alpha * 4)
        major = (255, 220, 100, major_alpha)
        major_w = 1 if cell_px <= 3.5 else 2
        for x_cell in GRID_MARKS:
            if not (0 <= x_cell <= INTERNAL_W):
                continue
            x = (x_cell * (w - 1)) // INTERNAL_W
            if 0 <= x < w:
                pygame.draw.line(overlay, major, (x, 0), (x, h - 1), major_w)
        for y_cell in GRID_MARKS:
            if not (0 <= y_cell <= INTERNAL_H):
                continue
            y = (y_cell * (h - 1)) // INTERNAL_H
            if 0 <= y < h:
                pygame.draw.line(overlay, major, (0, y), (w - 1, y), major_w)

        self._grid_overlay = overlay
        self._grid_overlay_key = (dest_size[0], dest_size[1], int(INTERNAL_W), int(INTERNAL_H))

    def screen_to_internal(self, screen_pos: tuple[int, int]) -> tuple[int, int] | None:
        if not hasattr(self, "view_rect"):
            self._update_view_transform()
        if not self.view_rect.collidepoint(screen_pos):
            return None
        w = max(1, int(self.view_rect.w))
        h = max(1, int(self.view_rect.h))
        x = int((screen_pos[0] - self.view_rect.x) * INTERNAL_W / w)
        y = int((screen_pos[1] - self.view_rect.y) * INTERNAL_H / h)
        if 0 <= x < INTERNAL_W and 0 <= y < INTERNAL_H:
            return x, y
        return None

    def set_state(self, state: State) -> None:
        self.state = state
        self.state.on_enter()

    def set_config(self, *, scale: int | None = None, fullscreen: bool | None = None, show_grid: bool | None = None) -> None:
        if scale is not None:
            self.config.scale = int(clamp(scale, 1, 6))
        if fullscreen is not None:
            self.config.fullscreen = bool(fullscreen)
        if show_grid is not None:
            self.config.show_grid = bool(show_grid)
        self.config.save()
        self._apply_display()

    def blit_scaled(self) -> None:
        self._update_view_transform()
        pygame.transform.scale(self.render, self._scaled.get_size(), self._scaled)
        if self._grid_overlay is not None:
            self._scaled.blit(self._grid_overlay, (0, 0))
            self._draw_grid_markers(self._scaled)
        self.screen.fill((0, 0, 0))
        self.screen.blit(self._scaled, getattr(self, "view_offset", (0, 0)))

    def _draw_grid_markers(self, surface: pygame.Surface) -> None:
        w, h = surface.get_size()
        cell_px = float(min(getattr(self, "view_scale_x", 1.0), getattr(self, "view_scale_y", 1.0)))
        ui_scale = max(1, int(round(cell_px)))
        tick_len = max(6, int(cell_px * 4))
        col = pygame.Color(255, 220, 100)
        text_col = pygame.Color(255, 240, 180)

        marks = GRID_MARKS

        def scale_text(img: pygame.Surface) -> pygame.Surface:
            if ui_scale == 1:
                return img
            return pygame.transform.scale(img, (img.get_width() * ui_scale, img.get_height() * ui_scale))

        info = f"GRID {INTERNAL_W}x{INTERNAL_H}"
        info_img = scale_text(self.font_s.render(info, False, pygame.Color(230, 230, 240)))
        info_rect = info_img.get_rect(topright=(w - 2, 2))
        surface.blit(info_img, info_rect)

        # X-axis markers (top/bottom)
        for x_cell in marks:
            if not (0 <= x_cell <= INTERNAL_W):
                continue
            x = (x_cell * (w - 1)) // INTERNAL_W
            if not (0 <= x < w):
                continue
            pygame.draw.line(surface, col, (x, 0), (x, min(h - 1, tick_len)))
            pygame.draw.line(surface, col, (x, h - 1), (x, max(0, h - 1 - tick_len)))

            label = str(x_cell)
            img = scale_text(self.font_s.render(label, False, text_col))
            lx = x + 2
            ly = 2
            if lx + img.get_width() > w - 1:
                lx = max(0, w - 1 - img.get_width())
            surface.blit(img, (lx, ly))

        # Y-axis markers (left/right)
        for y_cell in marks:
            if not (0 <= y_cell <= INTERNAL_H):
                continue
            y = (y_cell * (h - 1)) // INTERNAL_H
            if not (0 <= y < h):
                continue
            pygame.draw.line(surface, col, (0, y), (min(w - 1, tick_len), y))
            pygame.draw.line(surface, col, (w - 1, y), (max(0, w - 1 - tick_len), y))

            label = str(y_cell)
            img = scale_text(self.font_s.render(label, False, text_col))
            lx = 2
            ly = y + 2
            if ly + img.get_height() > h - 1:
                ly = max(0, y - 2 - img.get_height())
            surface.blit(img, (lx, ly))

    def run(self) -> None:
        running = True
        while running:
            # Fixed-step timing: keeps pixel motion consistent and avoids the
            # subtle "lurch" you get from variable dt + pixel snapping.
            self.clock.tick_busy_loop(FPS)
            dt = 1.0 / float(FPS)
            self._update_view_transform()
            for event in pygame.event.get():
                if event.type == pygame.VIDEORESIZE:
                    # Keep the display surface in sync with the resized window.
                    self.screen = pygame.display.set_mode(event.size, pygame.RESIZABLE)
                    self._scaled = None
                    self._update_view_transform()
                    continue
                if event.type == pygame.QUIT:
                    running = False
                    break
                self.state.handle_event(event)

            if not running:
                break

            self.state.update(dt)
            self.state.draw(self.render)
            self.blit_scaled()
            pygame.display.flip()

        pygame.quit()


SURVIVAL_GENDER_OPTIONS = ("男", "女")
SURVIVAL_HEIGHT_OPTIONS = ("矮", "标准", "高")
SURVIVAL_FACE_OPTIONS = ("圆", "方", "尖")
SURVIVAL_EYE_OPTIONS = ("正常", "大眼", "凶", "眯眼")
SURVIVAL_HAIR_OPTIONS = ("短发", "刘海", "长发", "帽子")
SURVIVAL_NOSE_OPTIONS = ("无", "点", "线")
SURVIVAL_OUTFIT_OPTIONS = (
    "夹克蓝",
    "工装绿",
    "战术灰",
    "囚服橙",
    "医护白",
    "雨衣黄",
    "街头卫衣粉",
    "牛仔外套蓝",
    "厨师白",
    "赛车服红",
    "圣诞毛衣绿",
    "黑西装",
    "沙漠迷彩",
    "运动套装青",
    "睡衣小熊",
    "女仆装",
)


@dataclass
class SurvivalAvatar:
    gender: int = 0
    height: int = 1
    face: int = 0
    eyes: int = 0
    hair: int = 0
    nose: int = 0
    outfit: int = 0

    def clamp_all(self) -> None:
        self.gender = int(self.gender) % len(SURVIVAL_GENDER_OPTIONS)
        self.height = int(self.height) % len(SURVIVAL_HEIGHT_OPTIONS)
        self.face = int(self.face) % len(SURVIVAL_FACE_OPTIONS)
        self.eyes = int(self.eyes) % len(SURVIVAL_EYE_OPTIONS)
        self.hair = int(self.hair) % len(SURVIVAL_HAIR_OPTIONS)
        self.nose = int(self.nose) % len(SURVIVAL_NOSE_OPTIONS)
        self.outfit = int(self.outfit) % len(SURVIVAL_OUTFIT_OPTIONS)


class StartScreenState(State):
    def on_enter(self) -> None:
        self.t = 0.0

    def _start(self) -> None:
        self.app.set_state(MainMenuState(self.app))

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            if event.key in (pygame.K_ESCAPE,):
                pygame.event.post(pygame.event.Event(pygame.QUIT))
                return
            self._start()
            return

        if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
            self._start()
            return

        if event.type == pygame.JOYBUTTONDOWN:
            self._start()
            return

    def update(self, dt: float) -> None:
        self.t += dt

    def draw(self, surface: pygame.Surface) -> None:
        surface.fill((12, 12, 16))

        draw_text(
            surface,
            self.app.font_l,
            "幸存者 DEMO",
            (INTERNAL_W // 2, 92),
            pygame.Color(240, 240, 240),
            anchor="center",
        )
        draw_text(
            surface,
            self.app.font_s,
            f"像素画布 {INTERNAL_W}x{INTERNAL_H}",
            (INTERNAL_W // 2, 122),
            pygame.Color(170, 170, 180),
            anchor="center",
        )

        blink = int(self.t * 2.0) % 2 == 0
        prompt_col = pygame.Color(230, 230, 240) if blink else pygame.Color(120, 120, 135)
        draw_text(
            surface,
            self.app.font_m,
            "按任意键开始",
            (INTERNAL_W // 2, 168),
            prompt_col,
            anchor="center",
        )
        draw_text(
            surface,
            self.app.font_s,
            "Esc 退出",
            (INTERNAL_W // 2, INTERNAL_H - 18),
            pygame.Color(120, 120, 135),
            anchor="center",
        )


class MainMenuState(State):
    def on_enter(self) -> None:
        self.items = ["硬核生存(原型)", "幸存者Demo", "设置", "退出"]
        self.index = 0
        self.item_rects: list[pygame.Rect] = []

    def _activate(self) -> None:
        if self.index == 0:
            self.app.set_state(SurvivalCreateState(self.app))
        elif self.index == 1:
            self.app.set_state(CharacterSelectState(self.app))
        elif self.index == 2:
            self.app.set_state(SettingsState(self.app))
        else:
            pygame.event.post(pygame.event.Event(pygame.QUIT))

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            if event.key in (pygame.K_UP, pygame.K_w):
                self.index = (self.index - 1) % len(self.items)
            elif event.key in (pygame.K_DOWN, pygame.K_s):
                self.index = (self.index + 1) % len(self.items)
            elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                self._activate()
            return

        if event.type not in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONDOWN):
            return
        if not hasattr(event, "pos"):
            return

        internal = self.app.screen_to_internal(event.pos)
        if internal is None:
            return

        for i, rect in enumerate(self.item_rects):
            if rect.collidepoint(internal):
                self.index = i
                if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
                    self._activate()
                break

    def draw(self, surface: pygame.Surface) -> None:
        surface.fill((18, 18, 22))
        draw_text(
            surface,
            self.app.font_l,
            "幸存者 DEMO",
            (INTERNAL_W // 2, 30),
            pygame.Color(240, 240, 240),
            anchor="center",
        )
        draw_text(
            surface,
            self.app.font_s,
            "方向键/鼠标选择 | Enter/左键确认",
            (INTERNAL_W // 2, 50),
            pygame.Color(180, 180, 190),
            anchor="center",
        )

        self.item_rects = []
        y0 = 88
        for i, label in enumerate(self.items):
            rect = pygame.Rect(0, 0, 180, 22)
            rect.center = (INTERNAL_W // 2, y0 + i * 28)
            self.item_rects.append(draw_button(surface, self.app.font_m, label, rect, selected=(i == self.index)))


class SurvivalCreateState(State):
    def on_enter(self) -> None:
        self.avatar = SurvivalAvatar()
        self.avatar.clamp_all()
        self.fields: list[tuple[str, str, tuple[str, ...]]] = [
            ("性别", "gender", SURVIVAL_GENDER_OPTIONS),
            ("身高", "height", SURVIVAL_HEIGHT_OPTIONS),
            ("脸型", "face", SURVIVAL_FACE_OPTIONS),
            ("眼睛", "eyes", SURVIVAL_EYE_OPTIONS),
            ("头发", "hair", SURVIVAL_HAIR_OPTIONS),
            ("鼻子", "nose", SURVIVAL_NOSE_OPTIONS),
            ("衣服", "outfit", SURVIVAL_OUTFIT_OPTIONS),
        ]
        self.index = 0
        self._dirty = True
        self._preview_frames: dict[str, list[pygame.Surface]] | None = None
        self.row_rects: list[pygame.Rect] = []
        self.left_rects: list[pygame.Rect] = []
        self.right_rects: list[pygame.Rect] = []

    def _rebuild_preview(self) -> None:
        self.avatar.clamp_all()
        self._preview_frames = HardcoreSurvivalState.build_avatar_player_frames(self.avatar, run=False)
        self._dirty = False

    def _change_value(self, delta: int) -> None:
        label, attr, options = self.fields[int(self.index)]
        cur = int(getattr(self.avatar, attr, 0))
        nxt = (cur + int(delta)) % max(1, len(options))
        setattr(self.avatar, attr, int(nxt))
        self._dirty = True

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            key = int(event.key)
            if key in (pygame.K_ESCAPE,):
                self.app.set_state(MainMenuState(self.app))
                return
            if key in (pygame.K_UP, pygame.K_w):
                self.index = (int(self.index) - 1) % len(self.fields)
                return
            if key in (pygame.K_DOWN, pygame.K_s):
                self.index = (int(self.index) + 1) % len(self.fields)
                return
            if key in (pygame.K_LEFT, pygame.K_a):
                self._change_value(-1)
                return
            if key in (pygame.K_RIGHT, pygame.K_d):
                self._change_value(1)
                return
            if key in (pygame.K_RETURN, pygame.K_SPACE):
                self.avatar.clamp_all()
                self.app.set_state(HardcoreSurvivalState(self.app, avatar=self.avatar))
                return
            return

        if event.type not in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONDOWN):
            return
        if not hasattr(event, "pos"):
            return
        internal = self.app.screen_to_internal(event.pos)
        if internal is None:
            return

        # Arrow buttons first.
        for i, r in enumerate(self.left_rects):
            if r.collidepoint(internal):
                self.index = int(i)
                if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
                    self._change_value(-1)
                return
        for i, r in enumerate(self.right_rects):
            if r.collidepoint(internal):
                self.index = int(i)
                if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
                    self._change_value(1)
                return

        for i, r in enumerate(self.row_rects):
            if r.collidepoint(internal):
                self.index = int(i)
                return

    def update(self, dt: float) -> None:
        pass

    def draw(self, surface: pygame.Surface) -> None:
        if self._dirty or self._preview_frames is None:
            self._rebuild_preview()

        surface.fill((14, 14, 18))
        draw_text(surface, self.app.font_l, "捏脸 / 角色创建", (INTERNAL_W // 2, 26), pygame.Color(240, 240, 240), anchor="center")
        draw_text(surface, self.app.font_s, "↑↓选择  ←→调整  Enter开始  Esc返回", (INTERNAL_W // 2, 48), pygame.Color(170, 170, 180), anchor="center")

        # Options (left)
        x0 = 22
        y0 = 74
        row_w = 220
        row_h = 20
        gap = 4
        btn_w = 20
        btn_gap = 2

        self.row_rects = []
        self.left_rects = []
        self.right_rects = []
        for i, (label, attr, options) in enumerate(self.fields):
            v = int(getattr(self.avatar, attr, 0)) % max(1, len(options))
            selected = i == int(self.index)
            text = f"{label}: {options[v]}"
            r = pygame.Rect(x0, y0 + i * (row_h + gap), row_w, row_h)

            bg = (34, 34, 42) if selected else (24, 24, 30)
            border = (110, 110, 130) if selected else (70, 70, 86)
            text_col = pygame.Color(240, 240, 240) if selected else pygame.Color(200, 200, 210)
            pygame.draw.rect(surface, bg, r, border_radius=6)
            pygame.draw.rect(surface, border, r, 2, border_radius=6)

            left_btn = pygame.Rect(r.right - btn_w * 2 - btn_gap, r.y, btn_w, r.h)
            right_btn = pygame.Rect(r.right - btn_w, r.y, btn_w, r.h)
            draw_button(surface, self.app.font_m, "<", left_btn, selected=selected)
            draw_button(surface, self.app.font_m, ">", right_btn, selected=selected)
            draw_text(surface, self.app.font_m, text, (r.x + 8, r.y + 2), text_col, anchor="topleft")

            self.row_rects.append(r)
            self.left_rects.append(left_btn)
            self.right_rects.append(right_btn)

        # Preview (right)
        panel = pygame.Rect(250, 70, 208, 170)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (70, 70, 86), panel, 2, border_radius=12)
        frames = self._preview_frames or {}
        spr_down = frames.get("down", [None])[0]
        spr_right = frames.get("right", [None])[0]
        scale = 7
        if spr_down is not None:
            img = pygame.transform.scale(spr_down, (spr_down.get_width() * scale, spr_down.get_height() * scale))
            surface.blit(img, img.get_rect(center=(panel.centerx - 40, panel.centery + 10)))
        if spr_right is not None:
            img = pygame.transform.scale(spr_right, (spr_right.get_width() * scale, spr_right.get_height() * scale))
            surface.blit(img, img.get_rect(center=(panel.centerx + 48, panel.centery + 10)))
        draw_text(surface, self.app.font_s, "预览: 下 / 右", (panel.centerx, panel.top + 10), pygame.Color(200, 200, 210), anchor="center")


class HardcoreSurvivalState(State):
    TILE_SIZE = 10
    CHUNK_SIZE = 32
    ROAD_PERIOD = CHUNK_SIZE * 4
    ROAD_HALF = ROAD_PERIOD // 2
    ROAD_W = 2

    T_GRASS = 1
    T_FOREST = 2
    T_WATER = 3
    T_ROAD = 4
    T_FLOOR = 5
    T_WALL = 6
    T_DOOR = 7
    T_TABLE = 8
    T_SHELF = 9
    T_BED = 10
    T_PAVEMENT = 11
    T_PARKING = 12
    T_COURT = 13
    T_SIDEWALK = 14
    T_BRICK = 15
    T_CONCRETE = 16
    T_SAND = 17
    T_BOARDWALK = 18
    T_MARSH = 19
    T_HIGHWAY = 20
    T_STAIRS_UP = 21
    T_STAIRS_DOWN = 22
    T_ELEVATOR = 23
    T_BARRICADE = 24
    # Furniture / home markers (world-map interiors)
    T_DOOR_HOME = 25
    T_SOFA = 26
    T_FRIDGE = 27
    T_TV = 28
    T_CHAIR = 29
    # Locked doors (require keys)
    T_DOOR_LOCKED = 30
    T_DOOR_HOME_LOCKED = 31
    # Extra furniture
    T_PC = 32
    T_LAMP = 33
    T_SWITCH = 34
    T_TOILET = 35
    T_CABINET = 36
    T_SINK = 37
    T_DOOR_BROKEN = 38
    T_GAS_PUMP = 39
    T_STEER = 40

    # World furniture durability/drops (tables/chairs/etc). HP is per connected block.
    _WORLD_FURNITURE_HP_DEFAULTS: dict[int, int] = {
        T_TABLE: 26,
        T_CHAIR: 18,
        T_SHELF: 24,
        T_CABINET: 24,
        T_BED: 34,
        T_SOFA: 32,
        T_FRIDGE: 28,
        T_TV: 20,
        T_PC: 22,
        T_LAMP: 10,
        T_SWITCH: 10,
        T_TOILET: 24,
        T_SINK: 20,
    }
    _WORLD_FURNITURE_WOOD_TILES: set[int] = {
        T_TABLE,
        T_CHAIR,
        T_SHELF,
        T_CABINET,
        T_BED,
        T_SOFA,
    }
    _WORLD_FURNITURE_METAL_TILES: set[int] = {
        T_FRIDGE,
        T_TV,
        T_PC,
        T_LAMP,
        T_SWITCH,
        T_TOILET,
        T_SINK,
    }

    DAY_LENGTH_S = 8 * 60.0
    SEASON_LENGTH_DAYS = 7
    SEASONS = ("春", "夏", "秋", "冬")
    START_DAY_FRACTION = 0.30  # ~07:12

    WEATHER_TRANSITION_S = 18.0
    WEATHER_KINDS = ("clear", "cloudy", "rain", "storm", "snow")
    WEATHER_NAMES: dict[str, str] = {
        "clear": "晴",
        "cloudy": "阴",
        "rain": "雨",
        "storm": "暴雨",
        "snow": "雪",
    }

    def __init__(self, app: "App", *, avatar: SurvivalAvatar | None = None) -> None:
        super().__init__(app)
        self.avatar = avatar if avatar is not None else SurvivalAvatar()
        self.avatar.clamp_all()

    @dataclass(frozen=True)
    class _TileDef:
        name: str
        color: tuple[int, int, int]
        solid: bool
        slow: float = 1.0

    _TILES: dict[int, _TileDef] = {
        T_GRASS: _TileDef("grass", (32, 120, 56), solid=False),
        T_FOREST: _TileDef("forest", (22, 86, 42), solid=False, slow=0.82),
        T_WATER: _TileDef("water", (22, 56, 98), solid=True),
        T_ROAD: _TileDef("road", (72, 72, 74), solid=False),
        T_HIGHWAY: _TileDef("highway", (58, 58, 62), solid=False),
        T_FLOOR: _TileDef("floor", (58, 56, 52), solid=False),
        T_WALL: _TileDef("wall", (28, 28, 30), solid=True),
        T_DOOR: _TileDef("door", (120, 96, 52), solid=False),
        T_TABLE: _TileDef("table", (78, 62, 44), solid=True),
        T_SHELF: _TileDef("shelf", (50, 50, 54), solid=True),
        T_BED: _TileDef("bed", (84, 84, 110), solid=True),
        T_PAVEMENT: _TileDef("pavement", (92, 92, 96), solid=False),
        T_PARKING: _TileDef("parking", (66, 66, 78), solid=False),
        T_COURT: _TileDef("court", (116, 86, 66), solid=False),
        T_SIDEWALK: _TileDef("sidewalk", (156, 132, 86), solid=False),
        T_BRICK: _TileDef("brick", (140, 94, 80), solid=False),
        T_CONCRETE: _TileDef("concrete", (112, 112, 118), solid=False),
        T_SAND: _TileDef("sand", (192, 176, 112), solid=False, slow=0.92),
        T_BOARDWALK: _TileDef("boardwalk", (156, 116, 68), solid=False),
        T_MARSH: _TileDef("marsh", (56, 92, 62), solid=False, slow=0.78),
        T_STAIRS_UP: _TileDef("stairs_up", (84, 76, 62), solid=False),   
        T_STAIRS_DOWN: _TileDef("stairs_down", (84, 76, 62), solid=False),
        T_ELEVATOR: _TileDef("elevator", (82, 82, 96), solid=False),     
        T_BARRICADE: _TileDef("barricade", (96, 78, 52), solid=True),
        T_DOOR_HOME: _TileDef("door_home", (56, 156, 96), solid=False),
        T_SOFA: _TileDef("sofa", (94, 78, 112), solid=True),
        T_FRIDGE: _TileDef("fridge", (182, 186, 194), solid=True),
        T_TV: _TileDef("tv", (34, 34, 40), solid=True),
        T_CHAIR: _TileDef("chair", (92, 72, 54), solid=True),
        T_DOOR_LOCKED: _TileDef("door_locked", (120, 96, 52), solid=True),
        T_DOOR_HOME_LOCKED: _TileDef("door_home_locked", (56, 156, 96), solid=True),
        T_PC: _TileDef("pc", (78, 68, 56), solid=True),
        T_LAMP: _TileDef("lamp", (196, 186, 120), solid=False),
        T_SWITCH: _TileDef("switch", (170, 170, 176), solid=False),
        T_TOILET: _TileDef("toilet", (240, 240, 245), solid=True),
        T_CABINET: _TileDef("cabinet", (92, 72, 54), solid=True),
        T_SINK: _TileDef("sink", (184, 188, 196), solid=True),
        T_DOOR_BROKEN: _TileDef("door_broken", (120, 96, 52), solid=False),
        T_GAS_PUMP: _TileDef("gas_pump", (200, 70, 70), solid=True),
        # Steering wheel marker (used in RV world-interior). Keep non-solid so the player
        # won't get shoved out of the RV when walking to the very front edge.
        T_STEER: _TileDef("steer", (90, 90, 96), solid=False),
    }

    _PLAYER_PAL = {
        "H": (26, 26, 30),  # hair
        "S": (220, 190, 160),  # skin
        "C": (72, 92, 160),  # coat
        "P": (52, 52, 62),  # pants
        "B": (22, 22, 26),  # boots
        "E": (6, 6, 8),  # eye
    }

    # Side-walk gait tables (6 steps). "Near" is the leg closer to the camera
    # when facing right; "far" is the back leg. Offsets are in pixels from the
    # hip X, lifts drive knee bend (and a small 1px foot raise).
    #
    # Default gait is WALK; sprint (Shift) switches to RUN.
    _SIDE_WALK_WALK_NEAR_OFFSETS = (1, 1, 0, -1, 0, 2)
    _SIDE_WALK_WALK_FAR_OFFSETS = (-1, 0, 2, 1, 1, 0)
    _SIDE_WALK_WALK_NEAR_LIFTS = (0, 0, 0, 0, 1, 2)
    _SIDE_WALK_WALK_FAR_LIFTS = (0, 1, 2, 0, 0, 0)

    _SIDE_WALK_RUN_NEAR_OFFSETS = (2, 1, -1, -1, 1, 3)
    _SIDE_WALK_RUN_FAR_OFFSETS = (-2, 1, 3, 2, 1, -1)
    _SIDE_WALK_RUN_NEAR_LIFTS = (0, 0, 0, 1, 3, 4)
    _SIDE_WALK_RUN_FAR_LIFTS = (1, 3, 4, 0, 0, 0)

    @classmethod
    def _side_walk_tables(
        cls,
        *,
        run: bool,
    ) -> tuple[tuple[int, ...], tuple[int, ...], tuple[int, ...], tuple[int, ...]]:
        if bool(run):
            return (
                cls._SIDE_WALK_RUN_NEAR_OFFSETS,
                cls._SIDE_WALK_RUN_FAR_OFFSETS,
                cls._SIDE_WALK_RUN_NEAR_LIFTS,
                cls._SIDE_WALK_RUN_FAR_LIFTS,
            )
        return (
            cls._SIDE_WALK_WALK_NEAR_OFFSETS,
            cls._SIDE_WALK_WALK_FAR_OFFSETS,
            cls._SIDE_WALK_WALK_NEAR_LIFTS,
            cls._SIDE_WALK_WALK_FAR_LIFTS,
        )

    _SURVIVOR_SKELETON_BONES: tuple[tuple[str, str], ...] = (
        ("head", "chest"),
        ("chest", "hip"),
        ("hip", "l_knee"),
        ("l_knee", "l_foot"),
        ("hip", "r_knee"),
        ("r_knee", "r_foot"),
        ("chest", "l_hand"),
        ("chest", "r_hand"),
    )

    @staticmethod
    def _solve_two_bone_knee(
        hip_x: float,
        hip_y: float,
        foot_x: float,
        foot_y: float,
        upper_len: float,
        lower_len: float,
        *,
        prefer_forward: bool = True,
    ) -> tuple[int, int]:
        dx = float(foot_x) - float(hip_x)
        dy = float(foot_y) - float(hip_y)
        d = float(math.hypot(dx, dy))
        if d <= 1e-4:
            return int(round(float(hip_x))), int(round(float(hip_y) + float(upper_len)))

        max_d = float(upper_len + lower_len) - 1e-3
        min_d = float(abs(float(upper_len) - float(lower_len))) + 1e-3
        d = float(clamp(float(d), float(min_d), float(max_d)))

        ux = dx / d
        uy = dy / d

        a = (float(upper_len) * float(upper_len) - float(lower_len) * float(lower_len) + d * d) / (2.0 * d)
        h2 = float(upper_len) * float(upper_len) - a * a
        h = math.sqrt(max(0.0, float(h2)))

        px = float(hip_x) + a * ux
        py = float(hip_y) + a * uy

        vx = -uy
        vy = ux
        k1x = px + h * vx
        k1y = py + h * vy
        k2x = px - h * vx
        k2y = py - h * vy

        if prefer_forward:
            kx, ky = (k1x, k1y) if k1x >= k2x else (k2x, k2y)
        else:
            kx, ky = (k1x, k1y) if k1x <= k2x else (k2x, k2y)
        return int(round(float(kx))), int(round(float(ky)))

    @classmethod
    def _survivor_skeleton_nodes(
        cls,
        direction: str,
        step: int,
        *,
        idle: bool,
        height_delta: int = 0,
        run: bool = False,
    ) -> dict[str, tuple[int, int]]:
        direction = str(direction)
        w, h = 12, 16

        step = int(step) % 6
        if idle:
            step = 2

        height_delta = int(height_delta)
        nodes: dict[str, tuple[int, int]] = {}

        if direction in ("right", "left"):
            leg_top = int(clamp(10 + height_delta, 8, 12))
            hip_y = int(leg_top)
            far_hip_x = 5
            near_hip_x = 6

            if idle:
                step_idx = 0
                near_off = 0
                far_off = 0
                near_lift = 0
                far_lift = 0
            else:
                step_idx = int(step) % 6
                near_offsets, far_offsets, near_lifts, far_lifts = cls._side_walk_tables(run=bool(run))
                near_off = int(near_offsets[step_idx])
                far_off = int(far_offsets[step_idx])
                near_lift = int(near_lifts[step_idx])
                far_lift = int(far_lifts[step_idx])

            def leg_joints(hip_x: int, foot_x: int, lift: int) -> tuple[tuple[int, int], tuple[int, int], tuple[int, int]]:
                hip_x = int(clamp(int(hip_x), 0, w - 1))
                foot_x = int(clamp(int(foot_x), 0, w - 1))
                lift_px = int(clamp(int(min(int(lift), 4)), 0, 4))

                raise_px = 1 if int(lift_px) > 0 else 0
                foot_y = int(max(int(hip_y) + 1, 15 - int(raise_px)))
                foot_y = int(clamp(int(foot_y), 0, 15))

                mid_x = float(hip_x + foot_x) * 0.5
                mid_y = float(hip_y + foot_y) * 0.5

                if lift_px <= 0:
                    knee_x = int(round((float(hip_x) + float(foot_x)) * 0.5))
                    knee_y = int(round((float(hip_y) + float(foot_y)) * 0.5))
                else:
                    dist = float(15 - int(hip_y))
                    total = float(max(4.0, float(dist) + 1.0))
                    upper = float(total * 0.5)
                    lower = float(total * 0.5)
                    ik_x, ik_y = cls._solve_two_bone_knee(
                        float(hip_x),
                        float(hip_y),
                        float(foot_x),
                        float(foot_y),
                        float(upper),
                        float(lower),
                        prefer_forward=True,
                    )
                    # Blend toward IK as the lift increases to avoid a too-sharp knee on small lifts.
                    t = float(clamp((float(lift_px) / 4.0) ** 0.85, 0.0, 1.0))
                    knee_x = int(round(mid_x + (float(ik_x) - mid_x) * t))
                    knee_y = int(round(mid_y + (float(ik_y) - mid_y) * t))

                kmin = min(int(hip_x), int(foot_x)) - 1
                kmax = max(int(hip_x), int(foot_x)) + 2
                knee_x = int(clamp(int(knee_x), int(kmin), int(kmax)))
                knee_x = int(clamp(int(knee_x), 0, w - 1))
                knee_y = int(clamp(int(knee_y), int(hip_y), int(foot_y)))
                return (int(hip_x), int(hip_y)), (int(knee_x), int(knee_y)), (int(foot_x), int(foot_y))

            far_foot_x = int(far_hip_x + int(far_off))
            near_foot_x = int(near_hip_x + int(near_off))

            l_hip, l_knee, l_foot = leg_joints(int(far_hip_x), int(far_foot_x), int(far_lift))
            r_hip, r_knee, r_foot = leg_joints(int(near_hip_x), int(near_foot_x), int(near_lift))

            nodes.update(
                {
                    "head": (7, 3),
                    "chest": (6, 8),
                    "hip": (int(round((float(far_hip_x) + float(near_hip_x)) * 0.5)), int(hip_y)),
                    "l_hip": l_hip,
                    "l_knee": l_knee,
                    "l_foot": l_foot,
                    "r_hip": r_hip,
                    "r_knee": r_knee,
                    "r_foot": r_foot,
                    "l_hand": (4, 9),
                    "r_hand": (8, 9),
                }
            )

            if direction == "left":
                nodes = {name: (int(w - 1 - x), int(y)) for name, (x, y) in nodes.items()}
            return nodes

        if direction in ("down", "up"):
            leg_top = int(clamp((11 if direction == "up" else 10) + height_delta, 8, 12))
            if direction == "down":
                left_hip = 4
                right_hip = 7
                head = (6, 3)
                l_hand = (2, 9)
                r_hand = (9, 9)
            else:
                left_hip = 5
                right_hip = 6
                head = (6, 2)
                l_hand = (2, 8)
                r_hand = (9, 8)

            left_lift = 2 if step == 1 else 1 if step == 0 else 0
            right_lift = 2 if step == 4 else 1 if step == 3 else 0

            left_x = int(left_hip - (1 if left_lift else 0))
            right_x = int(right_hip + (1 if right_lift else 0))
            left_knee_y = int(13 - left_lift)
            right_knee_y = int(13 - right_lift)
            left_boot_y = int(15 - left_lift)
            right_boot_y = int(15 - right_lift)

            nodes.update(
                {
                    "head": (int(head[0]), int(head[1])),
                    "chest": (6, 8),
                    "hip": (6, int(leg_top)),
                    "l_hip": (int(left_hip), int(leg_top)),
                    "r_hip": (int(right_hip), int(leg_top)),
                    "l_knee": (int(left_x), int(left_knee_y)),
                    "r_knee": (int(right_x), int(right_knee_y)),
                    "l_foot": (int(left_x), int(left_boot_y)),
                    "r_foot": (int(right_x), int(right_boot_y)),
                    "l_hand": (int(l_hand[0]), int(l_hand[1])),
                    "r_hand": (int(r_hand[0]), int(r_hand[1])),
                }
            )
            return nodes

        return {}

    def _make_player_sprite(
        direction: str,
        step: int,
        *,
        idle: bool,
        run: bool = False,
        pal=_PLAYER_PAL,
    ) -> pygame.Surface:
        w, h = 12, 16
        surf = pygame.Surface((w, h), pygame.SRCALPHA)

        hair = pal["H"]
        skin = pal["S"]
        coat = pal["C"]
        pants = pal["P"]
        boots = pal["B"]
        eye = pal["E"]
        coat_dark = (56, 72, 140)
        pants_dark = (40, 40, 50)

        step = int(step) % 6
        if idle:
            step = 2

        def draw_line(
            col: tuple[int, int, int],
            x0: int,
            y0: int,
            x1: int,
            y1: int,
        ) -> None:
            x0 = int(clamp(int(x0), 0, w - 1))
            x1 = int(clamp(int(x1), 0, w - 1))
            y0 = int(clamp(int(y0), 0, h - 1))
            y1 = int(clamp(int(y1), 0, h - 1))

            dx = abs(x1 - x0)
            dy = -abs(y1 - y0)
            sx = 1 if x0 < x1 else -1
            sy = 1 if y0 < y1 else -1
            err = dx + dy
            x, y = x0, y0
            while True:
                surf.fill(col, pygame.Rect(int(x), int(y), 1, 1))
                if x == x1 and y == y1:
                    break
                e2 = 2 * err
                if e2 >= dy:
                    err += dy
                    x += sx
                if e2 <= dx:
                    err += dx
                    y += sy

        def draw_leg(
            hip_x: int,
            knee_x: int,
            boot_x: int,
            boot_y: int,
            *,
            leg_top: int,
            knee_y: int,
            leg_col: tuple[int, int, int],
        ) -> None:
            hip_x = int(clamp(int(hip_x), 0, w - 1))
            knee_x = int(clamp(int(knee_x), 0, w - 1))
            boot_x = int(clamp(int(boot_x), 0, w - 1))
            leg_top = int(clamp(int(leg_top), 0, h - 1))
            knee_y = int(clamp(int(knee_y), 0, h - 1))
            boot_y = int(clamp(int(boot_y), 0, h - 1))

            if knee_y < leg_top:
                knee_y = leg_top
            if boot_y < knee_y:
                boot_y = knee_y

            draw_line(leg_col, int(hip_x), int(leg_top), int(knee_x), int(knee_y))
            draw_line(leg_col, int(knee_x), int(knee_y), int(boot_x), int(boot_y))
            surf.fill(boots, pygame.Rect(boot_x, boot_y, 1, 1))

        def draw_straight_leg(
            hip_x: int,
            foot_x: int,
            foot_y: int,
            *,
            leg_top: int,
            leg_col: tuple[int, int, int],
        ) -> None:
            hip_x = int(clamp(int(hip_x), 0, w - 1))
            foot_x = int(clamp(int(foot_x), 0, w - 1))
            leg_top = int(clamp(int(leg_top), 0, h - 1))
            foot_y = int(clamp(int(foot_y), 0, h - 1))

            draw_line(leg_col, int(hip_x), int(leg_top), int(foot_x), int(foot_y))
            surf.fill(boots, pygame.Rect(int(foot_x), int(foot_y), 1, 1))

        if direction in ("down", "up"):
            leg_top = 11 if direction == "up" else 10
            if direction == "down":
                left_hip = 4
                right_hip = 7
            else:
                left_hip = 5
                right_hip = 6

            # 6-step walk: left swings early, right swings late.
            left_lift = 2 if step == 1 else 1 if step == 0 else 0
            right_lift = 2 if step == 4 else 1 if step == 3 else 0

            left_x = left_hip - (1 if left_lift else 0)
            right_x = right_hip + (1 if right_lift else 0)
            left_knee_y = 13 - left_lift
            right_knee_y = 13 - right_lift
            left_boot_y = 15 - left_lift
            right_boot_y = 15 - right_lift

            # Legs first (behind torso) so the player doesn't look "spidery".
            draw_leg(
                int(right_hip),
                int(right_x),
                int(right_x),
                int(right_boot_y),
                leg_top=int(leg_top),
                knee_y=int(right_knee_y),
                leg_col=pants_dark,
            )
            draw_leg(
                int(left_hip),
                int(left_x),
                int(left_x),
                int(left_boot_y),
                leg_top=int(leg_top),
                knee_y=int(left_knee_y),
                leg_col=pants,
            )

            if direction == "down":
                # Torso + arms.
                surf.fill(coat, pygame.Rect(3, 5, 6, 6))
                surf.fill(coat_dark, pygame.Rect(3, 10, 6, 1))
                surf.fill(coat, pygame.Rect(2, 6, 1, 3))
                surf.fill(coat, pygame.Rect(9, 6, 1, 3))
                surf.fill(skin, pygame.Rect(2, 9, 1, 1))
                surf.fill(skin, pygame.Rect(9, 9, 1, 1))

                # Head.
                surf.fill(hair, pygame.Rect(4, 0, 4, 2))
                surf.fill(skin, pygame.Rect(4, 2, 4, 3))
                surf.set_at((5, 3), eye)
                surf.set_at((7, 3), eye)
            else:
                # Torso + arms.
                surf.fill(coat, pygame.Rect(3, 4, 6, 7))
                surf.fill(coat_dark, pygame.Rect(4, 6, 4, 4))
                surf.fill(coat, pygame.Rect(2, 5, 1, 4))
                surf.fill(coat, pygame.Rect(9, 5, 1, 4))

                # Back head.
                surf.fill(hair, pygame.Rect(4, 0, 4, 3))
                surf.fill(skin, pygame.Rect(5, 3, 2, 1))

            return surf

        if direction == "right":
            leg_top = 10
            far_hip = 5
            near_hip = 6

            # Side-walk: alternating stride (one leg swings while the other supports).
            # 4-frame side gait (迈腿→向前→交叉→换腿向前):
            # - Swing leg bends (knee) on the first frame of the step.
            # - Then it extends straight while still forward.
            # - Swap draw order when legs cross so it doesn't look like only one
            #   leg is moving.
            if idle:
                step = 0
                near_offsets = (0, 0, 0, 0, 0, 0)
                far_offsets = (0, 0, 0, 0, 0, 0)
                near_lifts = (0, 0, 0, 0, 0, 0)
                far_lifts = (0, 0, 0, 0, 0, 0)
            else:
                step = int(step) % 6
                if bool(run):
                    near_offsets = (2, 1, -1, -1, 1, 3)
                    far_offsets = (-2, 1, 3, 2, 1, -1)
                    near_lifts = (0, 0, 0, 1, 3, 4)
                    far_lifts = (1, 3, 4, 0, 0, 0)
                else:
                    near_offsets = (1, 1, 0, -1, 0, 2)
                    far_offsets = (-1, 0, 2, 1, 1, 0)
                    near_lifts = (0, 0, 0, 0, 1, 2)
                    far_lifts = (0, 1, 2, 0, 0, 0)

            near_foot_x = int(near_hip + int(near_offsets[int(step)]))
            far_foot_x = int(far_hip + int(far_offsets[int(step)]))
            near_lift = int(near_lifts[int(step)])
            far_lift = int(far_lifts[int(step)])

            def solve_knee_ik(
                hip_x: float,
                hip_y: float,
                foot_x: float,
                foot_y: float,
                upper_len: float,
                lower_len: float,
            ) -> tuple[int, int]:
                dx = float(foot_x) - float(hip_x)
                dy = float(foot_y) - float(hip_y)
                d = float(math.hypot(dx, dy))
                if d <= 1e-4:
                    return int(round(float(hip_x))), int(round(float(hip_y) + float(upper_len)))

                max_d = float(upper_len + lower_len) - 1e-3
                min_d = float(abs(float(upper_len) - float(lower_len))) + 1e-3
                d = float(clamp(float(d), float(min_d), float(max_d)))

                ux = dx / d
                uy = dy / d

                a = (float(upper_len) * float(upper_len) - float(lower_len) * float(lower_len) + d * d) / (2.0 * d)
                h2 = float(upper_len) * float(upper_len) - a * a
                h = math.sqrt(max(0.0, float(h2)))

                px = float(hip_x) + a * ux
                py = float(hip_y) + a * uy

                # Prefer the knee to face forward (right) for the unflipped sprite.
                vx = -uy
                vy = ux
                k1x = px + h * vx
                k1y = py + h * vy
                k2x = px - h * vx
                k2y = py - h * vy
                if k1x >= k2x:
                    kx, ky = k1x, k1y
                else:
                    kx, ky = k2x, k2y
                return int(round(float(kx))), int(round(float(ky)))

            def draw_pose(hip_x: int, foot_x: int, lift: int, *, col: tuple[int, int, int]) -> None:
                hip_x = int(hip_x)
                foot_x = int(clamp(int(foot_x), 0, w - 1))
                lift_px = int(clamp(int(min(int(lift), 4)), 0, 4))

                hip_y = int(leg_top)
                raise_px = 1 if int(lift_px) > 0 else 0
                foot_y = int(max(int(leg_top) + 1, 15 - int(raise_px)))
                foot_y = int(clamp(int(foot_y), 0, 15))

                if lift_px <= 0:
                    draw_straight_leg(int(hip_x), int(foot_x), int(foot_y), leg_top=int(hip_y), leg_col=col)
                    return

                else:
                    dist = float(15 - int(hip_y))
                    total = float(max(4.0, float(dist) + 1.0))
                    upper = float(total * 0.5)
                    lower = float(total * 0.5)
                    knee_x, knee_y = solve_knee_ik(float(hip_x), float(hip_y), float(foot_x), float(foot_y), float(upper), float(lower))

                    mid_x = float(hip_x + foot_x) * 0.5
                    mid_y = float(hip_y + foot_y) * 0.5
                    t = float(clamp((float(lift_px) / 4.0) ** 0.85, 0.0, 1.0))
                    knee_x = int(round(mid_x + (float(knee_x) - mid_x) * t))
                    knee_y = int(round(mid_y + (float(knee_y) - mid_y) * t))
                    kmin = min(int(hip_x), int(foot_x)) - 1
                    kmax = max(int(hip_x), int(foot_x)) + 2
                    knee_x = int(clamp(int(knee_x), int(kmin), int(kmax)))

                knee_x = int(clamp(int(knee_x), 0, w - 1))
                knee_y = int(clamp(int(knee_y), int(hip_y), int(foot_y)))

                draw_leg(
                    int(hip_x),
                    int(knee_x),
                    int(foot_x),
                    int(foot_y),
                    leg_top=int(hip_y),
                    knee_y=int(knee_y),
                    leg_col=col,
                )

            # Depth + shading: the front leg uses the lighter pants color so
            # the crossing reads clearly (otherwise it can look like only the
            # near leg is moving).
            if int(near_foot_x) >= int(far_foot_x):
                # Near leg is in front.
                draw_pose(int(far_hip), int(far_foot_x), int(far_lift), col=pants_dark)
                draw_pose(int(near_hip), int(near_foot_x), int(near_lift), col=pants)
            else:
                # Far leg crosses in front.
                draw_pose(int(near_hip), int(near_foot_x), int(near_lift), col=pants_dark)
                draw_pose(int(far_hip), int(far_foot_x), int(far_lift), col=pants)

            # Torso + near arm.
            surf.fill(coat, pygame.Rect(4, 5, 5, 6))
            surf.fill(coat_dark, pygame.Rect(4, 10, 5, 1))
            surf.fill(coat, pygame.Rect(8, 6, 1, 3))
            surf.fill(skin, pygame.Rect(8, 9, 1, 1))

            # Head.
            surf.fill(hair, pygame.Rect(4, 0, 4, 2))
            surf.fill(skin, pygame.Rect(6, 2, 3, 3))
            surf.set_at((8, 3), eye)

            return surf

        return surf

    _P_DOWN_FRAMES: list[pygame.Surface] = []
    _P_DOWN_FRAMES.append(_make_player_sprite("down", 0, idle=True))
    for _i in range(6):
        _P_DOWN_FRAMES.append(_make_player_sprite("down", _i, idle=False))

    _P_UP_FRAMES: list[pygame.Surface] = []
    _P_UP_FRAMES.append(_make_player_sprite("up", 0, idle=True))
    for _i in range(6):
        _P_UP_FRAMES.append(_make_player_sprite("up", _i, idle=False))

    _P_RIGHT_FRAMES: list[pygame.Surface] = []
    _P_RIGHT_FRAMES.append(_make_player_sprite("right", 0, idle=True))
    for _i in range(6):
        _P_RIGHT_FRAMES.append(_make_player_sprite("right", _i, idle=False))    

    _PLAYER_FRAMES: dict[str, list[pygame.Surface]] = {
        "down": _P_DOWN_FRAMES,
        "up": _P_UP_FRAMES,
        "right": _P_RIGHT_FRAMES,
        "left": [],
    }
    for _s in _P_RIGHT_FRAMES:
        _PLAYER_FRAMES["left"].append(pygame.transform.flip(_s, True, False))

    @classmethod
    def _avatar_colors(cls, avatar: SurvivalAvatar) -> dict[str, tuple[int, int, int]]:
        avatar.clamp_all()
        gender = int(avatar.gender)
        outfit = int(avatar.outfit)

        hair = (26, 26, 30) if gender == 0 else (34, 28, 30)
        skin = (220, 190, 160) if gender == 0 else (230, 198, 168)
        eye = (6, 6, 8)
        boots = (22, 22, 26)

        pals: list[tuple[tuple[int, int, int], tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]]] = [
            ((72, 92, 160), (56, 72, 140), (52, 52, 62), (40, 40, 50)),  # 夹克蓝
            ((70, 120, 90), (48, 86, 64), (66, 54, 40), (46, 38, 28)),  # 工装绿
            ((92, 92, 104), (70, 70, 82), (44, 44, 56), (32, 32, 40)),  # 战术灰
            ((210, 130, 60), (170, 90, 44), (70, 46, 34), (50, 32, 24)),  # 囚服橙
            ((220, 220, 230), (180, 180, 190), (92, 92, 104), (70, 70, 82)),  # 医护白
            ((224, 210, 112), (190, 176, 84), (70, 70, 82), (52, 52, 62)),  # 雨衣黄
            ((210, 120, 160), (168, 92, 130), (44, 44, 56), (32, 32, 40)),  # 卫衣粉
            ((90, 140, 210), (70, 110, 170), (60, 52, 46), (44, 38, 34)),  # 牛仔外套
            ((240, 240, 245), (200, 200, 210), (92, 92, 104), (70, 70, 82)),  # 厨师白
            ((210, 70, 80), (160, 50, 60), (22, 22, 26), (12, 12, 16)),  # 赛车服红
            ((120, 190, 140), (92, 150, 110), (70, 46, 34), (50, 32, 24)),  # 圣诞毛衣绿
            ((28, 28, 34), (18, 18, 22), (28, 28, 34), (18, 18, 22)),  # 黑西装
            ((160, 140, 90), (120, 110, 70), (90, 80, 60), (70, 62, 44)),  # 沙漠迷彩
            ((80, 160, 210), (60, 120, 170), (40, 40, 50), (28, 28, 34)),  # 运动套装青
            ((200, 190, 230), (160, 150, 190), (92, 92, 104), (70, 70, 82)),  # 睡衣小熊
            ((220, 220, 240), (180, 180, 200), (200, 140, 170), (160, 100, 130)),  # 女仆装
        ]
        coat, coat_dark, pants, pants_dark = pals[int(outfit) % len(pals)]

        return {
            "hair": hair,
            "skin": skin,
            "eye": eye,
            "coat": coat,
            "coat_dark": coat_dark,
            "pants": pants,
            "pants_dark": pants_dark,
            "boots": boots,
        }

    @classmethod
    def _make_avatar_player_sprite(
        cls,
        direction: str,
        step: int,
        *,
        idle: bool,
        avatar: SurvivalAvatar,
        run: bool = False,
    ) -> pygame.Surface:
        avatar.clamp_all()
        w, h = 12, 16
        surf = pygame.Surface((w, h), pygame.SRCALPHA)

        cols = cls._avatar_colors(avatar)
        hair = cols["hair"]
        skin = cols["skin"]
        coat = cols["coat"]
        coat_dark = cols["coat_dark"]
        pants = cols["pants"]
        pants_dark = cols["pants_dark"]
        boots = cols["boots"]
        eye = cols["eye"]
        outline = (10, 10, 12)
        skin_shade = (max(0, skin[0] - 45), max(0, skin[1] - 45), max(0, skin[2] - 45))

        step = int(step) % 6
        if idle:
            step = 2

        height_delta = 1 if int(avatar.height) == 0 else -1 if int(avatar.height) == 2 else 0
        face_kind = int(avatar.face)
        eye_kind = int(avatar.eyes)
        hair_kind = int(avatar.hair)
        nose_kind = int(avatar.nose)
        outfit_kind = int(avatar.outfit)

        def draw_hair_down() -> None:
            if hair_kind == 3:  # hat
                hat = coat_dark
                pygame.draw.rect(surf, hat, pygame.Rect(3, 0, 6, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 0, 6, 2), 1, border_radius=1)
                pygame.draw.rect(surf, hat, pygame.Rect(3, 2, 5, 1), border_radius=1)
                return

            surf.fill(hair, pygame.Rect(4, 0, 4, 2))
            if hair_kind == 1:  # bangs
                surf.set_at((5, 2), hair)
                surf.set_at((6, 2), hair)
            elif hair_kind == 2:  # long
                for (x, y) in ((3, 2), (8, 2), (3, 3), (8, 3), (3, 4), (8, 4)):
                    surf.set_at((x, y), hair)

        def draw_face_down() -> None:
            if face_kind == 0:  # round
                surf.fill(skin, pygame.Rect(4, 2, 4, 3))
            elif face_kind == 1:  # square
                surf.fill(skin, pygame.Rect(4, 2, 4, 3))
                surf.fill(skin, pygame.Rect(3, 3, 1, 2))
                surf.fill(skin, pygame.Rect(8, 3, 1, 2))
            else:  # sharp
                surf.fill(skin, pygame.Rect(4, 2, 4, 2))
                surf.fill(skin, pygame.Rect(5, 4, 2, 1))

            if eye_kind == 0:  # normal
                surf.set_at((5, 3), eye)
                surf.set_at((7, 3), eye)
            elif eye_kind == 1:  # big
                for px in (5, 7):
                    surf.set_at((px, 3), eye)
                    surf.set_at((px, 4), eye)
            elif eye_kind == 2:  # angry
                surf.set_at((5, 3), eye)
                surf.set_at((7, 3), eye)
                surf.set_at((5, 2), outline)
                surf.set_at((7, 2), outline)
            else:  # sleepy
                surf.set_at((5, 3), outline)
                surf.set_at((7, 3), outline)

            if nose_kind == 1:  # dot
                surf.set_at((5, 4), skin_shade)
            elif nose_kind == 2:  # line
                surf.set_at((5, 4), skin_shade)
                surf.set_at((6, 4), skin_shade)

        def draw_hair_right() -> None:
            if hair_kind == 3:  # hat
                hat = coat_dark
                pygame.draw.rect(surf, hat, pygame.Rect(3, 0, 7, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 0, 7, 2), 1, border_radius=1)
                pygame.draw.rect(surf, hat, pygame.Rect(4, 2, 5, 1), border_radius=1)
                return

            surf.fill(hair, pygame.Rect(4, 0, 4, 2))
            if hair_kind == 1:  # bangs
                surf.set_at((7, 2), hair)
            elif hair_kind == 2:  # long
                for (x, y) in ((4, 2), (4, 3), (4, 4)):
                    surf.set_at((x, y), hair)

        def draw_face_right() -> None:
            if face_kind == 0:
                surf.fill(skin, pygame.Rect(6, 2, 3, 3))
            elif face_kind == 1:
                surf.fill(skin, pygame.Rect(6, 2, 3, 3))
                surf.fill(skin, pygame.Rect(5, 3, 1, 2))
            else:
                surf.fill(skin, pygame.Rect(6, 2, 3, 2))
                surf.fill(skin, pygame.Rect(7, 4, 1, 1))

            if eye_kind == 1:  # big
                surf.set_at((8, 3), eye)
                surf.set_at((8, 4), eye)
            elif eye_kind == 2:  # angry
                surf.set_at((8, 3), eye)
                surf.set_at((8, 2), outline)
            elif eye_kind == 3:  # sleepy
                surf.set_at((8, 3), outline)
            else:
                surf.set_at((8, 3), eye)

            if nose_kind == 1:
                surf.set_at((7, 4), skin_shade)
            elif nose_kind == 2:
                surf.set_at((7, 4), skin_shade)
                surf.set_at((8, 4), skin_shade)

        def draw_line(
            col: tuple[int, int, int],
            x0: int,
            y0: int,
            x1: int,
            y1: int,
        ) -> None:
            x0 = int(clamp(int(x0), 0, w - 1))
            x1 = int(clamp(int(x1), 0, w - 1))
            y0 = int(clamp(int(y0), 0, h - 1))
            y1 = int(clamp(int(y1), 0, h - 1))

            dx = abs(x1 - x0)
            dy = -abs(y1 - y0)
            sx = 1 if x0 < x1 else -1
            sy = 1 if y0 < y1 else -1
            err = dx + dy
            x, y = x0, y0
            while True:
                surf.fill(col, pygame.Rect(int(x), int(y), 1, 1))
                if x == x1 and y == y1:
                    break
                e2 = 2 * err
                if e2 >= dy:
                    err += dy
                    x += sx
                if e2 <= dx:
                    err += dx
                    y += sy

        def draw_leg(
            hip_x: int,
            knee_x: int,
            boot_x: int,
            boot_y: int,
            *,
            leg_top: int,
            knee_y: int,
            leg_col: tuple[int, int, int],
        ) -> None:
            hip_x = int(clamp(int(hip_x), 0, w - 1))
            knee_x = int(clamp(int(knee_x), 0, w - 1))
            boot_x = int(clamp(int(boot_x), 0, w - 1))
            leg_top = int(clamp(int(leg_top), 0, h - 1))
            knee_y = int(clamp(int(knee_y), 0, h - 1))
            boot_y = int(clamp(int(boot_y), 0, h - 1))

            if knee_y < leg_top:
                knee_y = leg_top
            if boot_y < knee_y:
                boot_y = knee_y

            draw_line(leg_col, int(hip_x), int(leg_top), int(knee_x), int(knee_y))
            draw_line(leg_col, int(knee_x), int(knee_y), int(boot_x), int(boot_y))
            surf.fill(boots, pygame.Rect(boot_x, boot_y, 1, 1))

        def draw_straight_leg(
            hip_x: int,
            foot_x: int,
            foot_y: int,
            *,
            leg_top: int,
            leg_col: tuple[int, int, int],
        ) -> None:
            hip_x = int(clamp(int(hip_x), 0, w - 1))
            foot_x = int(clamp(int(foot_x), 0, w - 1))
            leg_top = int(clamp(int(leg_top), 0, h - 1))
            foot_y = int(clamp(int(foot_y), 0, h - 1))

            draw_line(leg_col, int(hip_x), int(leg_top), int(foot_x), int(foot_y))
            surf.fill(boots, pygame.Rect(int(foot_x), int(foot_y), 1, 1))

        if direction in ("down", "up"):
            leg_top = (11 if direction == "up" else 10) + height_delta
            leg_top = int(clamp(int(leg_top), 8, 12))

            if direction == "down":
                left_hip = 4
                right_hip = 7
            else:
                left_hip = 5
                right_hip = 6

            # 6-step walk: left swings early, right swings late.
            left_lift = 2 if step == 1 else 1 if step == 0 else 0
            right_lift = 2 if step == 4 else 1 if step == 3 else 0

            left_x = left_hip - (1 if left_lift else 0)
            right_x = right_hip + (1 if right_lift else 0)
            left_knee_y = 13 - left_lift
            right_knee_y = 13 - right_lift
            left_boot_y = 15 - left_lift
            right_boot_y = 15 - right_lift

            draw_leg(
                int(right_hip),
                int(right_x),
                int(right_x),
                int(right_boot_y),
                leg_top=int(leg_top),
                knee_y=int(right_knee_y),
                leg_col=pants_dark,
            )
            draw_leg(
                int(left_hip),
                int(left_x),
                int(left_x),
                int(left_boot_y),
                leg_top=int(leg_top),
                knee_y=int(left_knee_y),
                leg_col=pants,
            )

            if direction == "down":
                surf.fill(coat, pygame.Rect(3, 5, 6, 6))
                surf.fill(coat_dark, pygame.Rect(3, 10, 6, 1))
                surf.fill(coat, pygame.Rect(2, 6, 1, 3))
                surf.fill(coat, pygame.Rect(9, 6, 1, 3))
                surf.fill(skin, pygame.Rect(2, 9, 1, 1))
                surf.fill(skin, pygame.Rect(9, 9, 1, 1))

                if outfit_kind == 2:  # tactical pouches
                    surf.fill(coat_dark, pygame.Rect(4, 7, 2, 2))
                    surf.fill(coat_dark, pygame.Rect(6, 7, 2, 2))
                elif outfit_kind == 3:  # stripes
                    for y in (6, 8, 10):
                        surf.fill(pants_dark, pygame.Rect(3, y, 6, 1))
                elif outfit_kind == 4:  # medic cross
                    surf.fill((210, 70, 80), pygame.Rect(5, 7, 1, 3))
                    surf.fill((210, 70, 80), pygame.Rect(4, 8, 3, 1))
                elif outfit_kind == 1:  # belt
                    surf.fill(pants_dark, pygame.Rect(3, 9, 6, 1))

                draw_hair_down()
                draw_face_down()
            else:
                surf.fill(coat, pygame.Rect(3, 4, 6, 7))
                surf.fill(coat_dark, pygame.Rect(4, 6, 4, 4))
                surf.fill(coat, pygame.Rect(2, 5, 1, 4))
                surf.fill(coat, pygame.Rect(9, 5, 1, 4))
                surf.fill(hair, pygame.Rect(4, 0, 4, 3))
                surf.fill(skin, pygame.Rect(5, 3, 2, 1))
                if hair_kind == 2:  # long hair back
                    surf.set_at((3, 3), hair)
                    surf.set_at((8, 3), hair)

            return surf

        # right (left built by flipping)
        leg_top = 10 + height_delta
        leg_top = int(clamp(int(leg_top), 8, 12))
        sk = cls._survivor_skeleton_nodes(
            "right",
            int(step),
            idle=bool(idle),
            height_delta=int(height_delta),
            run=bool(run),
        )
        l_hip = sk.get("l_hip", (5, int(leg_top)))
        l_knee = sk.get("l_knee", (5, 13))
        l_foot = sk.get("l_foot", (5, 15))
        r_hip = sk.get("r_hip", (6, int(leg_top)))
        r_knee = sk.get("r_knee", (6, 13))
        r_foot = sk.get("r_foot", (6, 15))

        if idle:
            step_idx = 0
            near_lift = 0
            far_lift = 0
        else:
            step_idx = int(step) % 6
            _, _, near_lifts, far_lifts = cls._side_walk_tables(run=bool(run))
            near_lift = int(near_lifts[step_idx])
            far_lift = int(far_lifts[step_idx])

        def draw_pose(
            hip: tuple[int, int],
            knee: tuple[int, int],
            foot: tuple[int, int],
            lift: int,
            *,
            col: tuple[int, int, int],
        ) -> None:
            if int(lift) <= 0:
                draw_straight_leg(int(hip[0]), int(foot[0]), int(foot[1]), leg_top=int(hip[1]), leg_col=col)
                return
            draw_leg(
                int(hip[0]),
                int(knee[0]),
                int(foot[0]),
                int(foot[1]),
                leg_top=int(hip[1]),
                knee_y=int(knee[1]),
                leg_col=col,
            )

        # Depth + shading: whichever leg is in front gets the lighter pants
        # color so the "cross" reads clearly.
        if int(r_foot[0]) >= int(l_foot[0]):
            # Near (right) leg in front.
            draw_pose(l_hip, l_knee, l_foot, int(far_lift), col=pants_dark)
            draw_pose(r_hip, r_knee, r_foot, int(near_lift), col=pants)
        else:
            # Far (left) leg crosses in front.
            draw_pose(r_hip, r_knee, r_foot, int(near_lift), col=pants_dark)
            draw_pose(l_hip, l_knee, l_foot, int(far_lift), col=pants)

        surf.fill(coat, pygame.Rect(4, 5, 5, 6))
        surf.fill(coat_dark, pygame.Rect(4, 10, 5, 1))
        surf.fill(coat, pygame.Rect(8, 6, 1, 3))
        surf.fill(skin, pygame.Rect(8, 9, 1, 1))

        if outfit_kind == 2:
            surf.fill(coat_dark, pygame.Rect(5, 7, 2, 2))
        elif outfit_kind == 3:
            for y in (6, 8, 10):
                surf.fill(pants_dark, pygame.Rect(4, y, 5, 1))
        elif outfit_kind == 4:
            surf.fill((210, 70, 80), pygame.Rect(6, 7, 1, 3))
            surf.fill((210, 70, 80), pygame.Rect(5, 8, 3, 1))

        draw_hair_right()
        draw_face_right()
        return surf

    @classmethod
    def build_avatar_player_frames(cls, avatar: SurvivalAvatar, *, run: bool = False) -> dict[str, list[pygame.Surface]]:
        avatar = avatar or SurvivalAvatar()
        avatar.clamp_all()

        down = [cls._make_avatar_player_sprite("down", 0, idle=True, avatar=avatar, run=bool(run))]
        for i in range(6):
            down.append(cls._make_avatar_player_sprite("down", i, idle=False, avatar=avatar, run=bool(run)))

        up = [cls._make_avatar_player_sprite("up", 0, idle=True, avatar=avatar, run=bool(run))]
        for i in range(6):
            up.append(cls._make_avatar_player_sprite("up", i, idle=False, avatar=avatar, run=bool(run)))

        right = [cls._make_avatar_player_sprite("right", 0, idle=True, avatar=avatar, run=bool(run))]
        for i in range(6):
            right.append(cls._make_avatar_player_sprite("right", i, idle=False, avatar=avatar, run=bool(run)))

        left: list[pygame.Surface] = []
        for s in right:
            left.append(pygame.transform.flip(s, True, False))

        return {"down": down, "up": up, "right": right, "left": left}

    @classmethod
    def _make_avatar_pose_sit_sprite(cls, direction: str, *, avatar: SurvivalAvatar) -> pygame.Surface:
        avatar = avatar or SurvivalAvatar()
        avatar.clamp_all()
        direction = str(direction)
        if direction == "left":
            return pygame.transform.flip(cls._make_avatar_pose_sit_sprite("right", avatar=avatar), True, False)

        w, h = 12, 16
        surf = pygame.Surface((w, h), pygame.SRCALPHA)
        cols = cls._avatar_colors(avatar)
        hair = cols["hair"]
        skin = cols["skin"]
        coat = cols["coat"]
        coat_dark = cols["coat_dark"]
        pants = cols["pants"]
        pants_dark = cols["pants_dark"]
        boots = cols["boots"]
        eye = cols["eye"]
        outline = (10, 10, 12)

        def px(x: int, y: int, c: tuple[int, int, int]) -> None:
            if 0 <= x < w and 0 <= y < h:
                surf.set_at((int(x), int(y)), c)

        def rect(x: int, y: int, rw: int, rh: int, c: tuple[int, int, int]) -> None:
            if rw <= 0 or rh <= 0:
                return
            surf.fill(c, pygame.Rect(int(x), int(y), int(rw), int(rh)))

        if direction in ("down", "up"):
            # Head + hair.
            rect(4, 0, 4, 2, hair)
            rect(4, 2, 4, 3, skin)
            if direction == "down":
                px(5, 3, eye)
                px(6, 3, eye)
            else:
                px(5, 2, hair)
                px(6, 2, hair)

            # Torso.
            rect(4, 5, 4, 4, coat)
            rect(4, 9, 4, 1, coat_dark)
            rect(3, 6, 1, 3, coat_dark)
            rect(8, 6, 1, 3, coat_dark)

            # Sitting legs (bent).
            rect(4, 10, 4, 1, pants)
            rect(4, 11, 4, 1, pants_dark)
            rect(5, 12, 2, 1, pants)
            rect(4, 13, 2, 1, boots)
            rect(6, 13, 2, 1, boots)

            pygame.draw.rect(surf, outline, pygame.Rect(3, 0, 6, 14), 1)
        else:
            # Right-facing sit pose.
            rect(4, 0, 4, 2, hair)
            rect(6, 2, 3, 3, skin)
            px(8, 3, eye)
            rect(4, 5, 5, 4, coat)
            rect(4, 9, 5, 1, coat_dark)
            rect(4, 6, 1, 3, coat_dark)
            rect(8, 6, 1, 3, coat_dark)

            rect(5, 10, 4, 1, pants)
            rect(6, 11, 3, 1, pants_dark)
            rect(7, 12, 2, 1, pants)
            rect(8, 13, 2, 1, boots)
            pygame.draw.rect(surf, outline, pygame.Rect(3, 0, 7, 14), 1)

        return surf

    @classmethod
    def _make_avatar_pose_sleep_sprite(cls, frame: int, *, avatar: SurvivalAvatar) -> pygame.Surface:
        avatar = avatar or SurvivalAvatar()
        avatar.clamp_all()
        w, h = 16, 12
        surf = pygame.Surface((w, h), pygame.SRCALPHA)
        cols = cls._avatar_colors(avatar)
        hair = cols["hair"]
        skin = cols["skin"]
        coat = cols["coat"]
        coat_dark = cols["coat_dark"]
        pants = cols["pants"]
        boots = cols["boots"]
        eye = cols["eye"]
        outline = (10, 10, 12)

        def rect(x: int, y: int, rw: int, rh: int, c: tuple[int, int, int]) -> None:
            if rw <= 0 or rh <= 0:
                return
            surf.fill(c, pygame.Rect(int(x), int(y), int(rw), int(rh)))

        # Head on the left.
        rect(1, 1, 4, 2, hair)
        rect(1, 3, 4, 2, skin)
        surf.set_at((3, 4), eye)

        # Body.
        rect(5, 2, 6, 4, coat)
        rect(5, 6, 6, 1, coat_dark)
        rect(11, 3, 3, 3, pants)
        rect(14, 4, 1, 2, boots)

        # Tiny "breath" highlight.
        if int(frame) % 2 == 0:
            surf.set_at((7, 3), (min(255, coat[0] + 20), min(255, coat[1] + 20), min(255, coat[2] + 20)))
        else:
            surf.set_at((7, 4), (min(255, coat[0] + 20), min(255, coat[1] + 20), min(255, coat[2] + 20)))

        pygame.draw.rect(surf, outline, pygame.Rect(0, 1, 15, 7), 1)
        return surf

    @classmethod
    def _make_avatar_cyclist_sprite(cls, direction: str, frame: int, *, avatar: SurvivalAvatar) -> pygame.Surface:
        avatar.clamp_all()
        w, h = 12, 16
        surf = pygame.Surface((w, h), pygame.SRCALPHA)

        cols = cls._avatar_colors(avatar)
        hair = cols["hair"]
        skin = cols["skin"]
        coat = cols["coat"]
        coat_dark = cols["coat_dark"]
        pants = cols["pants"]
        pants_dark = cols["pants_dark"]
        boots = cols["boots"]
        eye = cols["eye"]
        outline = (10, 10, 12)
        skin_shade = (max(0, skin[0] - 45), max(0, skin[1] - 45), max(0, skin[2] - 45))

        phase = int(frame) % 2
        face_kind = int(avatar.face)
        eye_kind = int(avatar.eyes)
        hair_kind = int(avatar.hair)
        nose_kind = int(avatar.nose)

        def draw_hair_down() -> None:
            if hair_kind == 3:
                hat = coat_dark
                pygame.draw.rect(surf, hat, pygame.Rect(3, 0, 6, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 0, 6, 2), 1, border_radius=1)
                pygame.draw.rect(surf, hat, pygame.Rect(3, 2, 5, 1), border_radius=1)
                return
            surf.fill(hair, pygame.Rect(4, 0, 4, 2))
            if hair_kind == 1:
                surf.set_at((5, 2), hair)
                surf.set_at((6, 2), hair)
            elif hair_kind == 2:
                for (x, y) in ((3, 2), (8, 2), (3, 3), (8, 3), (3, 4), (8, 4)):
                    surf.set_at((x, y), hair)

        def draw_face_down() -> None:
            if face_kind == 0:
                surf.fill(skin, pygame.Rect(4, 2, 4, 3))
            elif face_kind == 1:
                surf.fill(skin, pygame.Rect(4, 2, 4, 3))
                surf.fill(skin, pygame.Rect(3, 3, 1, 2))
                surf.fill(skin, pygame.Rect(8, 3, 1, 2))
            else:
                surf.fill(skin, pygame.Rect(4, 2, 4, 2))
                surf.fill(skin, pygame.Rect(5, 4, 2, 1))

            if eye_kind == 1:
                surf.set_at((5, 3), eye)
                surf.set_at((5, 4), eye)
                surf.set_at((6, 3), eye)
                surf.set_at((6, 4), eye)
            elif eye_kind == 2:
                surf.set_at((5, 3), eye)
                surf.set_at((6, 3), eye)
                surf.set_at((5, 2), outline)
                surf.set_at((6, 2), outline)
            elif eye_kind == 3:
                surf.set_at((5, 3), outline)
                surf.set_at((6, 3), outline)
            else:
                surf.set_at((5, 3), eye)
                surf.set_at((6, 3), eye)

            if nose_kind == 1:
                surf.set_at((5, 4), skin_shade)
            elif nose_kind == 2:
                surf.set_at((5, 4), skin_shade)
                surf.set_at((6, 4), skin_shade)

        def draw_hair_right() -> None:
            if hair_kind == 3:
                hat = coat_dark
                pygame.draw.rect(surf, hat, pygame.Rect(3, 0, 7, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 0, 7, 2), 1, border_radius=1)
                pygame.draw.rect(surf, hat, pygame.Rect(4, 2, 5, 1), border_radius=1)
                return
            surf.fill(hair, pygame.Rect(4, 0, 4, 2))
            if hair_kind == 1:
                surf.set_at((7, 2), hair)
            elif hair_kind == 2:
                for (x, y) in ((4, 2), (4, 3), (4, 4)):
                    surf.set_at((x, y), hair)

        def draw_face_right() -> None:
            if face_kind == 0:
                surf.fill(skin, pygame.Rect(6, 2, 3, 3))
            elif face_kind == 1:
                surf.fill(skin, pygame.Rect(6, 2, 3, 3))
                surf.fill(skin, pygame.Rect(5, 3, 1, 2))
            else:
                surf.fill(skin, pygame.Rect(6, 2, 3, 2))
                surf.fill(skin, pygame.Rect(7, 4, 1, 1))

            if eye_kind == 1:
                surf.set_at((8, 3), eye)
                surf.set_at((8, 4), eye)
            elif eye_kind == 2:
                surf.set_at((8, 3), eye)
                surf.set_at((8, 2), outline)
            elif eye_kind == 3:
                surf.set_at((8, 3), outline)
            else:
                surf.set_at((8, 3), eye)

            if nose_kind == 1:
                surf.set_at((7, 4), skin_shade)
            elif nose_kind == 2:
                surf.set_at((7, 4), skin_shade)
                surf.set_at((8, 4), skin_shade)

        def draw_leg(x: int, y0: int, y1: int, *, col: tuple[int, int, int]) -> None:
            x = int(clamp(int(x), 0, w - 1))
            y0 = int(clamp(int(y0), 0, h - 1))
            y1 = int(clamp(int(y1), 0, h - 1))
            if y1 < y0:
                y0, y1 = y1, y0
            for y in range(y0, y1):
                surf.fill(col, pygame.Rect(x, y, 1, 1))
            surf.fill(boots, pygame.Rect(x, y1, 1, 1))

        if direction in ("down", "up"):
            if direction == "down":
                draw_hair_down()
                draw_face_down()
            else:
                surf.fill(hair, pygame.Rect(4, 0, 4, 3))
                surf.fill(skin, pygame.Rect(5, 3, 2, 1))
                if hair_kind == 2:
                    surf.set_at((3, 3), hair)
                    surf.set_at((8, 3), hair)

            surf.fill(coat, pygame.Rect(3, 5, 6, 5))
            surf.fill(coat_dark, pygame.Rect(4, 7, 4, 3))
            surf.fill(coat, pygame.Rect(2, 6, 1, 2))
            surf.fill(coat, pygame.Rect(9, 6, 1, 2))
            surf.fill(skin, pygame.Rect(2, 8, 1, 1))
            surf.fill(skin, pygame.Rect(9, 8, 1, 1))

            lx = 5
            rx = 6
            if direction == "down":
                l_y = 13 + (0 if phase == 0 else 1)
                r_y = 13 + (1 if phase == 0 else 0)
            else:
                l_y = 14 - (0 if phase == 0 else 1)
                r_y = 14 - (1 if phase == 0 else 0)
            draw_leg(lx, 11, l_y, col=pants)
            draw_leg(rx, 11, r_y, col=pants_dark)
            surf.fill((30, 30, 34), pygame.Rect(4, 10, 4, 1))  # seat hint
            return surf

        # right
        draw_hair_right()
        draw_face_right()
        surf.fill(coat, pygame.Rect(4, 5, 5, 5))
        surf.fill(coat_dark, pygame.Rect(4, 9, 5, 1))
        surf.fill(coat, pygame.Rect(8, 6, 2, 1))
        surf.fill(skin, pygame.Rect(9, 7, 1, 1))
        near_shift = 1 if phase == 0 else 0
        far_shift = 0 if phase == 0 else 1
        draw_leg(5 + far_shift, 10, 14, col=pants_dark)
        draw_leg(6 + near_shift, 10, 13, col=pants)
        return surf

    @classmethod
    def build_avatar_cyclist_frames(cls, avatar: SurvivalAvatar) -> dict[str, list[pygame.Surface]]:
        avatar = avatar or SurvivalAvatar()
        avatar.clamp_all()
        down = [cls._make_avatar_cyclist_sprite("down", 0, avatar=avatar), cls._make_avatar_cyclist_sprite("down", 1, avatar=avatar)]
        up = [cls._make_avatar_cyclist_sprite("up", 0, avatar=avatar), cls._make_avatar_cyclist_sprite("up", 1, avatar=avatar)]
        right = [cls._make_avatar_cyclist_sprite("right", 0, avatar=avatar), cls._make_avatar_cyclist_sprite("right", 1, avatar=avatar)]
        left: list[pygame.Surface] = []
        for s in right:
            left.append(pygame.transform.flip(s, True, False))
        return {"down": down, "up": up, "right": right, "left": left}

    _MONSTER_PALS: dict[str, dict[str, tuple[int, int, int]]] = {
        "walker": {
            "skin": (92, 140, 96),
            "cloth": (76, 82, 74),
            "cloth2": (56, 60, 54),
            "pants": (44, 44, 56),
            "boots": (18, 18, 22),
            "eye": (18, 18, 22),
            "blood": (150, 70, 70),
        },
        "runner": {
            "skin": (100, 150, 104),
            "cloth": (140, 70, 70),
            "cloth2": (108, 52, 54),
            "pants": (40, 40, 50),
            "boots": (18, 18, 22),
            "eye": (18, 18, 22),
            "blood": (160, 76, 76),
        },
        "screamer": {
            "skin": (170, 170, 182),
            "cloth": (110, 80, 140),
            "cloth2": (78, 56, 104),
            "pants": (40, 40, 50),
            "boots": (18, 18, 22),
            "eye": (18, 18, 22),
            "blood": (170, 80, 90),
        },
    }

    def _make_monster_sprite(
        kind: str,
        direction: str,
        step: int,
        *,
        idle: bool,
        pals: dict[str, dict[str, tuple[int, int, int]]] = _MONSTER_PALS,
    ) -> pygame.Surface:
        w, h = 12, 16
        surf = pygame.Surface((w, h), pygame.SRCALPHA)

        pal = pals.get(str(kind), pals["walker"])
        skin = pal["skin"]
        cloth = pal["cloth"]
        cloth2 = pal["cloth2"]
        pants = pal["pants"]
        boots = pal["boots"]
        eye = pal["eye"]
        blood = pal["blood"]
        outline = (10, 10, 12)

        def shade(col: tuple[int, int, int], k: float) -> tuple[int, int, int]:
            return (
                int(clamp(float(col[0]) * float(k), 0.0, 255.0)),
                int(clamp(float(col[1]) * float(k), 0.0, 255.0)),
                int(clamp(float(col[2]) * float(k), 0.0, 255.0)),
            )

        pants_far = shade(pants, 0.72)
        boots_far = shade(boots, 0.72)

        step = int(step) % 2
        if idle:
            step = 0

        stride = 1 if step == 0 else -1

        def draw_leg(
            hip_x: int,
            knee_x: int,
            boot_x: int,
            boot_y: int,
            *,
            col: tuple[int, int, int],
            boot_col: tuple[int, int, int] | None = None,
        ) -> None:
            hip_x = int(clamp(int(hip_x), 0, w - 1))
            knee_x = int(clamp(int(knee_x), 0, w - 1))
            boot_x = int(clamp(int(boot_x), 0, w - 1))
            boot_y = int(clamp(int(boot_y), 0, h - 1))
            leg_top = 10
            knee_y = 13
            for y in range(leg_top, knee_y):
                surf.fill(col, pygame.Rect(hip_x, y, 1, 1))
            x0 = min(hip_x, knee_x)
            x1 = max(hip_x, knee_x)
            for x in range(x0, x1 + 1):
                surf.fill(col, pygame.Rect(x, knee_y, 1, 1))
            for y in range(knee_y, boot_y):
                surf.fill(col, pygame.Rect(knee_x, y, 1, 1))
            surf.fill((boots if boot_col is None else boot_col), pygame.Rect(boot_x, boot_y, 1, 1))

        if direction in ("down", "up"):
            left_hip = 4
            right_hip = 7
            left_boot_x = left_hip
            right_boot_x = right_hip
            if kind in ("walker", "screamer"):
                # Zombie shuffle: one leg "scuffs" forward with a bent knee, the other drags.
                lift = (1 if kind == "walker" else 2) if not idle else 0
                bend = (1 if kind == "walker" else 2) if not idle else 0
                if step == 0:
                    left_boot_y = 15 - lift
                    right_boot_y = 15
                    left_knee_x = left_hip + bend
                    right_knee_x = right_hip
                else:
                    left_boot_y = 15
                    right_boot_y = 15 - lift
                    left_knee_x = left_hip
                    right_knee_x = right_hip - bend
                left_boot_x = left_knee_x
                right_boot_x = right_knee_x
            else:
                left_boot_y = 15 - (1 if stride > 0 else 0)
                right_boot_y = 15 - (1 if stride < 0 else 0)
                left_knee_x = left_hip + stride
                right_knee_x = right_hip - stride
                left_boot_x = left_knee_x
                right_boot_x = right_knee_x

            # Legs behind torso.
            draw_leg(
                right_hip,
                right_knee_x,
                right_boot_x,
                right_boot_y,
                col=pants_far,
                boot_col=boots_far,
            )
            draw_leg(left_hip, left_knee_x, left_boot_x, left_boot_y, col=pants, boot_col=boots)

            # Torso + arms.
            torso_y = 6 if kind in ("walker", "screamer") else 5
            surf.fill(cloth, pygame.Rect(3, torso_y, 6, 6))
            surf.fill(cloth2, pygame.Rect(3, torso_y + 5, 6, 1))
            if kind == "walker":
                arm_y = torso_y
                reach = 4 if not idle else 3
                if direction == "down":
                    y0 = arm_y + (0 if stride > 0 else 1)
                else:
                    y0 = max(0, arm_y - reach - (0 if stride > 0 else 1))
                for ax in (3, 8):
                    surf.fill(skin, pygame.Rect(ax, y0, 1, reach))
                    surf.fill(skin, pygame.Rect(ax, y0 + reach, 1, 1))
                # Sleeves.
                surf.fill(cloth, pygame.Rect(3, arm_y, 1, 1))
                surf.fill(cloth, pygame.Rect(8, arm_y, 1, 1))
            else:
                arm_y = 6 if kind != "runner" else 5
                surf.fill(cloth, pygame.Rect(2, arm_y, 1, 3))
                surf.fill(cloth, pygame.Rect(9, arm_y, 1, 3))
                if kind == "screamer":
                    surf.fill(cloth, pygame.Rect(1, arm_y - 1, 1, 3))
                    surf.fill(cloth, pygame.Rect(10, arm_y - 1, 1, 3))

            # Head / face.
            head_y = 2 if kind in ("walker", "screamer") else 1
            if direction == "down":
                surf.fill(skin, pygame.Rect(4, head_y, 4, 4))
                surf.fill(outline, pygame.Rect(4, head_y, 4, 4), 1)
                surf.set_at((5, head_y + 2), eye)
                surf.set_at((6, head_y + 2), eye)
                if kind == "screamer":
                    surf.fill(blood, pygame.Rect(5, head_y + 3, 2, 1))
                else:
                    surf.set_at((6, head_y + 3), blood if kind == "runner" else outline)
            else:
                surf.fill(skin, pygame.Rect(4, head_y, 4, 4))
                surf.fill(outline, pygame.Rect(4, head_y, 4, 4), 1)
                surf.fill(cloth2, pygame.Rect(4, head_y, 4, 2))

            return surf

        # right / left (build right, flip elsewhere)
        # Legs.
        far_hip = 4
        near_hip = 7
        if kind in ("walker", "screamer"):
            lift = (1 if kind == "walker" else 2) if not idle else 0
            bend = (1 if kind == "walker" else 2) if not idle else 0
            far_knee_x = far_hip + (bend if step == 1 else 0)
            near_knee_x = near_hip - (bend if step == 0 else 0)
            near_boot_y = 15 - (lift if step == 0 else 0)
            far_boot_y = 15 - (lift if step == 1 else 0)
            draw_leg(far_hip, far_knee_x, far_knee_x, far_boot_y, col=pants_far, boot_col=boots_far)
            draw_leg(near_hip, near_knee_x, near_knee_x, near_boot_y, col=pants, boot_col=boots)
        else:
            near_dx = 1 if stride > 0 else -1
            far_dx = -near_dx
            near_boot_y = 15 - (1 if stride > 0 else 0)
            far_boot_y = 15 - (1 if stride < 0 else 0)
            draw_leg(far_hip, far_hip + far_dx, far_hip + far_dx, far_boot_y, col=pants_far, boot_col=boots_far)
            draw_leg(near_hip, near_hip + near_dx, near_hip + near_dx, near_boot_y, col=pants, boot_col=boots)

        # Body.
        body_y = 4 if kind == "runner" else 6 if kind in ("walker", "screamer") else 5
        surf.fill(cloth, pygame.Rect(4, body_y, 5, 7))
        surf.fill(cloth2, pygame.Rect(4, body_y + 5, 5, 1))
        # Arm / reach.
        if kind == "runner":
            surf.fill(cloth, pygame.Rect(8, body_y + 1, 3, 2))
            surf.fill(blood, pygame.Rect(10, body_y + 2, 1, 1))
        elif kind == "screamer":
            surf.fill(cloth, pygame.Rect(8, body_y, 3, 3))
            surf.fill(cloth, pygame.Rect(8, body_y + 3, 2, 2))
        else:
            # Walker: two forward-reaching arms (zombie style).
            arm_y0 = body_y + 2 + (0 if stride > 0 else 1)
            arm_y1 = body_y + 4 + (1 if stride > 0 else 0)
            ext0 = 4 if not idle else 3
            ext1 = 3 if not idle else 2
            surf.fill(skin, pygame.Rect(8, arm_y0, ext0, 1))
            surf.fill(skin, pygame.Rect(9, arm_y0 + 1, max(1, ext0 - 1), 1))
            surf.fill(skin, pygame.Rect(8, arm_y1, ext1, 1))
            surf.fill(skin, pygame.Rect(9, arm_y1 + 1, max(1, ext1 - 1), 1))
            # Sleeve pixel near torso.
            surf.fill(cloth, pygame.Rect(8, body_y + 2, 1, 1))

        # Head.
        head_y = 2 if kind in ("walker", "screamer") else 1
        surf.fill(skin, pygame.Rect(6, head_y, 4, 4))
        surf.fill(outline, pygame.Rect(6, head_y, 4, 4), 1)
        surf.set_at((9, head_y + 2), eye)
        if kind == "screamer":
            surf.fill(blood, pygame.Rect(8, head_y + 3, 2, 1))
        else:
            surf.set_at((9, head_y + 3), blood if kind == "runner" else outline)
        return surf

    _MONSTER_FRAMES: dict[str, dict[str, list[pygame.Surface]]] = {}
    for _kind in ("walker", "runner", "screamer"):
        _down = [
            _make_monster_sprite(_kind, "down", 0, idle=True),
            _make_monster_sprite(_kind, "down", 0, idle=False),
            _make_monster_sprite(_kind, "down", 1, idle=False),
        ]
        _up = [
            _make_monster_sprite(_kind, "up", 0, idle=True),
            _make_monster_sprite(_kind, "up", 0, idle=False),
            _make_monster_sprite(_kind, "up", 1, idle=False),
        ]
        _right = [
            _make_monster_sprite(_kind, "right", 0, idle=True),
            _make_monster_sprite(_kind, "right", 0, idle=False),
            _make_monster_sprite(_kind, "right", 1, idle=False),
        ]
        _left: list[pygame.Surface] = []
        for _spr in _right:
            _left.append(pygame.transform.flip(_spr, True, False))
        _MONSTER_FRAMES[_kind] = {"down": _down, "up": _up, "right": _right, "left": _left}

    @dataclass(frozen=True)
    class _CarModel:
        id: str
        name: str
        sprite_size: tuple[int, int]
        collider: tuple[int, int]
        wheelbase: float
        max_fwd: float
        max_rev: float
        accel: float
        brake: float
        fuel_per_px: float
        steer_max: float = 0.62
        # Optional tighter collision box while driving (px).
        # Use this when the visual/footprint collider is intentionally large (e.g. RV interior stamping),
        # but driving would feel "stuck" in dense city streets/building facades.
        drive_collider: tuple[int, int] | None = None

    _CAR_MODELS: dict[str, _CarModel] = {
        "rv": _CarModel(
            id="rv",
            name="房车",
            # Larger RV so it can contain a small walkable interior space (world camera mode).
            sprite_size=(90, 40),
            collider=(90, 40),
            # City roads are 5 tiles wide (+1 tile sidewalk each side). A 9-tile-wide RV footprint
            # tends to constantly collide with adjacent building facades, making it feel immobile.
            # Keep the big footprint for RV interior stamping, but drive with a tighter box.
            # NOTE: Must be <= 5 tiles wide (<= 50px) to reliably move on the main road grid.
            drive_collider=(46, 24),
            wheelbase=30.0,
            max_fwd=105.0,
            max_rev=38.0,
            accel=165.0,
            brake=320.0,
            fuel_per_px=0.022,
            steer_max=0.52,
        ),
        "beetle": _CarModel(
            id="beetle",
            name="甲壳虫(风格)",
            sprite_size=(32, 22),
            collider=(22, 14),
            wheelbase=18.0,
            max_fwd=115.0,
            max_rev=48.0,
            accel=190.0,
            brake=320.0,
            fuel_per_px=0.012,
        ),
        "porsche": _CarModel(
            id="porsche",
            name="保时捷(风格)",
            sprite_size=(36, 18),
            collider=(26, 12),
            wheelbase=20.0,
            max_fwd=150.0,
            max_rev=55.0,
            accel=240.0,
            brake=380.0,
            fuel_per_px=0.014,
        ),
        "truck": _CarModel(
            id="truck",
            name="卡车",
            sprite_size=(44, 20),
            collider=(30, 14),
            wheelbase=26.0,
            max_fwd=110.0,
            max_rev=44.0,
            accel=175.0,
            brake=320.0,
            fuel_per_px=0.018,
        ),
        "schoolbus": _CarModel(
            id="schoolbus",
            name="校车",
            sprite_size=(50, 20),
            collider=(34, 14),
            wheelbase=30.0,
            max_fwd=105.0,
            max_rev=40.0,
            accel=165.0,
            brake=310.0,
            fuel_per_px=0.020,
        ),
        "lamborghini": _CarModel(
            id="lamborghini",
            name="兰博基尼(风格)",
            sprite_size=(36, 18),
            collider=(26, 12),
            wheelbase=20.0,
            max_fwd=165.0,
            max_rev=58.0,
            accel=260.0,
            brake=400.0,
            fuel_per_px=0.016,
        ),
        "mercedes": _CarModel(
            id="mercedes",
            name="奔驰(风格)",
            sprite_size=(38, 18),
            collider=(28, 12),
            wheelbase=22.0,
            max_fwd=135.0,
            max_rev=52.0,
            accel=220.0,
            brake=360.0,
            fuel_per_px=0.015,
        ),
    }

    def _draw_wheel(
        surf: pygame.Surface,
        cx: int,
        cy: int,
        *,
        r: int,
        frame: int,
        outline: tuple[int, int, int],
        steer_state: int = 0,
        is_front: bool = False,
    ) -> None:
        # Top-down wheel: compact contact patch with a steer hint (MiniDayZ-like feel,
        # but original art).
        r = max(1, int(r))
        cx = int(cx)
        cy = int(cy)
        steer_state = int(clamp(int(steer_state), -1, 1))

        tire = (14, 14, 18)
        rim = (64, 64, 76)
        hi = (44, 44, 54)

        length = max(5, int(r * 3))
        thickness = max(2, int(r))
        half_l = int(length // 2)
        half_t = int(thickness // 2)
        br = max(1, int(min(length, thickness) // 2))

        def draw_patch(rect: pygame.Rect) -> None:
            pygame.draw.rect(surf, tire, rect, border_radius=br)
            inner = rect.inflate(-2, -2)
            if inner.w > 0 and inner.h > 0:
                pygame.draw.rect(surf, rim, inner, border_radius=max(1, int(min(inner.w, inner.h) // 2)))
            # Spinning hint.
            if int(frame) % 2 == 0:
                pygame.draw.line(surf, hi, (rect.left + 1, rect.centery), (rect.right - 2, rect.centery), 1)
            else:
                pygame.draw.line(surf, hi, (rect.centerx, rect.top + 1), (rect.centerx, rect.bottom - 2), 1)
            pygame.draw.rect(surf, outline, rect, 1, border_radius=br)

        if is_front and steer_state != 0:
            # A simple slanted patch to imply steering.
            sl = 2 if r >= 3 else 1
            sl *= 1 if steer_state > 0 else -1
            pts = [
                (cx - half_l + sl, cy - half_t),
                (cx + half_l + sl, cy - half_t),
                (cx + half_l - sl, cy + half_t),
                (cx - half_l - sl, cy + half_t),
            ]
            pygame.draw.polygon(surf, tire, pts)
            ipts = [
                (cx - max(1, half_l - 2) + sl, cy - max(0, half_t - 1)),
                (cx + max(1, half_l - 2) + sl, cy - max(0, half_t - 1)),
                (cx + max(1, half_l - 2) - sl, cy + max(0, half_t - 1)),
                (cx - max(1, half_l - 2) - sl, cy + max(0, half_t - 1)),
            ]
            pygame.draw.polygon(surf, rim, ipts)
            pygame.draw.polygon(surf, outline, pts, 1)
            # Steer direction accent.
            if steer_state > 0:
                pygame.draw.line(surf, hi, (cx + half_l - 1, cy - half_t), (cx + half_l - 3, cy + half_t), 1)
            else:
                pygame.draw.line(surf, hi, (cx - half_l + 1, cy - half_t), (cx - half_l + 3, cy + half_t), 1)
            return

        rect = pygame.Rect(int(cx - half_l), int(cy - half_t), int(length), int(thickness))
        draw_patch(rect)

    def _make_car_base(
        model_id: str,
        frame: int,
        steer_state: int,
        _car_models: dict[str, "HardcoreSurvivalState._CarModel"] = _CAR_MODELS,
        _draw_wheel_fn: Callable[..., None] = _draw_wheel,
    ) -> pygame.Surface:
        model = _car_models.get(str(model_id))
        if model is None:
            model = _car_models["beetle"]
        w, h = int(model.sprite_size[0]), int(model.sprite_size[1])
        surf = pygame.Surface((w, h), pygame.SRCALPHA)

        outline = (12, 12, 16)
        glass = (120, 140, 160)
        glass2 = (160, 180, 200)
        light = (255, 230, 150)
        tail = (255, 110, 110)

        steer_state = int(clamp(int(steer_state), -1, 1))

        def tint(c: tuple[int, int, int], add: tuple[int, int, int]) -> tuple[int, int, int]:
            return (
                int(clamp(int(c[0]) + int(add[0]), 0, 255)),
                int(clamp(int(c[1]) + int(add[1]), 0, 255)),
                int(clamp(int(c[2]) + int(add[2]), 0, 255)),
            )

        wheel_centers: list[tuple[int, int]] = []
        wheel_r = 3

        if model.id == "rv":
            body = (236, 236, 242)
            body2 = tint(body, (-30, -30, -32))
            body3 = tint(body, (10, 10, 12))
            stripe = (210, 120, 80)

            shell = pygame.Rect(2, 3, w - 4, h - 6)
            coach = pygame.Rect(shell.x, shell.y, shell.w - 18, shell.h)
            cab_left = int(coach.right - 2)
            cab_top = int(shell.y + 2)
            cab_bottom = int(shell.bottom - 3)
            front = int(shell.right - 1)
            midy = int((cab_top + cab_bottom) // 2)

            pygame.draw.rect(surf, body, coach, border_radius=4)
            pygame.draw.rect(surf, outline, coach, 2, border_radius=4)
            # Rear bumper + ladder hint.
            pygame.draw.rect(surf, body2, pygame.Rect(coach.x + 1, coach.y + 1, 3, coach.h - 2), border_radius=2)
            pygame.draw.line(surf, outline, (coach.x + 3, coach.y + 3), (coach.x + 3, coach.bottom - 4), 1)
            pygame.draw.line(surf, outline, (coach.x + 2, coach.y + 5), (coach.x + 4, coach.y + 5), 1)
            pygame.draw.line(surf, outline, (coach.x + 2, coach.y + 8), (coach.x + 4, coach.y + 8), 1)

            # Roof on the coach.
            roof = pygame.Rect(coach.x + 6, coach.y + 2, coach.w - 14, coach.h - 4)
            pygame.draw.rect(surf, body3, roof, border_radius=3)
            pygame.draw.rect(surf, outline, roof, 1, border_radius=3)
            pygame.draw.rect(surf, tint(body, (-10, -10, -10)), pygame.Rect(roof.x + 8, roof.y + 2, 6, 3), border_radius=1)  # vent
            pygame.draw.rect(surf, tint(body, (-10, -10, -10)), pygame.Rect(roof.right - 12, roof.y + 2, 8, 3), border_radius=1)  # AC

            # Side windows (coach).
            wx0 = coach.x + 10
            for i in range(4):
                rwin = pygame.Rect(wx0 + i * 8, coach.y + 3, 6, 4)
                pygame.draw.rect(surf, glass, rwin, border_radius=2)
                pygame.draw.rect(surf, outline, rwin, 1, border_radius=2)

            # Cab (tapered nose).
            cab_poly = [
                (cab_left, cab_top),
                (front - 3, cab_top + 1),
                (front, midy),
                (front - 3, cab_bottom - 1),
                (cab_left, cab_bottom),
            ]
            pygame.draw.polygon(surf, body2, cab_poly)
            pygame.draw.polygon(surf, outline, cab_poly, 1)
            # Windshield.
            wind = [
                (front - 8, cab_top + 2),
                (front - 2, cab_top + 3),
                (front - 2, cab_bottom - 3),
                (front - 8, cab_bottom - 2),
            ]
            pygame.draw.polygon(surf, glass, wind)
            pygame.draw.polygon(surf, outline, wind, 1)
            pygame.draw.line(surf, glass2, (front - 7, cab_top + 3), (front - 3, cab_top + 3), 1)

            # Side stripe + door hint.
            pygame.draw.rect(surf, stripe, pygame.Rect(coach.x + 6, coach.bottom - 5, coach.w + 6, 2), border_radius=1)
            door_x = int(coach.right - 10)
            pygame.draw.line(surf, outline, (door_x, coach.y + 4), (door_x, coach.bottom - 5), 1)
            pygame.draw.circle(surf, outline, (door_x + 2, midy + 2), 1)

            # Lights.
            pygame.draw.circle(surf, light, (front, cab_top + 2), 1)
            pygame.draw.circle(surf, light, (front, cab_bottom - 2), 1)
            pygame.draw.circle(surf, tail, (coach.x + 1, coach.y + 2), 1)
            pygame.draw.circle(surf, tail, (coach.x + 1, coach.bottom - 3), 1)

            y_top = int(shell.y + 1)
            y_bottom = int(shell.bottom - 2)
            wheel_centers = [(12, y_top), (12, y_bottom), (w - 10, y_top), (w - 10, y_bottom)]
            wheel_r = 3
        elif model.id == "beetle":
            body = (84, 170, 190)
            body2 = tint(body, (-22, -22, -18))
            shell = pygame.Rect(3, 4, w - 6, h - 8)
            pygame.draw.rect(surf, body, shell, border_radius=10)
            pygame.draw.rect(surf, outline, shell, 2, border_radius=10)
            roof = pygame.Rect(shell.x + 9, shell.y + 2, shell.w - 18, shell.h - 4)
            pygame.draw.rect(surf, body2, roof, border_radius=8)
            win = roof.inflate(-2, -2)
            pygame.draw.rect(surf, glass, win, border_radius=7)
            pygame.draw.rect(surf, outline, win, 1, border_radius=7)
            pygame.draw.line(surf, outline, (shell.x + 7, shell.y + 2), (shell.x + 7, shell.bottom - 3), 1)
            pygame.draw.line(surf, outline, (shell.right - 8, shell.y + 2), (shell.right - 8, shell.bottom - 3), 1)
            pygame.draw.circle(surf, light, (w - 4, h // 2 - 3), 1)
            pygame.draw.circle(surf, light, (w - 4, h // 2 + 3), 1)
            pygame.draw.circle(surf, tail, (3, h // 2 - 3), 1)
            pygame.draw.circle(surf, tail, (3, h // 2 + 3), 1)
            y_top = 4
            y_bottom = h - 5
            wheel_centers = [(7, y_top), (7, y_bottom), (w - 7, y_top), (w - 7, y_bottom)]
            wheel_r = 3
        elif model.id == "porsche":
            body = (220, 80, 80)
            body2 = tint(body, (-40, -32, -32))
            shell = pygame.Rect(3, 4, w - 6, h - 8)
            pygame.draw.rect(surf, body, shell, border_radius=6)
            pygame.draw.rect(surf, outline, shell, 2, border_radius=6)
            hood = pygame.Rect(shell.right - 14, shell.y + 1, 10, shell.h - 2)
            pygame.draw.rect(surf, body2, hood, border_radius=5)
            roof = pygame.Rect(shell.x + 12, shell.y + 2, shell.w - 26, shell.h - 4)
            pygame.draw.rect(surf, tint(body, (-12, -12, -12)), roof, border_radius=4)
            win = roof.inflate(-2, -2)
            pygame.draw.rect(surf, glass, win, border_radius=3)
            pygame.draw.rect(surf, outline, win, 1, border_radius=3)
            pygame.draw.line(surf, glass2, (win.x + 2, win.y + 2), (win.right - 3, win.y + 2), 1)
            pygame.draw.circle(surf, light, (w - 4, 6), 1)
            pygame.draw.circle(surf, light, (w - 4, h - 7), 1)
            pygame.draw.circle(surf, tail, (3, 6), 1)
            pygame.draw.circle(surf, tail, (3, h - 7), 1)
            y_top = 4
            y_bottom = h - 5
            wheel_centers = [(9, y_top), (9, y_bottom), (w - 7, y_top), (w - 7, y_bottom)]
            wheel_r = 2
        elif model.id == "lamborghini":
            body = (86, 190, 96)
            body2 = tint(body, (-28, -38, -28))
            shell = pygame.Rect(3, 4, w - 6, h - 8)
            pygame.draw.rect(surf, body, shell, border_radius=4)
            pygame.draw.rect(surf, outline, shell, 2, border_radius=4)
            # Wedge nose.
            pygame.draw.polygon(surf, body2, [(w - 4, h // 2), (w - 14, shell.y + 1), (w - 14, shell.bottom - 2)])
            # Engine cover vents.
            eng = pygame.Rect(shell.x + 4, shell.y + 2, 10, shell.h - 4)
            pygame.draw.rect(surf, body2, eng, border_radius=2)
            for y in range(eng.y + 1, eng.bottom - 1, 2):
                pygame.draw.line(surf, outline, (eng.x + 1, y), (eng.right - 2, y), 1)
            roof = pygame.Rect(shell.x + 14, shell.y + 2, shell.w - 28, shell.h - 4)
            pygame.draw.polygon(
                surf,
                glass,
                [(roof.x, roof.y + 1), (roof.right, roof.y + 2), (roof.right - 2, roof.bottom - 2), (roof.x + 2, roof.bottom - 1)],
            )
            pygame.draw.polygon(
                surf,
                outline,
                [(roof.x, roof.y + 1), (roof.right, roof.y + 2), (roof.right - 2, roof.bottom - 2), (roof.x + 2, roof.bottom - 1)],
                1,
            )
            pygame.draw.circle(surf, light, (w - 4, 6), 1)
            pygame.draw.circle(surf, light, (w - 4, h - 7), 1)
            pygame.draw.circle(surf, tail, (3, 6), 1)
            pygame.draw.circle(surf, tail, (3, h - 7), 1)
            y_top = 4
            y_bottom = h - 5
            wheel_centers = [(9, y_top), (9, y_bottom), (w - 7, y_top), (w - 7, y_bottom)]
            wheel_r = 2
        elif model.id == "mercedes":
            body = (150, 150, 160)
            body2 = tint(body, (-34, -34, -34))
            shell = pygame.Rect(3, 4, w - 6, h - 8)
            pygame.draw.rect(surf, body, shell, border_radius=5)
            pygame.draw.rect(surf, outline, shell, 2, border_radius=5)
            hood = pygame.Rect(shell.right - 15, shell.y + 1, 10, shell.h - 2)
            pygame.draw.rect(surf, body2, hood, border_radius=4)
            roof = pygame.Rect(shell.x + 11, shell.y + 2, shell.w - 24, shell.h - 4)
            pygame.draw.rect(surf, tint(body, (8, 8, 10)), roof, border_radius=4)
            win = roof.inflate(-2, -2)
            pygame.draw.rect(surf, glass, win, border_radius=3)
            pygame.draw.rect(surf, outline, win, 1, border_radius=3)
            pygame.draw.circle(surf, light, (w - 4, 6), 1)
            pygame.draw.circle(surf, light, (w - 4, h - 7), 1)
            pygame.draw.circle(surf, tail, (3, 6), 1)
            pygame.draw.circle(surf, tail, (3, h - 7), 1)
            y_top = 4
            y_bottom = h - 5
            wheel_centers = [(10, y_top), (10, y_bottom), (w - 6, y_top), (w - 6, y_bottom)]
            wheel_r = 2
        elif model.id == "truck":
            cab = (220, 220, 230)
            cab2 = tint(cab, (-26, -26, -26))
            bed = (92, 92, 104)
            bed2 = tint(bed, (-22, -22, -22))
            cab_w = 16
            bed_r = pygame.Rect(3, 4, w - cab_w - 5, h - 8)
            pygame.draw.rect(surf, bed, bed_r, border_radius=4)
            pygame.draw.rect(surf, outline, bed_r, 2, border_radius=4)
            pygame.draw.rect(surf, bed2, pygame.Rect(bed_r.x + 1, bed_r.y + bed_r.h - 4, bed_r.w - 2, 2), border_radius=2)
            for x in range(bed_r.x + 3, bed_r.right - 2, 4):
                pygame.draw.line(surf, outline, (x, bed_r.y + 2), (x, bed_r.bottom - 3), 1)
            cab_r = pygame.Rect(w - cab_w - 2, 3, cab_w, h - 6)
            pygame.draw.rect(surf, cab, cab_r, border_radius=4)
            pygame.draw.rect(surf, outline, cab_r, 2, border_radius=4)
            wind = pygame.Rect(cab_r.x + 3, cab_r.y + 3, cab_r.w - 6, 6)
            pygame.draw.rect(surf, glass, wind, border_radius=2)
            pygame.draw.rect(surf, outline, wind, 1, border_radius=2)
            pygame.draw.rect(surf, cab2, pygame.Rect(cab_r.x + 2, cab_r.bottom - 6, cab_r.w - 4, 3), border_radius=2)
            pygame.draw.circle(surf, light, (w - 3, 6), 1)
            pygame.draw.circle(surf, light, (w - 3, h - 7), 1)
            pygame.draw.circle(surf, tail, (3, 6), 1)
            pygame.draw.circle(surf, tail, (3, h - 7), 1)
            y_top = 4
            y_bottom = h - 5
            wheel_centers = [(11, y_top), (11, y_bottom), (w - 7, y_top), (w - 7, y_bottom)]
            wheel_r = 3
        else:
            # schoolbus
            body = (230, 200, 90)
            body2 = tint(body, (-28, -28, -18))
            stripe = (80, 80, 86)
            shell = pygame.Rect(2, 4, w - 4, h - 8)
            pygame.draw.rect(surf, body, shell, border_radius=3)
            pygame.draw.rect(surf, outline, shell, 2, border_radius=3)
            pygame.draw.rect(surf, body2, pygame.Rect(shell.x + 1, shell.y + shell.h - 4, shell.w - 2, 2), border_radius=2)
            pygame.draw.rect(surf, stripe, pygame.Rect(shell.x + 6, shell.bottom - 6, shell.w - 12, 2), border_radius=1)
            wx0 = shell.x + 10
            for i in range(6):
                r = pygame.Rect(wx0 + i * 6, shell.y + 2, 4, 4)
                pygame.draw.rect(surf, glass, r, border_radius=1)
                pygame.draw.rect(surf, outline, r, 1, border_radius=1)
            pygame.draw.line(surf, outline, (w - 16, shell.y + 2), (w - 16, shell.bottom - 3), 1)  # door hint
            pygame.draw.circle(surf, light, (w - 3, shell.y + 2), 1)
            pygame.draw.circle(surf, light, (w - 3, shell.bottom - 3), 1)       
            pygame.draw.circle(surf, tail, (shell.x + 1, shell.y + 2), 1)       
            pygame.draw.circle(surf, tail, (shell.x + 1, shell.bottom - 3), 1)  
            y_top = 4
            y_bottom = h - 5
            wheel_centers = [(12, y_top), (12, y_bottom), (w - 8, y_top), (w - 8, y_bottom)]
            wheel_r = 3

        front_x = max(int(cx) for cx, _ in wheel_centers) - 1 if wheel_centers else (w - 6)
        for cx, cy in wheel_centers:
            is_front = int(cx) >= int(front_x)
            _draw_wheel_fn(
                surf,
                int(cx),
                int(cy),
                r=int(wheel_r),
                frame=int(frame),
                outline=outline,
                steer_state=int(steer_state),
                is_front=is_front,
            )

        return surf

    def _make_shadow(sprite: pygame.Surface, *, alpha: int = 110) -> pygame.Surface:
        w, h = sprite.get_size()
        shadow = pygame.Surface((w, h), pygame.SRCALPHA)
        alpha = int(clamp(int(alpha), 0, 255))
        for y in range(int(h)):
            for x in range(int(w)):
                r, g, b, a = sprite.get_at((x, y))
                if a == 0:
                    continue
                shadow.set_at((x, y), (0, 0, 0, alpha))
        return shadow

    _CAR_BASE: dict[tuple[str, int, int], pygame.Surface] = {}
    _CAR_SHADOW: dict[tuple[str, int, int], pygame.Surface] = {}
    for _mid in _CAR_MODELS:
        for _steer in (-1, 0, 1):
            for _frm in (0, 1):
                _base = _make_car_base(_mid, _frm, _steer)
                _CAR_BASE[(_mid, _steer, _frm)] = _base
                _CAR_SHADOW[(_mid, _steer, _frm)] = _make_shadow(_base, alpha=110)

    def _make_bike_sprite(direction: str, frame: int) -> pygame.Surface:        
        w, h = 18, 18
        surf = pygame.Surface((w, h), pygame.SRCALPHA)

        outline = (10, 10, 12)
        tire = (16, 16, 20)
        rim = (62, 62, 72)
        spoke = (130, 130, 142)
        frame_col = (96, 96, 110)
        frame_dark = (72, 72, 86)
        seat = (44, 44, 54)
        light = (255, 230, 150)
        moving = int(frame) % 2 == 1

        def draw_wheel(cx: int, cy: int, *, orient: str) -> None:
            cx = int(cx)
            cy = int(cy)
            # Round wheels (top-down look).
            outer = 3
            inner = 2
            pygame.draw.circle(surf, tire, (cx, cy), int(outer))
            pygame.draw.circle(surf, rim, (cx, cy), int(inner))
            pygame.draw.circle(surf, outline, (cx, cy), int(outer), 1)
            pygame.draw.circle(surf, (90, 90, 104), (cx, cy), 1)  # hub

            if moving:
                pygame.draw.line(surf, spoke, (cx - 2, cy), (cx + 2, cy), 1)
                pygame.draw.line(surf, spoke, (cx, cy - 2), (cx, cy + 2), 1)
            else:
                pygame.draw.line(surf, spoke, (cx - 2, cy - 2), (cx + 2, cy + 2), 1)
                pygame.draw.line(surf, spoke, (cx - 2, cy + 2), (cx + 2, cy - 2), 1)

        if direction in ("left", "right"):
            y = 10
            front_x = 14 if direction == "right" else 4
            rear_x = 4 if direction == "right" else 14

            draw_wheel(rear_x, y, orient="h")
            draw_wheel(front_x, y, orient="h")

            crank_x, crank_y = 9, 10
            seat_x, seat_y = 8, 6
            handle_y = 6

            pygame.draw.line(surf, frame_col, (rear_x, y), (crank_x, crank_y), 1)
            pygame.draw.line(surf, frame_col, (crank_x, crank_y), (front_x, y), 1)
            pygame.draw.line(surf, frame_col, (crank_x, crank_y), (seat_x, seat_y), 1)
            pygame.draw.line(surf, frame_col, (seat_x, seat_y), (rear_x + (2 if direction == "right" else -2), y - 1), 1)

            pygame.draw.rect(surf, seat, pygame.Rect(seat_x - 2, seat_y - 1, 5, 2), border_radius=1)
            pygame.draw.line(surf, outline, (seat_x - 2, seat_y), (seat_x + 2, seat_y), 1)

            # Fork + handlebar.
            pygame.draw.line(surf, frame_dark, (front_x, y), (front_x + (0 if direction == "right" else 0), handle_y + 2), 1)
            pygame.draw.line(surf, frame_dark, (front_x - 2, handle_y), (front_x + 2, handle_y), 1)
            pygame.draw.line(surf, frame_dark, (front_x, handle_y), (front_x, handle_y + 2), 1)

            # Pedal hint.
            if moving:
                surf.set_at((crank_x + (1 if direction == "right" else -1), crank_y), spoke)
                surf.set_at((crank_x, crank_y + 1), spoke)
            else:
                surf.set_at((crank_x, crank_y + 1), spoke)
                surf.set_at((crank_x + (1 if direction == "right" else -1), crank_y + 1), spoke)

            pygame.draw.circle(surf, light, (front_x + (2 if direction == "right" else -2), y - 2), 1)
        else:
            x = 9
            front_y = 4 if direction == "up" else 14
            rear_y = 14 if direction == "up" else 4

            draw_wheel(x, rear_y, orient="v")
            draw_wheel(x, front_y, orient="v")

            crank_x, crank_y = 8, 9
            seat_x, seat_y = 6, 8
            handle_x = x

            pygame.draw.line(surf, frame_col, (x, rear_y), (crank_x, crank_y), 1)
            pygame.draw.line(surf, frame_col, (crank_x, crank_y), (x, front_y), 1)
            pygame.draw.line(surf, frame_col, (crank_x, crank_y), (seat_x, seat_y), 1)
            pygame.draw.line(surf, frame_col, (seat_x, seat_y), (x - 1, rear_y + (-2 if direction == "up" else 2)), 1)

            pygame.draw.rect(surf, seat, pygame.Rect(seat_x - 2, seat_y - 1, 5, 2), border_radius=1)
            pygame.draw.line(surf, outline, (seat_x - 2, seat_y), (seat_x + 2, seat_y), 1)

            pygame.draw.line(surf, frame_dark, (x, front_y), (x + 2, front_y + (2 if direction == "down" else -2)), 1)
            pygame.draw.line(surf, frame_dark, (handle_x - 2, front_y), (handle_x + 2, front_y), 1)
            pygame.draw.line(surf, frame_dark, (handle_x, front_y - 1), (handle_x, front_y + 1), 1)

            if moving:
                surf.set_at((crank_x + 1, crank_y), spoke)
                surf.set_at((crank_x, crank_y + (1 if direction == "down" else -1)), spoke)
            else:
                surf.set_at((crank_x, crank_y + 1), spoke)
                surf.set_at((crank_x + 1, crank_y + 1), spoke)

            pygame.draw.circle(surf, light, (x + 3, front_y + (3 if direction == "down" else -3)), 1)

        return surf

    _BIKE_FRAMES: dict[str, list[pygame.Surface]] = {
        "up": [_make_bike_sprite("up", 0), _make_bike_sprite("up", 1)],
        "down": [_make_bike_sprite("down", 0), _make_bike_sprite("down", 1)],   
        "left": [_make_bike_sprite("left", 0), _make_bike_sprite("left", 1)],   
        "right": [_make_bike_sprite("right", 0), _make_bike_sprite("right", 1)],
    }

    def _recolor_sprite(
        src: pygame.Surface,
        mapping: dict[tuple[int, int, int, int], tuple[int, int, int, int]],
    ) -> pygame.Surface:
        out = src.copy()
        w, h = out.get_size()
        for y in range(int(h)):
            for x in range(int(w)):
                rgba = out.get_at((x, y))
                repl = mapping.get((int(rgba.r), int(rgba.g), int(rgba.b), int(rgba.a)))
                if repl is not None:
                    out.set_at((x, y), repl)
        return out

    def _bike_variant_from_base(
        base: dict[str, list[pygame.Surface]],
        mapping: dict[tuple[int, int, int, int], tuple[int, int, int, int]],
        *,
        basket: bool = False,
        battery: bool = False,
    ) -> dict[str, list[pygame.Surface]]:
        out: dict[str, list[pygame.Surface]] = {}
        basket_col = (130, 92, 62, 255)
        basket_line = (10, 10, 12, 255)
        battery_col = (70, 90, 140, 255)
        for d, frames in base.items():
            nf: list[pygame.Surface] = []
            for s in frames:
                ns = s.copy()
                w, h = ns.get_size()
                for yy in range(int(h)):
                    for xx in range(int(w)):
                        rgba = ns.get_at((xx, yy))
                        repl = mapping.get((int(rgba.r), int(rgba.g), int(rgba.b), int(rgba.a)))
                        if repl is not None:
                            ns.set_at((xx, yy), repl)
                if basket:
                    if d == "right":
                        pygame.draw.rect(ns, basket_col, pygame.Rect(14, 6, 3, 3), border_radius=1)
                        pygame.draw.rect(ns, basket_line, pygame.Rect(14, 6, 3, 3), 1, border_radius=1)
                    elif d == "left":
                        pygame.draw.rect(ns, basket_col, pygame.Rect(1, 6, 3, 3), border_radius=1)
                        pygame.draw.rect(ns, basket_line, pygame.Rect(1, 6, 3, 3), 1, border_radius=1)
                    elif d == "up":
                        pygame.draw.rect(ns, basket_col, pygame.Rect(12, 1, 3, 3), border_radius=1)
                        pygame.draw.rect(ns, basket_line, pygame.Rect(12, 1, 3, 3), 1, border_radius=1)
                    else:
                        pygame.draw.rect(ns, basket_col, pygame.Rect(12, 14, 3, 3), border_radius=1)
                        pygame.draw.rect(ns, basket_line, pygame.Rect(12, 14, 3, 3), 1, border_radius=1)
                if battery:
                    pygame.draw.rect(ns, battery_col, pygame.Rect(8, 9, 4, 3), border_radius=1)
                    pygame.draw.rect(ns, basket_line, pygame.Rect(8, 9, 4, 3), 1, border_radius=1)
                nf.append(ns)
            out[str(d)] = nf
        return out

    def _make_moto_sprite(
        direction: str,
        frame: int,
        *,
        body: tuple[int, int, int] = (110, 80, 80),
        body2: tuple[int, int, int] = (72, 50, 50),
        accent: tuple[int, int, int] = (240, 210, 140),
        long: bool = False,
    ) -> pygame.Surface:
        w, h = 22, 22
        surf = pygame.Surface((w, h), pygame.SRCALPHA)
        outline = (10, 10, 12)
        tire = (16, 16, 20)
        rim = (62, 62, 72)
        spoke = (130, 130, 142)
        moving = int(frame) % 2 == 1

        def draw_wheel(cx: int, cy: int) -> None:
            pygame.draw.circle(surf, tire, (int(cx), int(cy)), 4)
            pygame.draw.circle(surf, rim, (int(cx), int(cy)), 3)
            pygame.draw.circle(surf, outline, (int(cx), int(cy)), 4, 1)
            if moving:
                pygame.draw.line(surf, spoke, (cx - 2, cy), (cx + 2, cy), 1)
                pygame.draw.line(surf, spoke, (cx, cy - 2), (cx, cy + 2), 1)
            else:
                pygame.draw.line(surf, spoke, (cx - 2, cy - 2), (cx + 2, cy + 2), 1)
                pygame.draw.line(surf, spoke, (cx - 2, cy + 2), (cx + 2, cy - 2), 1)

        if direction in ("left", "right"):
            y = 12
            front_x = 17 if direction == "right" else 4
            rear_x = 5 if direction == "right" else 18
            draw_wheel(rear_x, y)
            draw_wheel(front_x, y)
            body_r = pygame.Rect(min(front_x, rear_x) + 2, y - 4, abs(front_x - rear_x) - 3, 7)
            if long:
                body_r.w += 2
                body_r.x -= 1
            pygame.draw.rect(surf, body, body_r, border_radius=3)
            pygame.draw.rect(surf, outline, body_r, 1, border_radius=3)
            pygame.draw.rect(surf, body2, pygame.Rect(body_r.x + 2, body_r.y + 1, max(1, body_r.w - 4), 2), border_radius=2)
            pygame.draw.rect(surf, accent, pygame.Rect(body_r.centerx - 2, body_r.y + 3, 4, 2), border_radius=1)
        else:
            x = 11
            front_y = 4 if direction == "up" else 17
            rear_y = 18 if direction == "up" else 5
            draw_wheel(x, rear_y)
            draw_wheel(x, front_y)
            body_r = pygame.Rect(x - 4, min(front_y, rear_y) + 2, 7, abs(front_y - rear_y) - 3)
            if long:
                body_r.h += 2
                body_r.y -= 1
            pygame.draw.rect(surf, body, body_r, border_radius=3)
            pygame.draw.rect(surf, outline, body_r, 1, border_radius=3)
            pygame.draw.rect(surf, body2, pygame.Rect(body_r.x + 1, body_r.y + 2, 2, max(1, body_r.h - 4)), border_radius=2)
            pygame.draw.rect(surf, accent, pygame.Rect(body_r.x + 3, body_r.centery - 2, 2, 4), border_radius=1)
        return surf

    _TWO_WHEEL_FRAMES: dict[str, dict[str, list[pygame.Surface]]] = {
        "bike": _BIKE_FRAMES,
        "bike_lady": _bike_variant_from_base(
            _BIKE_FRAMES,
            {
                (96, 96, 110, 255): (220, 110, 180, 255),
                (72, 72, 86, 255): (170, 70, 140, 255),
                (44, 44, 54, 255): (60, 40, 50, 255),
            },
            basket=True,
        ),
        "bike_mountain": _bike_variant_from_base(
            _BIKE_FRAMES,
            {
                (96, 96, 110, 255): (90, 170, 110, 255),
                (72, 72, 86, 255): (60, 130, 80, 255),
                (44, 44, 54, 255): (30, 40, 34, 255),
            },
        ),
        "bike_auto": _bike_variant_from_base(
            _BIKE_FRAMES,
            {
                (96, 96, 110, 255): (90, 140, 210, 255),
                (72, 72, 86, 255): (60, 100, 170, 255),
                (44, 44, 54, 255): (30, 40, 60, 255),
            },
            battery=True,
        ),
        "moto": {
            "up": [_make_moto_sprite("up", 0), _make_moto_sprite("up", 1)],
            "down": [_make_moto_sprite("down", 0), _make_moto_sprite("down", 1)],
            "right": [_make_moto_sprite("right", 0), _make_moto_sprite("right", 1)],
            "left": [pygame.transform.flip(_make_moto_sprite("right", 0), True, False), pygame.transform.flip(_make_moto_sprite("right", 1), True, False)],
        },
        "moto_lux": {
            "up": [_make_moto_sprite("up", 0, body=(40, 40, 46), body2=(26, 26, 32), accent=(220, 180, 90)), _make_moto_sprite("up", 1, body=(40, 40, 46), body2=(26, 26, 32), accent=(220, 180, 90))],
            "down": [_make_moto_sprite("down", 0, body=(40, 40, 46), body2=(26, 26, 32), accent=(220, 180, 90)), _make_moto_sprite("down", 1, body=(40, 40, 46), body2=(26, 26, 32), accent=(220, 180, 90))],
            "right": [_make_moto_sprite("right", 0, body=(40, 40, 46), body2=(26, 26, 32), accent=(220, 180, 90)), _make_moto_sprite("right", 1, body=(40, 40, 46), body2=(26, 26, 32), accent=(220, 180, 90))],
            "left": [pygame.transform.flip(_make_moto_sprite("right", 0, body=(40, 40, 46), body2=(26, 26, 32), accent=(220, 180, 90)), True, False), pygame.transform.flip(_make_moto_sprite("right", 1, body=(40, 40, 46), body2=(26, 26, 32), accent=(220, 180, 90)), True, False)],
        },
        "moto_long": {
            "up": [_make_moto_sprite("up", 0, body=(110, 90, 70), body2=(70, 60, 46), accent=(240, 210, 140), long=True), _make_moto_sprite("up", 1, body=(110, 90, 70), body2=(70, 60, 46), accent=(240, 210, 140), long=True)],
            "down": [_make_moto_sprite("down", 0, body=(110, 90, 70), body2=(70, 60, 46), accent=(240, 210, 140), long=True), _make_moto_sprite("down", 1, body=(110, 90, 70), body2=(70, 60, 46), accent=(240, 210, 140), long=True)],
            "right": [_make_moto_sprite("right", 0, body=(110, 90, 70), body2=(70, 60, 46), accent=(240, 210, 140), long=True), _make_moto_sprite("right", 1, body=(110, 90, 70), body2=(70, 60, 46), accent=(240, 210, 140), long=True)],
            "left": [pygame.transform.flip(_make_moto_sprite("right", 0, body=(110, 90, 70), body2=(70, 60, 46), accent=(240, 210, 140), long=True), True, False), pygame.transform.flip(_make_moto_sprite("right", 1, body=(110, 90, 70), body2=(70, 60, 46), accent=(240, 210, 140), long=True), True, False)],
        },
    }

    def _make_cyclist_sprite(
        direction: str,
        frame: int,
        *,
        pal=_PLAYER_PAL,
    ) -> pygame.Surface:
        # A seated variant of the player used when riding the bike (2 pedal frames).
        w, h = 12, 16
        surf = pygame.Surface((w, h), pygame.SRCALPHA)

        hair = pal["H"]
        skin = pal["S"]
        coat = pal["C"]
        pants = pal["P"]
        boots = pal["B"]
        eye = pal["E"]
        coat_dark = (56, 72, 140)
        pants_dark = (40, 40, 50)

        phase = int(frame) % 2

        def draw_leg(x: int, y0: int, y1: int, *, col: tuple[int, int, int]) -> None:
            x = int(clamp(int(x), 0, w - 1))
            y0 = int(clamp(int(y0), 0, h - 1))
            y1 = int(clamp(int(y1), 0, h - 1))
            if y1 < y0:
                y0, y1 = y1, y0
            for y in range(y0, y1):
                surf.fill(col, pygame.Rect(x, y, 1, 1))
            surf.fill(boots, pygame.Rect(x, y1, 1, 1))

        if direction in ("down", "up"):
            # Head.
            if direction == "down":
                surf.fill(hair, pygame.Rect(4, 0, 4, 2))
                surf.fill(skin, pygame.Rect(4, 2, 4, 3))
                surf.set_at((5, 3), eye)
                surf.set_at((6, 3), eye)
            else:
                surf.fill(hair, pygame.Rect(4, 0, 4, 3))
                surf.fill(skin, pygame.Rect(5, 3, 2, 1))

            # Torso (lower + leaning).
            surf.fill(coat, pygame.Rect(3, 5, 6, 5))
            surf.fill(coat_dark, pygame.Rect(4, 7, 4, 3))
            # Arms forward to a "handlebar" hint.
            surf.fill(coat, pygame.Rect(2, 6, 1, 2))
            surf.fill(coat, pygame.Rect(9, 6, 1, 2))
            surf.fill(skin, pygame.Rect(2, 8, 1, 1))
            surf.fill(skin, pygame.Rect(9, 8, 1, 1))

            # Legs pedal around the crank: alternate boot height.
            lx = 5
            rx = 6
            if direction == "down":
                l_y = 13 + (0 if phase == 0 else 1)
                r_y = 13 + (1 if phase == 0 else 0)
            else:
                l_y = 14 - (0 if phase == 0 else 1)
                r_y = 14 - (1 if phase == 0 else 0)
            draw_leg(lx, 11, l_y, col=pants)
            draw_leg(rx, 11, r_y, col=pants_dark)
            surf.fill((30, 30, 34), pygame.Rect(4, 10, 4, 1))  # seat hint
            return surf

        # right
        # Head.
        surf.fill(hair, pygame.Rect(4, 0, 4, 2))
        surf.fill(skin, pygame.Rect(6, 2, 3, 3))
        surf.set_at((8, 3), eye)
        # Torso + near arm.
        surf.fill(coat, pygame.Rect(4, 5, 5, 5))
        surf.fill(coat_dark, pygame.Rect(4, 9, 5, 1))
        surf.fill(coat, pygame.Rect(8, 6, 2, 1))
        surf.fill(skin, pygame.Rect(9, 7, 1, 1))

        # Legs (2-frame pedal hint).
        near_shift = 1 if phase == 0 else 0
        far_shift = 0 if phase == 0 else 1
        draw_leg(5 + far_shift, 10, 14, col=pants_dark)
        draw_leg(6 + near_shift, 10, 13, col=pants)
        return surf

    _CYC_DOWN_FRAMES = [_make_cyclist_sprite("down", 0), _make_cyclist_sprite("down", 1)]
    _CYC_UP_FRAMES = [_make_cyclist_sprite("up", 0), _make_cyclist_sprite("up", 1)]
    _CYC_RIGHT_FRAMES = [_make_cyclist_sprite("right", 0), _make_cyclist_sprite("right", 1)]
    _CYC_LEFT_FRAMES: list[pygame.Surface] = []
    for _s in _CYC_RIGHT_FRAMES:
        _CYC_LEFT_FRAMES.append(pygame.transform.flip(_s, True, False))

    _CYCLIST_FRAMES: dict[str, list[pygame.Surface]] = {
        "down": _CYC_DOWN_FRAMES,
        "up": _CYC_UP_FRAMES,
        "right": _CYC_RIGHT_FRAMES,
        "left": _CYC_LEFT_FRAMES,
    }

    # High-rise apartment (multi-floor) interior.
    _HR_INT_LOBBY_LAYOUT: list[str] = [
        "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
        "W.............................W",
        "W....CC.................CC....W",
        "W....CC.................CC....W",
        "W.............................W",
        "W.......^^....EE..............W",
        "W.......vv....EE..............W",
        "W.............................D",
        "W.............................W",
        "W....CC.................CC....W",
        "W....CC.................CC....W",
        "W.............................W",
        "W.............................W",
        "W.............................W",
        "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
    ]
    _HR_INT_HALL_BASE: list[str] = [
        "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
        "W..............A..............W",
        "W.............................W",
        "W.......A.............A.......W",
        "W.............................W",
        "W.......^^....EE..............W",
        "W.......vv....EE..............W",
        "W.............................W",
        "W.............................W",
        "W.............................W",
        "W.............................W",
        "W.............................W",
        "W.............................W",
        "W.............................W",
        "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
    ]
    _HR_INT_HOME_LAYOUT: list[str] = [
        "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
        "WVVV....VVV....VVV....VVV.....W",
        "W....SSS.....W...W.....SSS....W",
        "W..BBBB......W...W..BBBB......W",
        "W..BBBB......W...W..BBBB......W",
        "W....SSS.....W...W....SSS.....W",
        "W.............................W",
        "WWWWWWWWWWWWWW...WWWWWWWWWWWWWW",
        "W.............................W",
        "W..PPP.....CCC..L..XXX........D",
        "W...C.................WWWWWWWWW",
        "WKKKKK.FF.............W,,,,,,,W",
        "WKKKKK..TTT............,,,,,,,W",
        "WKKKKK................W,,,O,,,W",
        "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
    ]
    _HR_INT_HOME_LAYOUT_VERSION = 5
    _HR_INT_W = 31
    _HR_INT_H = 15
    _HR_INT_TILE_SIZE = 20
    _HR_INT_SPRITE_SCALE = 2
    HIGHRISE_MAX_FLOORS = 10
    # Minimum playable interior height (in world tiles, excluding border walls)
    # for high-rises so the lobby + apartments don't collapse into "only elevator".
    HIGHRISE_MIN_FLOOR_TILES = 9
    _HR_INT_MAX_FLOORS_DEFAULT = HIGHRISE_MAX_FLOORS
    _HR_INT_APT_DOORS: list[tuple[int, int]] = [(8, 3), (22, 3), (15, 1)]

    GAS_CAN_REFUEL = 45.0

    # School (multi-floor) interior.
    _SCH_INT_LOBBY_LAYOUT: list[str] = [
        "WWWWWWWWWWWWWWWWWWWWWWW",
        "WVV.................VVW",
        "WLL...TTTT..TTTT....LLW",
        "WLL...TTTT..TTTT....LLW",
        "W.....................W",
        "W....^^.....EE.....vv.D",
        "W....^^.....EE.....vv.W",
        "W.....................W",
        "WLL...TTTT..TTTT....LLW",
        "WLL...TTTT..TTTT....LLW",
        "WWWWWWWWWWWWWWWWWWWWWWW",
    ]
    _SCH_INT_FLOOR_LAYOUT: list[str] = [
        "WWWWWWWWWWWWWWWWWWWWWWW",
        "WVV.................VVW",
        "WLL...TTTT..TTTT....LLW",
        "WLL...TTTT..TTTT....LLW",
        "W.....................W",
        "W....^^.....EE.....vv.W",
        "W....^^.....EE.....vv.W",
        "W.....................W",
        "WLL...TTTT..TTTT....LLW",
        "WLL...TTTT..TTTT....LLW",
        "WWWWWWWWWWWWWWWWWWWWWWW",
    ]
    _SCH_INT_W = 23
    _SCH_INT_H = 11
    _SCH_INT_TILE_SIZE = 20
    _SCH_INT_SPRITE_SCALE = 2
    _SCH_INT_MAX_FLOORS_DEFAULT = 4

    # Multi-floor house (2–3 floors) interior.
    _HOUSE_INT_F1_LAYOUT: list[str] = [
        "WWWWWWWWWWWWWWWWWWWWWWW",
        "WVV...........W,,,,,VVW",
        "W..BBBBB..SSSSW,,,O,,,W",
        "W..BBBBB..SSSSd,,,,,,,W",
        "W..............,,,R,,,W",
        "W....^^........vvWWWWWD",
        "W....^^........vv.....W",
        "W.....................W",
        "W..KKKKK..TTTT..FFFF..W",
        "W..KKKKK..TTTT..FFFF..W",
        "WWWWWWWWWWWWWWWWWWWWWWW",
    ]
    _HOUSE_INT_FLOOR_LAYOUT: list[str] = [
        "WWWWWWWWWWWWWWWWWWWWWWW",
        "WVV...........W,,,,,VVW",
        "W......SSSS...W,,,O,,,W",
        "W..TT..SSSS...d,,,,,,,W",
        "W..TT..........,,,R,,,W",
        "W....^^........vvWWWWWW",
        "W....^^........vv.....W",
        "W.........BBBBB.......W",
        "W..KKKKK..BBBBB.SSSS..W",
        "W..KKKKK........SSSS..W",
        "WWWWWWWWWWWWWWWWWWWWWWW",
    ]
    _HOUSE_INT_W = 23
    _HOUSE_INT_H = 11
    _HOUSE_INT_TILE_SIZE = 20
    _HOUSE_INT_SPRITE_SCALE = 2
    _HOUSE_INT_MAX_FLOORS_DEFAULT = 3

    @dataclass(frozen=True)
    class _ItemDef:
        id: str
        name: str
        stack: int
        color: tuple[int, int, int]
        kind: str
        desc: str = ""

    _ITEMS: dict[str, _ItemDef] = {
        "cola": _ItemDef("cola", "可乐", stack=3, color=(220, 70, 80), kind="drink"),
        "food_can": _ItemDef("food_can", "罐头", stack=6, color=(210, 170, 90), kind="food"),
        "water": _ItemDef("water", "瓶装水", stack=3, color=(120, 170, 230), kind="drink"),
        "bandage": _ItemDef("bandage", "绷带", stack=12, color=(230, 230, 240), kind="med"),
        "medkit": _ItemDef("medkit", "急救包", stack=2, color=(240, 120, 120), kind="med"),
        "pistol": _ItemDef("pistol", "9mm手枪", stack=1, color=(190, 190, 200), kind="gun"),
        "ammo_9mm": _ItemDef("ammo_9mm", "9mm弹", stack=60, color=(230, 220, 140), kind="ammo"),
        "scrap": _ItemDef("scrap", "废铁", stack=20, color=(150, 150, 160), kind="mat"),
        "wood": _ItemDef("wood", "木材", stack=20, color=(150, 110, 70), kind="mat"),
        "cup": _ItemDef("cup", "杯子", stack=1, color=(230, 230, 236), kind="tool"),
        "cup_water": _ItemDef("cup_water", "杯装水", stack=1, color=(120, 170, 230), kind="drink"),
    }

    # Procedurally-generated bulk item library (300+). Keep it compact by composing
    # base types + variants, but still deterministic and readable.
    def _bulk_item_seed(s: str) -> int:
        n = 0
        for ch in str(s):
            n = (n * 131 + ord(ch)) & 0xFFFFFFFF
        return int(n)

    def _bulk_item_color(base: tuple[int, int, int], seed: int, *, spread: int = 22) -> tuple[int, int, int]:
        seed = int(seed) & 0xFFFFFFFF
        dv = int((seed >> 8) % 11) - 5  # -5..+5
        dv2 = int((seed >> 16) % 9) - 4
        s = int(max(6, int(spread)))
        r = int(clamp(int(base[0]) + dv * (s // 6), 0, 255))
        g = int(clamp(int(base[1]) + dv2 * (s // 7), 0, 255))
        b = int(clamp(int(base[2]) + dv * (s // 8), 0, 255))
        return (r, g, b)

    _BULK_ITEMS: dict[str, _ItemDef] = {}

    _FOOD_BASES: list[tuple[str, str]] = [
        ("bread", "面包"),
        ("biscuit", "饼干"),
        ("chips", "薯片"),
        ("jerky", "肉干"),
        ("noodle", "泡面"),
        ("riceball", "饭团"),
        ("candy", "糖果"),
        ("chocolate", "巧克力"),
        ("nuts", "坚果"),
        ("sausage", "香肠"),
        ("cereal", "麦片"),
        ("crackers", "苏打饼干"),
        ("tuna", "金枪鱼"),
        ("beans", "豆子"),
        ("corn", "玉米"),
        ("fruitcan", "水果罐头"),
        ("soup", "汤罐头"),
        ("mre", "军粮"),
        ("driedfruit", "果干"),
        ("pickles", "腌黄瓜"),
        ("seaweed", "海苔"),
        ("cheese", "奶酪"),
        ("energybar", "能量棒"),
        ("mealbox", "便当"),
    ]
    _FOOD_FLAVORS: list[tuple[str, str]] = [
        ("plain", "原味"),
        ("spicy", "香辣"),
        ("tomato", "番茄"),
        ("curry", "咖喱"),
        ("garlic", "蒜香"),
        ("bbq", "烧烤"),
        ("pepper", "椒盐"),
        ("sweet", "甜味"),
    ]
    for _bid, _bname in _FOOD_BASES:
        for _fid, _fname in _FOOD_FLAVORS:
            _iid = f"food_{_bid}_{_fid}"
            if _iid in _ITEMS or _iid in _BULK_ITEMS:
                continue
            _seed = _bulk_item_seed(_iid)
            _BULK_ITEMS[_iid] = _ItemDef(
                _iid,
                f"{_fname}{_bname}",
                stack=6,
                color=_bulk_item_color((210, 170, 90), _seed),
                kind="food",
            )

    _DRINK_BASES: list[tuple[str, str]] = [
        ("soda", "汽水"),
        ("energy", "能量饮料"),
        ("juice", "果汁"),
        ("tea", "茶饮"),
        ("coffee", "咖啡"),
        ("milk", "牛奶"),
        ("soymilk", "豆奶"),
        ("beer", "啤酒"),
        ("wine", "葡萄酒"),
        ("sports", "运动饮料"),
        ("sparkling", "苏打水"),
        ("cocoa", "可可"),
        ("lemonade", "柠檬水"),
        ("water_mineral", "矿泉水"),
        ("milk_choco", "巧克力奶"),
    ]
    _DRINK_FLAVORS: list[tuple[str, str]] = [
        ("plain", "原味"),
        ("lemon", "柠檬"),
        ("orange", "橙"),
        ("grape", "葡萄"),
        ("peach", "桃"),
        ("sugarfree", "无糖"),
    ]
    for _bid, _bname in _DRINK_BASES:
        for _fid, _fname in _DRINK_FLAVORS:
            _iid = f"drink_{_bid}_{_fid}"
            if _iid in _ITEMS or _iid in _BULK_ITEMS:
                continue
            _seed = _bulk_item_seed(_iid)
            _BULK_ITEMS[_iid] = _ItemDef(
                _iid,
                f"{_fname}{_bname}",
                stack=3,
                color=_bulk_item_color((120, 170, 230), _seed),
                kind="drink",
            )

    _MEDS: list[tuple[str, str]] = [
        ("med_painkillers", "止痛药"),
        ("med_antibiotic", "抗生素"),
        ("med_vitamin", "维生素"),
        ("med_alcoholwipe", "酒精棉片"),
        ("med_iodine", "碘伏"),
        ("med_saline", "生理盐水"),
        ("med_glucose", "葡萄糖"),
        ("med_cough", "止咳药"),
        ("med_allergy", "抗过敏药"),
        ("med_burncream", "烫伤膏"),
        ("med_antiseptic", "消毒水"),
        ("med_sleep", "安眠药"),
        ("med_bandage_roll", "纱布卷"),
        ("med_splint", "夹板"),
        ("med_ointment", "药膏"),
        ("med_eye", "眼药水"),
        ("med_mask", "口罩"),
        ("med_gloves", "医用手套"),
        ("med_syringe", "注射器"),
        ("med_adrenaline", "肾上腺素"),
        ("med_charcoal", "活性炭片"),
        ("med_disinfect_wipes", "消毒湿巾"),
        ("med_thermometer", "体温计"),
        ("med_pain_patch", "止痛贴"),
        ("med_antifungal", "抗真菌药"),
        ("med_antidiarrheal", "止泻药"),
        ("med_antacid", "胃药"),
        ("med_suture", "缝合包"),
        ("med_salt", "盐丸"),
        ("med_medicinal_tea", "药草茶"),
    ]
    for _iid, _name in _MEDS:
        if _iid in _ITEMS or _iid in _BULK_ITEMS:
            continue
        _seed = _bulk_item_seed(_iid)
        _BULK_ITEMS[_iid] = _ItemDef(_iid, _name, stack=6, color=_bulk_item_color((230, 230, 240), _seed), kind="med")

    _MATS: list[tuple[str, str]] = [
        ("nails", "钉子"),
        ("screws", "螺丝"),
        ("duct_tape", "胶带"),
        ("rope", "绳子"),
        ("cloth", "布料"),
        ("plastic", "塑料"),
        ("glass", "玻璃"),
        ("wire", "电线"),
        ("battery", "电池"),
        ("charcoal", "木炭"),
        ("matches", "火柴"),
        ("lighter", "打火机"),
        ("soap", "肥皂"),
        ("salt", "食盐"),
        ("sugar", "白糖"),
        ("spices", "香料"),
        ("paper", "纸张"),
        ("book", "书"),
        ("map", "地图"),
        ("flashlight", "手电筒"),
        ("knife", "小刀"),
        ("hammer", "锤子"),
        ("saw", "锯子"),
        ("wrench", "扳手"),
        ("screwdriver", "螺丝刀"),
        ("crowbar", "撬棍"),
        ("backpack", "背包"),
        ("phone", "手机"),
        ("radio", "收音机"),
        ("binoculars", "望远镜"),
        ("can_opener", "开罐器"),
        ("cigarettes", "香烟"),
        ("lighter_fluid", "打火机油"),
        ("bottle_empty", "空瓶"),
        ("plank", "木板"),
        ("sheet_metal", "铁皮"),
        ("oil_filter", "机油滤芯"),
        ("spark_plug", "火花塞"),
        ("repair_kit", "修理包"),
    ]
    for _iid, _name in _MATS:
        if _iid in _ITEMS or _iid in _BULK_ITEMS:
            continue
        _seed = _bulk_item_seed(_iid)
        stack = (
            1
            if _iid
            in (
                "flashlight",
                "knife",
                "hammer",
                "saw",
                "wrench",
                "screwdriver",
                "crowbar",
                "backpack",
                "phone",
                "radio",
                "binoculars",
                "can_opener",
                "repair_kit",
            )
            else 20
        )
        kind = "tool" if stack == 1 else "mat"
        _BULK_ITEMS[_iid] = _ItemDef(_iid, _name, stack=int(stack), color=_bulk_item_color((150, 150, 160), _seed), kind=kind)

    _FURN_BASES: list[tuple[str, str]] = [
        ("chair", "椅子"),
        ("stool", "凳子"),
        ("table", "桌子"),
        ("sofa", "沙发"),
        ("bed", "床"),
        ("cabinet", "柜子"),
        ("wardrobe", "衣柜"),
        ("shelf", "书架"),
        ("tv", "电视"),
        ("lamp", "台灯"),
        ("fan", "风扇"),
        ("microwave", "微波炉"),
        ("fridge", "冰箱"),
        ("washer", "洗衣机"),
        ("heater", "取暖器"),
    ]
    _FURN_VARIANTS: list[tuple[str, str]] = [
        ("old", "旧"),
        ("new", "新"),
        ("broken", "破损"),
        ("heavy", "加固"),
    ]
    for _bid, _bname in _FURN_BASES:
        for _vid, _vname in _FURN_VARIANTS:
            _iid = f"furn_{_bid}_{_vid}"
            if _iid in _ITEMS or _iid in _BULK_ITEMS:
                continue
            _seed = _bulk_item_seed(_iid)
            _BULK_ITEMS[_iid] = _ItemDef(
                _iid,
                f"{_vname}{_bname}",
                stack=1,
                color=_bulk_item_color((120, 110, 100), _seed),
                kind="furniture",
            )

    # Keys / fuel (used by vehicle systems).
    _EXTRA_CORE: list[tuple[str, str, str, tuple[int, int, int], int]] = [
        ("key_rv", "房车钥匙", "key", (220, 220, 240), 1),
        ("key_moto", "摩托钥匙", "key", (220, 220, 240), 1),
        ("key_house", "房门钥匙", "key", (220, 220, 240), 1),
        ("gas_can", "汽油桶", "fuel", (210, 170, 90), 1),
    ]
    for _iid, _name, _kind, _base_col, _stack in _EXTRA_CORE:
        if _iid in _ITEMS or _iid in _BULK_ITEMS:
            continue
        _seed = _bulk_item_seed(_iid)
        _BULK_ITEMS[_iid] = _ItemDef(_iid, _name, stack=int(_stack), color=_bulk_item_color(_base_col, _seed), kind=str(_kind))

    # Guns / ammo / attachments (core gameplay loop).
    _EXTRA_WEAPONS: list[tuple[str, str, str, tuple[int, int, int], int, str]] = [
        ("uzi", "UZI冲锋枪", "gun", (190, 190, 200), 1, "近距离：泼水快乐枪；远距离：祝你好运。"),
        ("ak47", "AK-47", "gun", (190, 190, 200), 1, "经典老伙计，后坐力有脾气，但很讲义气。"),
        ("scar_l", "SCAR-L", "gun", (190, 190, 200), 1, "稳、准、帅。你只差一件战术背心。"),
        ("rpg", "火箭筒", "gun", (200, 190, 170), 1, "大声一点，清场就快一点。"),
        ("ammo_556", "5.56mm弹", "ammo", (210, 220, 170), 90, "5.56×45mm：轻快、平直，适合连发控。"),
        ("ammo_762", "7.62mm弹", "ammo", (230, 200, 120), 75, "7.62×39mm：更猛、更硬，也更吵一点。"),
        ("ammo_rocket", "火箭弹", "ammo", (240, 140, 100), 6, "别问后坐力，问就是：你整个人都在后坐。"),
        # Attachments
        ("mod_optic_reddot", "红点瞄准镜", "gun_mod", (170, 170, 190), 1, "近中距离神器：把‘差不多’变成‘差一点点都不行’。"),
        ("mod_optic_4x", "4倍镜", "gun_mod", (170, 170, 190), 1, "看得更远，心也更虚：远处那坨是不是在动？"),
        ("mod_muzzle_suppressor_9mm", "9mm消音器", "gun_mod", (120, 120, 132), 1, "把‘砰’调成‘噗’——僵尸：啊？"),
        ("mod_muzzle_suppressor_rifle", "步枪消音器", "gun_mod", (120, 120, 132), 1, "降低噪声半径，适合想当忍者的你。"),
        ("mod_muzzle_comp_rifle", "补偿器", "gun_mod", (140, 140, 154), 1, "压枪更稳，但声音更‘硬核’。"),
        ("mod_undergrip_stab", "稳定器前握把", "gun_mod", (120, 140, 150), 1, "握把一装，手抖先投降。"),
        ("mod_mag_ext_pistol", "手枪加长弹匣", "gun_mod", (170, 150, 120), 1, "多出来的不是子弹，是安全感。"),
        ("mod_mag_ext_9mm", "9mm加长弹匣", "gun_mod", (170, 150, 120), 1, "一梭子更长：你可以少换一次弹，真的就一次。"),
        ("mod_mag_ext_rifle", "步枪加长弹匣", "gun_mod", (170, 150, 120), 1, "长弹匣的代价：换弹像在掰手腕。"),
    ]
    for _iid, _name, _kind, _base_col, _stack, _desc in _EXTRA_WEAPONS:
        if _iid in _ITEMS or _iid in _BULK_ITEMS:
            continue
        _seed = _bulk_item_seed(_iid)
        _BULK_ITEMS[_iid] = _ItemDef(
            _iid,
            _name,
            stack=int(_stack),
            color=_bulk_item_color(_base_col, _seed),
            kind=str(_kind),
            desc=str(_desc),
        )

    _EXTRA_MELEE: list[tuple[str, str, str, tuple[int, int, int], int, str]] = [
        ("melee_club", "木棍", "melee", (150, 110, 70), 1, "木棍：不讲道理的物理学课代表。"),
        ("melee_bat", "棒球棍", "melee", (160, 120, 80), 1, "棒球棍：不是用来打全垒打的，是用来让僵尸‘回家’的。"),
        ("melee_pipe", "铁管", "melee", (150, 150, 160), 1, "铁管：朴素、沉稳、打人很痛。"),
        ("melee_machete", "砍刀", "melee", (200, 200, 210), 1, "砍刀：一刀下去，烦恼少一半（至少对你）。"),
    ]
    for _iid, _name, _kind, _base_col, _stack, _desc in _EXTRA_MELEE:
        if _iid in _ITEMS or _iid in _BULK_ITEMS:
            continue
        _seed = _bulk_item_seed(_iid)
        _BULK_ITEMS[_iid] = _ItemDef(
            _iid,
            _name,
            stack=int(_stack),
            color=_bulk_item_color(_base_col, _seed),
            kind=str(_kind),
            desc=str(_desc),
        )

    _EXTRA_CLOTHES: list[tuple[str, str, str, tuple[int, int, int], int, str]] = [
        ("clothes_jacket_blue", "夹克蓝", "clothes", (72, 92, 160), 1, "经典开局皮肤：耐看、耐脏、耐末日。"),
        ("clothes_work_green", "工装绿", "clothes", (70, 120, 90), 1, "口袋多到你怀疑自己是个移动仓库。"),
        ("clothes_tactical_gray", "战术灰", "clothes", (92, 92, 104), 1, "看起来很专业；实际上你还是会迷路。"),
        ("clothes_prisoner_orange", "囚服橙", "clothes", (210, 130, 60), 1, "穿上它，连僵尸都以为你是‘熟客’。"),
        ("clothes_medic_white", "医护白", "clothes", (220, 220, 230), 1, "白大褂是精神护甲：自带‘我很可靠’Buff。"),
        ("clothes_raincoat_yellow", "雨衣黄", "clothes", (224, 210, 112), 1, "雨再大也不怕；唯一缺点：太显眼。"),
        ("clothes_hoodie_pink", "街头卫衣粉", "clothes", (210, 120, 160), 1, "可爱是第一生产力，吓人是副产品。"),
        ("clothes_denim_blue", "牛仔外套蓝", "clothes", (90, 140, 210), 1, "帅不帅先不说，反正很耐磨。"),
        ("clothes_chef_white", "厨师白", "clothes", (240, 240, 245), 1, "闻到香味了吗？那是你…的错觉。"),
        ("clothes_racing_red", "赛车服红", "clothes", (210, 70, 80), 1, "速度感拉满，方向感随缘。"),
        ("clothes_xmas_green", "圣诞毛衣绿", "clothes", (120, 190, 140), 1, "丑萌丑萌的：僵尸都不忍心咬。"),
        ("clothes_black_suit", "黑西装", "clothes", (28, 28, 34), 1, "末日也要体面：你可能是最后的绅士。"),
        ("clothes_desert_camo", "沙漠迷彩", "clothes", (160, 140, 90), 1, "藏得住尘土，藏不住你那点小慌张。"),
        ("clothes_sport_cyan", "运动套装青", "clothes", (80, 160, 210), 1, "跑得快不如穿得像跑得快。"),
        ("clothes_pajama_bear", "睡衣小熊", "clothes", (200, 190, 230), 1, "抱紧我，我怕。——衣服先说的。"),
        ("clothes_maid", "女仆装", "clothes", (220, 220, 240), 1, "打扫战场也是打扫，服务对象：自己。"),
    ]
    for _iid, _name, _kind, _base_col, _stack, _desc in _EXTRA_CLOTHES:
        if _iid in _ITEMS or _iid in _BULK_ITEMS:
            continue
        _seed = _bulk_item_seed(_iid)
        _BULK_ITEMS[_iid] = _ItemDef(
            _iid,
            _name,
            stack=int(_stack),
            color=_bulk_item_color(_base_col, _seed),
            kind=str(_kind),
            desc=str(_desc),
        )

    _EXTRA_GUN_MODS_MORE: list[tuple[str, str, str, tuple[int, int, int], int, str]] = [
        ("mod_optic_holo", "全息瞄准镜", "gun_mod", (170, 170, 190), 1, "红点的亲戚：更清晰的框，更坚定的心。"),
        ("mod_undergrip_bipod", "两脚架", "gun_mod", (120, 140, 150), 1, "趴下稳如狗，站起来随缘抖。"),
        ("mod_stock_tactical", "战术枪托", "gun_mod", (140, 140, 154), 1, "肩膀：我可以。后坐力：我不太行。"),
        ("mod_muzzle_flash_hider_rifle", "消焰器", "gun_mod", (120, 120, 132), 1, "夜里别闪瞎自己：低调一点，但不够‘静’。"),
        ("mod_trigger_light", "轻量扳机组", "gun_mod", (170, 170, 190), 1, "手指更快，枪口更飘：快乐与代价同时到场。"),
        ("mod_mag_drum_9mm", "9mm鼓包弹匣", "gun_mod", (170, 150, 120), 1, "一梭子开到天荒地老；换弹也要等到天荒地老。"),
        ("mod_mag_drum_rifle", "步枪鼓包弹匣", "gun_mod", (170, 150, 120), 1, "子弹多到你开始思考人生；换弹慢到人生开始思考你。"),
    ]
    for _iid, _name, _kind, _base_col, _stack, _desc in _EXTRA_GUN_MODS_MORE:
        if _iid in _ITEMS or _iid in _BULK_ITEMS:
            continue
        _seed = _bulk_item_seed(_iid)
        _BULK_ITEMS[_iid] = _ItemDef(
            _iid,
            _name,
            stack=int(_stack),
            color=_bulk_item_color(_base_col, _seed),
            kind=str(_kind),
            desc=str(_desc),
        )

    for _iid, _idef in _BULK_ITEMS.items():
        if _iid not in _ITEMS:
            _ITEMS[_iid] = _idef

    _ICON_PAL = {
        "K": (18, 18, 22),
        "G": (190, 190, 200),
        "W": (240, 240, 240),
        "R": (240, 120, 120),
        "C": (220, 70, 80),
        "c": (170, 50, 60),
        "B": (120, 170, 230),
        "Y": (230, 220, 140),
        "O": (210, 170, 90),
        "S": (150, 150, 160),
        "T": (150, 110, 70),
    }

    _ICON_PISTOL = sprite_from_pixels(
        [
            "        ",
            "   GGG  ",
            "  GKKG  ",
            "  GGGG  ",
            "    KG  ",
            "   GKG  ",
            "    G   ",
            "        ",
        ],
        _ICON_PAL,
    )
    _ICON_AMMO = sprite_from_pixels(
        [
            "        ",
            "  YYYY  ",
            "  YYYY  ",
            "  YYYY  ",
            "   YY   ",
            "   YY   ",
            "        ",
            "        ",
        ],
        _ICON_PAL,
    )
    _ICON_FOOD = sprite_from_pixels(
        [
            "        ",
            "  OOOO  ",
            " OOOOOO ",
            " OOKKOO ",
            " OOOOOO ",
            "  OOOO  ",
            "        ",
            "        ",
        ],
        _ICON_PAL,
    )
    _ICON_WATER = sprite_from_pixels(
        [
            "        ",
            "   BB   ",
            "   BB   ",
            "  BBBB  ",
            "  BBBB  ",
            "  BBBB  ",
            "   BB   ",
            "        ",
        ],
        _ICON_PAL,
    )
    _ICON_COLA = sprite_from_pixels(
        [
            "        ",
            "  CCCC  ",
            " CCCCC  ",
            " CWWWC  ",
            " CCCCC  ",
            "  CCCC  ",
            "   CC   ",
            "        ",
        ],
        _ICON_PAL,
    )
    _ICON_BANDAGE = sprite_from_pixels(
        [
            "        ",
            "  WWWW  ",
            "  WKKW  ",
            "  WWWW  ",
            "  WKKW  ",
            "  WWWW  ",
            "        ",
            "        ",
        ],
        _ICON_PAL,
    )
    _ICON_MEDKIT = sprite_from_pixels(
        [
            "        ",
            "  RRRR  ",
            "  RWWR  ",
            "  RWWR  ",
            "  RRRR  ",
            "   RR   ",
            "        ",
            "        ",
        ],
        _ICON_PAL,
    )
    _ICON_SCRAP = sprite_from_pixels(
        [
            "        ",
            "  SSSS  ",
            " SSKKSS ",
            " SSSSSS ",
            "  SSSS  ",
            "   SS   ",
            "        ",
            "        ",
        ],
        _ICON_PAL,
    )
    _ICON_WOOD = sprite_from_pixels(
        [
            "        ",
            "  TTTT  ",
            " TTKKTT ",
            " TTTTTT ",
            "  TTTT  ",
            "   TT   ",
            "        ",
            "        ",
        ],
        _ICON_PAL,
    )

    _ITEM_ICONS: dict[str, pygame.Surface] = {
        "pistol": _ICON_PISTOL,
        "ammo_9mm": _ICON_AMMO,
        "food_can": _ICON_FOOD,
        "water": _ICON_WATER,
        "cola": _ICON_COLA,
        "bandage": _ICON_BANDAGE,
        "medkit": _ICON_MEDKIT,
        "scrap": _ICON_SCRAP,
        "wood": _ICON_WOOD,
    }

    def _make_item_sprite_pistol() -> pygame.Surface:
        surf = pygame.Surface((20, 12), pygame.SRCALPHA)
        outline = (10, 10, 12)
        dark = (62, 62, 72)
        mid = (92, 92, 104)
        hi = (150, 150, 162)

        # Slide + barrel.
        pygame.draw.rect(surf, dark, pygame.Rect(2, 3, 14, 3))
        pygame.draw.rect(surf, hi, pygame.Rect(3, 4, 12, 1))
        pygame.draw.rect(surf, outline, pygame.Rect(2, 3, 14, 3), 1)
        pygame.draw.rect(surf, dark, pygame.Rect(16, 4, 2, 2))
        pygame.draw.rect(surf, outline, pygame.Rect(16, 4, 2, 2), 1)
        surf.set_at((18, 5), outline)  # muzzle
        pygame.draw.rect(surf, mid, pygame.Rect(9, 3, 3, 1))  # ejection port hint

        # Grip + trigger guard.
        pygame.draw.rect(surf, mid, pygame.Rect(8, 6, 5, 5))
        pygame.draw.rect(surf, outline, pygame.Rect(8, 6, 5, 5), 1)
        pygame.draw.rect(surf, dark, pygame.Rect(9, 6, 3, 2))
        pygame.draw.rect(surf, outline, pygame.Rect(9, 6, 3, 2), 1)
        pygame.draw.line(surf, outline, (7, 7), (8, 7), 1)
        # Trigger + grip texture.
        surf.set_at((9, 8), outline)
        for y in range(7, 11):
            if y % 2 == 0:
                surf.set_at((11, y), dark)

        return surf

    def _make_item_sprite_ammo() -> pygame.Surface:
        surf = pygame.Surface((16, 12), pygame.SRCALPHA)
        outline = (10, 10, 12)
        box = (120, 120, 132)
        box2 = (92, 92, 104)
        brass = (230, 220, 140)
        brass2 = (200, 180, 90)

        pygame.draw.rect(surf, box, pygame.Rect(2, 4, 12, 6), border_radius=2)
        pygame.draw.rect(surf, outline, pygame.Rect(2, 4, 12, 6), 1, border_radius=2)
        pygame.draw.rect(surf, box2, pygame.Rect(2, 8, 12, 2), border_radius=1)
        for i in range(3):
            x = 4 + i * 3
            pygame.draw.rect(surf, brass, pygame.Rect(x, 2, 2, 4))
            pygame.draw.rect(surf, brass2, pygame.Rect(x, 4, 2, 1))
            pygame.draw.rect(surf, outline, pygame.Rect(x, 2, 2, 4), 1)
        return surf

    def _make_item_sprite_food_can() -> pygame.Surface:
        surf = pygame.Surface((14, 12), pygame.SRCALPHA)
        outline = (10, 10, 12)
        can = (210, 170, 90)
        can2 = (170, 130, 70)
        label = (230, 220, 140)
        label2 = (200, 180, 90)

        pygame.draw.rect(surf, can, pygame.Rect(3, 2, 8, 9), border_radius=2)
        pygame.draw.rect(surf, outline, pygame.Rect(3, 2, 8, 9), 1, border_radius=2)
        pygame.draw.line(surf, label, (4, 5), (9, 5), 2)
        pygame.draw.line(surf, label2, (4, 7), (9, 7), 1)
        pygame.draw.line(surf, can2, (4, 3), (9, 3), 1)
        return surf

    def _make_item_sprite_water() -> pygame.Surface:
        surf = pygame.Surface((12, 14), pygame.SRCALPHA)
        outline = (10, 10, 12)
        water = (120, 170, 230)
        water2 = (90, 130, 190)
        cap = (220, 220, 230)

        # Cap.
        pygame.draw.rect(surf, cap, pygame.Rect(5, 1, 2, 2), border_radius=1)
        pygame.draw.rect(surf, outline, pygame.Rect(5, 1, 2, 2), 1, border_radius=1)

        # Neck.
        pygame.draw.rect(surf, water, pygame.Rect(5, 3, 2, 2), border_radius=1)
        pygame.draw.rect(surf, outline, pygame.Rect(5, 3, 2, 2), 1, border_radius=1)

        # Body.
        body = pygame.Rect(3, 5, 6, 8)
        pygame.draw.rect(surf, water, body, border_radius=3)
        pygame.draw.rect(surf, outline, body, 1, border_radius=3)

        # Label band.
        label = pygame.Rect(3, 8, 6, 2)
        pygame.draw.rect(surf, cap, label, border_radius=1)
        pygame.draw.rect(surf, outline, label, 1, border_radius=1)
        surf.set_at((5, 9), (255, 255, 255))

        # Highlights.
        pygame.draw.line(surf, water2, (4, 6), (4, 12), 1)
        pygame.draw.line(surf, cap, (8, 6), (8, 12), 1)
        return surf

    def _make_item_sprite_cola() -> pygame.Surface:
        surf = pygame.Surface((12, 14), pygame.SRCALPHA)
        outline = (10, 10, 12)
        red = (220, 70, 80)
        red2 = (170, 50, 60)
        white = (240, 240, 240)
        steel = (220, 220, 230)

        # Top.
        pygame.draw.rect(surf, steel, pygame.Rect(4, 1, 4, 2), border_radius=1)
        pygame.draw.rect(surf, outline, pygame.Rect(4, 1, 4, 2), 1, border_radius=1)

        # Can body.
        body = pygame.Rect(3, 3, 6, 10)
        pygame.draw.rect(surf, red, body, border_radius=2)
        pygame.draw.rect(surf, outline, body, 1, border_radius=2)
        pygame.draw.rect(surf, red2, pygame.Rect(3, 4, 2, 8), border_radius=1)
        pygame.draw.line(surf, steel, (8, 4), (8, 11), 1)  # right highlight

        # Logo wave (simple, readable at 2x in world).
        pygame.draw.line(surf, white, (4, 7), (7, 6), 2)
        pygame.draw.line(surf, white, (4, 9), (7, 8), 1)
        pygame.draw.line(surf, white, (4, 11), (7, 10), 1)
        pygame.draw.circle(surf, white, (6, 8), 1)  # badge

        # Bottom rim.
        pygame.draw.line(surf, steel, (4, 12), (7, 12), 1)
        surf.set_at((6, 2), outline)  # pull-tab hint
        return surf

    def _make_item_sprite_bandage() -> pygame.Surface:
        surf = pygame.Surface((14, 10), pygame.SRCALPHA)
        outline = (10, 10, 12)
        cloth = (240, 240, 240)
        cloth2 = (200, 200, 210)

        # Rolled bandage + loose tail.
        roll = pygame.Rect(2, 2, 7, 6)
        pygame.draw.ellipse(surf, cloth, roll)
        pygame.draw.ellipse(surf, outline, roll, 1)
        pygame.draw.ellipse(surf, cloth2, roll.inflate(-3, -3))
        pygame.draw.line(surf, outline, (roll.centerx, roll.top + 1), (roll.centerx, roll.bottom - 2), 1)

        tail = pygame.Rect(8, 4, 4, 3)
        pygame.draw.rect(surf, cloth, tail, border_radius=1)
        pygame.draw.rect(surf, outline, tail, 1, border_radius=1)
        pygame.draw.line(surf, cloth2, (tail.left + 1, tail.top + 1), (tail.right - 2, tail.top + 1), 1)
        return surf

    def _make_item_sprite_medkit() -> pygame.Surface:
        surf = pygame.Surface((16, 12), pygame.SRCALPHA)
        outline = (10, 10, 12)
        red = (240, 120, 120)
        red2 = (190, 90, 90)
        white = (240, 240, 240)

        pygame.draw.rect(surf, red, pygame.Rect(3, 3, 10, 7), border_radius=2)
        pygame.draw.rect(surf, outline, pygame.Rect(3, 3, 10, 7), 1, border_radius=2)
        pygame.draw.rect(surf, red2, pygame.Rect(3, 8, 10, 2), border_radius=1)
        pygame.draw.rect(surf, outline, pygame.Rect(6, 1, 4, 2), 1)  # handle
        pygame.draw.rect(surf, white, pygame.Rect(7, 5, 2, 4))
        pygame.draw.rect(surf, white, pygame.Rect(6, 6, 4, 2))
        return surf

    def _make_item_sprite_scrap() -> pygame.Surface:
        surf = pygame.Surface((14, 12), pygame.SRCALPHA)
        outline = (10, 10, 12)
        metal = (150, 150, 160)
        metal2 = (110, 110, 122)

        pygame.draw.polygon(surf, metal, [(2, 7), (5, 2), (12, 3), (10, 10), (4, 11)])
        pygame.draw.polygon(surf, outline, [(2, 7), (5, 2), (12, 3), (10, 10), (4, 11)], 1)
        pygame.draw.polygon(surf, metal2, [(6, 5), (11, 4), (9, 9), (5, 9)])
        pygame.draw.line(surf, metal2, (3, 8), (9, 6), 1)

        # Bolt plate.
        plate = pygame.Rect(1, 2, 5, 3)
        pygame.draw.rect(surf, metal2, plate, border_radius=1)
        pygame.draw.rect(surf, outline, plate, 1, border_radius=1)
        pygame.draw.circle(surf, metal, (plate.left + 2, plate.centery), 1)
        pygame.draw.circle(surf, outline, (plate.left + 2, plate.centery), 1, 1)
        return surf

    def _make_item_sprite_wood() -> pygame.Surface:
        surf = pygame.Surface((16, 10), pygame.SRCALPHA)
        outline = (10, 10, 12)
        wood = (150, 110, 70)
        wood2 = (120, 86, 56)
        wood3 = (176, 132, 86)

        # Back plank.
        back = pygame.Rect(4, 1, 10, 4)
        pygame.draw.rect(surf, wood2, back, border_radius=2)
        pygame.draw.rect(surf, outline, back, 1, border_radius=2)
        pygame.draw.line(surf, wood3, (back.left + 2, back.top + 1), (back.right - 3, back.top + 1), 1)

        # Front plank.
        front = pygame.Rect(2, 4, 12, 4)
        pygame.draw.rect(surf, wood, front, border_radius=2)
        pygame.draw.rect(surf, outline, front, 1, border_radius=2)
        for x in (4, 7, 10):
            pygame.draw.line(surf, wood2, (x, 5), (x, 7), 1)
        pygame.draw.circle(surf, wood2, (9, 6), 1)  # knot
        return surf

    _ITEM_SPRITES: dict[str, pygame.Surface] = {
        "pistol": _make_item_sprite_pistol(),
        "ammo_9mm": _make_item_sprite_ammo(),
        "food_can": _make_item_sprite_food_can(),
        "water": _make_item_sprite_water(),
        "cola": _make_item_sprite_cola(),
        "bandage": _make_item_sprite_bandage(),
        "medkit": _make_item_sprite_medkit(),
        "scrap": _make_item_sprite_scrap(),
        "wood": _make_item_sprite_wood(),
    }

    _ITEM_SPRITES_WORLD: dict[str, pygame.Surface] = {}
    for _iid, _spr in _ITEM_SPRITES.items():
        try:
            # World loot should be smaller than the player sprite (12x16).
            # We keep the detailed sprite, but scale it down to a small icon-like
            # footprint so ground drops don't look oversized.
            max_px = 11
            sw, sh = int(_spr.get_width()), int(_spr.get_height())
            biggest = max(1, max(int(sw), int(sh)))
            scale = min(1.0, float(max_px) / float(biggest))
            if scale < 1.0:
                nw = max(1, int(round(float(sw) * scale)))
                nh = max(1, int(round(float(sh) * scale)))
                _ITEM_SPRITES_WORLD[_iid] = pygame.transform.scale(_spr, (int(nw), int(nh)))
            else:
                _ITEM_SPRITES_WORLD[_iid] = _spr
        except Exception:
            _ITEM_SPRITES_WORLD[_iid] = _spr

    for _iid, _spr in _ITEM_SPRITES.items():
        try:
            if _iid not in _ITEM_ICONS:
                _ITEM_ICONS[_iid] = pygame.transform.scale(_spr, (8, 8))
        except Exception:
            pass

    # Keep pistol visuals consistent across world + inventory + in-hand.
    try:
        _ps = _ITEM_SPRITES_WORLD.get("pistol")
        if _ps is not None:
            bw, bh = int(_ps.get_width()), int(_ps.get_height())
            scale = min(8.0 / max(1.0, float(bw)), 8.0 / max(1.0, float(bh)))
            tw = int(max(1, round(float(bw) * scale)))
            th = int(max(1, round(float(bh) * scale)))
            thumb = pygame.transform.scale(_ps, (tw, th))
            icon = pygame.Surface((8, 8), pygame.SRCALPHA)
            icon.blit(thumb, (int((8 - tw) // 2), int((8 - th) // 2)))
            _ITEM_ICONS["pistol"] = icon
    except Exception:
        pass

    def _make_hand_pistol_sprite(_src: pygame.Surface = _ITEM_SPRITES_WORLD["pistol"]) -> pygame.Surface:
        # Keep the held pistol consistent with the pickup sprite.
        return _src

    _GUN_HAND_SPRITES: dict[str, pygame.Surface] = {
        "pistol": _make_hand_pistol_sprite(),
    }

    # Auto item sprites for the bulk item library.

    @staticmethod
    def _rgb_shift(col: tuple[int, int, int], dr: int = 0, dg: int = 0, db: int = 0) -> tuple[int, int, int]:
        r, g, b = int(col[0]) + int(dr), int(col[1]) + int(dg), int(col[2]) + int(db)
        return (int(clamp(r, 0, 255)), int(clamp(g, 0, 255)), int(clamp(b, 0, 255)))

    @staticmethod
    def _rgb_lerp(a: tuple[int, int, int], b: tuple[int, int, int], t: float) -> tuple[int, int, int]:
        t = float(clamp(float(t), 0.0, 1.0))
        return (
            int(clamp(int(round(float(a[0]) + (float(b[0]) - float(a[0])) * t)), 0, 255)),
            int(clamp(int(round(float(a[1]) + (float(b[1]) - float(a[1])) * t)), 0, 255)),
            int(clamp(int(round(float(a[2]) + (float(b[2]) - float(a[2])) * t)), 0, 255)),
        )

    @staticmethod
    def _make_item_icon_from_sprite(spr: pygame.Surface) -> pygame.Surface:
        bw, bh = int(spr.get_width()), int(spr.get_height())
        scale = min(8.0 / max(1.0, float(bw)), 8.0 / max(1.0, float(bh)))
        scale = float(min(1.0, float(scale)))
        tw = int(max(1, round(float(bw) * float(scale))))
        th = int(max(1, round(float(bh) * float(scale))))
        thumb = pygame.transform.scale(spr, (int(tw), int(th))) if (tw != bw or th != bh) else spr
        icon = pygame.Surface((8, 8), pygame.SRCALPHA)
        icon.blit(thumb, (int((8 - tw) // 2), int((8 - th) // 2)))
        return icon

    @staticmethod
    def _make_item_world_sprite(spr: pygame.Surface, *, max_px: int = 11) -> pygame.Surface:
        max_px = int(max(2, int(max_px)))
        sw, sh = int(spr.get_width()), int(spr.get_height())
        biggest = max(1, max(int(sw), int(sh)))
        scale = min(1.0, float(max_px) / float(biggest))
        if scale >= 1.0:
            return spr
        nw = max(1, int(round(float(sw) * float(scale))))
        nh = max(1, int(round(float(sh) * float(scale))))
        return pygame.transform.scale(spr, (int(nw), int(nh)))

    @staticmethod
    def _make_item_sprite_auto(item_id: str, idef) -> pygame.Surface:
        item_id = str(item_id or "")
        seed = 0
        for ch in item_id:
            seed = (seed * 131 + ord(ch)) & 0xFFFFFFFF

        base_col = (180, 180, 192)
        kind = ""
        if idef is not None:
            try:
                base_col = (int(idef.color[0]), int(idef.color[1]), int(idef.color[2]))
                kind = str(getattr(idef, "kind", ""))
            except Exception:
                pass

        outline = (10, 10, 12)

        if item_id in ("cup", "cup_water"):
            surf = pygame.Surface((12, 12), pygame.SRCALPHA)
            cup_col = (232, 232, 238)
            cup_sh = (200, 200, 210)
            water_col = (120, 170, 230)
            body = pygame.Rect(3, 4, 6, 6)
            pygame.draw.rect(surf, cup_col, body, border_radius=2)
            pygame.draw.rect(surf, outline, body, 1, border_radius=2)
            # Rim highlight + base shadow.
            surf.fill((245, 245, 250), pygame.Rect(body.x + 1, body.y + 1, body.w - 2, 1))
            surf.fill(cup_sh, pygame.Rect(body.x + 1, body.bottom - 2, body.w - 2, 1))
            # Handle.
            handle = pygame.Rect(body.right - 1, body.y + 2, 2, 3)
            pygame.draw.rect(surf, cup_col, handle, border_radius=1)
            pygame.draw.rect(surf, outline, handle, 1, border_radius=1)
            if item_id == "cup_water":
                fill = pygame.Rect(body.x + 1, body.y + 2, body.w - 2, body.h - 3)
                pygame.draw.rect(surf, water_col, fill, border_radius=1)
                pygame.draw.rect(surf, outline, fill, 1, border_radius=1)
            return surf

        def seed_sign(shift: int) -> int:
            return -1 if (((int(seed) >> int(shift)) & 1) == 1) else 1

        accent = HardcoreSurvivalState._rgb_shift(
            base_col,
            45 * seed_sign(3),
            30 * seed_sign(7),
            35 * seed_sign(11),
        )
        accent2 = HardcoreSurvivalState._rgb_shift(accent, -35, -35, -35)

        def make_can(*, label: tuple[int, int, int]) -> pygame.Surface:
            surf = pygame.Surface((14, 12), pygame.SRCALPHA)
            can_body = HardcoreSurvivalState._rgb_lerp((210, 170, 90), base_col, 0.35)
            can_shadow = HardcoreSurvivalState._rgb_shift(can_body, -35, -35, -35)
            pygame.draw.rect(surf, can_body, pygame.Rect(3, 2, 8, 9), border_radius=2)
            pygame.draw.rect(surf, outline, pygame.Rect(3, 2, 8, 9), 1, border_radius=2)
            pygame.draw.line(surf, can_shadow, (4, 3), (9, 3), 1)
            pygame.draw.rect(surf, label, pygame.Rect(4, 5, 6, 3), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(4, 5, 6, 3), 1, border_radius=1)
            ink = HardcoreSurvivalState._rgb_shift(label, 55, 55, 55)
            for xx in range(5, 9, 2):
                surf.set_at((xx, 6), ink)
            return surf

        def make_bottle(*, cap: tuple[int, int, int], liquid: tuple[int, int, int], label: tuple[int, int, int]) -> pygame.Surface:
            surf = pygame.Surface((12, 14), pygame.SRCALPHA)
            liq2 = HardcoreSurvivalState._rgb_shift(liquid, -30, -30, -30)
            cap2 = HardcoreSurvivalState._rgb_shift(cap, -25, -25, -25)
            pygame.draw.rect(surf, cap, pygame.Rect(4, 1, 4, 2), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(4, 1, 4, 2), 1, border_radius=1)
            pygame.draw.rect(surf, cap2, pygame.Rect(5, 3, 2, 2), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(5, 3, 2, 2), 1, border_radius=1)
            body = pygame.Rect(3, 5, 6, 8)
            pygame.draw.rect(surf, liquid, body, border_radius=3)
            pygame.draw.rect(surf, outline, body, 1, border_radius=3)
            band = pygame.Rect(3, 8, 6, 2)
            pygame.draw.rect(surf, label, band, border_radius=1)
            pygame.draw.rect(surf, outline, band, 1, border_radius=1)
            pygame.draw.line(surf, liq2, (4, 6), (4, 12), 1)
            pygame.draw.line(surf, cap, (8, 6), (8, 12), 1)
            return surf

        def make_carton(*, body: tuple[int, int, int], band: tuple[int, int, int]) -> pygame.Surface:
            surf = pygame.Surface((12, 14), pygame.SRCALPHA)
            b2 = HardcoreSurvivalState._rgb_shift(body, -30, -30, -30)
            hi = HardcoreSurvivalState._rgb_shift(body, 25, 25, 25)
            box = pygame.Rect(3, 2, 6, 11)
            pygame.draw.rect(surf, body, box, border_radius=2)
            pygame.draw.rect(surf, outline, box, 1, border_radius=2)
            pygame.draw.polygon(surf, hi, [(3, 3), (6, 1), (9, 3)])
            pygame.draw.polygon(surf, outline, [(3, 3), (6, 1), (9, 3)], 1)
            pygame.draw.rect(surf, band, pygame.Rect(3, 8, 6, 2), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(3, 8, 6, 2), 1, border_radius=1)
            surf.set_at((6, 9), (240, 240, 240))
            pygame.draw.line(surf, b2, (8, 4), (8, 12), 1)
            pygame.draw.line(surf, outline, (8, 6), (10, 4), 1)
            return surf

        def make_bag(*, body: tuple[int, int, int], band: tuple[int, int, int]) -> pygame.Surface:
            surf = pygame.Surface((14, 14), pygame.SRCALPHA)
            b2 = HardcoreSurvivalState._rgb_shift(body, -35, -35, -35)
            hi = HardcoreSurvivalState._rgb_shift(body, 30, 30, 30)
            pts = [(3, 2), (11, 2), (10, 12), (4, 12)]
            pygame.draw.polygon(surf, body, pts)
            pygame.draw.polygon(surf, outline, pts, 1)
            pygame.draw.line(surf, hi, (4, 3), (10, 3), 1)
            pygame.draw.rect(surf, band, pygame.Rect(4, 6, 6, 3), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(4, 6, 6, 3), 1, border_radius=1)
            pygame.draw.line(surf, b2, (5, 11), (9, 11), 1)
            return surf

        def make_box(*, body: tuple[int, int, int], band: tuple[int, int, int]) -> pygame.Surface:
            surf = pygame.Surface((14, 12), pygame.SRCALPHA)
            b2 = HardcoreSurvivalState._rgb_shift(body, -35, -35, -35)
            hi = HardcoreSurvivalState._rgb_shift(body, 35, 35, 35)
            box = pygame.Rect(2, 3, 10, 7)
            pygame.draw.rect(surf, body, box, border_radius=2)
            pygame.draw.rect(surf, outline, box, 1, border_radius=2)
            pygame.draw.rect(surf, hi, pygame.Rect(3, 4, 8, 1))
            pygame.draw.rect(surf, b2, pygame.Rect(3, 9, 8, 1))
            pygame.draw.rect(surf, band, pygame.Rect(4, 6, 6, 2), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(4, 6, 6, 2), 1, border_radius=1)
            return surf

        def make_pills(
            *,
            body: tuple[int, int, int],
            label: tuple[int, int, int] | None = None,
            symbol: str = "cross",
        ) -> pygame.Surface:
            surf = pygame.Surface((14, 12), pygame.SRCALPHA)
            cap = (230, 230, 240)
            b2 = HardcoreSurvivalState._rgb_shift(body, -25, -25, -25)
            bottle = pygame.Rect(4, 2, 6, 9)
            pygame.draw.rect(surf, body, bottle, border_radius=3)
            pygame.draw.rect(surf, outline, bottle, 1, border_radius=3)
            pygame.draw.rect(surf, cap, pygame.Rect(5, 1, 4, 2), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(5, 1, 4, 2), 1, border_radius=1)
            pygame.draw.line(surf, b2, (5, 8), (8, 8), 1)
            if label is not None:
                band = pygame.Rect(bottle.x + 1, bottle.y + 4, bottle.w - 2, 2)
                pygame.draw.rect(surf, label, band, border_radius=1)
                pygame.draw.rect(surf, outline, band, 1, border_radius=1)

            sym = str(symbol or "cross")
            sym_col = (220, 80, 90) if sym != "blue" else (90, 160, 230)
            sym_col = sym_col if sym != "green" else (90, 200, 140)
            sym_col = sym_col if sym != "yellow" else (232, 190, 90)
            if sym == "dot":
                pygame.draw.circle(surf, sym_col, (7, 7), 2)
            else:
                pygame.draw.rect(surf, sym_col, pygame.Rect(6, 5, 2, 4))
                pygame.draw.rect(surf, sym_col, pygame.Rect(5, 6, 4, 2))
            return surf

        def make_key(*, metal: tuple[int, int, int]) -> pygame.Surface:
            surf = pygame.Surface((14, 10), pygame.SRCALPHA)
            m2 = HardcoreSurvivalState._rgb_shift(metal, -30, -30, -30)
            pygame.draw.circle(surf, metal, (4, 5), 3)
            pygame.draw.circle(surf, outline, (4, 5), 3, 1)
            pygame.draw.circle(surf, (0, 0, 0, 0), (4, 5), 1)
            pygame.draw.rect(surf, metal, pygame.Rect(6, 4, 7, 2))
            pygame.draw.rect(surf, outline, pygame.Rect(6, 4, 7, 2), 1)
            pygame.draw.rect(surf, metal, pygame.Rect(11, 6, 2, 2))
            pygame.draw.rect(surf, metal, pygame.Rect(9, 6, 1, 2))
            pygame.draw.line(surf, m2, (6, 5), (12, 5), 1)
            return surf

        def make_gas_can(*, body: tuple[int, int, int]) -> pygame.Surface:
            surf = pygame.Surface((14, 14), pygame.SRCALPHA)
            b2 = HardcoreSurvivalState._rgb_shift(body, -35, -35, -35)
            hi = HardcoreSurvivalState._rgb_shift(body, 30, 30, 30)
            can = pygame.Rect(3, 3, 8, 9)
            pygame.draw.rect(surf, body, can, border_radius=2)
            pygame.draw.rect(surf, outline, can, 1, border_radius=2)
            pygame.draw.rect(surf, hi, pygame.Rect(5, 2, 4, 2), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(5, 2, 4, 2), 1, border_radius=1)
            pygame.draw.rect(surf, b2, pygame.Rect(9, 4, 3, 2), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(9, 4, 3, 2), 1, border_radius=1)
            mark = (240, 240, 240)
            pygame.draw.line(surf, mark, (5, 6), (9, 10), 1)
            pygame.draw.line(surf, mark, (9, 6), (5, 10), 1)
            return surf

        def make_simple_tool(*, tool: str, body: tuple[int, int, int]) -> pygame.Surface:
            surf = pygame.Surface((16, 12), pygame.SRCALPHA)
            steel = (220, 220, 230)
            handle = body
            handle2 = HardcoreSurvivalState._rgb_shift(handle, -30, -30, -30)
            if tool == "flashlight":
                pygame.draw.rect(surf, handle, pygame.Rect(3, 5, 9, 4), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 5, 9, 4), 1, border_radius=2)
                pygame.draw.rect(surf, steel, pygame.Rect(12, 5, 2, 4), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(12, 5, 2, 4), 1, border_radius=1)
                pygame.draw.line(surf, handle2, (4, 8), (10, 8), 1)
                return surf
            if tool == "knife":
                pygame.draw.rect(surf, steel, pygame.Rect(3, 6, 9, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 6, 9, 2), 1, border_radius=1)
                pygame.draw.rect(surf, handle, pygame.Rect(12, 5, 2, 4), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(12, 5, 2, 4), 1, border_radius=1)
                return surf
            if tool == "hammer":
                pygame.draw.rect(surf, handle, pygame.Rect(7, 3, 2, 8), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(7, 3, 2, 8), 1, border_radius=1)
                pygame.draw.rect(surf, steel, pygame.Rect(4, 3, 8, 3), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(4, 3, 8, 3), 1, border_radius=1)
                pygame.draw.line(surf, handle2, (8, 5), (8, 10), 1)
                return surf
            if tool == "wrench":
                pygame.draw.polygon(surf, steel, [(4, 4), (7, 4), (12, 9), (9, 9)])
                pygame.draw.polygon(surf, outline, [(4, 4), (7, 4), (12, 9), (9, 9)], 1)
                pygame.draw.circle(surf, steel, (4, 4), 2)
                pygame.draw.circle(surf, outline, (4, 4), 2, 1)
                return surf
            if tool == "screwdriver":
                pygame.draw.rect(surf, handle, pygame.Rect(3, 6, 6, 3), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 6, 6, 3), 1, border_radius=2)
                pygame.draw.rect(surf, steel, pygame.Rect(9, 7, 5, 1))
                pygame.draw.rect(surf, outline, pygame.Rect(9, 7, 5, 1), 1)
                pygame.draw.line(surf, handle2, (4, 8), (7, 8), 1)
                return surf
            if tool == "crowbar":
                pygame.draw.line(surf, steel, (4, 9), (12, 3), 2)
                pygame.draw.line(surf, outline, (4, 9), (12, 3), 1)
                pygame.draw.line(surf, steel, (12, 3), (13, 4), 1)
                pygame.draw.line(surf, outline, (12, 3), (13, 4), 1)
                return surf
            if tool == "saw":
                pygame.draw.rect(surf, handle, pygame.Rect(3, 7, 4, 4), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 7, 4, 4), 1, border_radius=2)
                pygame.draw.rect(surf, steel, pygame.Rect(6, 4, 8, 4), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(6, 4, 8, 4), 1, border_radius=1)
                for xx in range(7, 14, 2):
                    surf.set_at((xx, 8), outline)
                return surf
            return make_box(body=body, band=HardcoreSurvivalState._rgb_shift(body, 45, 45, 45))

        def make_furniture(*, fkind: str, variant: str) -> pygame.Surface:
            surf = pygame.Surface((16, 16), pygame.SRCALPHA)
            col = base_col
            if variant == "old":
                col = HardcoreSurvivalState._rgb_shift(col, -25, -25, -25)
            elif variant == "new":
                col = HardcoreSurvivalState._rgb_shift(col, 20, 20, 20)
            elif variant == "broken":
                col = HardcoreSurvivalState._rgb_shift(col, -10, -10, -10)
            col2 = HardcoreSurvivalState._rgb_shift(col, -30, -30, -30)
            hi = HardcoreSurvivalState._rgb_shift(col, 25, 25, 25)
            steel = (220, 220, 230)
            if fkind == "chair":
                pygame.draw.rect(surf, col, pygame.Rect(5, 6, 6, 6), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(5, 6, 6, 6), 1, border_radius=2)
                pygame.draw.rect(surf, col2, pygame.Rect(5, 4, 6, 3), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(5, 4, 6, 3), 1, border_radius=1)
            elif fkind == "table":
                pygame.draw.rect(surf, col, pygame.Rect(3, 5, 10, 4), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 5, 10, 4), 1, border_radius=2)
                for xx in (5, 11):
                    pygame.draw.line(surf, col2, (xx, 9), (xx, 14), 1)
            elif fkind == "sofa":
                pygame.draw.rect(surf, col, pygame.Rect(3, 7, 10, 6), border_radius=3)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 7, 10, 6), 1, border_radius=3)
                pygame.draw.rect(surf, hi, pygame.Rect(4, 8, 8, 2), border_radius=1)
            elif fkind == "bed":
                pygame.draw.rect(surf, col, pygame.Rect(3, 6, 10, 7), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 6, 10, 7), 1, border_radius=2)
                pygame.draw.rect(surf, (240, 240, 240), pygame.Rect(4, 7, 4, 2), border_radius=1)
                pygame.draw.line(surf, col2, (4, 12), (12, 12), 1)
            elif fkind in ("cabinet", "wardrobe", "fridge"):
                pygame.draw.rect(surf, col, pygame.Rect(4, 3, 8, 11), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(4, 3, 8, 11), 1, border_radius=2)
                pygame.draw.line(surf, col2, (8, 4), (8, 13), 1)
                surf.set_at((7, 8), steel)
                surf.set_at((9, 8), steel)
            else:
                pygame.draw.rect(surf, col, pygame.Rect(4, 4, 8, 10), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(4, 4, 8, 10), 1, border_radius=2)
            pygame.draw.line(surf, hi, (5, 5), (10, 5), 1)
            if variant == "broken":
                pygame.draw.line(surf, outline, (5, 11), (11, 7), 1)
            return surf

        # choose by kind/id
        if kind == "key":
            return make_key(metal=HardcoreSurvivalState._rgb_lerp((220, 220, 240), base_col, 0.4))
        if kind == "fuel":
            return make_gas_can(body=HardcoreSurvivalState._rgb_lerp((220, 80, 70), base_col, 0.35))
        if kind == "ammo":
            if item_id == "ammo_rocket":
                surf = pygame.Surface((18, 12), pygame.SRCALPHA)
                tube = HardcoreSurvivalState._rgb_lerp((120, 120, 132), base_col, 0.55)
                tube2 = HardcoreSurvivalState._rgb_shift(tube, -28, -28, -28)
                nose = HardcoreSurvivalState._rgb_lerp((240, 140, 100), base_col, 0.25)
                nose2 = HardcoreSurvivalState._rgb_shift(nose, -28, -18, -18)
                pygame.draw.rect(surf, tube, pygame.Rect(3, 5, 12, 4), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 5, 12, 4), 1, border_radius=2)
                pygame.draw.rect(surf, tube2, pygame.Rect(3, 8, 12, 1), border_radius=1)
                pygame.draw.polygon(surf, nose, [(15, 5), (17, 7), (15, 9)])
                pygame.draw.polygon(surf, outline, [(15, 5), (17, 7), (15, 9)], 1)
                pygame.draw.line(surf, nose2, (15, 6), (16, 7), 1)
                # fins
                pygame.draw.line(surf, outline, (4, 4), (6, 5), 1)
                pygame.draw.line(surf, outline, (4, 10), (6, 9), 1)
                return surf
            box = HardcoreSurvivalState._rgb_lerp((120, 120, 132), base_col, 0.55)
            brass = (230, 220, 140)
            surf = pygame.Surface((16, 12), pygame.SRCALPHA)
            pygame.draw.rect(surf, box, pygame.Rect(2, 4, 12, 6), border_radius=2)
            pygame.draw.rect(surf, outline, pygame.Rect(2, 4, 12, 6), 1, border_radius=2)
            pygame.draw.rect(surf, HardcoreSurvivalState._rgb_shift(box, -28, -28, -28), pygame.Rect(2, 8, 12, 2), border_radius=1)
            for i in range(3):
                xx = 4 + i * 3
                pygame.draw.rect(surf, brass, pygame.Rect(xx, 2, 2, 4))
                pygame.draw.rect(surf, outline, pygame.Rect(xx, 2, 2, 4), 1)
            return surf
        if kind == "melee":
            surf = pygame.Surface((16, 12), pygame.SRCALPHA)
            col = HardcoreSurvivalState._rgb_lerp((200, 200, 210), base_col, 0.35)
            col2 = HardcoreSurvivalState._rgb_shift(col, -30, -30, -30)
            hi = HardcoreSurvivalState._rgb_shift(col, 30, 30, 30)
            wood = HardcoreSurvivalState._rgb_lerp((150, 110, 70), base_col, 0.20)
            if item_id == "melee_machete":
                pygame.draw.line(surf, col, (3, 9), (13, 3), 3)
                pygame.draw.line(surf, outline, (3, 9), (13, 3), 1)
                pygame.draw.line(surf, hi, (4, 8), (12, 4), 1)
                pygame.draw.rect(surf, wood, pygame.Rect(2, 8, 3, 3), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(2, 8, 3, 3), 1, border_radius=1)
                return surf
            if item_id == "melee_pipe":
                pygame.draw.line(surf, col, (3, 9), (13, 3), 3)
                pygame.draw.line(surf, outline, (3, 9), (13, 3), 1)
                pygame.draw.line(surf, col2, (4, 9), (12, 4), 1)
                return surf
            # club / bat (default)
            pygame.draw.line(surf, wood, (3, 9), (13, 3), 3)
            pygame.draw.line(surf, outline, (3, 9), (13, 3), 1)
            pygame.draw.line(surf, HardcoreSurvivalState._rgb_shift(wood, 22, 18, 12), (4, 8), (12, 4), 1)
            return surf
        if kind == "clothes":
            surf = pygame.Surface((14, 12), pygame.SRCALPHA)
            body = HardcoreSurvivalState._rgb_lerp((200, 200, 210), base_col, 0.35)
            body2 = HardcoreSurvivalState._rgb_shift(body, -30, -30, -30)
            hi = HardcoreSurvivalState._rgb_shift(body, 30, 30, 30)
            # sleeves
            pygame.draw.rect(surf, body2, pygame.Rect(1, 4, 4, 3), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(1, 4, 4, 3), 1, border_radius=1)
            pygame.draw.rect(surf, body2, pygame.Rect(9, 4, 4, 3), border_radius=1)
            pygame.draw.rect(surf, outline, pygame.Rect(9, 4, 4, 3), 1, border_radius=1)
            # torso
            pygame.draw.rect(surf, body, pygame.Rect(4, 3, 6, 8), border_radius=2)
            pygame.draw.rect(surf, outline, pygame.Rect(4, 3, 6, 8), 1, border_radius=2)
            pygame.draw.line(surf, hi, (5, 4), (8, 4), 1)
            return surf
        if kind == "gun":
            # keep guns consistent with the pistol sprite style, but differentiate silhouettes
            dark = (62, 62, 72)
            mid = (92, 92, 104)
            hi = (150, 150, 162)
            if item_id in ("ak47", "scar_l"):
                surf = pygame.Surface((22, 12), pygame.SRCALPHA)
                pygame.draw.rect(surf, dark, pygame.Rect(2, 4, 16, 3))
                pygame.draw.rect(surf, hi, pygame.Rect(3, 5, 14, 1))
                pygame.draw.rect(surf, outline, pygame.Rect(2, 4, 16, 3), 1)
                # stock
                pygame.draw.rect(surf, mid, pygame.Rect(1, 5, 3, 4), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(1, 5, 3, 4), 1, border_radius=1)
                # mag
                pygame.draw.rect(surf, mid, pygame.Rect(9, 7, 3, 4), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(9, 7, 3, 4), 1, border_radius=1)
                surf.set_at((18, 6), outline)
                return surf
            if item_id == "uzi":
                surf = pygame.Surface((20, 12), pygame.SRCALPHA)
                pygame.draw.rect(surf, dark, pygame.Rect(3, 4, 12, 3))
                pygame.draw.rect(surf, outline, pygame.Rect(3, 4, 12, 3), 1)
                pygame.draw.rect(surf, mid, pygame.Rect(6, 7, 3, 4), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(6, 7, 3, 4), 1, border_radius=1)
                pygame.draw.rect(surf, hi, pygame.Rect(4, 5, 10, 1))
                surf.set_at((15, 6), outline)
                return surf
            if item_id == "rpg":
                surf = pygame.Surface((22, 12), pygame.SRCALPHA)
                tube = HardcoreSurvivalState._rgb_lerp((120, 120, 132), base_col, 0.45)
                tube2 = HardcoreSurvivalState._rgb_shift(tube, -28, -28, -28)
                pygame.draw.rect(surf, tube, pygame.Rect(2, 5, 18, 4), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(2, 5, 18, 4), 1, border_radius=2)
                pygame.draw.rect(surf, tube2, pygame.Rect(2, 8, 18, 1), border_radius=1)
                pygame.draw.rect(surf, mid, pygame.Rect(7, 8, 4, 3), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(7, 8, 4, 3), 1, border_radius=1)
                return surf
            return HardcoreSurvivalState._make_item_sprite_pistol()
        if kind == "gun_mod":
            surf = pygame.Surface((16, 12), pygame.SRCALPHA)
            body = HardcoreSurvivalState._rgb_lerp((92, 92, 104), base_col, 0.35)
            hi2 = HardcoreSurvivalState._rgb_shift(body, 25, 25, 25)
            pygame.draw.rect(surf, body, pygame.Rect(3, 5, 10, 4), border_radius=2)
            pygame.draw.rect(surf, outline, pygame.Rect(3, 5, 10, 4), 1, border_radius=2)
            pygame.draw.rect(surf, hi2, pygame.Rect(4, 6, 8, 1), border_radius=1)
            # tiny rail notch
            pygame.draw.line(surf, outline, (5, 4), (11, 4), 1)
            return surf
        if kind == "med":
            iid = item_id
            # Use stronger label colors so meds don't all look identical.
            lab_pal = [
                (90, 160, 230),  # blue
                (232, 190, 90),  # yellow
                (90, 200, 140),  # green
                (180, 120, 220),  # purple
                (220, 80, 90),  # red
                (200, 200, 210),  # gray
            ]
            lab = lab_pal[int(seed % len(lab_pal))]
            lab = HardcoreSurvivalState._rgb_lerp(lab, accent, 0.25)

            if iid == "medkit":
                surf = make_box(body=HardcoreSurvivalState._rgb_lerp((240, 120, 120), base_col, 0.35), band=lab)
                white = (240, 240, 240)
                cx, cy = 7, 7
                pygame.draw.rect(surf, white, pygame.Rect(cx - 1, cy - 3, 2, 7))
                pygame.draw.rect(surf, white, pygame.Rect(cx - 3, cy - 1, 7, 2))
                pygame.draw.rect(surf, outline, pygame.Rect(cx - 3, cy - 3, 7, 7), 1)
                return surf

            if iid == "bandage" or ("bandage" in iid and "wipe" not in iid):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                cloth = (235, 235, 242)
                cloth2 = (200, 200, 210)
                roll = pygame.Rect(3, 4, 8, 5)
                pygame.draw.rect(surf, cloth, roll, border_radius=3)
                pygame.draw.rect(surf, outline, roll, 1, border_radius=3)
                pygame.draw.line(surf, cloth2, (4, 6), (10, 6), 1)
                pygame.draw.line(surf, cloth2, (4, 8), (10, 8), 1)
                pad = pygame.Rect(5, 5, 4, 3)
                pygame.draw.rect(surf, lab, pad, border_radius=1)
                pygame.draw.rect(surf, outline, pad, 1, border_radius=1)
                return surf

            if "splint" in iid:
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                wood = HardcoreSurvivalState._rgb_lerp((150, 110, 70), base_col, 0.35)
                wood2 = HardcoreSurvivalState._rgb_shift(wood, -30, -30, -30)
                pygame.draw.rect(surf, wood, pygame.Rect(3, 3, 3, 8), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 3, 3, 8), 1, border_radius=1)
                pygame.draw.rect(surf, wood, pygame.Rect(8, 3, 3, 8), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(8, 3, 3, 8), 1, border_radius=1)
                wrap = (235, 235, 242)
                pygame.draw.rect(surf, wrap, pygame.Rect(2, 6, 10, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(2, 6, 10, 2), 1, border_radius=1)
                pygame.draw.line(surf, wood2, (4, 10), (10, 10), 1)
                return surf

            if "antacid" in iid or "antidiarrheal" in iid or "charcoal" in iid:
                # Blister pack.
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                pack = (210, 210, 220)
                pack2 = (180, 180, 192)
                r = pygame.Rect(2, 3, 10, 7)
                pygame.draw.rect(surf, pack, r, border_radius=2)
                pygame.draw.rect(surf, outline, r, 1, border_radius=2)
                surf.fill(pack2, pygame.Rect(r.x + 1, r.bottom - 2, r.w - 2, 1))
                pill = (90, 200, 140) if "antacid" in iid else ((232, 190, 90) if "antidiarrheal" in iid else (90, 160, 230))
                for cx in (5, 8, 11):
                    pygame.draw.circle(surf, pill, (int(cx), 6), 2, 1)
                return surf

            if "ointment" in iid or "burncream" in iid:
                surf = pygame.Surface((16, 10), pygame.SRCALPHA)
                body = HardcoreSurvivalState._rgb_lerp((230, 230, 240), base_col, 0.35)
                tube = pygame.Rect(3, 3, 10, 4)
                pygame.draw.rect(surf, body, tube, border_radius=2)
                pygame.draw.rect(surf, outline, tube, 1, border_radius=2)
                cap = pygame.Rect(13, 4, 2, 2)
                pygame.draw.rect(surf, (90, 90, 104), cap, border_radius=1)
                pygame.draw.rect(surf, outline, cap, 1, border_radius=1)
                band = pygame.Rect(4, 4, 5, 2)
                pygame.draw.rect(surf, lab, band, border_radius=1)
                pygame.draw.rect(surf, outline, band, 1, border_radius=1)
                return surf

            if "wipe" in iid or "alcohol" in iid:
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                pack = HardcoreSurvivalState._rgb_lerp((180, 180, 192), base_col, 0.35)
                r = pygame.Rect(2, 4, 10, 6)
                pygame.draw.rect(surf, pack, r, border_radius=2)
                pygame.draw.rect(surf, outline, r, 1, border_radius=2)
                flap = pygame.Rect(4, 5, 6, 2)
                pygame.draw.rect(surf, lab, flap, border_radius=1)
                pygame.draw.rect(surf, outline, flap, 1, border_radius=1)
                surf.set_at((10, 8), (240, 240, 240))
                return surf

            if "saline" in iid or "glucose" in iid:
                # Simple IV bag.
                surf = pygame.Surface((12, 14), pygame.SRCALPHA)
                bag = (235, 235, 242)
                bag2 = (200, 200, 210)
                r = pygame.Rect(3, 2, 6, 10)
                pygame.draw.rect(surf, bag, r, border_radius=2)
                pygame.draw.rect(surf, outline, r, 1, border_radius=2)
                liquid = (90, 160, 230) if "saline" in iid else (232, 190, 90)
                pygame.draw.rect(surf, liquid, pygame.Rect(r.x + 1, r.y + 4, r.w - 2, 6), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(r.x + 1, r.y + 4, r.w - 2, 6), 1, border_radius=1)
                pygame.draw.line(surf, bag2, (6, 1), (6, 2), 1)
                pygame.draw.line(surf, outline, (6, 1), (6, 2), 1)
                pygame.draw.line(surf, outline, (6, 12), (6, 14), 1)
                return surf

            if "iodine" in iid or "antiseptic" in iid:
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                bottle = pygame.Rect(5, 2, 4, 9)
                liquid = (150, 90, 60) if "iodine" in iid else (90, 120, 150)
                pygame.draw.rect(surf, liquid, bottle, border_radius=2)
                pygame.draw.rect(surf, outline, bottle, 1, border_radius=2)
                pygame.draw.rect(surf, (230, 230, 236), pygame.Rect(5, 1, 4, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(5, 1, 4, 2), 1, border_radius=1)
                pygame.draw.rect(surf, lab, pygame.Rect(5, 6, 4, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(5, 6, 4, 2), 1, border_radius=1)
                return surf

            if "eye" in iid:
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                bottle = pygame.Rect(5, 2, 4, 9)
                body = (230, 230, 236)
                pygame.draw.rect(surf, body, bottle, border_radius=2)
                pygame.draw.rect(surf, outline, bottle, 1, border_radius=2)
                pygame.draw.rect(surf, (90, 160, 230), pygame.Rect(5, 6, 4, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(5, 6, 4, 2), 1, border_radius=1)
                drop = (90, 160, 230)
                pygame.draw.circle(surf, drop, (10, 9), 1)
                return surf

            if "thermometer" in iid:
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                pygame.draw.line(surf, (230, 230, 236), (7, 3), (7, 9), 1)
                pygame.draw.line(surf, outline, (7, 3), (7, 9), 1)
                pygame.draw.circle(surf, (220, 80, 90), (7, 10), 2)
                pygame.draw.circle(surf, outline, (7, 10), 2, 1)
                return surf

            if "mask" in iid:
                surf = pygame.Surface((14, 10), pygame.SRCALPHA)
                cloth = (235, 235, 242)
                cloth2 = (200, 200, 210)
                pygame.draw.rect(surf, cloth, pygame.Rect(4, 3, 6, 4), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(4, 3, 6, 4), 1, border_radius=2)
                pygame.draw.line(surf, cloth2, (2, 4), (4, 4), 1)
                pygame.draw.line(surf, cloth2, (10, 4), (12, 4), 1)
                pygame.draw.line(surf, cloth2, (2, 6), (4, 6), 1)
                pygame.draw.line(surf, cloth2, (10, 6), (12, 6), 1)
                return surf
            if "gloves" in iid:
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                glove = (235, 235, 242)
                glove2 = (200, 200, 210)
                pygame.draw.rect(surf, glove, pygame.Rect(3, 4, 4, 6), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 4, 4, 6), 1, border_radius=2)
                pygame.draw.rect(surf, glove, pygame.Rect(7, 3, 4, 7), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(7, 3, 4, 7), 1, border_radius=2)
                pygame.draw.line(surf, glove2, (4, 9), (6, 9), 1)
                pygame.draw.line(surf, glove2, (8, 9), (10, 9), 1)
                return surf
            if "syringe" in iid:
                surf = pygame.Surface((16, 10), pygame.SRCALPHA)
                steel = (230, 230, 236)
                pygame.draw.rect(surf, steel, pygame.Rect(3, 4, 9, 2))
                pygame.draw.rect(surf, outline, pygame.Rect(3, 4, 9, 2), 1)
                pygame.draw.line(surf, outline, (12, 5), (15, 5), 1)
                pygame.draw.line(surf, steel, (2, 3), (2, 7), 1)
                pygame.draw.line(surf, outline, (2, 3), (2, 7), 1)
                return surf
            # Default pill bottle with item-specific label/symbol so medicines differ.
            sym = "cross"
            if "antibiotic" in iid:
                sym = "blue"
            elif "vitamin" in iid:
                sym = "yellow"
            elif "sleep" in iid:
                sym = "dot"
            elif "pain" in iid:
                sym = "cross"
            elif "allergy" in iid:
                sym = "green"
            return make_pills(body=HardcoreSurvivalState._rgb_lerp((230, 230, 240), base_col, 0.35), label=lab, symbol=sym)
        if kind == "drink":
            parts = item_id.split("_")
            base = parts[1] if len(parts) >= 3 and parts[0] == "drink" else item_id
            flavor = parts[2] if len(parts) >= 3 and parts[0] == "drink" else ""

            # Flavor-coded label so drinks read differently at a glance.
            flavor_col = {
                "plain": accent,
                "lemon": (232, 190, 90),
                "orange": (230, 140, 70),
                "grape": (160, 110, 220),
                "peach": (232, 160, 190),
                "sugarfree": (170, 190, 190),
            }.get(str(flavor), accent)
            label = HardcoreSurvivalState._rgb_lerp(accent, flavor_col, 0.8)

            cap = (230, 230, 236)
            if base in ("water", "water_mineral", "sparkling"):
                cap = (120, 170, 230)
            elif base in ("tea",):
                cap = (90, 200, 140)
            elif base in ("coffee",):
                cap = (200, 170, 120)
            elif base in ("energy",):
                cap = (232, 190, 90)

            # Container silhouettes by type.
            if base in ("milk", "soymilk", "cocoa", "milk_choco"):
                body = HardcoreSurvivalState._rgb_lerp((240, 240, 240), base_col, 0.35)
                return make_carton(body=body, band=label)
            if base in ("beer", "wine"):
                liquid = HardcoreSurvivalState._rgb_lerp(base_col, (110, 80, 60) if base == "beer" else (150, 70, 90), 0.35)
                return make_bottle(cap=cap, liquid=liquid, label=label)
            if base in ("soda", "energy", "cola"):
                return make_can(label=label)
            return make_bottle(cap=cap, liquid=base_col, label=label)
        if kind == "food":
            parts = item_id.split("_")
            base = parts[1] if len(parts) >= 3 and parts[0] == "food" else item_id
            flavor = parts[2] if len(parts) >= 3 and parts[0] == "food" else ""

            # Flavor-coded label so variants read differently at a glance.
            flavor_col = {
                "plain": accent,
                "spicy": (230, 92, 72),
                "tomato": (230, 78, 86),
                "curry": (232, 190, 90),
                "garlic": (230, 230, 214),
                "bbq": (184, 124, 78),
                "pepper": (130, 130, 142),
                "sweet": (232, 160, 190),
            }.get(str(flavor), accent)
            label = HardcoreSurvivalState._rgb_lerp(accent, flavor_col, 0.75)
            ink = HardcoreSurvivalState._rgb_shift(label, 70, 70, 70)

            def blit_pat_centered(surf: pygame.Surface, rect: pygame.Rect, pat: list[str], col: tuple[int, int, int]) -> None:
                if not pat:
                    return
                pw = max(len(r) for r in pat)
                ph = len(pat)
                ox = int(rect.x + max(0, (int(rect.w) - int(pw)) // 2))
                oy = int(rect.y + max(0, (int(rect.h) - int(ph)) // 2))
                sw, sh = int(surf.get_width()), int(surf.get_height())
                for yy, row in enumerate(pat):
                    for xx, ch in enumerate(row):
                        if ch != "#":
                            continue
                        px = int(ox + xx)
                        py = int(oy + yy)
                        if 0 <= px < sw and 0 <= py < sh:
                            surf.set_at((px, py), col)

            # More distinct silhouettes for common foods.
            if base in ("bread",):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                crust = HardcoreSurvivalState._rgb_lerp((190, 132, 78), base_col, 0.45)
                crumb = HardcoreSurvivalState._rgb_shift(crust, 28, 28, 28)
                loaf = pygame.Rect(2, 4, 10, 6)
                pygame.draw.rect(surf, crust, loaf, border_radius=3)
                pygame.draw.rect(surf, outline, loaf, 1, border_radius=3)
                pygame.draw.rect(surf, crumb, pygame.Rect(loaf.x + 1, loaf.y + 1, loaf.w - 2, 1))
                for xx in (5, 8):
                    pygame.draw.line(surf, HardcoreSurvivalState._rgb_shift(crust, -22, -22, -22), (xx, loaf.y + 2), (xx, loaf.bottom - 2), 1)
                tag = pygame.Rect(5, 6, 4, 2)
                pygame.draw.rect(surf, label, tag, border_radius=1)
                pygame.draw.rect(surf, outline, tag, 1, border_radius=1)
                return surf
            if base in ("cheese",):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                cheese = HardcoreSurvivalState._rgb_lerp((232, 210, 110), base_col, 0.35)
                cheese2 = HardcoreSurvivalState._rgb_shift(cheese, -35, -35, -35)
                pts = [(3, 10), (11, 7), (11, 11)]
                pygame.draw.polygon(surf, cheese, pts)
                pygame.draw.polygon(surf, outline, pts, 1)
                pygame.draw.line(surf, cheese2, (6, 10), (11, 7), 1)
                for px, py in ((7, 9), (9, 10), (8, 11)):
                    surf.set_at((px, py), HardcoreSurvivalState._rgb_shift(cheese, -55, -55, -55))
                return surf
            if base in ("pickles", "nuts"):
                # Small jar (pickles / nuts).
                surf = pygame.Surface((12, 14), pygame.SRCALPHA)
                cap = (220, 220, 230)
                jar = (110, 170, 110) if base == "pickles" else HardcoreSurvivalState._rgb_lerp((160, 120, 80), base_col, 0.35)
                jar2 = HardcoreSurvivalState._rgb_shift(jar, -30, -30, -30)
                pygame.draw.rect(surf, cap, pygame.Rect(4, 1, 4, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(4, 1, 4, 2), 1, border_radius=1)
                body = pygame.Rect(3, 3, 6, 10)
                pygame.draw.rect(surf, jar, body, border_radius=3)
                pygame.draw.rect(surf, outline, body, 1, border_radius=3)
                band = pygame.Rect(3, 8, 6, 2)
                pygame.draw.rect(surf, label, band, border_radius=1)
                pygame.draw.rect(surf, outline, band, 1, border_radius=1)
                pygame.draw.line(surf, jar2, (4, 5), (4, 12), 1)
                return surf
            if base in ("energybar", "chocolate"):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                wrap = HardcoreSurvivalState._rgb_lerp((210, 170, 90), base_col, 0.35)
                wrap2 = HardcoreSurvivalState._rgb_shift(wrap, -35, -35, -35)
                bar = pygame.Rect(2, 5, 10, 4)
                pygame.draw.rect(surf, wrap, bar, border_radius=2)
                pygame.draw.rect(surf, outline, bar, 1, border_radius=2)
                pygame.draw.line(surf, wrap2, (3, 8), (10, 8), 1)
                band = pygame.Rect(4, 6, 6, 2)
                pygame.draw.rect(surf, label, band, border_radius=1)
                pygame.draw.rect(surf, outline, band, 1, border_radius=1)
                if base == "chocolate":
                    cocoa = HardcoreSurvivalState._rgb_lerp((110, 70, 60), base_col, 0.35)
                    pygame.draw.rect(surf, cocoa, pygame.Rect(3, 4, 8, 4), border_radius=1)
                    pygame.draw.rect(surf, outline, pygame.Rect(3, 4, 8, 4), 1, border_radius=1)
                    for xx in (6, 8):
                        pygame.draw.line(surf, HardcoreSurvivalState._rgb_shift(cocoa, -30, -30, -30), (xx, 5), (xx, 7), 1)
                return surf
            if base in ("candy",):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                wrap = HardcoreSurvivalState._rgb_lerp((232, 160, 190), base_col, 0.35)
                wrap2 = HardcoreSurvivalState._rgb_shift(wrap, -35, -35, -35)
                core = pygame.Rect(4, 5, 6, 4)
                pygame.draw.rect(surf, wrap, core, border_radius=2)
                pygame.draw.rect(surf, outline, core, 1, border_radius=2)
                pygame.draw.polygon(surf, wrap2, [(3, 6), (4, 5), (4, 9)])
                pygame.draw.polygon(surf, wrap2, [(10, 5), (10, 9), (11, 6)])
                pygame.draw.polygon(surf, outline, [(3, 6), (4, 5), (4, 9)], 1)
                pygame.draw.polygon(surf, outline, [(10, 5), (10, 9), (11, 6)], 1)
                band = pygame.Rect(5, 6, 4, 2)
                pygame.draw.rect(surf, label, band, border_radius=1)
                pygame.draw.rect(surf, outline, band, 1, border_radius=1)
                return surf
            if base in ("mealbox",):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                box = HardcoreSurvivalState._rgb_lerp((220, 220, 230), base_col, 0.35)
                box2 = HardcoreSurvivalState._rgb_shift(box, -35, -35, -35)
                br = pygame.Rect(2, 4, 10, 7)
                pygame.draw.rect(surf, box, br, border_radius=2)
                pygame.draw.rect(surf, outline, br, 1, border_radius=2)
                pygame.draw.rect(surf, box2, pygame.Rect(br.x + 1, br.y + 4, br.w - 2, 2), border_radius=1)
                pygame.draw.line(surf, outline, (br.x + 5, br.y + 1), (br.x + 5, br.bottom - 2), 1)
                band = pygame.Rect(4, 6, 6, 2)
                pygame.draw.rect(surf, label, band, border_radius=1)
                pygame.draw.rect(surf, outline, band, 1, border_radius=1)
                return surf
            if base in ("mre",):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                pouch = HardcoreSurvivalState._rgb_lerp((120, 140, 110), base_col, 0.35)
                pouch2 = HardcoreSurvivalState._rgb_shift(pouch, -30, -30, -30)
                pr = pygame.Rect(3, 3, 8, 8)
                pygame.draw.rect(surf, pouch, pr, border_radius=2)
                pygame.draw.rect(surf, outline, pr, 1, border_radius=2)
                pygame.draw.line(surf, outline, (pr.x + 1, pr.y + 2), (pr.right - 2, pr.y + 2), 1)
                pygame.draw.line(surf, pouch2, (pr.x + 1, pr.bottom - 2), (pr.right - 2, pr.bottom - 2), 1)
                band = pygame.Rect(4, 6, 6, 2)
                pygame.draw.rect(surf, label, band, border_radius=1)
                pygame.draw.rect(surf, outline, band, 1, border_radius=1)
                return surf
            if base in ("seaweed",):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                pack = HardcoreSurvivalState._rgb_lerp((70, 110, 80), base_col, 0.35)
                pack2 = HardcoreSurvivalState._rgb_shift(pack, -35, -35, -35)
                pr = pygame.Rect(3, 4, 8, 7)
                pygame.draw.rect(surf, pack, pr, border_radius=2)
                pygame.draw.rect(surf, outline, pr, 1, border_radius=2)
                pygame.draw.line(surf, pack2, (4, 9), (10, 9), 1)
                band = pygame.Rect(4, 6, 6, 2)
                pygame.draw.rect(surf, label, band, border_radius=1)
                pygame.draw.rect(surf, outline, band, 1, border_radius=1)
                return surf

            if base in ("riceball",):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                rice = (240, 240, 240)
                wrap = accent2
                pygame.draw.polygon(surf, rice, [(7, 2), (12, 11), (2, 11)])
                pygame.draw.polygon(surf, outline, [(7, 2), (12, 11), (2, 11)], 1)
                pygame.draw.rect(surf, wrap, pygame.Rect(6, 7, 3, 3), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(6, 7, 3, 3), 1, border_radius=1)
                return surf
            if base in ("sausage",):
                surf = pygame.Surface((14, 10), pygame.SRCALPHA)
                meat = HardcoreSurvivalState._rgb_lerp((200, 120, 120), base_col, 0.45)
                meat2 = HardcoreSurvivalState._rgb_shift(meat, -30, -30, -30)
                pygame.draw.rect(surf, meat, pygame.Rect(2, 4, 10, 3), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(2, 4, 10, 3), 1, border_radius=2)
                pygame.draw.line(surf, meat2, (3, 6), (10, 6), 1)
                return surf
            if base in ("noodle",):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                cup = HardcoreSurvivalState._rgb_lerp((240, 240, 240), base_col, 0.35)
                cup2 = HardcoreSurvivalState._rgb_shift(cup, -30, -30, -30)
                pygame.draw.polygon(surf, cup, [(4, 3), (10, 3), (11, 11), (3, 11)])
                pygame.draw.polygon(surf, outline, [(4, 3), (10, 3), (11, 11), (3, 11)], 1)
                pygame.draw.line(surf, cup2, (4, 10), (10, 10), 1)
                pygame.draw.rect(surf, accent, pygame.Rect(5, 6, 5, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(5, 6, 5, 2), 1, border_radius=1)
                return surf
            if base in ("tuna", "beans", "corn", "fruitcan", "soup") or "can" in base:
                surf = make_can(label=label)
                pat = {
                    "tuna": ["###", ".#.", ".#."],  # T
                    "beans": ["##.", "###", "##."],  # B
                    "corn": ["###", "#..", "###"],  # C
                    "fruitcan": ["###", "##.", "#.."],  # F
                    "soup": ["###", ".##", "##."],  # S
                }.get(str(base))
                if pat:
                    blit_pat_centered(surf, pygame.Rect(4, 5, 6, 3), pat, ink)
                return surf
            if base in ("chips", "jerky", "driedfruit"):
                surf = make_bag(body=base_col, band=label)
                pat = {
                    "chips": ["#.#.#", ".#.#.", "#.#.#"],
                    "jerky": ["#####", ".....", "#####"],
                    "driedfruit": ["#...#", ".#.#.", "#...#"],
                }.get(str(base))
                if pat:
                    blit_pat_centered(surf, pygame.Rect(4, 6, 6, 3), pat, ink)
                return surf
            if base in ("cereal", "crackers", "biscuit"):
                surf = make_box(body=base_col, band=label)
                pat = {
                    "cereal": [".###.", "#...#"],
                    "crackers": ["#.#.#", ".#.#."],
                    "biscuit": [".###.", "#.#.#"],
                }.get(str(base))
                if pat:
                    blit_pat_centered(surf, pygame.Rect(4, 6, 6, 2), pat, ink)
                return surf
            return make_box(body=base_col, band=label)
        if kind == "furniture":
            parts = item_id.split("_")
            fkind = parts[1] if len(parts) >= 3 and parts[0] == "furn" else "cabinet"
            variant = parts[2] if len(parts) >= 3 and parts[0] == "furn" else "old"
            return make_furniture(fkind=fkind, variant=variant)
        if kind in ("mat", "tool"):
            iid = item_id
            if iid in ("plank",):
                return HardcoreSurvivalState._make_item_sprite_wood()
            if iid in ("sheet_metal", "scrap"):
                return HardcoreSurvivalState._make_item_sprite_scrap()
            if iid in ("flashlight", "knife", "hammer", "saw", "wrench", "screwdriver", "crowbar"):
                return make_simple_tool(tool=iid if iid != "knife" else "knife", body=base_col)
            if iid in ("rope", "wire"):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                coil = HardcoreSurvivalState._rgb_lerp((150, 110, 70), base_col, 0.35) if iid == "rope" else (180, 180, 192)
                coil2 = HardcoreSurvivalState._rgb_shift(coil, -30, -30, -30)
                for r in (4, 3, 2):
                    pygame.draw.circle(surf, coil, (7, 6), r, 1)
                pygame.draw.circle(surf, coil2, (7, 6), 4, 1)
                return surf
            if iid == "duct_tape":
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                tape = HardcoreSurvivalState._rgb_lerp((180, 180, 192), base_col, 0.35)
                tape2 = HardcoreSurvivalState._rgb_shift(tape, -35, -35, -35)
                pygame.draw.circle(surf, tape, (7, 6), 4)
                pygame.draw.circle(surf, outline, (7, 6), 4, 1)
                pygame.draw.circle(surf, tape2, (7, 6), 2)
                pygame.draw.circle(surf, outline, (7, 6), 2, 1)
                return surf
            if iid in ("key_rv", "key_moto"):
                return make_key(metal=(220, 220, 240))
            if iid == "gas_can":
                return make_gas_can(body=HardcoreSurvivalState._rgb_lerp((220, 80, 70), base_col, 0.35))
            if iid == "battery":
                surf = pygame.Surface((12, 12), pygame.SRCALPHA)
                body = (90, 90, 104)
                top = (230, 230, 236)
                pygame.draw.rect(surf, body, pygame.Rect(3, 3, 6, 7), border_radius=2)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 3, 6, 7), 1, border_radius=2)
                pygame.draw.rect(surf, top, pygame.Rect(5, 2, 2, 2), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(5, 2, 2, 2), 1, border_radius=1)
                return surf
            if iid in ("paper", "book", "map"):
                surf = pygame.Surface((14, 12), pygame.SRCALPHA)
                page = (235, 235, 242)
                page2 = (200, 200, 210)
                pygame.draw.rect(surf, page, pygame.Rect(3, 3, 8, 7), border_radius=1)
                pygame.draw.rect(surf, outline, pygame.Rect(3, 3, 8, 7), 1, border_radius=1)
                if iid == "book":
                    cover = HardcoreSurvivalState._rgb_lerp((120, 110, 100), base_col, 0.45)
                    pygame.draw.rect(surf, cover, pygame.Rect(2, 3, 4, 7), border_radius=1)
                    pygame.draw.rect(surf, outline, pygame.Rect(2, 3, 4, 7), 1, border_radius=1)
                elif iid == "map":
                    pygame.draw.line(surf, page2, (4, 4), (10, 5), 1)
                    pygame.draw.line(surf, page2, (4, 6), (10, 7), 1)
                else:
                    for yy in (5, 7, 9):
                        pygame.draw.line(surf, page2, (4, yy), (10, yy), 1)
                return surf
            # fallback
            return make_box(body=base_col, band=accent)
        return make_box(body=base_col, band=accent)

    def _ensure_item_visuals(self, item_id: str) -> None:
        item_id = str(item_id or "")
        if not item_id:
            return
        if item_id in self._ITEM_SPRITES and item_id in self._ITEM_SPRITES_WORLD and item_id in self._ITEM_ICONS:
            return

        spr = self._ITEM_SPRITES.get(item_id)
        if spr is None:
            idef = self._ITEMS.get(item_id)
            try:
                spr = self._make_item_sprite_auto(item_id, idef)
            except Exception:
                spr = pygame.Surface((12, 12), pygame.SRCALPHA)
                pygame.draw.rect(spr, (60, 60, 72), pygame.Rect(2, 2, 8, 8), border_radius=2)
                pygame.draw.rect(spr, (10, 10, 12), pygame.Rect(2, 2, 8, 8), 1, border_radius=2)
            self._ITEM_SPRITES[item_id] = spr

        if item_id not in self._ITEM_SPRITES_WORLD:
            try:
                self._ITEM_SPRITES_WORLD[item_id] = self._make_item_world_sprite(spr, max_px=11)
            except Exception:
                self._ITEM_SPRITES_WORLD[item_id] = spr

        if item_id not in self._ITEM_ICONS:
            try:
                self._ITEM_ICONS[item_id] = self._make_item_icon_from_sprite(spr)
            except Exception:
                pass

    @dataclass
    class _ItemStack:
        item_id: str
        qty: int
        meta: dict[str, object] = field(default_factory=dict)

    @dataclass
    class _WorldItem:
        pos: pygame.Vector2
        item_id: str
        qty: int

    @dataclass
    class _MapMarker:
        tx: int
        ty: int
        label: str
        color: tuple[int, int, int] = (255, 220, 140)

    @dataclass
    class _HitFX:
        pos: pygame.Vector2
        vel: pygame.Vector2
        ttl: float
        color: tuple[int, int, int] = (170, 80, 90)  # blood-ish

    @dataclass
    class _ParkedCar:
        pos: pygame.Vector2
        model_id: str
        heading: float = 0.0
        steer_state: int = 0
        frame: int = 0
        fuel: float = 0.0

    @dataclass
    class _ParkedBike:
        pos: pygame.Vector2
        model_id: str
        dir: str = "right"
        frame: int = 0
        fuel: float = 0.0

    @dataclass
    class _WorldProp:
        pos: pygame.Vector2
        prop_id: str
        variant: int = 0
        dir: str = "down"

    @dataclass(frozen=True)
    class _PropDef:
        id: str
        name: str
        category: str
        solid: bool = False
        collider: tuple[int, int] = (10, 10)  # px, for collisions (centered on pos)
        sprites: tuple[pygame.Surface, ...] = ()

    def _make_prop_sprite_sign(*, bg: tuple[int, int, int], accent: tuple[int, int, int], icon: str) -> pygame.Surface:
        surf = pygame.Surface((14, 10), pygame.SRCALPHA)
        outline = (10, 10, 12)
        border = pygame.Rect(1, 1, 12, 8)
        pygame.draw.rect(surf, bg, border, border_radius=2)
        pygame.draw.rect(surf, outline, border, 1, border_radius=2)
        pygame.draw.rect(surf, accent, pygame.Rect(1, 7, 12, 2), border_radius=1)
        # Small icon in the middle (readable at 1x).
        cx, cy = 7, 4
        if icon == "cross":
            red = (240, 80, 90)
            pygame.draw.rect(surf, red, pygame.Rect(cx - 1, cy - 2, 2, 5))
            pygame.draw.rect(surf, red, pygame.Rect(cx - 2, cy - 1, 5, 2))
        elif icon == "cart":
            white = (240, 240, 240)
            pygame.draw.rect(surf, white, pygame.Rect(cx - 3, cy - 1, 6, 3), 1)
            pygame.draw.line(surf, white, (cx - 4, cy - 2), (cx - 1, cy - 2), 1)
            pygame.draw.line(surf, white, (cx - 1, cy - 2), (cx + 1, cy + 1), 1)
            surf.set_at((cx - 2, cy + 2), white)
            surf.set_at((cx + 2, cy + 2), white)
        elif icon == "gun":
            # Tiny pistol silhouette (readable at 1x).
            steel = (230, 230, 236)
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 3, cy - 1, 6, 2))
            pygame.draw.rect(surf, outline, pygame.Rect(cx - 3, cy - 1, 6, 2), 1)
            pygame.draw.rect(surf, steel, pygame.Rect(cx + 3, cy - 1, 2, 1))
            pygame.draw.rect(surf, outline, pygame.Rect(cx + 3, cy - 1, 2, 1), 1)
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 1, cy + 1, 2, 3))
            pygame.draw.rect(surf, outline, pygame.Rect(cx - 1, cy + 1, 2, 3), 1)
            surf.set_at((cx + 5, cy - 1), outline)
        elif icon == "school":
            blue = (130, 190, 240)
            pygame.draw.rect(surf, blue, pygame.Rect(cx - 3, cy - 2, 6, 5), 1)
            pygame.draw.line(surf, blue, (cx - 3, cy - 1), (cx + 2, cy - 2), 1)
            pygame.draw.line(surf, blue, (cx - 3, cy + 1), (cx + 2, cy), 1)
        elif icon == "bars":
            steel = (220, 220, 230)
            for dx in (-2, 0, 2):
                pygame.draw.line(surf, steel, (cx + dx, cy - 2), (cx + dx, cy + 2), 1)
            pygame.draw.line(surf, steel, (cx - 3, cy - 2), (cx + 3, cy - 2), 1)
            pygame.draw.line(surf, steel, (cx - 3, cy + 2), (cx + 3, cy + 2), 1)
        elif icon == "tower":
            steel = (220, 220, 230)
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 2, cy - 3, 5, 7), 1)
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 1, cy - 2, 1, 1))
            pygame.draw.rect(surf, steel, pygame.Rect(cx + 1, cy - 1, 1, 1))
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 1, cy + 1, 1, 1))
        elif icon == "book":
            ink = (240, 240, 240)
            pygame.draw.rect(surf, ink, pygame.Rect(cx - 4, cy - 2, 4, 5), 1)
            pygame.draw.rect(surf, ink, pygame.Rect(cx, cy - 2, 4, 5), 1)
            pygame.draw.line(surf, ink, (cx, cy - 2), (cx, cy + 2), 1)
            surf.set_at((cx - 3, cy - 1), ink)
            surf.set_at((cx + 2, cy), ink)
        elif icon == "pagoda":
            gold = (240, 210, 130)
            red = (220, 90, 80)
            pygame.draw.line(surf, gold, (cx - 4, cy - 2), (cx + 4, cy - 2), 1)
            pygame.draw.line(surf, gold, (cx - 3, cy - 1), (cx + 3, cy - 1), 1)
            pygame.draw.line(surf, red, (cx - 4, cy), (cx + 4, cy), 1)
            pygame.draw.rect(surf, red, pygame.Rect(cx - 2, cy, 5, 3), 1)
            surf.set_at((cx, cy - 3), gold)
        elif icon == "fuel":
            white = (240, 240, 240)
            # Droplet silhouette.
            for dx, dy in (
                (0, -3),
                (-1, -2),
                (1, -2),
                (-2, -1),
                (2, -1),
                (-2, 0),
                (2, 0),
                (-1, 1),
                (1, 1),
                (0, 2),
            ):
                x = int(cx + dx)
                y = int(cy + dy)
                if 0 <= x < surf.get_width() and 0 <= y < surf.get_height():
                    surf.set_at((x, y), white)
        else:
            steel = (220, 220, 230)
            pygame.draw.rect(surf, steel, pygame.Rect(cx - 2, cy - 2, 4, 4), 1)
        return surf

    def _make_prop_sprite_billboard(*, variant: int = 0) -> pygame.Surface:
        surf = pygame.Surface((18, 10), pygame.SRCALPHA)
        outline = (10, 10, 12)
        paper = (200, 200, 210)
        grime = (130, 130, 140)
        frame = (70, 70, 86)
        board = pygame.Rect(1, 1, 16, 7)
        pygame.draw.rect(surf, frame, board, border_radius=2)
        pygame.draw.rect(surf, outline, board, 1, border_radius=2)
        pygame.draw.rect(surf, paper, pygame.Rect(2, 2, 14, 5), border_radius=1)
        # Torn / dirty lines.
        for i in range(3):
            y = 2 + i * 2
            pygame.draw.line(surf, grime, (3, y), (15, y), 1)
        if int(variant) % 2 == 1:
            pygame.draw.rect(surf, (240, 200, 120), pygame.Rect(2, 2, 4, 5))
        # Poles.
        pygame.draw.rect(surf, outline, pygame.Rect(5, 8, 2, 2))
        pygame.draw.rect(surf, outline, pygame.Rect(11, 8, 2, 2))
        return surf

    def _make_prop_sprite_seesaw(*, variant: int = 0) -> pygame.Surface:
        surf = pygame.Surface((16, 10), pygame.SRCALPHA)
        outline = (10, 10, 12)
        wood = (170, 130, 70)
        rust = (150, 90, 60)
        plank = pygame.Rect(1, 4, 14, 2)
        pygame.draw.rect(surf, wood, plank, border_radius=1)
        pygame.draw.rect(surf, outline, plank, 1, border_radius=1)
        pivot = pygame.Rect(7, 5, 2, 3)
        pygame.draw.rect(surf, rust, pivot, border_radius=1)
        pygame.draw.rect(surf, outline, pivot, 1, border_radius=1)
        # One broken seat.
        if int(variant) % 2 == 0:
            surf.set_at((2, 3), outline)
            surf.set_at((13, 6), outline)
        return surf

    def _make_prop_sprite_carousel(*, variant: int = 0) -> pygame.Surface:
        surf = pygame.Surface((16, 16), pygame.SRCALPHA)
        outline = (10, 10, 12)
        rust = (150, 90, 60)
        metal = (140, 140, 150)
        ring = pygame.Rect(2, 2, 12, 12)
        pygame.draw.ellipse(surf, metal, ring)
        pygame.draw.ellipse(surf, outline, ring, 1)
        pygame.draw.ellipse(surf, (110, 110, 122), ring.inflate(-6, -6))
        # Spokes + seats (some missing).
        cx, cy = 8, 8
        for i, (dx, dy) in enumerate(((0, -5), (4, -3), (5, 0), (4, 3), (0, 5), (-4, 3), (-5, 0), (-4, -3))):
            pygame.draw.line(surf, rust, (cx, cy), (cx + dx, cy + dy), 1)
            if int(variant) % 3 == 0 and i in (2, 6):
                continue
            surf.set_at((cx + dx, cy + dy), outline)
        return surf

    def _make_prop_sprite_swing(*, variant: int = 0) -> pygame.Surface:
        surf = pygame.Surface((16, 12), pygame.SRCALPHA)
        outline = (10, 10, 12)
        metal = (160, 160, 170)
        rust = (150, 90, 60)
        # Frame.
        pygame.draw.line(surf, metal, (3, 10), (6, 2), 1)
        pygame.draw.line(surf, metal, (13, 10), (10, 2), 1)
        pygame.draw.line(surf, metal, (6, 2), (10, 2), 1)
        pygame.draw.line(surf, outline, (3, 10), (6, 2), 1)
        pygame.draw.line(surf, outline, (13, 10), (10, 2), 1)
        pygame.draw.line(surf, outline, (6, 2), (10, 2), 1)
        # Chains + seat (one chain broken sometimes).
        pygame.draw.line(surf, rust, (7, 3), (7, 8), 1)
        if int(variant) % 2 == 0:
            pygame.draw.line(surf, rust, (9, 3), (9, 8), 1)
        pygame.draw.rect(surf, (90, 90, 110), pygame.Rect(6, 8, 4, 2), border_radius=1)
        pygame.draw.rect(surf, outline, pygame.Rect(6, 8, 4, 2), 1, border_radius=1)
        return surf

    def _make_prop_sprite_streetlamp(*, variant: int = 0) -> pygame.Surface:
        # Simple road-side lamp post (tall sprite; light itself is handled by the lighting system).
        w, h = 14, 30
        surf = pygame.Surface((w, h), pygame.SRCALPHA)
        outline = (10, 10, 12)
        pole = (130, 130, 140)
        pole2 = (96, 96, 106)
        glow = (255, 230, 150)

        # Pole.
        pygame.draw.rect(surf, pole, pygame.Rect(w // 2 - 1, 8, 2, 18))
        pygame.draw.rect(surf, pole2, pygame.Rect(w // 2, 8, 1, 18))
        pygame.draw.rect(surf, outline, pygame.Rect(w // 2 - 1, 8, 2, 18), 1)

        # Arm + head.
        arm_y = 8
        arm_w = 6
        if int(variant) % 2 == 0:
            pygame.draw.line(surf, pole, (w // 2, arm_y), (w // 2 + arm_w, arm_y + 2), 2)
            pygame.draw.line(surf, outline, (w // 2, arm_y), (w // 2 + arm_w, arm_y + 2), 1)
            head = pygame.Rect(w // 2 + arm_w - 2, arm_y + 1, 4, 4)
        else:
            pygame.draw.line(surf, pole, (w // 2, arm_y), (w // 2 - arm_w, arm_y + 2), 2)
            pygame.draw.line(surf, outline, (w // 2, arm_y), (w // 2 - arm_w, arm_y + 2), 1)
            head = pygame.Rect(w // 2 - arm_w - 2, arm_y + 1, 4, 4)
        pygame.draw.rect(surf, (34, 34, 42), head, border_radius=1)
        pygame.draw.rect(surf, outline, head, 1, border_radius=1)
        surf.fill(glow, head.inflate(-2, -2))

        # Base.
        base = pygame.Rect(w // 2 - 3, 25, 6, 3)
        pygame.draw.rect(surf, pole2, base, border_radius=1)
        pygame.draw.rect(surf, outline, base, 1, border_radius=1)
        return surf

    _PROP_DEFS: dict[str, _PropDef] = {
        # Building signs / markers.
        "sign_hospital": _PropDef(
            id="sign_hospital",
            name="医院招牌",
            category="招牌",
            solid=False,
            collider=(10, 8),
            sprites=(_make_prop_sprite_sign(bg=(220, 220, 230), accent=(200, 80, 90), icon="cross"),),
        ),
        "sign_shop": _PropDef(
            id="sign_shop",
            name="超市招牌",
            category="招牌",
            solid=False,
            collider=(10, 8),
            sprites=(_make_prop_sprite_sign(bg=(60, 60, 72), accent=(230, 200, 120), icon="cart"),),
        ),
        "sign_gas": _PropDef(
            id="sign_gas",
            name="加油站标识",
            category="建筑",
            solid=False,
            collider=(12, 8),
            sprites=(_make_prop_sprite_sign(bg=(46, 46, 56), accent=(240, 200, 120), icon="fuel"),),
        ),
        "sign_shop_big": _PropDef(
            id="sign_shop_big",
            name="大型超市招牌",
            category="招牌",
            solid=False,
            collider=(12, 8),
            sprites=(_make_prop_sprite_sign(bg=(70, 70, 86), accent=(240, 200, 120), icon="cart"),),
        ),
        "sign_gunshop": _PropDef(
            id="sign_gunshop",
            name="枪械店招牌",
            category="招牌",
            solid=False,
            collider=(12, 8),
            sprites=(_make_prop_sprite_sign(bg=(36, 36, 44), accent=(220, 140, 90), icon="gun"),),
        ),
        "sign_school": _PropDef(
            id="sign_school",
            name="学校标识牌",
            category="招牌",
            solid=False,
            collider=(10, 8),
            sprites=(_make_prop_sprite_sign(bg=(36, 44, 60), accent=(120, 180, 240), icon="school"),),
        ),
        "sign_prison": _PropDef(
            id="sign_prison",
            name="监狱警示牌",
            category="招牌",
            solid=False,
            collider=(12, 8),
            sprites=(_make_prop_sprite_sign(bg=(40, 40, 48), accent=(160, 160, 170), icon="bars"),),
        ),
        "sign_highrise": _PropDef(
            id="sign_highrise",
            name="高层住宅门牌",
            category="门牌",
            solid=False,
            collider=(10, 8),
            sprites=(_make_prop_sprite_sign(bg=(50, 50, 60), accent=(120, 120, 132), icon="tower"),),
        ),
        "sign_bookstore": _PropDef(
            id="sign_bookstore",
            name="新华书店招牌",
            category="招牌",
            solid=False,
            collider=(12, 8),
            sprites=(_make_prop_sprite_sign(bg=(38, 52, 88), accent=(240, 210, 130), icon="book"),),
        ),
        "sign_chinese": _PropDef(
            id="sign_chinese",
            name="中式建筑牌匾",
            category="招牌",
            solid=False,
            collider=(12, 8),
            sprites=(_make_prop_sprite_sign(bg=(70, 36, 36), accent=(240, 210, 130), icon="pagoda"),),
        ),
        "sign_home": _PropDef(
            id="sign_home",
            name="住宅门牌",
            category="门牌",
            solid=False,
            collider=(10, 8),
            sprites=(_make_prop_sprite_sign(bg=(58, 52, 46), accent=(170, 130, 70), icon="home"),),
        ),
        # City dressing.
        "billboard": _PropDef(
            id="billboard",
            name="破旧广告牌",
            category="广告",
            solid=False,
            collider=(16, 8),
            sprites=(
                _make_prop_sprite_billboard(variant=0),
                _make_prop_sprite_billboard(variant=1),
                _make_prop_sprite_billboard(variant=2),
            ),
        ),
        "streetlamp": _PropDef(
            id="streetlamp",
            name="路灯",
            category="路灯",
            solid=False,
            collider=(10, 10),
            sprites=(
                _make_prop_sprite_streetlamp(variant=0),
                _make_prop_sprite_streetlamp(variant=1),
            ),
        ),
        # Park toys (abandoned).
        "toy_seesaw": _PropDef(
            id="toy_seesaw",
            name="废弃跷跷板",
            category="公园设施",
            solid=True,
            collider=(16, 10),
            sprites=(_make_prop_sprite_seesaw(variant=0), _make_prop_sprite_seesaw(variant=1)),
        ),
        "toy_carousel": _PropDef(
            id="toy_carousel",
            name="废弃旋转木马",
            category="公园设施",
            solid=True,
            collider=(16, 16),
            sprites=(_make_prop_sprite_carousel(variant=0), _make_prop_sprite_carousel(variant=1), _make_prop_sprite_carousel(variant=2)),
        ),
        "toy_swing": _PropDef(
            id="toy_swing",
            name="废弃秋千",
            category="公园设施",
            solid=True,
            collider=(16, 12),
            sprites=(_make_prop_sprite_swing(variant=0), _make_prop_sprite_swing(variant=1)),
        ),
    }
    # Streetlamps must be solid so vehicles can't drive through them.
    try:
        _sl = _PROP_DEFS.get("streetlamp")
        if _sl is not None and not bool(getattr(_sl, "solid", False)):
            _PROP_DEFS["streetlamp"] = _PropDef(
                id=str(getattr(_sl, "id", "streetlamp")),
                name=str(getattr(_sl, "name", "streetlamp")),
                category=str(getattr(_sl, "category", "streetlamp")),
                solid=True,
                collider=tuple(getattr(_sl, "collider", (10, 10))),
                sprites=tuple(getattr(_sl, "sprites", ())),
            )
    except Exception:
        pass

    @dataclass
    class _Inventory:
        slots: list["HardcoreSurvivalState._ItemStack | None"]
        cols: int = 4

        def add(
            self,
            item_id: str,
            qty: int,
            item_defs: dict[str, "HardcoreSurvivalState._ItemDef"],
            *,
            meta: dict[str, object] | None = None,
        ) -> int:
            if qty <= 0:
                return 0
            idef = item_defs.get(item_id)
            if idef is None:
                return qty
            stack_max = max(1, int(idef.stack))
            meta = dict(meta) if isinstance(meta, dict) else None

            # Per-item metadata is only supported for non-stackable items for now.
            # (Guns/clothes/attachments are stack=1, so this is enough.)
            if meta is not None and stack_max > 1:
                meta = None

            left = int(qty)
            for slot in self.slots:
                if slot is None or slot.item_id != item_id:
                    continue
                if slot.qty >= stack_max:
                    continue
                take = min(stack_max - slot.qty, left)
                slot.qty += int(take)
                left -= int(take)
                if left <= 0:
                    return 0

            for i, slot in enumerate(self.slots):
                if slot is not None:
                    continue
                take = min(stack_max, left)
                st = HardcoreSurvivalState._ItemStack(item_id=item_id, qty=int(take))
                if meta is not None:
                    st.meta = dict(meta)
                self.slots[i] = st
                left -= int(take)
                if left <= 0:
                    return 0
            return left

        def drop_slot(self, index: int) -> "HardcoreSurvivalState._ItemStack | None":
            if not (0 <= index < len(self.slots)):
                return None
            stack = self.slots[index]
            self.slots[index] = None
            return stack

        def count(self, item_id: str) -> int:
            total = 0
            for slot in self.slots:
                if slot is not None and slot.item_id == item_id:
                    total += int(slot.qty)
            return int(total)

        def remove(self, item_id: str, qty: int) -> int:
            need = int(qty)
            if need <= 0:
                return 0
            removed = 0
            for i, slot in enumerate(self.slots):
                if need <= 0:
                    break
                if slot is None or slot.item_id != item_id:
                    continue
                take = min(int(slot.qty), need)
                slot.qty -= int(take)
                need -= int(take)
                removed += int(take)
                if slot.qty <= 0:
                    self.slots[i] = None
            return int(removed)

    @dataclass(frozen=True)
    class _GunDef:
        id: str
        name: str
        ammo_item: str
        mag_size: int
        fire_rate: float
        reload_s: float
        damage: int
        bullet_speed: float
        spread_deg: float
        noise_radius: float = 220.0
        muzzle_flash_s: float = 0.06
        bullet_ttl: float = 1.35
        bullet_kind: str = "bullet"  # "bullet" | "rocket"
        aoe_radius: float = 0.0  # px (rocket)
        aoe_damage: int = 0  # rocket splash base damage

    _GUNS: dict[str, _GunDef] = {
        "pistol": _GunDef(
            id="pistol",
            name="9mm手枪",
            ammo_item="ammo_9mm",
            mag_size=12,
            fire_rate=4.0,
            reload_s=1.15,
            damage=12,
            bullet_speed=260.0,
            spread_deg=4.0,
            noise_radius=210.0,
        ),
        "uzi": _GunDef(
            id="uzi",
            name="UZI 冲锋枪",
            ammo_item="ammo_9mm",
            mag_size=32,
            fire_rate=10.5,
            reload_s=1.75,
            damage=8,
            bullet_speed=270.0,
            spread_deg=7.0,
            noise_radius=240.0,
        ),
        "ak47": _GunDef(
            id="ak47",
            name="AK-47",
            ammo_item="ammo_762",
            mag_size=30,
            fire_rate=8.5,
            reload_s=2.25,
            damage=18,
            bullet_speed=310.0,
            spread_deg=6.0,
            noise_radius=300.0,
        ),
        "scar_l": _GunDef(
            id="scar_l",
            name="SCAR-L",
            ammo_item="ammo_556",
            mag_size=30,
            fire_rate=9.0,
            reload_s=2.10,
            damage=16,
            bullet_speed=330.0,
            spread_deg=5.0,
            noise_radius=290.0,
        ),
        "rpg": _GunDef(
            id="rpg",
            name="火箭筒",
            ammo_item="ammo_rocket",
            mag_size=1,
            fire_rate=0.65,
            reload_s=2.85,
            damage=80,
            bullet_speed=190.0,
            spread_deg=2.2,
            noise_radius=460.0,
            muzzle_flash_s=0.10,
            bullet_ttl=1.85,
            bullet_kind="rocket",
            aoe_radius=72.0,
            aoe_damage=55,
        ),
    }

    @dataclass(frozen=True)
    class _GunModDef:
        id: str
        name: str
        slot: str
        desc: str
        compat: tuple[str, ...]  # compatible gun ids
        mag_add: int = 0
        fire_rate_mult: float = 1.0
        reload_mult: float = 1.0
        damage_mult: float = 1.0
        damage_add: int = 0
        bullet_speed_mult: float = 1.0
        spread_mult: float = 1.0
        noise_mult: float = 1.0

    _GUN_MODS: dict[str, _GunModDef] = {
        # Optics
        "mod_optic_reddot": _GunModDef(
            id="mod_optic_reddot",
            name="红点瞄准镜",
            slot="optic",
            desc="小小一点红，准星说：我在这！",
            compat=("pistol", "uzi", "ak47", "scar_l"),
            spread_mult=0.78,
        ),
        "mod_optic_4x": _GunModDef(
            id="mod_optic_4x",
            name="4倍镜",
            slot="optic",
            desc="看得更远，也更容易把自己当狙击手。",
            compat=("ak47", "scar_l"),
            spread_mult=0.60,
        ),
        # Muzzle
        "mod_muzzle_suppressor_9mm": _GunModDef(
            id="mod_muzzle_suppressor_9mm",
            name="9mm 消音器",
            slot="muzzle",
            desc="‘噗’的一声，僵尸还没反应过来你已经跑了。",
            compat=("pistol", "uzi"),
            damage_mult=0.95,
            bullet_speed_mult=0.93,
            spread_mult=0.95,
            noise_mult=0.55,
        ),
        "mod_muzzle_suppressor_rifle": _GunModDef(
            id="mod_muzzle_suppressor_rifle",
            name="步枪消音器",
            slot="muzzle",
            desc="把吵闹收起来一点点——只是‘一点点’。",
            compat=("ak47", "scar_l"),
            damage_mult=0.96,
            bullet_speed_mult=0.94,
            spread_mult=0.95,
            noise_mult=0.60,
        ),
        "mod_muzzle_comp_rifle": _GunModDef(
            id="mod_muzzle_comp_rifle",
            name="补偿器",
            slot="muzzle",
            desc="后坐力：被你‘哄’得服服帖帖（但更吵）。",
            compat=("ak47", "scar_l"),
            spread_mult=0.86,
            noise_mult=1.10,
        ),
        # Stabilizers / grips
        "mod_undergrip_stab": _GunModDef(
            id="mod_undergrip_stab",
            name="稳定器前握把",
            slot="under",
            desc="握得更稳，心也更稳。",
            compat=("uzi", "ak47", "scar_l"),
            spread_mult=0.82,
        ),
        # Magazines
        "mod_mag_ext_pistol": _GunModDef(
            id="mod_mag_ext_pistol",
            name="手枪加长弹匣",
            slot="mag",
            desc="多几发子弹，多一点底气。",
            compat=("pistol",),
            mag_add=5,
            reload_mult=1.08,
        ),
        "mod_mag_ext_9mm": _GunModDef(
            id="mod_mag_ext_9mm",
            name="9mm 加长弹匣",
            slot="mag",
            desc="塞得更满，换弹更慢——很公平。",
            compat=("uzi",),
            mag_add=12,
            reload_mult=1.12,
        ),
        "mod_mag_ext_rifle": _GunModDef(
            id="mod_mag_ext_rifle",
            name="步枪加长弹匣",
            slot="mag",
            desc="一梭子更长，手忙脚乱也更长。",
            compat=("ak47", "scar_l"),
            mag_add=15,
            reload_mult=1.15,
        ),
        "mod_optic_holo": _GunModDef(
            id="mod_optic_holo",
            name="全息瞄准镜",
            slot="optic",
            desc="红点的亲戚：更清晰的框，更坚定的心。",
            compat=("pistol", "uzi", "ak47", "scar_l"),
            spread_mult=0.72,
        ),
        "mod_undergrip_bipod": _GunModDef(
            id="mod_undergrip_bipod",
            name="两脚架",
            slot="under",
            desc="趴下稳如狗，站起来随缘抖。",
            compat=("ak47", "scar_l"),
            spread_mult=0.72,
            reload_mult=1.08,
        ),
        "mod_stock_tactical": _GunModDef(
            id="mod_stock_tactical",
            name="战术枪托",
            slot="stock",
            desc="肩膀：我可以。后坐力：我不太行。",
            compat=("uzi", "ak47", "scar_l"),
            spread_mult=0.90,
        ),
        "mod_muzzle_flash_hider_rifle": _GunModDef(
            id="mod_muzzle_flash_hider_rifle",
            name="消焰器",
            slot="muzzle",
            desc="夜里别闪瞎自己：低调一点，但不够‘静’。",
            compat=("ak47", "scar_l"),
            spread_mult=0.94,
            noise_mult=0.85,
        ),
        "mod_trigger_light": _GunModDef(
            id="mod_trigger_light",
            name="轻量扳机组",
            slot="trigger",
            desc="手指更快，枪口更飘：快乐与代价同时到场。",
            compat=("pistol", "uzi"),
            fire_rate_mult=1.15,
            spread_mult=1.05,
        ),
        "mod_mag_drum_9mm": _GunModDef(
            id="mod_mag_drum_9mm",
            name="9mm 鼓包弹匣",
            slot="mag",
            desc="一梭子开到天荒地老；换弹也要等到天荒地老。",
            compat=("uzi",),
            mag_add=38,
            reload_mult=1.25,
        ),
        "mod_mag_drum_rifle": _GunModDef(
            id="mod_mag_drum_rifle",
            name="步枪 鼓包弹匣",
            slot="mag",
            desc="子弹多到你开始思考人生；换弹慢到人生开始思考你。",
            compat=("ak47", "scar_l"),
            mag_add=35,
            reload_mult=1.30,
        ),
    }

    @dataclass
    class _Gun:
        gun_id: str
        mag: int
        mods: dict[str, str] = field(default_factory=dict)
        cooldown_left: float = 0.0
        reload_left: float = 0.0
        reload_total: float = 0.0

    @dataclass
    class _Bullet:
        pos: pygame.Vector2
        vel: pygame.Vector2
        ttl: float
        dmg: int
        kind: str = "bullet"
        aoe_radius: float = 0.0
        aoe_damage: int = 0

    @dataclass
    class _ThrownFurniture:
        pos: pygame.Vector2
        vel: pygame.Vector2
        ttl: float
        tid: int
        offsets: list[tuple[int, int]]
        space: str = "world"  # home | rv | world
        hp: int | None = None

    @dataclass(frozen=True)
    class _MonsterDef:
        id: str
        name: str
        hp: int
        speed: float
        dmg: int
        sense: float
        attack_range: float
        attack_cd: float
        roam_speed: float
        scream_cd: float = 0.0
        scream_radius: float = 0.0
        scream_spawn: int = 0

    _MONSTER_DEFS: dict[str, _MonsterDef] = {
        "walker": _MonsterDef(
            id="walker",
            name="行尸",
            hp=26,
            speed=16.0,
            dmg=8,
            sense=120.0,
            attack_range=10.0,
            attack_cd=0.65,
            roam_speed=7.0,
        ),
        "runner": _MonsterDef(
            id="runner",
            name="奔跑者",
            hp=16,
            speed=24.0,
            dmg=12,
            sense=140.0,
            attack_range=12.0,
            attack_cd=0.90,
            roam_speed=11.0,
        ),
        "screamer": _MonsterDef(
            id="screamer",
            name="尖叫者",
            hp=18,
            speed=20.0,
            dmg=7,
            sense=150.0,
            attack_range=10.0,
            attack_cd=0.80,
            roam_speed=9.0,
            scream_cd=10.0,
            scream_radius=110.0,
            scream_spawn=4,
        ),
    }

    # Player melee (unarmed punch).
    _PUNCH_TOTAL_S = 0.26
    _PUNCH_WINDUP_S = 0.06
    _PUNCH_COOLDOWN_S = 0.28
    _PUNCH_HIT_T = 0.50  # 0..1 progress (hit near full extension)
    _PUNCH_RANGE_PX = 18.0
    _PUNCH_ARC_DOT = 0.28  # smaller => wider arc
    _PUNCH_DAMAGE = 7
    _PUNCH_STAGGER_S = 0.18
    _PUNCH_STAGGER_SPEED = 95.0

    @dataclass(frozen=True)
    class _MeleeDef:
        id: str
        name: str
        total_s: float
        windup_s: float
        cooldown_s: float
        hit_t: float
        range_px: float
        arc_dot: float
        damage: int
        stagger_s: float
        stagger_speed: float
        stamina_cost: float = 5.0
        noise_radius: float = 120.0
        visual_len: float = 0.0
        visual_thick: int = 2

    _MELEE_DEFS: dict[str, _MeleeDef] = {
        "fist": _MeleeDef(
            id="fist",
            name="鎷沖嚮",
            total_s=_PUNCH_TOTAL_S,
            windup_s=_PUNCH_WINDUP_S,
            cooldown_s=_PUNCH_COOLDOWN_S,
            hit_t=_PUNCH_HIT_T,
            range_px=_PUNCH_RANGE_PX,
            arc_dot=_PUNCH_ARC_DOT,
            damage=_PUNCH_DAMAGE,
            stagger_s=_PUNCH_STAGGER_S,
            stagger_speed=_PUNCH_STAGGER_SPEED,
            stamina_cost=5.0,
            noise_radius=120.0,
            visual_len=0.0,
            visual_thick=2,
        ),
        "melee_club": _MeleeDef(
            id="melee_club",
            name="\u6728\u68cd",
            total_s=0.36,
            windup_s=0.10,
            cooldown_s=0.42,
            hit_t=0.52,
            range_px=26.0,
            arc_dot=0.18,
            damage=11,
            stagger_s=0.20,
            stagger_speed=115.0,
            stamina_cost=7.0,
            noise_radius=150.0,
            visual_len=11.0,
            visual_thick=2,
        ),
        "melee_bat": _MeleeDef(
            id="melee_bat",
            name="\u68d2\u7403\u68cd",
            total_s=0.42,
            windup_s=0.12,
            cooldown_s=0.50,
            hit_t=0.54,
            range_px=30.0,
            arc_dot=0.16,
            damage=14,
            stagger_s=0.24,
            stagger_speed=135.0,
            stamina_cost=9.0,
            noise_radius=180.0,
            visual_len=13.0,
            visual_thick=3,
        ),
        "melee_pipe": _MeleeDef(
            id="melee_pipe",
            name="\u94c1\u7ba1",
            total_s=0.46,
            windup_s=0.13,
            cooldown_s=0.56,
            hit_t=0.55,
            range_px=28.0,
            arc_dot=0.20,
            damage=16,
            stagger_s=0.26,
            stagger_speed=150.0,
            stamina_cost=10.0,
            noise_radius=190.0,
            visual_len=12.0,
            visual_thick=3,
        ),
        "melee_machete": _MeleeDef(
            id="melee_machete",
            name="\u780d\u5200",
            total_s=0.34,
            windup_s=0.10,
            cooldown_s=0.40,
            hit_t=0.50,
            range_px=24.0,
            arc_dot=0.30,
            damage=18,
            stagger_s=0.16,
            stagger_speed=110.0,
            stamina_cost=8.0,
            noise_radius=140.0,
            visual_len=10.0,
            visual_thick=2,
        ),
    }

    _CLOTHES_OUTFIT_INDEX: dict[str, int] = {
        "clothes_jacket_blue": 0,
        "clothes_work_green": 1,
        "clothes_tactical_gray": 2,
        "clothes_prisoner_orange": 3,
        "clothes_medic_white": 4,
        "clothes_raincoat_yellow": 5,
        "clothes_hoodie_pink": 6,
        "clothes_denim_blue": 7,
        "clothes_chef_white": 8,
        "clothes_racing_red": 9,
        "clothes_xmas_green": 10,
        "clothes_black_suit": 11,
        "clothes_desert_camo": 12,
        "clothes_sport_cyan": 13,
        "clothes_pajama_bear": 14,
        "clothes_maid": 15,
    }

    _OUTFIT_TO_CLOTHES: dict[int, str] = {
        0: "clothes_jacket_blue",
        1: "clothes_work_green",
        2: "clothes_tactical_gray",
        3: "clothes_prisoner_orange",
        4: "clothes_medic_white",
        5: "clothes_raincoat_yellow",
        6: "clothes_hoodie_pink",
        7: "clothes_denim_blue",
        8: "clothes_chef_white",
        9: "clothes_racing_red",
        10: "clothes_xmas_green",
        11: "clothes_black_suit",
        12: "clothes_desert_camo",
        13: "clothes_sport_cyan",
        14: "clothes_pajama_bear",
        15: "clothes_maid",
    }
    # Zombie corpse/decay (keep bodies for a while instead of despawning instantly).
    _ZOMBIE_CORPSE_TOTAL_S = 14.0
    _ZOMBIE_FALL_S = 0.22
    _ZOMBIE_VEHICLE_HIT_CD_S = 0.18

    _BODY_PART_NAMES: dict[str, str] = {
        "head": "头部",
        "torso": "躯干",
        "left_arm": "左臂",
        "right_arm": "右臂",
        "left_leg": "左腿",
        "right_leg": "右腿",
    }

    @dataclass
    class _Zombie:
        pos: pygame.Vector2
        vel: pygame.Vector2
        hp: int
        speed: float
        kind: str = "walker"
        w: int = 10
        h: int = 10
        dir: str = "down"
        anim: float = 0.0
        attack_left: float = 0.0
        scream_left: float = 0.0
        wander_dir: pygame.Vector2 = field(default_factory=lambda: pygame.Vector2(0, 0))
        wander_left: float = 0.0
        stagger_left: float = 0.0
        stagger_vel: pygame.Vector2 = field(default_factory=lambda: pygame.Vector2(0, 0))
        # Death/decay (corpse stays for a while; used for vehicle kills too).
        corpse_total: float = 0.0
        corpse_left: float = 0.0
        death_t: float = 0.0
        # Cooldown so vehicles don't multi-hit the same zombie every tick while overlapping.
        vehicle_hit_left: float = 0.0

        def rect(self) -> pygame.Rect:
            return pygame.Rect(
                iround(float(self.pos.x) - float(self.w) / 2.0),
                iround(float(self.pos.y) - float(self.h) / 2.0),
                int(self.w),
                int(self.h),
            )

    @dataclass
    class _RV:
        pos: pygame.Vector2
        vel: pygame.Vector2
        model_id: str = "rv"
        fuel: float = 100.0
        heading: float = 0.0  # radians; 0 points right
        speed: float = 0.0  # px/s (signed)
        steer: float = 0.0  # radians (signed)
        w: int = 26
        h: int = 16

        def rect(self) -> pygame.Rect:
            return pygame.Rect(
                iround(float(self.pos.x) - float(self.w) / 2.0),
                iround(float(self.pos.y) - float(self.h) / 2.0),
                int(self.w),
                int(self.h),
            )

    @dataclass
    class _Bike:
        pos: pygame.Vector2
        vel: pygame.Vector2
        model_id: str = "bike"
        fuel: float = 0.0
        w: int = 14
        h: int = 10

        def rect(self) -> pygame.Rect:
            return pygame.Rect(
                iround(float(self.pos.x) - float(self.w) / 2.0),
                iround(float(self.pos.y) - float(self.h) / 2.0),
                int(self.w),
                int(self.h),
            )

    def _hash_u32(self, n: int) -> int:
        n &= 0xFFFFFFFF
        n ^= (n >> 16) & 0xFFFFFFFF
        n = (n * 0x7FEB352D) & 0xFFFFFFFF
        n ^= (n >> 15) & 0xFFFFFFFF
        n = (n * 0x846CA68B) & 0xFFFFFFFF
        n ^= (n >> 16) & 0xFFFFFFFF
        return n & 0xFFFFFFFF

    def _hash2_u32(self, x: int, y: int, seed: int) -> int:
        n = (x * 0x1F123BB5 + y * 0x05491333 + seed * 0x9E3779B9) & 0xFFFFFFFF
        return self._hash_u32(n)

    def _rand01(self, x: int, y: int, seed: int) -> float:
        return self._hash2_u32(x, y, seed) / 4294967296.0

    def _fade(self, t: float) -> float:
        return t * t * t * (t * (t * 6.0 - 15.0) + 10.0)

    def _lerp(self, a: float, b: float, t: float) -> float:
        return a + (b - a) * t

    def _noise2(self, x: float, y: float, seed: int) -> float:
        xi = math.floor(x)
        yi = math.floor(y)
        xf = x - xi
        yf = y - yi
        v00 = self._rand01(int(xi), int(yi), seed)
        v10 = self._rand01(int(xi) + 1, int(yi), seed)
        v01 = self._rand01(int(xi), int(yi) + 1, seed)
        v11 = self._rand01(int(xi) + 1, int(yi) + 1, seed)
        u = self._fade(float(xf))
        v = self._fade(float(yf))
        return self._lerp(self._lerp(v00, v10, u), self._lerp(v01, v11, u), v)

    def _fractal(self, x: float, y: float, seed: int) -> float:
        value = 0.0
        amp = 1.0
        total = 0.0
        freq = 1.0 / 64.0
        for octave in range(4):
            value += self._noise2(x * freq, y * freq, seed + octave * 101) * amp
            total += amp
            amp *= 0.5
            freq *= 2.0
        if total <= 0.0:
            return 0.0
        return value / total

    @dataclass(frozen=True)
    class _SpecialBuilding:
        kind: str  # e.g. "highrise"
        name: str
        tx0: int
        ty0: int
        w: int
        h: int
        door_tiles: tuple[tuple[int, int], ...]
        floors: int = 0

    @dataclass
    class _MultiHouse:
        tx0: int
        ty0: int
        w: int
        h: int
        floors: int
        cur_floor: int = 1
        floor_tiles: dict[int, list[int]] = field(default_factory=dict)  # floor -> w*h snapshot

    @dataclass
    class _Chunk:
        cx: int
        cy: int
        tiles: list[int]
        items: list["HardcoreSurvivalState._WorldItem"] = field(default_factory=list)
        buildings: list[tuple[int, int, int, int, int, int]] = field(default_factory=list)  # (tx0, ty0, w, h, roof_kind, floors) in world tiles
        special_buildings: list["HardcoreSurvivalState._SpecialBuilding"] = field(default_factory=list)
        multi_houses: list["HardcoreSurvivalState._MultiHouse"] = field(default_factory=list)
        cars: list["HardcoreSurvivalState._ParkedCar"] = field(default_factory=list)
        bikes: list["HardcoreSurvivalState._ParkedBike"] = field(default_factory=list)
        props: list["HardcoreSurvivalState._WorldProp"] = field(default_factory=list)
        town_kind: str | None = None

    class _World:
        def __init__(self, state: "HardcoreSurvivalState", seed: int) -> None:
            self.state = state
            self.seed = int(seed) & 0xFFFFFFFF
            self.chunks: dict[tuple[int, int], HardcoreSurvivalState._Chunk] = {}
            # Chunk streaming: we avoid generating new chunks during render (draw)
            # to prevent big hitches when the camera crosses chunk corners.
            self._gen_queue: list[tuple[int, int]] = []
            self._gen_queue_i = 0
            self._gen_queue_set: set[tuple[int, int]] = set()
            self.road_off_x = state._hash2_u32(7, 11, self.seed) % state.ROAD_PERIOD
            self.road_off_y = state._hash2_u32(13, 17, self.seed) % state.ROAD_PERIOD

            # Spawn-city: a dense urban region centered on the spawn road intersection.
            stx, sty = self.spawn_tile()
            self.city_cx = int(stx) // state.CHUNK_SIZE
            self.city_cy = int(sty) // state.CHUNK_SIZE
            self.city_radius = 5  # chunks
            self.city_period = 24  # minor street grid (tiles)
            self.city_w = 1  # half-width of minor streets (tiles)
            self.city_off_x = state._hash2_u32(29, 37, self.seed) % max(1, int(self.city_period))
            self.city_off_y = state._hash2_u32(41, 53, self.seed) % max(1, int(self.city_period))

            # Coastline (sea) near the city (for beach / boardwalk / wetlands).
            self.coast_dir = int(state._hash2_u32(61, 67, self.seed) % 4)  # 0=N,1=E,2=S,3=W
            coast_offset_chunks = int(self.city_radius) + 4
            if self.coast_dir == 0:  # north
                self.coast_line = (int(self.city_cy) - coast_offset_chunks) * int(state.CHUNK_SIZE)
            elif self.coast_dir == 1:  # east
                self.coast_line = (int(self.city_cx) + coast_offset_chunks) * int(state.CHUNK_SIZE)
            elif self.coast_dir == 2:  # south
                self.coast_line = (int(self.city_cy) + coast_offset_chunks) * int(state.CHUNK_SIZE)
            else:  # west
                self.coast_line = (int(self.city_cx) - coast_offset_chunks) * int(state.CHUNK_SIZE)

            # Abandoned highways: two wide bands around the city outskirts.
            self.highway_w = 4  # half-width (tiles)
            hw_off_y = int(state._hash2_u32(97, 101, self.seed) % (state.CHUNK_SIZE * 2)) - int(state.CHUNK_SIZE)
            hw_off_x = int(state._hash2_u32(103, 107, self.seed) % (state.CHUNK_SIZE * 2)) - int(state.CHUNK_SIZE)
            self.highway_y = (int(self.city_cy) + int(self.city_radius) + 2) * int(state.CHUNK_SIZE) + int(hw_off_y)
            self.highway_x = (int(self.city_cx) - int(self.city_radius) - 2) * int(state.CHUNK_SIZE) + int(hw_off_x)

            # Chinese residential compound (小区) near spawn: one enclosed community
            # with ~7-8 tall towers and a low-rise podium ("裙楼") around them.
            self.compound_w_chunks = 5
            self.compound_h_chunks = 5
            self.compound_cx0 = int(self.city_cx) - int(self.compound_w_chunks // 2)
            # Place the compound just north of spawn so you can approach the gate.
            self.compound_cy1 = int(self.city_cy) - 1
            self.compound_cy0 = int(self.compound_cy1) - int(self.compound_h_chunks - 1)
            self.compound_cx1 = int(self.compound_cx0) + int(self.compound_w_chunks) - 1
            self.compound_cy1 = int(self.compound_cy0) + int(self.compound_h_chunks) - 1
            self.compound_tx0 = int(self.compound_cx0) * int(state.CHUNK_SIZE)
            self.compound_ty0 = int(self.compound_cy0) * int(state.CHUNK_SIZE)
            self.compound_tx1 = (int(self.compound_cx1) + 1) * int(state.CHUNK_SIZE) - 1
            self.compound_ty1 = (int(self.compound_cy1) + 1) * int(state.CHUNK_SIZE) - 1

            # Internal road stripes (local coords within each chunk).
            # Keep roads a bit narrower so towers can be wider (bigger apartments).
            self.compound_road_v_x0 = 15
            self.compound_road_v_x1 = 16
            # Put the horizontal road at the very bottom so towers can be taller
            # (bigger apartments) without eating into the internal road.
            self.compound_road_h_y0 = 31
            self.compound_road_h_y1 = 31

            # Gate opening (south wall) aligned with the central chunk column.
            gate_cx = int(self.compound_cx0) + int(self.compound_w_chunks // 2)
            self.compound_gate_x0 = int(gate_cx) * int(state.CHUNK_SIZE) + int(self.compound_road_v_x0)
            self.compound_gate_x1 = int(gate_cx) * int(state.CHUNK_SIZE) + int(self.compound_road_v_x1)

            # Reserve entrance/parking chunks near the gate.
            self.compound_gate_chunks: set[tuple[int, int]] = {
                (int(gate_cx), int(self.compound_cy1)),
                (int(gate_cx) - 1, int(self.compound_cy1)),
                (int(gate_cx) + 1, int(self.compound_cy1)),
            }
            self.compound_parking_chunks: set[tuple[int, int]] = {
                (int(gate_cx) - 1, int(self.compound_cy1)),
                (int(gate_cx) + 1, int(self.compound_cy1)),
            }
            self.compound_towers_by_chunk: dict[
                tuple[int, int], list[tuple[int, int, int, int, int, int]]
            ] = self._plan_compound_towers(target=8)

            # Gas station (world-map POI): place one on the south highway near the main road,
            # so the player can drive there to refuel.
            try:
                stx, _sty = self.spawn_tile()
                self.gas_station_cx = int(stx) // int(state.CHUNK_SIZE)
                self.gas_station_cy = int(getattr(self, "highway_y", 0)) // int(state.CHUNK_SIZE)
                if self._is_city_chunk(int(self.gas_station_cx), int(self.gas_station_cy)):
                    self.gas_station_cy = int(self.city_cy) + int(self.city_radius) + 1
                if self._is_compound_chunk(int(self.gas_station_cx), int(self.gas_station_cy)):
                    self.gas_station_cy = int(self.compound_cy1) + 2
            except Exception:
                self.gas_station_cx = int(self.city_cx)
                self.gas_station_cy = int(self.city_cy) + int(self.city_radius) + 1

        def spawn_tile(self) -> tuple[int, int]:
            tx = self.state.ROAD_HALF - int(self.road_off_x)
            ty = self.state.ROAD_HALF - int(self.road_off_y)
            return tx, ty

        def _is_road_x(self, tx: int) -> bool:
            d = ((tx + int(self.road_off_x)) % self.state.ROAD_PERIOD) - self.state.ROAD_HALF
            return abs(int(d)) <= self.state.ROAD_W

        def _is_road_y(self, ty: int) -> bool:
            d = ((ty + int(self.road_off_y)) % self.state.ROAD_PERIOD) - self.state.ROAD_HALF
            return abs(int(d)) <= self.state.ROAD_W

        def is_road(self, tx: int, ty: int) -> bool:
            return self._is_road_x(tx) or self._is_road_y(ty)

        def is_highway(self, tx: int, ty: int) -> bool:
            tx = int(tx)
            ty = int(ty)
            w = int(getattr(self, "highway_w", 0))
            if w <= 0:
                return False
            hx = int(getattr(self, "highway_x", 0))
            hy = int(getattr(self, "highway_y", 0))
            return abs(tx - hx) <= w or abs(ty - hy) <= w

        def _coast_distance(self, tx: int, ty: int) -> int:
            # Signed distance from coastline (>=0 is sea side).
            tx = int(tx)
            ty = int(ty)
            cd = int(getattr(self, "coast_dir", 0)) & 3
            line = int(getattr(self, "coast_line", 0))
            if cd == 0:  # north
                return int(line - ty)
            if cd == 2:  # south
                return int(ty - line)
            if cd == 1:  # east
                return int(tx - line)
            return int(line - tx)  # west

        def _is_city_chunk(self, cx: int, cy: int) -> bool:
            dx = abs(int(cx) - int(getattr(self, "city_cx", 0)))
            dy = abs(int(cy) - int(getattr(self, "city_cy", 0)))
            r = max(0, int(getattr(self, "city_radius", 0)))
            return max(dx, dy) <= r

        def _is_compound_chunk(self, cx: int, cy: int) -> bool:
            cx0 = int(getattr(self, "compound_cx0", 0))
            cy0 = int(getattr(self, "compound_cy0", 0))
            cx1 = int(getattr(self, "compound_cx1", -1))
            cy1 = int(getattr(self, "compound_cy1", -1))
            return int(cx0) <= int(cx) <= int(cx1) and int(cy0) <= int(cy) <= int(cy1)

        def _plan_compound_towers(
            self,
            *,
            target: int,
        ) -> dict[tuple[int, int], list[tuple[int, int, int, int, int, int]]]:
            target = int(target)
            if target <= 0:
                return {}

            cx0 = int(getattr(self, "compound_cx0", 0))
            cy0 = int(getattr(self, "compound_cy0", 0))
            cx1 = int(getattr(self, "compound_cx1", -1))
            cy1 = int(getattr(self, "compound_cy1", -1))
            if cx1 < cx0 or cy1 < cy0:
                return {}

            # One tower per inner chunk (7-8 total); keep the perimeter for the podium/skirt building.
            # Slightly larger towers so each apartment feels like a real home.
            tower_w = 15
            tower_h = 31
            inner_cx0 = int(cx0) + 1
            inner_cx1 = int(cx1) - 1
            inner_cy0 = int(cy0) + 1
            inner_cy1 = int(cy1) - 1
            if inner_cx1 < inner_cx0 or inner_cy1 < inner_cy0:
                return {}

            inner_chunks: list[tuple[int, int]] = []
            for cy in range(int(inner_cy0), int(inner_cy1) + 1):
                for cx in range(int(inner_cx0), int(inner_cx1) + 1):
                    inner_chunks.append((int(cx), int(cy)))
            if not inner_chunks:
                return {}

            # Keep the very center chunk empty as a courtyard/green space when possible.
            center = ((int(inner_cx0) + int(inner_cx1)) // 2, (int(inner_cy0) + int(inner_cy1)) // 2)
            inner_chunks_usable = [c for c in inner_chunks if c != center]
            if not inner_chunks_usable:
                inner_chunks_usable = inner_chunks

            rng = random.Random(self.state._hash2_u32(211, 223, self.seed ^ 0x51C17011))
            rng.shuffle(inner_chunks_usable)
            picked = inner_chunks_usable[: int(clamp(int(target), 1, len(inner_chunks_usable)))]

            plan: dict[tuple[int, int], list[tuple[int, int, int, int, int, int]]] = {}
            for cx, cy in picked:
                # Alternate left/right so we don't overwrite the internal road stripe at x=15..16.
                x0 = 0 if ((int(cx) + int(cy)) % 2 == 0) else 17
                y0 = 0
                base_tx = int(cx) * int(self.state.CHUNK_SIZE)
                base_ty = int(cy) * int(self.state.CHUNK_SIZE)
                tx0w = int(base_tx + int(x0))
                ty0w = int(base_ty + int(y0))
                rr = random.Random(self.state._hash2_u32(int(tx0w), int(ty0w), self.seed ^ 0xA17F1A2B))
                roof_var = int(rr.randrange(0, 256))
                # Keep compound towers at 6F so the roof-cut doesn't shrink the
                # walkable apartment area too much (home must be >= 100 tiles).
                floors = 6
                plan.setdefault((int(cx), int(cy)), []).append(
                    (int(x0), int(y0), int(tower_w), int(tower_h), int(roof_var), int(floors))
                )
            return plan

        def _is_city_street_x(self, tx: int) -> bool:
            period = max(8, int(getattr(self, "city_period", 24)))
            half = int(period // 2)
            w = max(1, int(getattr(self, "city_w", 1)))
            off = int(getattr(self, "city_off_x", 0)) % period
            d = ((int(tx) + off) % period) - half
            return abs(int(d)) <= w

        def _is_city_street_y(self, ty: int) -> bool:
            period = max(8, int(getattr(self, "city_period", 24)))
            half = int(period // 2)
            w = max(1, int(getattr(self, "city_w", 1)))
            off = int(getattr(self, "city_off_y", 0)) % period
            d = ((int(ty) + off) % period) - half
            return abs(int(d)) <= w

        def is_city_street(self, tx: int, ty: int) -> bool:
            return self._is_city_street_x(tx) or self._is_city_street_y(ty)

        def get_tile(self, tx: int, ty: int) -> int:
            cx = tx // self.state.CHUNK_SIZE
            cy = ty // self.state.CHUNK_SIZE
            lx = tx - cx * self.state.CHUNK_SIZE
            ly = ty - cy * self.state.CHUNK_SIZE
            chunk = self.get_chunk(cx, cy)
            return chunk.tiles[ly * self.state.CHUNK_SIZE + lx]

        def peek_chunk(self, cx: int, cy: int) -> "HardcoreSurvivalState._Chunk | None":
            return self.chunks.get((int(cx), int(cy)))

        def peek_tile(self, tx: int, ty: int, *, default: int | None = None) -> int:
            cx = tx // self.state.CHUNK_SIZE
            cy = ty // self.state.CHUNK_SIZE
            lx = tx - cx * self.state.CHUNK_SIZE
            ly = ty - cy * self.state.CHUNK_SIZE
            chunk = self.peek_chunk(cx, cy)
            if chunk is None:
                return int(self.state.T_GRASS if default is None else default)
            return int(chunk.tiles[int(ly) * int(self.state.CHUNK_SIZE) + int(lx)])

        def request_chunk(self, cx: int, cy: int) -> None:
            key = (int(cx), int(cy))
            if key in self.chunks or key in self._gen_queue_set:
                return
            self._gen_queue.append(key)
            self._gen_queue_set.add(key)

        def pump_generation(self, *, max_chunks: int = 1) -> int:
            made = 0
            max_chunks = max(0, int(max_chunks))
            while made < max_chunks and self._gen_queue_i < len(self._gen_queue):
                key = self._gen_queue[self._gen_queue_i]
                self._gen_queue_i += 1
                self._gen_queue_set.discard(key)
                if key not in self.chunks:
                    self.chunks[key] = self._gen_chunk(int(key[0]), int(key[1]))
                made += 1

            # Compact occasionally to avoid unbounded growth.
            if self._gen_queue_i > 256 and self._gen_queue_i > (len(self._gen_queue) // 2):
                self._gen_queue = self._gen_queue[self._gen_queue_i :]
                self._gen_queue_i = 0
            return int(made)

        def get_chunk(self, cx: int, cy: int) -> "HardcoreSurvivalState._Chunk":
            key = (int(cx), int(cy))
            chunk = self.chunks.get(key)
            if chunk is None:
                chunk = self._gen_chunk(int(cx), int(cy))
                self.chunks[key] = chunk
            return chunk

        def _chunk_has_intersection(self, cx: int, cy: int) -> bool:
            base_tx = cx * self.state.CHUNK_SIZE
            base_ty = cy * self.state.CHUNK_SIZE
            has_x = any(self._is_road_x(base_tx + i) for i in range(self.state.CHUNK_SIZE))
            has_y = any(self._is_road_y(base_ty + i) for i in range(self.state.CHUNK_SIZE))
            return has_x and has_y

        def _is_town_chunk(self, cx: int, cy: int) -> bool:
            if self._chunk_has_intersection(cx, cy):
                return True
            r = self.state._rand01(cx, cy, self.seed ^ 0xA17F1A2B)
            return r >= 0.92

        def _gen_chunk(self, cx: int, cy: int) -> "HardcoreSurvivalState._Chunk":
            tiles = [self.state.T_GRASS] * (self.state.CHUNK_SIZE * self.state.CHUNK_SIZE)
            base_tx = cx * self.state.CHUNK_SIZE
            base_ty = cy * self.state.CHUNK_SIZE
            items: list[HardcoreSurvivalState._WorldItem] = []
            buildings: list[tuple[int, int, int, int, int, int]] = []
            special_buildings: list[HardcoreSurvivalState._SpecialBuilding] = []
            multi_houses: list[HardcoreSurvivalState._MultiHouse] = []
            cars: list[HardcoreSurvivalState._ParkedCar] = []
            bikes: list[HardcoreSurvivalState._ParkedBike] = []
            props: list[HardcoreSurvivalState._WorldProp] = []
            door_reserved: set[tuple[int, int]] = set()

            # Allow stamping helpers to register 2F house floor snapshots without
            # threading an extra parameter through every call site.
            self._multi_houses_out = multi_houses

            is_city = self._is_city_chunk(int(cx), int(cy))

            for ly in range(self.state.CHUNK_SIZE):
                ty = base_ty + ly
                for lx in range(self.state.CHUNK_SIZE):
                    tx = base_tx + lx
                    if is_city:
                        # City ground zoning: highways -> roads -> sidewalks -> district floors.
                        if self.is_highway(tx, ty):
                            tile = int(self.state.T_HIGHWAY)
                        elif self.is_road(tx, ty) or self.is_city_street(tx, ty):
                            tile = int(self.state.T_ROAD)
                        else:
                            near_road = bool(
                                self.is_highway(tx - 1, ty)
                                or self.is_highway(tx + 1, ty)
                                or self.is_highway(tx, ty - 1)
                                or self.is_highway(tx, ty + 1)
                                or self.is_road(tx - 1, ty)
                                or self.is_road(tx + 1, ty)
                                or self.is_road(tx, ty - 1)
                                or self.is_road(tx, ty + 1)
                                or self.is_city_street(tx - 1, ty)
                                or self.is_city_street(tx + 1, ty)
                                or self.is_city_street(tx, ty - 1)
                                or self.is_city_street(tx, ty + 1)
                            )
                            if near_road:
                                tile = int(self.state.T_SIDEWALK)
                            else:
                                district = float(
                                    self.state._noise2(float(tx) / 96.0, float(ty) / 96.0, self.seed ^ 0x7A11C1D3)
                                )
                                grit = float(
                                    self.state._noise2(float(tx) / 24.0, float(ty) / 24.0, self.seed ^ 0x1B7D3D39)
                                )
                                if district > 0.70:
                                    tile = int(self.state.T_BRICK)
                                elif district > 0.42:
                                    tile = int(self.state.T_CONCRETE)
                                else:
                                    tile = int(self.state.T_PAVEMENT)

                                # Occasional brick courtyards / plazas inside blocks.
                                if tile != int(self.state.T_BRICK) and grit > 0.885:
                                    tile = int(self.state.T_BRICK)
                                elif tile == int(self.state.T_PAVEMENT) and grit < 0.14:
                                    tile = int(self.state.T_CONCRETE)

                                # Small parks inside the city (keep roads/sidewalks clean).
                                park = float(
                                    self.state._noise2(float(tx) / 48.0, float(ty) / 48.0, self.seed ^ 0x51C17011)
                                )
                                if park > 0.905:
                                    tile = int(self.state.T_FOREST)
                                elif park > 0.84:
                                    tile = int(self.state.T_GRASS)
                    else:
                        n = self.state._fractal(float(tx), float(ty), self.seed)
                        coast_d = int(self._coast_distance(tx, ty))
                        if coast_d >= 10:
                            tile = self.state.T_WATER
                        elif coast_d >= 3:
                            # Shallows with occasional sand bars.
                            tile = self.state.T_WATER
                            shoal = float(self.state._noise2(float(tx) / 18.0, float(ty) / 18.0, self.seed ^ 0x0CEAD511))
                            if shoal > 0.88:
                                tile = self.state.T_SAND
                        elif coast_d >= 0:
                            tile = self.state.T_WATER
                        elif coast_d >= -4:
                            tile = self.state.T_SAND
                        elif coast_d >= -7:
                            # Boardwalk band just inland from the beach.
                            bw = float(self.state._noise2(float(tx) / 12.0, float(ty) / 12.0, self.seed ^ 0xB04A7A1C))
                            tile = self.state.T_BOARDWALK if bw > 0.55 else self.state.T_SAND
                        elif coast_d >= -18:
                            # Coastal wetlands behind the beach.
                            wet = float(self.state._noise2(float(tx) / 24.0, float(ty) / 24.0, self.seed ^ 0x717E17D5))
                            if wet > 0.92:
                                tile = self.state.T_WATER
                            elif wet > 0.78:
                                tile = self.state.T_MARSH
                            else:
                                if n < 0.30:
                                    tile = self.state.T_FOREST
                                else:
                                    tile = self.state.T_GRASS
                        else:
                            if n < 0.24:
                                tile = self.state.T_WATER
                            elif n < 0.36:
                                tile = self.state.T_FOREST
                            else:
                                tile = self.state.T_GRASS

                        # Roads/highways override terrain (but keep deep sea water intact).
                        if tile != self.state.T_WATER and self.is_highway(tx, ty):
                            tile = self.state.T_HIGHWAY
                        elif self.is_road(tx, ty):
                            tile = self.state.T_ROAD
                    tiles[ly * self.state.CHUNK_SIZE + lx] = tile

            gas_station_cx = int(getattr(self, "gas_station_cx", 10**9))
            gas_station_cy = int(getattr(self, "gas_station_cy", 10**9))
            is_gas_station = bool(int(cx) == int(gas_station_cx) and int(cy) == int(gas_station_cy))

            town_kind: str | None = None
            if is_gas_station:
                rng = random.Random(self.state._hash2_u32(cx, cy, self.seed ^ 0xA511F00D))
                self._stamp_gas_station_chunk(tiles, items, buildings, props, cx, cy, rng=rng, reserved=door_reserved)
                town_kind = "加油站"
            elif is_city:
                rng = random.Random(self.state._hash2_u32(cx, cy, self.seed ^ 0xC17C1701))
                self._stamp_city_chunk(
                    tiles,
                    items,
                    buildings,
                    special_buildings,
                    cars,
                    bikes,
                    props,
                    cx,
                    cy,
                    rng,
                    reserved=door_reserved,
                )
                town_kind = "城市"
            elif self._is_town_chunk(cx, cy):
                rng = random.Random(self.state._hash2_u32(cx, cy, self.seed))
                kinds = ["超市", "新华书店", "枪械店", "医院", "监狱", "学校", "高层住宅"]
                stx, sty = self.spawn_tile()
                is_spawn_chunk = (int(stx) // self.state.CHUNK_SIZE == int(cx)) and (int(sty) // self.state.CHUNK_SIZE == int(cy))
                if is_spawn_chunk:
                    plan = ["高层住宅", "学校"]
                else:
                    plan = [rng.choice(kinds)]
                    if plan[0] != "监狱" and rng.random() < 0.35:
                        pool = [k for k in kinds if k not in plan and k != "监狱"]
                        if pool:
                            plan.append(rng.choice(pool))

                town_kind = "+".join(plan)
                for kind in plan:
                    self._stamp_buildings(
                        tiles,
                        items,
                        buildings,
                        special_buildings,
                        props,
                        cx,
                        cy,
                        rng,
                        kind,
                        reserved=door_reserved,
                    )

                if not is_city and not is_gas_station:
                    # Beach / wetlands / highway decoration on non-city chunks.
                    rng2 = random.Random(self.state._hash2_u32(cx, cy, self.seed ^ 0x0D00BDEC))
                    self._stamp_outdoor_decor(tiles, props, cx, cy, rng=rng2)

            # Safety net: ensure every stamped building that has a walkable interior
            # is actually enterable from outside (some rare stamp interactions can
            # overwrite door tiles).
            if buildings or special_buildings:
                self._ensure_building_doors(tiles, buildings, special_buildings, cx, cy, reserved=door_reserved)

            # Safety: prevent parked vehicles from ending up inside building footprints.
            # This can happen if later stamps overwrite previously spawned vehicles.
            if buildings and (cars or bikes):
                tile_size = float(self.state.TILE_SIZE)
                chunk_size = int(self.state.CHUNK_SIZE)
                t_floor = int(self.state.T_FLOOR)
                t_door = int(self.state.T_DOOR)

                def inside_any_building(tx: int, ty: int) -> bool:
                    for bx0, by0, bw, bh, _roof_kind, _floors in buildings:
                        if int(bx0) <= int(tx) < int(bx0) + int(bw) and int(by0) <= int(ty) < int(by0) + int(bh):
                            return True
                    return False

                def tile_blocks_vehicle(t: int) -> bool:
                    t = int(t)
                    if t in (t_floor, t_door):
                        return True
                    tdef = self.state._TILES.get(int(t))
                    if tdef is None:
                        return False
                    return bool(getattr(tdef, "solid", False))

                def keep_vehicle_at(px: float, py: float) -> bool:
                    tx = int(math.floor(float(px) / tile_size))
                    ty = int(math.floor(float(py) / tile_size))
                    if inside_any_building(int(tx), int(ty)):
                        return False
                    lx = int(tx - base_tx)
                    ly = int(ty - base_ty)
                    if not (0 <= lx < chunk_size and 0 <= ly < chunk_size):
                        return False
                    t = int(tiles[int(ly) * chunk_size + int(lx)])
                    return not tile_blocks_vehicle(int(t))

                cars[:] = [c for c in cars if keep_vehicle_at(float(c.pos.x), float(c.pos.y))]
                bikes[:] = [b for b in bikes if keep_vehicle_at(float(b.pos.x), float(b.pos.y))]

            # Clear the transient registration hook for stamping helpers.
            try:
                self._multi_houses_out = None
            except Exception:
                pass

            return HardcoreSurvivalState._Chunk(
                cx=cx,
                cy=cy,
                tiles=tiles,
                items=items,
                buildings=buildings,
                special_buildings=special_buildings,
                multi_houses=multi_houses,
                cars=cars,
                bikes=bikes,
                props=props,
                town_kind=town_kind,
            )

        def _stamp_compound_highrise_tower(
            self,
            tiles: list[int],
            buildings: list[tuple[int, int, int, int, int, int]],
            special_buildings: list["HardcoreSurvivalState._SpecialBuilding"],
            cx: int,
            cy: int,
            *,
            x0: int,
            y0: int,
            w: int,
            h: int,
            roof_var: int,
            floors: int,
        ) -> None:
            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            x0 = int(x0)
            y0 = int(y0)
            w = int(w)
            h = int(h)
            roof_var = int(roof_var) & 0xFF
            max_f = int(max(2, int(getattr(self.state, "HIGHRISE_MAX_FLOORS", 10))))
            floors = int(max(2, min(int(floors), int(max_f))))

            cut_px = int(self.state._roof_cut_px(style=6, w=int(w), h=int(h), var=int(roof_var), floors=int(floors)))
            ts = int(max(1, int(self.state.TILE_SIZE)))
            cut_tiles = int(cut_px) // ts
            core_h = int(max(2, int(h) - 2 - int(cut_tiles)))
            min_core_h = int(max(6, int(getattr(self.state, "HIGHRISE_MIN_FLOOR_TILES", 9))))
            core_h = int(min(int(max(int(core_h), int(min_core_h))), int(max(2, int(h) - 2))))
            top_cut = int(max(0, (int(h) - 2) - int(core_h)))
            floor_y0 = int(y0 + 1 + int(top_cut))

            # Border walls + walkable interior (same mode as regular houses).
            for y in range(int(y0), int(y0 + h)):
                for x in range(int(x0), int(x0 + w)):
                    if 0 <= x < int(self.state.CHUNK_SIZE) and 0 <= y < int(self.state.CHUNK_SIZE):
                        is_border = (
                            int(x) == int(x0)
                            or int(x) == int(x0 + w - 1)
                            or int(y) == int(y0)
                            or int(y) == int(y0 + h - 1)
                        )
                        if is_border:
                            tiles[idx(int(x), int(y))] = int(self.state.T_WALL)
                        else:
                            inside_floor = bool(int(y) >= int(floor_y0))
                            tiles[idx(int(x), int(y))] = int(self.state.T_FLOOR if inside_floor else self.state.T_WALL)

            # South-facing entrance (2 tiles wide).
            door_y = int(y0 + h - 1)
            door_x0 = int(clamp(int(x0 + w // 2 - 1), int(x0 + 1), int(x0 + w - 3)))
            door_tiles_local = [(int(door_x0), int(door_y)), (int(door_x0 + 1), int(door_y))]
            for dx, dy in door_tiles_local:
                if 0 <= dx < int(self.state.CHUNK_SIZE) and 0 <= dy < int(self.state.CHUNK_SIZE):
                    tiles[idx(int(dx), int(dy))] = int(self.state.T_DOOR)

            # Elevator tile inside the lobby (world-map multi-floor switching).
            try:
                elev_x = int(clamp(int(door_x0), int(x0 + 1), int(x0 + w - 2)))
                elev_y = int(clamp(int(door_y - 3), int(floor_y0), int(y0 + h - 2)))
                if 0 <= elev_x < int(self.state.CHUNK_SIZE) and 0 <= elev_y < int(self.state.CHUNK_SIZE):
                    if int(tiles[idx(int(elev_x), int(elev_y))]) != int(self.state.T_WALL):
                        tiles[idx(int(elev_x), int(elev_y))] = int(self.state.T_ELEVATOR)
            except Exception:
                pass

            # 1F interior: elevator lobby + 2/3 apartments (never single-unit).
            apt_doors: list[tuple[int, int, bool]] = []
            try:
                in_left = int(x0 + 1)
                in_right = int(x0 + w - 2)
                in_top = int(floor_y0)
                in_bottom = int(y0 + h - 2)
                usable_h = int(in_bottom - in_top + 1)
                usable_w = int(in_right - in_left + 1)

                if int(usable_h) >= 6 and int(usable_w) >= 7:
                    # Find (or force) elevator position in the bottom lobby.
                    ex = None
                    ey = None
                    for yy in range(int(in_top), int(in_bottom) + 1):
                        for xx in range(int(in_left), int(in_right) + 1):
                            if int(tiles[idx(int(xx), int(yy))]) == int(self.state.T_ELEVATOR):
                                ex = int(xx)
                                ey = int(yy)
                                break
                        if ex is not None:
                            break

                    # Keep the lobby compact so apartments feel like real homes.
                    lobby_h = int(clamp(int(round(float(usable_h) * 0.18)), 2, 3))
                    min_apt_h = 4
                    lobby_h = int(clamp(int(lobby_h), 2, max(2, int(usable_h) - int(min_apt_h))))
                    sep_y = int(in_bottom - int(lobby_h))
                    sep_y = int(clamp(int(sep_y), int(in_top + min_apt_h - 1), int(in_bottom - 2)))

                    if ex is None or ey is None or int(ey) <= int(sep_y):
                        # Clear any old elevator tiles and place one in the lobby.
                        for yy in range(int(in_top), int(in_bottom) + 1):
                            for xx in range(int(in_left), int(in_right) + 1):
                                if int(tiles[idx(int(xx), int(yy))]) == int(self.state.T_ELEVATOR):
                                    tiles[idx(int(xx), int(yy))] = int(self.state.T_FLOOR)
                        ex = int(clamp(int(door_x0), int(in_left + 1), int(in_right - 1)))
                        ey = int(clamp(int(sep_y + 1), int(sep_y + 1), int(in_bottom - 1)))
                        if int(tiles[idx(int(ex), int(ey))]) != int(self.state.T_WALL):
                            tiles[idx(int(ex), int(ey))] = int(self.state.T_ELEVATOR)

                    lobby_area: set[tuple[int, int]] = set()
                    for dy in (-1, 0, 1):
                        for dx in (-1, 0, 1):
                            lobby_area.add((int(ex + dx), int(ey + dy)))

                    # Horizontal separator: lobby (south) vs apartments (north).
                    for xx in range(int(in_left), int(in_right) + 1):
                        if int(tiles[idx(int(xx), int(sep_y))]) == int(self.state.T_ELEVATOR):
                            continue
                        tiles[idx(int(xx), int(sep_y))] = int(self.state.T_WALL)

                    # Always 2 units (一梯两户).
                    units = 2
                    min_unit_w = 5 if int(usable_w) >= 11 else 3
                    if int(units) == 3:
                        min_unit_w = 5
                    unit_ranges: list[tuple[int, int]] = []
                    split_xs: list[int] = []
                    if int(units) == 2:
                        split_x = int(clamp(int(ex), int(in_left + min_unit_w), int(in_right - min_unit_w)))
                        split_xs = [int(split_x)]
                        unit_ranges = [(int(in_left), int(split_x - 1)), (int(split_x + 1), int(in_right))]
                    else:
                        x1 = int(in_left + (int(usable_w) // 3))
                        x2 = int(in_left + (int(usable_w) * 2) // 3)
                        x1 = int(clamp(int(x1), int(in_left + min_unit_w), int(in_right - 2 * min_unit_w - 1)))
                        x2 = int(clamp(int(x2), int(x1 + min_unit_w + 1), int(in_right - min_unit_w)))
                        split_xs = [int(x1), int(x2)]
                        unit_ranges = [
                            (int(in_left), int(x1 - 1)),
                            (int(x1 + 1), int(x2 - 1)),
                            (int(x2 + 1), int(in_right)),
                        ]

                    # Vertical separators between units (only above the lobby line).
                    for sx in split_xs:
                        for yy in range(int(in_top), int(sep_y)):
                            tiles[idx(int(sx), int(yy))] = int(self.state.T_WALL)

                    reserved: set[tuple[int, int]] = set(lobby_area)
                    seed_base = int(self.seed) ^ 0x6B8B4567
                    for ux0, ux1 in unit_ranges:
                        if int(ux1 - ux0 + 1) < 3:
                            continue
                        dx = int(clamp(int((ux0 + ux1) // 2), int(ux0 + 1), int(ux1 - 1)))
                        # Unit-entry doors:
                        # - 1F: always locked (prevents breaking into neighbors from the lobby).
                        # - Upper floors: some are broken (enterable).
                        wx = int(cx) * int(self.state.CHUNK_SIZE) + int(dx)
                        wy = int(cy) * int(self.state.CHUNK_SIZE) + int(sep_y)
                        hh = int(self.state._hash2_u32(int(wx), int(wy), int(seed_base)))
                        broken_up = int(hh % 100) < 18
                        tiles[idx(int(dx), int(sep_y))] = int(self.state.T_DOOR_LOCKED)
                        apt_doors.append((int(dx), int(sep_y), bool(broken_up)))
                        for dy in (-1, 0, 1):
                            for dx2 in (-1, 0, 1):
                                reserved.add((int(dx + dx2), int(sep_y + dy)))
            except Exception:
                pass

            # Register as a high-rise (for markers/home selection).     
            tx0w = int(cx) * int(self.state.CHUNK_SIZE) + int(x0)       
            ty0w = int(cy) * int(self.state.CHUNK_SIZE) + int(y0)       
            doors_w = tuple(
                (int(cx) * int(self.state.CHUNK_SIZE) + int(dx), int(cy) * int(self.state.CHUNK_SIZE) + int(dy))
                for dx, dy in door_tiles_local
            )
            special_buildings.append(
                HardcoreSurvivalState._SpecialBuilding(
                    kind="highrise",
                    name="楂樺眰浣忓畢",
                    tx0=int(tx0w),
                    ty0=int(ty0w),
                    w=int(w),
                    h=int(h),
                    door_tiles=doors_w,
                    floors=int(floors),
                )
            )
            roof_kind = (6 << 8) | int(roof_var)
            buildings.append((int(tx0w), int(ty0w), int(w), int(h), int(roof_kind), int(floors)))

            # Register as a multi-floor building so facade slicing + floor switching works.
            mh_out: list[HardcoreSurvivalState._MultiHouse] | None = getattr(self, "_multi_houses_out", None)
            if mh_out is not None and int(floors) > 1:
                f1: list[int] = []
                for yy in range(int(h)):
                    for xx in range(int(w)):
                        f1.append(int(tiles[idx(int(x0 + xx), int(y0 + yy))]))

                f_up = list(f1)
                for dx, dy in door_tiles_local:
                    i2 = int(dy - y0) * int(w) + int(dx - x0)
                    if 0 <= i2 < len(f_up):
                        f_up[int(i2)] = int(self.state.T_WALL)
                # Upper floors: apply the precomputed broken/locked state for unit-entry doors.
                try:
                    for dx, dy, broken_up in list(apt_doors):
                        i2 = int(dy - y0) * int(w) + int(dx - x0)
                        if 0 <= i2 < len(f_up):
                            f_up[int(i2)] = int(self.state.T_DOOR_BROKEN) if bool(broken_up) else int(self.state.T_DOOR_LOCKED)
                except Exception:
                    pass

                floor_tiles: dict[int, list[int]] = {1: f1}
                for fl in range(2, int(floors) + 1):
                    floor_tiles[int(fl)] = f_up

                mh_out.append(
                    HardcoreSurvivalState._MultiHouse(
                        tx0=int(tx0w),
                        ty0=int(ty0w),
                        w=int(w),
                        h=int(h),
                        floors=int(floors),
                        cur_floor=1,
                        floor_tiles=floor_tiles,
                    )
                )

        def _stamp_compound_podium_block(
            self,
            tiles: list[int],
            buildings: list[tuple[int, int, int, int, int, int]],
            cx: int,
            cy: int,
            *,
            x0: int,
            y0: int,
            w: int,
            h: int,
            roof_style: int = 2,
            roof_var: int | None = None,
        ) -> None:
            # Simple low-rise skirt building chunk: solid mass with a roof (visual ring).
            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            x0 = int(x0)
            y0 = int(y0)
            w = int(w)
            h = int(h)
            if w <= 0 or h <= 0:
                return

            for y in range(int(y0), int(y0 + h)):
                if not (0 <= int(y) < int(self.state.CHUNK_SIZE)):
                    continue
                for x in range(int(x0), int(x0 + w)):
                    if not (0 <= int(x) < int(self.state.CHUNK_SIZE)):
                        continue
                    tiles[idx(int(x), int(y))] = int(self.state.T_WALL)

            tx0w = int(cx) * int(self.state.CHUNK_SIZE) + int(x0)
            ty0w = int(cy) * int(self.state.CHUNK_SIZE) + int(y0)
            if roof_var is None:
                roof_var = int(self.state._hash2_u32(int(tx0w), int(ty0w), self.seed ^ 0x7A11C1D3) & 0xFF)
            roof_kind = (int(roof_style) << 8) | (int(roof_var) & 0xFF)
            buildings.append((int(tx0w), int(ty0w), int(w), int(h), int(roof_kind), 0))

        def _stamp_compound_chunk(
            self,
            tiles: list[int],
            buildings: list[tuple[int, int, int, int, int, int]],
            special_buildings: list["HardcoreSurvivalState._SpecialBuilding"],
            cars: list["HardcoreSurvivalState._ParkedCar"],
            bikes: list["HardcoreSurvivalState._ParkedBike"],
            props: list["HardcoreSurvivalState._WorldProp"],
            cx: int,
            cy: int,
            rng: random.Random,
        ) -> None:
            # Walled "小区": ~7-8 tall towers (20+ floors) with a low-rise podium ring.
            cx = int(cx)
            cy = int(cy)

            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            base_tx = int(cx) * int(self.state.CHUNK_SIZE)
            base_ty = int(cy) * int(self.state.CHUNK_SIZE)

            tx0 = int(getattr(self, "compound_tx0", 0))
            ty0 = int(getattr(self, "compound_ty0", 0))
            tx1 = int(getattr(self, "compound_tx1", 0))
            ty1 = int(getattr(self, "compound_ty1", 0))
            gate_x0 = int(getattr(self, "compound_gate_x0", 0))
            gate_x1 = int(getattr(self, "compound_gate_x1", -1))
            rvx0 = int(getattr(self, "compound_road_v_x0", 15))
            rvx1 = int(getattr(self, "compound_road_v_x1", 16))
            rhy0 = int(getattr(self, "compound_road_h_y0", 31))
            rhy1 = int(getattr(self, "compound_road_h_y1", 31))

            ccx0 = int(getattr(self, "compound_cx0", cx))
            ccy0 = int(getattr(self, "compound_cy0", cy))
            ccx1 = int(getattr(self, "compound_cx1", cx))
            ccy1 = int(getattr(self, "compound_cy1", cy))
            gate_cx = int(ccx0) + int(int(getattr(self, "compound_w_chunks", 0)) // 2)
            near_gate = bool(int(cy) == int(ccy1) and abs(int(cx) - int(gate_cx)) <= 1)
            is_gate_chunk = bool(int(cy) == int(ccy1) and int(cx) == int(gate_cx))

            parking_chunks = set(getattr(self, "compound_parking_chunks", set()))
            is_parking_chunk = (int(cx), int(cy)) in parking_chunks

            # Base ground (overwrite the city district pattern in the compound area).
            for y in range(int(self.state.CHUNK_SIZE)):
                wy = int(base_ty + y)
                for x in range(int(self.state.CHUNK_SIZE)):
                    wx = int(base_tx + x)

                    tile = int(self.state.T_CONCRETE)
                    # Sparse greenery between blocks.
                    g = float(self.state._noise2(float(wx) / 18.0, float(wy) / 18.0, self.seed ^ 0x7A11C1D3))
                    if g > 0.94:
                        tile = int(self.state.T_GRASS)

                    if not is_parking_chunk:
                        if int(rvx0) <= int(x) <= int(rvx1) or int(rhy0) <= int(y) <= int(rhy1):
                            tile = int(self.state.T_ROAD)

                    # Outer compound wall (leave a driveable opening at the gate).
                    if int(wx) == int(tx0) or int(wx) == int(tx1) or int(wy) == int(ty0) or int(wy) == int(ty1):
                        if int(wy) == int(ty1) and int(gate_x0) <= int(wx) <= int(gate_x1):
                            tile = int(self.state.T_ROAD)  # gate opening (walk/drive through)
                        else:
                            tile = int(self.state.T_WALL)

                    tiles[idx(int(x), int(y))] = int(tile)

            # Podium ("裙楼") ring along the compound perimeter (keep the gate approach open).
            on_edge = bool(int(cx) == int(ccx0) or int(cx) == int(ccx1) or int(cy) == int(ccy0) or int(cy) == int(ccy1))
            if on_edge and (not is_parking_chunk):
                pod_t = 10
                if int(cy) == int(ccy0):
                    self._stamp_compound_podium_block(tiles, buildings, cx, cy, x0=2, y0=2, w=28, h=pod_t, roof_style=2)
                if int(cy) == int(ccy1) and (not near_gate):
                    # Keep a few tiles open near the south wall so the player can reach the gate.
                    self._stamp_compound_podium_block(tiles, buildings, cx, cy, x0=2, y0=18, w=28, h=pod_t, roof_style=2)
                if int(cx) == int(ccx0):
                    self._stamp_compound_podium_block(tiles, buildings, cx, cy, x0=2, y0=2, w=pod_t, h=28, roof_style=2)
                if int(cx) == int(ccx1):
                    self._stamp_compound_podium_block(tiles, buildings, cx, cy, x0=20, y0=2, w=pod_t, h=28, roof_style=2)

            # Gatehouse blocks (1F) framing the opening.
            if is_gate_chunk:
                # Two small wings near the south wall, leave the center corridor clear.
                self._stamp_compound_podium_block(tiles, buildings, cx, cy, x0=2, y0=22, w=10, h=8, roof_style=2, roof_var=64)
                self._stamp_compound_podium_block(tiles, buildings, cx, cy, x0=20, y0=22, w=10, h=8, roof_style=2, roof_var=96)
                # A sign prop near the gate so it reads as an entrance.
                gx = int(clamp(int((gate_x0 + gate_x1) // 2), int(base_tx), int(base_tx + self.state.CHUNK_SIZE - 1)))
                gy = int(ty1 - 1)
                props.append(
                    HardcoreSurvivalState._WorldProp(
                        pos=pygame.Vector2((float(gx) + 0.5) * float(self.state.TILE_SIZE), (float(gy) + 0.5) * float(self.state.TILE_SIZE)),
                        prop_id="sign_chinese",
                        variant=int(rng.randint(0, 3)),
                        dir="down",
                    )
                )

            # Parking lots near the gate (visual interest).
            if is_parking_chunk:
                self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings)
                self._spawn_two_wheelers(
                    tiles,
                    bikes,
                    cx,
                    cy,
                    rng=rng,
                    count=int(rng.randint(0, 2)),
                    models=["bike_lady", "bike_mountain", "bike_auto", "moto"],
                    buildings=buildings,
                )

            # Stamp planned towers for this chunk.
            towers = (getattr(self, "compound_towers_by_chunk", {}) or {}).get((int(cx), int(cy)), [])
            for x0, y0, w, h, roof_var, floors in towers:
                self._stamp_compound_highrise_tower(
                    tiles,
                    buildings,
                    special_buildings,
                    cx,
                    cy,
                    x0=int(x0),
                    y0=int(y0),
                    w=int(w),
                    h=int(h),
                    roof_var=int(roof_var),
                    floors=int(floors),
                )

        def _stamp_city_chunk(
            self,
            tiles: list[int],
            items: list["HardcoreSurvivalState._WorldItem"],
            buildings: list[tuple[int, int, int, int, int, int]],
            special_buildings: list["HardcoreSurvivalState._SpecialBuilding"],
            cars: list["HardcoreSurvivalState._ParkedCar"],
            bikes: list["HardcoreSurvivalState._ParkedBike"],
            props: list["HardcoreSurvivalState._WorldProp"],
            cx: int,
            cy: int,
            rng: random.Random,
            reserved: set[tuple[int, int]] | None = None,
        ) -> None:
            # Dense city composition: mix facilities + residential blocks.
            roll = float(rng.random())
            dist = max(abs(int(cx) - int(getattr(self, "city_cx", 0))), abs(int(cy) - int(getattr(self, "city_cy", 0))))
            radius = max(1, int(getattr(self, "city_radius", 1)))
            density = 1.0 - float(dist) / float(radius)
            buildings_n = int(clamp(3 + int(round(5.0 * density)), 3, 8))

            # Chunk-level districts so city blocks feel different.
            district = float(self.state._noise2(float(cx) / 3.4, float(cy) / 3.4, self.seed ^ 0x4C17C0DE))
            chinese_district = bool(district > 0.78)
            commercial_district = bool(district < 0.22)

            core = bool(density >= 0.72)
            stx, sty = self.spawn_tile()
            spawn_cx = int(stx) // self.state.CHUNK_SIZE
            spawn_cy = int(sty) // self.state.CHUNK_SIZE
            if self._is_compound_chunk(int(cx), int(cy)):
                self._stamp_compound_chunk(
                    tiles,
                    buildings,
                    special_buildings,
                    cars,
                    bikes,
                    props,
                    cx,
                    cy,
                    rng,
                )
                return
            is_spawn_chunk = (int(spawn_cx) == int(cx)) and (int(spawn_cy) == int(cy))
            # Starter "Chinese community": a small cluster of high-rises near spawn.
            in_community = (int(spawn_cx) <= int(cx) <= int(spawn_cx) + 1) and (int(spawn_cy) <= int(cy) <= int(spawn_cy) + 1)
            school_chunk = (int(cx) == int(spawn_cx) + 1) and (int(cy) == int(spawn_cy))
            # Dedicated compound exists now; disable the old starter-community cluster here.
            use_starter_community = False
            if use_starter_community and is_spawn_chunk:
                # Spawn block: guarantee a home high-rise; the school is in an adjacent
                # community chunk to keep this block more residential.
                self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "高层住宅", reserved=reserved)
                # Add a few extra towers so it reads like a "小区".
                for _ in range(int(rng.randint(1, 3))):
                    if rng.random() < 0.85:
                        self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "高层住宅", reserved=reserved)
                if rng.random() < 0.35:
                    self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "高层住宅大", reserved=reserved)
                self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, school=True, buildings=buildings, reserved=reserved)
                self._spawn_two_wheelers(
                    tiles,
                    bikes,
                    cx,
                    cy,
                    rng=rng,
                    count=rng.randint(6, 12),
                    models=["bike_lady", "bike_mountain", "bike_auto", "moto", "moto_lux", "moto_long"],
                    buildings=buildings,
                    reserved=reserved,
                )
                buildings_n = max(3, buildings_n - 2)
            elif use_starter_community and in_community:
                # Community chunks: mostly residential towers; one chunk hosts the school.
                if school_chunk:
                    self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "学校", reserved=reserved)
                    self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, school=True, buildings=buildings, reserved=reserved)
                else:
                    self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "高层住宅", reserved=reserved)
                    if rng.random() < 0.55:
                        self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "高层住宅", reserved=reserved)
                    if core and rng.random() < 0.22:
                        self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "高层住宅大", reserved=reserved)
                    if rng.random() < 0.55:
                        self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)
                buildings_n = max(3, buildings_n - 1)
            elif core:
                big_roll = float(rng.random())
                if big_roll < 0.07:
                    self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "大型超市", reserved=reserved)
                    self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)
                    buildings_n = max(3, buildings_n - 1)
                elif big_roll < 0.12:
                    self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "高层住宅大", reserved=reserved)
                    if rng.random() < 0.35:
                        self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "高层住宅", reserved=reserved)
                    buildings_n = max(3, buildings_n - 1)
                elif big_roll < 0.18:
                    self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "大型监狱", reserved=reserved)
                    buildings_n = max(3, buildings_n - 1)
                elif big_roll < 0.24:
                    # Core districts should always have a few recognizable shops.
                    kind = "新华书店" if rng.random() < 0.52 else "枪械店"
                    self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, kind, reserved=reserved)
                    self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)
                    buildings_n = max(3, buildings_n - 1)

            if chinese_district and (not is_spawn_chunk) and rng.random() < (0.55 + 0.25 * density):
                # A small cluster of Chinese-style buildings.
                n = 2 if (density > 0.55 and rng.random() < 0.55) else 1
                for _ in range(int(n)):
                    self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "中式建筑", reserved=reserved)
                buildings_n = max(3, int(buildings_n) - int(n))

            if roll < 0.16:
                self._stamp_basketball_court(tiles, rng=rng)
                self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)
            elif roll < 0.32:
                self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "学校", reserved=reserved)
                self._stamp_basketball_court(tiles, rng=rng)
                self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, school=True, buildings=buildings, reserved=reserved)
                self._spawn_two_wheelers(tiles, bikes, cx, cy, rng=rng, count=rng.randint(2, 6), models=["bike_lady", "bike_mountain", "bike_auto", "moto", "moto_lux", "moto_long"], buildings=buildings, reserved=reserved)
                buildings_n = max(3, buildings_n - 1)
            elif roll < 0.46:
                self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "医院", reserved=reserved)
                self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)
            elif roll < 0.60:
                self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "超市", reserved=reserved)
                self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)
            elif roll < 0.68 and commercial_district:
                kind = "新华书店" if rng.random() < 0.55 else "枪械店"
                self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, kind, reserved=reserved)
                self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)
            elif roll < 0.74:
                self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, "高层住宅", reserved=reserved)

            for _ in range(int(buildings_n)):
                if chinese_district and rng.random() < 0.55:
                    kind = "中式建筑"
                else:
                    if commercial_district:
                        pool = ["住宅", "住宅", "住宅", "超市", "超市", "超市", "医院", "新华书店", "枪械店", "高层住宅", "监狱"]
                    else:
                        # Non-commercial blocks still occasionally get a bookstore/gun shop,
                        # so the whole city doesn't end up as pure residential.
                        pool = ["住宅", "住宅", "住宅", "住宅", "住宅", "住宅", "超市", "超市", "医院", "新华书店", "枪械店", "高层住宅", "监狱"]
                    kind = str(rng.choice(pool))
                if core:
                    if kind == "超市" and rng.random() < 0.45:
                        kind = "大型超市"
                    elif kind == "高层住宅" and rng.random() < 0.45:
                        kind = "高层住宅大"
                    elif kind == "监狱" and rng.random() < 0.35:
                        kind = "大型监狱"
                if not commercial_district:
                    if kind in ("超市", "医院", "大型超市") and rng.random() < 0.35:
                        kind = "住宅"
                    elif kind in ("新华书店", "枪械店") and rng.random() < 0.15:
                        kind = "住宅"
                self._stamp_buildings(tiles, items, buildings, special_buildings, props, cx, cy, rng, kind, reserved=reserved)

            # Make parking lots common/visible in city blocks (esp. near core).
            # (Parking stamping is safe: it avoids overwriting buildings/roads.)
            if not is_spawn_chunk:
                lot_chance = float(clamp(0.12 + 0.18 * density, 0.10, 0.35))
                if rng.random() < lot_chance:
                    self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)
                if core and rng.random() < 0.10:
                    self._stamp_parking_lot(tiles, cars, bikes, cx, cy, rng=rng, buildings=buildings, reserved=reserved)

            # Street lighting: road-side lamp posts so nights aren't pure black.
            self._stamp_city_streetlamps(tiles, props, buildings, cx, cy, rng=rng, reserved=reserved)
            self._stamp_city_decor(tiles, props, cx, cy, rng=rng)

        def _stamp_city_streetlamps(
            self,
            tiles: list[int],
            props: list["HardcoreSurvivalState._WorldProp"],
            buildings: list[tuple[int, int, int, int, int, int]],
            cx: int,
            cy: int,
            *,
            rng: random.Random,
            reserved: set[tuple[int, int]] | None = None,
        ) -> None:
            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            base_tx = int(cx) * int(self.state.CHUNK_SIZE)
            base_ty = int(cy) * int(self.state.CHUNK_SIZE)
            tile_size = int(self.state.TILE_SIZE)

            t_road = int(self.state.T_ROAD)
            t_highway = int(self.state.T_HIGHWAY)
            walk_tiles = {
                int(self.state.T_SIDEWALK),
                int(self.state.T_PAVEMENT),
                int(self.state.T_BRICK),
                int(self.state.T_CONCRETE),
            }

            def inside_any_building(tx: int, ty: int) -> bool:
                for bx0, by0, bw, bh, _roof_kind, _floors in buildings:
                    if int(bx0) <= int(tx) < int(bx0) + int(bw) and int(by0) <= int(ty) < int(by0) + int(bh):
                        return True
                return False

            # Deterministic spacing along streets.
            spacing = 10
            off_x = int(rng.randrange(spacing))
            off_y = int(rng.randrange(spacing))

            cand: list[tuple[int, int]] = []
            for y in range(2, int(self.state.CHUNK_SIZE) - 2):
                for x in range(2, int(self.state.CHUNK_SIZE) - 2):
                    if reserved is not None and (int(x), int(y)) in reserved:
                        continue
                    t = int(tiles[idx(int(x), int(y))])
                    if t not in walk_tiles:
                        continue
                    # Must be next to a road/highway edge.
                    left = int(tiles[idx(int(x - 1), int(y))])
                    right = int(tiles[idx(int(x + 1), int(y))])
                    up = int(tiles[idx(int(x), int(y - 1))])
                    down = int(tiles[idx(int(x), int(y + 1))])
                    near_lr = (left in (t_road, t_highway)) or (right in (t_road, t_highway))
                    near_ud = (up in (t_road, t_highway)) or (down in (t_road, t_highway))
                    if not (near_lr or near_ud):
                        continue

                    # Avoid placing right against building walls/doors to reduce visual overlap.
                    near_wall = False
                    for ny in range(int(y) - 1, int(y) + 2):
                        for nx in range(int(x) - 1, int(x) + 2):
                            tt = int(tiles[idx(int(nx), int(ny))])
                            if tt in (int(self.state.T_WALL), int(self.state.T_DOOR)):
                                near_wall = True
                                break
                        if near_wall:
                            break
                    if near_wall:
                        continue

                    tx = int(base_tx + int(x))
                    ty = int(base_ty + int(y))
                    if inside_any_building(int(tx), int(ty)):
                        continue

                    if near_lr and (int(ty) % spacing) != int(off_y):
                        continue
                    if near_ud and (int(tx) % spacing) != int(off_x):
                        continue
                    cand.append((int(x), int(y)))

            if not cand:
                return
            rng.shuffle(cand)

            # Cap per chunk to keep lighting cost predictable.
            want = int(clamp(int(len(cand) // 18), 4, 14))
            min_d2 = float((tile_size * 6) ** 2)

            placed = 0
            for x, y in cand:
                if placed >= want:
                    break
                tx = int(base_tx + int(x))
                ty = int(base_ty + int(y))
                px = (float(tx) + 0.5) * float(tile_size)
                py = (float(ty) + 0.5) * float(tile_size)
                ok = True
                for pr in props:
                    if str(getattr(pr, "prop_id", "")) != "streetlamp":
                        continue
                    dx = float(pr.pos.x) - float(px)
                    dy = float(pr.pos.y) - float(py)
                    if dx * dx + dy * dy < min_d2:
                        ok = False
                        break
                if not ok:
                    continue
                props.append(
                    HardcoreSurvivalState._WorldProp(
                        pos=pygame.Vector2(px, py),
                        prop_id="streetlamp",
                        variant=int(rng.randint(0, 1)),
                        dir=str(rng.choice(["left", "right"])),
                    )
                )
                placed += 1

        def _ensure_building_doors(
            self,
            tiles: list[int],
            buildings: list[tuple[int, int, int, int, int, int]],
            special_buildings: list["HardcoreSurvivalState._SpecialBuilding"],
            cx: int,
            cy: int,
            *,
            reserved: set[tuple[int, int]] | None = None,
        ) -> None:
            # Ensure that:
            # - portal buildings' door tiles are actually doors on the tilemap
            # - "walkable interior" buildings have at least 1 exterior door
            # This prevents un-enterable buildings (solid wall loops).
            chunk_size = int(self.state.CHUNK_SIZE)
            base_tx = int(cx) * chunk_size
            base_ty = int(cy) * chunk_size

            def idx(x: int, y: int) -> int:
                return int(y) * chunk_size + int(x)

            door_tids = {
                int(self.state.T_DOOR),
                int(self.state.T_DOOR_HOME),
                int(self.state.T_DOOR_LOCKED),
                int(self.state.T_DOOR_HOME_LOCKED),
                int(self.state.T_DOOR_BROKEN),
            }

            # 1) Special building portals: force the listed door tiles to be doors.
            try:
                for sb in list(special_buildings or []):
                    for tx, ty in getattr(sb, "door_tiles", ()) or ():
                        lx = int(tx) - int(base_tx)
                        ly = int(ty) - int(base_ty)
                        if 0 <= lx < chunk_size and 0 <= ly < chunk_size:
                            tiles[idx(lx, ly)] = int(self.state.T_DOOR)
            except Exception:
                pass

            def has_walkable_interior(x0: int, y0: int, w: int, h: int) -> bool: 
                # Decorative blocks (e.g., podium ring) are all-wall; skip them. 
                t_floor = int(self.state.T_FLOOR) 
                t_elev = int(self.state.T_ELEVATOR) 
                t_up = int(self.state.T_STAIRS_UP) 
                t_dn = int(self.state.T_STAIRS_DOWN) 
                for yy in range(int(y0) + 1, int(y0 + h) - 1):
                    for xx in range(int(x0) + 1, int(x0 + w) - 1):
                        t = int(tiles[idx(int(xx), int(yy))])
                        if t in (t_floor, t_elev, t_up, t_dn):
                            return True
                return False 

            def clear_if_solid(x: int, y: int) -> None: 
                if not (0 <= int(x) < chunk_size and 0 <= int(y) < chunk_size): 
                    return 
                tid = int(tiles[idx(int(x), int(y))]) 
                tdef = self.state._TILES.get(int(tid)) 
                if tdef is None: 
                    return 
                if bool(getattr(tdef, "solid", False)): 
                    tiles[idx(int(x), int(y))] = int(self.state.T_FLOOR) 

            def border_has_door(x0: int, y0: int, w: int, h: int) -> bool:
                for xx in range(int(x0), int(x0 + w)):
                    if int(tiles[idx(int(xx), int(y0))]) in door_tids:
                        return True
                    if int(tiles[idx(int(xx), int(y0 + h - 1))]) in door_tids:
                        return True
                for yy in range(int(y0), int(y0 + h)):
                    if int(tiles[idx(int(x0), int(yy))]) in door_tids:
                        return True
                    if int(tiles[idx(int(x0 + w - 1), int(yy))]) in door_tids:
                        return True
                return False

            def approach_clear(x: int, y: int, *, ox: int, oy: int) -> bool:
                # Ensure a few tiles outside the door aren't blocked by other buildings.
                for step in range(1, 9):
                    px = int(x) + int(ox) * int(step)
                    py = int(y) + int(oy) * int(step)
                    if not (0 <= px < chunk_size and 0 <= py < chunk_size):
                        break
                    tcur = int(tiles[idx(int(px), int(py))])
                    if tcur in (
                        int(self.state.T_WALL),
                        int(self.state.T_FLOOR),
                        int(self.state.T_DOOR),
                        int(self.state.T_DOOR_HOME),
                        int(self.state.T_DOOR_LOCKED),
                        int(self.state.T_DOOR_HOME_LOCKED),
                        int(self.state.T_DOOR_BROKEN),
                    ):
                        return False
                return True

            def carve_path_from(x: int, y: int, *, ox: int, oy: int) -> None:
                path_tile = (
                    int(self.state.T_SIDEWALK) if bool(self._is_city_chunk(int(cx), int(cy))) else int(self.state.T_ROAD)
                )
                for step in range(1, 9):
                    px = int(x) + int(ox) * int(step)
                    py = int(y) + int(oy) * int(step)
                    if not (0 <= px < chunk_size and 0 <= py < chunk_size):
                        break
                    tcur = int(tiles[idx(int(px), int(py))])
                    if tcur in (
                        int(self.state.T_WALL),
                        int(self.state.T_FLOOR),
                        int(self.state.T_DOOR),
                        int(self.state.T_DOOR_HOME),
                        int(self.state.T_DOOR_LOCKED),
                        int(self.state.T_DOOR_HOME_LOCKED),
                        int(self.state.T_DOOR_BROKEN),
                    ):
                        break
                    tiles[idx(int(px), int(py))] = int(path_tile)
                    if reserved is not None:
                        reserved.add((int(px), int(py)))

            # 2) Regular buildings: if interior is walkable, guarantee at least one exterior door.
            for bx0, by0, bw, bh, _roof_kind, _floors in list(buildings or []):
                bx0 = int(bx0)
                by0 = int(by0)
                bw = int(bw)
                bh = int(bh)
                lx0 = int(bx0) - int(base_tx)
                ly0 = int(by0) - int(base_ty)
                if bw <= 0 or bh <= 0:
                    continue
                if not (0 <= lx0 < chunk_size and 0 <= ly0 < chunk_size):
                    continue
                if lx0 + bw > chunk_size or ly0 + bh > chunk_size: 
                    continue 
                if not has_walkable_interior(lx0, ly0, bw, bh): 
                    continue 
 
                if not border_has_door(lx0, ly0, bw, bh): 
                    # Default to a south-facing 2-tile entrance (matches our facade draw). 
                    door_y = int(ly0 + bh - 1) 
                    if door_y <= 0 or door_y >= chunk_size: 
                        continue 
                    ox, oy = 0, 1 
 
                    # Prefer positions with a clear approach; fall back to centered. 
                    x_candidates = [int(x) for x in range(int(lx0 + 1), int(lx0 + bw - 2))] 
                    if x_candidates: 
                        # Center bias: check closer-to-center candidates first. 
                        cx0 = int(lx0 + bw // 2) 
                        x_candidates.sort(key=lambda v: abs(int(v) - int(cx0))) 
 
                    door_x0: int | None = None 
                    for cand in x_candidates: 
                        if cand + 1 >= int(lx0 + bw - 1): 
                            continue 
                        # Ensure the tiles just inside the doorway are not walls. 
                        in_ok = True 
                        for dx in (cand, cand + 1): 
                            if int(tiles[idx(int(dx), int(door_y - 1))]) == int(self.state.T_WALL): 
                                in_ok = False 
                                break 
                        if not in_ok: 
                            continue 
                        if approach_clear(int(cand), int(door_y), ox=ox, oy=oy): 
                            door_x0 = int(cand) 
                            break 
 
                    if door_x0 is None: 
                        # As a last resort, carve the interior landing too. 
                        door_x0 = int(clamp(int(lx0 + bw // 2 - 1), int(lx0 + 1), int(lx0 + bw - 3))) 
 
                    for dx in (int(door_x0), int(door_x0 + 1)): 
                        tiles[idx(int(dx), int(door_y))] = int(self.state.T_DOOR) 
                        clear_if_solid(int(dx), int(door_y - 1)) 
 
                    carve_path_from(int(door_x0), int(door_y), ox=ox, oy=oy) 
                    carve_path_from(int(door_x0 + 1), int(door_y), ox=ox, oy=oy) 
 
                # Ensure existing/new doorway landings aren't blocked by solid furniture. 
                try: 
                    for xx in range(int(lx0), int(lx0 + bw)): 
                        if int(tiles[idx(int(xx), int(ly0))]) in door_tids: 
                            clear_if_solid(int(xx), int(ly0 + 1)) 
                        if int(tiles[idx(int(xx), int(ly0 + bh - 1))]) in door_tids: 
                            clear_if_solid(int(xx), int(ly0 + bh - 2)) 
                    for yy in range(int(ly0), int(ly0 + bh)): 
                        if int(tiles[idx(int(lx0), int(yy))]) in door_tids: 
                            clear_if_solid(int(lx0 + 1), int(yy)) 
                        if int(tiles[idx(int(lx0 + bw - 1), int(yy))]) in door_tids: 
                            clear_if_solid(int(lx0 + bw - 2), int(yy)) 
                except Exception: 
                    pass 
 
        def _stamp_basketball_court(self, tiles: list[int], *, rng: random.Random) -> None: 
            # Simple outdoor court: a rectangle of court tiles. 
            w = rng.randint(10, 14) 
            h = rng.randint(8, 10)
            x0 = rng.randint(2, self.state.CHUNK_SIZE - w - 2)
            y0 = rng.randint(2, self.state.CHUNK_SIZE - h - 2)

            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            for y in range(int(y0), int(y0 + h)):
                for x in range(int(x0), int(x0 + w)):
                    if int(tiles[idx(x, y)]) == int(self.state.T_ROAD):
                        return
            for y in range(int(y0), int(y0 + h)):
                for x in range(int(x0), int(x0 + w)):
                    tiles[idx(x, y)] = int(self.state.T_COURT)

        def _stamp_gas_station_chunk(
            self,
            tiles: list[int],
            items: list["HardcoreSurvivalState._WorldItem"],
            buildings: list[tuple[int, int, int, int, int, int]],
            props: list["HardcoreSurvivalState._WorldProp"],
            cx: int,
            cy: int,
            *,
            rng: random.Random,
            reserved: set[tuple[int, int]] | None = None,
        ) -> None:
            # Simple roadside gas station: a small shop + a couple of pumps.
            chunk_size = int(self.state.CHUNK_SIZE)

            def idx(x: int, y: int) -> int:
                return y * chunk_size + x

            base_tx = int(cx) * chunk_size
            base_ty = int(cy) * chunk_size

            # Forecourt aligned near the highway band (if present).
            hy = int(getattr(self, "highway_y", base_ty + chunk_size // 2))
            y_center = int(clamp(int(hy - base_ty), 8, 24))
            x0 = 4
            w = 24
            h = 14
            y0 = int(clamp(int(y_center) - 10, 2, chunk_size - h - 2))

            for y in range(int(y0), int(y0 + h)):
                for x in range(int(x0), int(x0 + w)):
                    tiles[idx(int(x), int(y))] = int(self.state.T_PAVEMENT)

            # Shop building (1F).
            shop_x0 = int(x0 + 2)
            shop_y0 = int(y0 + 2)
            shop_w = 9
            shop_h = 7
            door_x = int(shop_x0 + shop_w // 2)
            door_y = int(shop_y0 + shop_h - 1)
            for y in range(int(shop_y0), int(shop_y0 + shop_h)):
                for x in range(int(shop_x0), int(shop_x0 + shop_w)):
                    border = bool(
                        int(x) == int(shop_x0)
                        or int(x) == int(shop_x0 + shop_w - 1)
                        or int(y) == int(shop_y0)
                        or int(y) == int(shop_y0 + shop_h - 1)
                    )
                    tiles[idx(int(x), int(y))] = int(self.state.T_WALL if border else self.state.T_FLOOR)
            tiles[idx(int(door_x), int(door_y))] = int(self.state.T_DOOR)
            if reserved is not None:
                for dy in (-1, 0, 1):
                    for dx in (-1, 0, 1):
                        reserved.add((int(door_x + dx), int(door_y + dy)))

            roof_var = int(rng.randrange(0, 256))
            roof_kind = (2 << 8) | int(roof_var)
            buildings.append((int(base_tx + shop_x0), int(base_ty + shop_y0), int(shop_w), int(shop_h), int(roof_kind), 1))

            # Front sign.
            props.append(
                HardcoreSurvivalState._WorldProp(
                    pos=pygame.Vector2((float(base_tx + door_x) + 0.5) * float(self.state.TILE_SIZE), (float(base_ty + door_y) + 0.5) * float(self.state.TILE_SIZE)),
                    prop_id="sign_gas",
                    variant=0,
                    dir="down",
                )
            )

            # Pumps (solid tiles).
            pump_y = int(y0 + h - 5)
            for pump_x in (int(x0 + w - 8), int(x0 + w - 5)):
                if int(x0) <= int(pump_x) < int(x0 + w) and int(y0) <= int(pump_y) < int(y0 + h):
                    tiles[idx(int(pump_x), int(pump_y))] = int(self.state.T_GAS_PUMP)

            # Small parking stripe to the side.
            for y in range(int(y0 + 1), int(y0 + h - 1)):
                x = int(x0 + w - 2)
                if 0 <= x < chunk_size:
                    tiles[idx(int(x), int(y))] = int(self.state.T_PARKING)

        def _stamp_parking_lot(
            self,
            tiles: list[int],
            cars: list["HardcoreSurvivalState._ParkedCar"],
            bikes: list["HardcoreSurvivalState._ParkedBike"],
            cx: int,
            cy: int,
            *,
            rng: random.Random,
            school: bool = False,
            buildings: list[tuple[int, int, int, int, int, int]] | None = None,
            reserved: set[tuple[int, int]] | None = None,
        ) -> None:
            # Parking lot: stamp tiles + spawn parked vehicles (visual props).
            allowed_base = {
                int(self.state.T_GRASS),
                int(self.state.T_FOREST),
                int(self.state.T_PAVEMENT),
                int(self.state.T_PARKING),
                int(self.state.T_SIDEWALK),
                int(self.state.T_BRICK),
                int(self.state.T_CONCRETE),
            }

            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            placed: tuple[int, int, int, int] | None = None
            for _ in range(18):
                w = rng.randint(12, 20)
                h = rng.randint(9, 14)
                x0 = rng.randint(2, self.state.CHUNK_SIZE - w - 2)
                y0 = rng.randint(2, self.state.CHUNK_SIZE - h - 2)

                blocked = False
                for y in range(int(y0), int(y0 + h)):
                    for x in range(int(x0), int(x0 + w)):
                        t = int(tiles[idx(x, y)])
                        if t not in allowed_base:
                            blocked = True
                            break
                    if blocked:
                        break
                if blocked:
                    continue
                placed = (int(x0), int(y0), int(w), int(h))
                break
            if placed is None:
                return

            x0, y0, w, h = placed
            for y in range(int(y0), int(y0 + h)):
                for x in range(int(x0), int(x0 + w)):
                    tiles[idx(x, y)] = int(self.state.T_PARKING)
                    if reserved is not None:
                        reserved.add((int(x), int(y)))

            # Spawn cars in a loose grid.
            car_pool = [mid for mid in self.state._CAR_MODELS.keys() if str(mid) != "rv"]
            if not car_pool:
                return
            base_tx = int(cx) * int(self.state.CHUNK_SIZE)
            base_ty = int(cy) * int(self.state.CHUNK_SIZE)
            spots: list[tuple[int, int]] = []
            for yy in range(int(y0) + 1, int(y0 + h) - 1, 3):
                for xx in range(int(x0) + 1, int(x0 + w) - 1, 4):
                    if int(tiles[idx(xx, yy)]) != int(self.state.T_PARKING):
                        continue
                    spots.append((int(xx), int(yy)))
            if not spots:
                return
            rng.shuffle(spots)
            n_cars = int(clamp(int(rng.randint(1, 4)), 0, len(spots)))
            for i in range(n_cars):
                sx, sy = spots[i]
                tx = base_tx + int(sx)
                ty = base_ty + int(sy)
                px = (float(tx) + 0.5) * float(self.state.TILE_SIZE)
                py = (float(ty) + 0.5) * float(self.state.TILE_SIZE)
                model_id = str(rng.choice(car_pool))
                heading = 0.0 if (i % 2 == 0) else (math.pi / 2)
                fuel = float(rng.uniform(18.0, 96.0)) if rng.random() < 0.85 else float(rng.uniform(0.0, 28.0))
                cars.append(
                    HardcoreSurvivalState._ParkedCar(
                        pos=pygame.Vector2(px, py),
                        model_id=model_id,
                        heading=float(heading),
                        fuel=float(fuel),
                    )
                )

            if school:
                # A few bikes near the parking lot.
                self._spawn_two_wheelers(
                    tiles,
                    bikes,
                    cx,
                    cy,
                    rng=rng,
                    count=rng.randint(1, 3),
                    models=["bike_lady", "bike_mountain", "bike_auto"],
                    buildings=buildings,
                    reserved=reserved,
                )

        def _spawn_two_wheelers(
            self,
            tiles: list[int],
            bikes: list["HardcoreSurvivalState._ParkedBike"],
            cx: int,
            cy: int,
            *,
            rng: random.Random,
            count: int,
            models: list[str],
            buildings: list[tuple[int, int, int, int, int, int]] | None = None,
            reserved: set[tuple[int, int]] | None = None,
        ) -> None:
            if count <= 0 or not models:
                return

            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            base_tx = int(cx) * int(self.state.CHUNK_SIZE)
            base_ty = int(cy) * int(self.state.CHUNK_SIZE)
            candidates: list[tuple[int, int]] = []
            for y in range(2, self.state.CHUNK_SIZE - 2):
                for x in range(2, self.state.CHUNK_SIZE - 2):
                    t = int(tiles[idx(int(x), int(y))])
                    if t in (int(self.state.T_ROAD), int(self.state.T_WALL), int(self.state.T_DOOR)):
                        continue
                    if t not in (
                        int(self.state.T_PAVEMENT),
                        int(self.state.T_PARKING),
                        int(self.state.T_SIDEWALK),
                        int(self.state.T_BRICK),
                        int(self.state.T_CONCRETE),
                    ):
                        continue
                    # Avoid spawning right next to building walls/doors (looks like bikes are "on the facade").
                    near_wall = False
                    for ny in range(int(y) - 2, int(y) + 3):
                        for nx in range(int(x) - 2, int(x) + 3):
                            if not (0 <= int(nx) < int(self.state.CHUNK_SIZE) and 0 <= int(ny) < int(self.state.CHUNK_SIZE)):
                                continue
                            nt = int(tiles[idx(int(nx), int(ny))])        
                            if nt in (int(self.state.T_WALL), int(self.state.T_DOOR)):
                                near_wall = True
                                break
                        if near_wall:
                            break
                    if near_wall:
                        continue
                    candidates.append((int(x), int(y)))
            if not candidates:
                return
            rng.shuffle(candidates)
            want = int(clamp(int(count), 0, len(candidates)))
            dirs = ["up", "down", "left", "right"]
            tile_size = int(self.state.TILE_SIZE)
            chunk_size = int(self.state.CHUNK_SIZE)
            t_floor = int(self.state.T_FLOOR)
            t_door = int(self.state.T_DOOR)

            def tile_blocks_vehicle(t: int) -> bool:
                t = int(t)
                if t in (t_floor, t_door):
                    return True
                tdef = self.state._TILES.get(int(t))
                if tdef is None:
                    return False
                return bool(getattr(tdef, "solid", False))

            def rect_clear(r: pygame.Rect) -> bool:
                left = int(math.floor(r.left / tile_size))
                right = int(math.floor((r.right - 1) / tile_size))
                top = int(math.floor(r.top / tile_size))
                bottom = int(math.floor((r.bottom - 1) / tile_size))
                for ty in range(int(top), int(bottom) + 1):
                    ly = int(ty - base_ty)
                    if not (0 <= ly < chunk_size):
                        return False
                    for tx in range(int(left), int(right) + 1):
                        lx = int(tx - base_tx)
                        if not (0 <= lx < chunk_size):
                            return False
                        if tile_blocks_vehicle(int(tiles[idx(int(lx), int(ly))])):
                            return False
                return True

            def inside_any_building(tx: int, ty: int) -> bool:
                if not buildings:
                    return False
                for bx0, by0, bw, bh, _roof_kind, _floors in buildings:
                    if int(bx0) <= int(tx) < int(bx0) + int(bw) and int(by0) <= int(ty) < int(by0) + int(bh):
                        return True
                return False

            placed = 0
            for sx, sy in candidates:
                if placed >= want:
                    break
                tx = base_tx + int(sx)
                ty = base_ty + int(sy)
                if inside_any_building(int(tx), int(ty)):
                    continue

                mid = str(rng.choice(models))
                w_px, h_px = self.state._two_wheel_collider_px(mid)
                px = (float(tx) + 0.5) * float(tile_size)
                py = (float(ty) + 0.5) * float(tile_size)
                rect = pygame.Rect(
                    int(iround(float(px) - float(w_px) / 2.0)),
                    int(iround(float(py) - float(h_px) / 2.0)),
                    int(w_px),
                    int(h_px),
                )
                if not rect_clear(rect):
                    continue

                d = str(rng.choice(dirs))
                fuel = 0.0
                if str(mid).startswith("moto"):
                    fuel = float(rng.uniform(25.0, 95.0))
                elif str(mid) == "bike_auto":
                    fuel = float(rng.uniform(40.0, 100.0))
                bikes.append(
                    HardcoreSurvivalState._ParkedBike(pos=pygame.Vector2(px, py), model_id=mid, dir=d, fuel=float(fuel))
                )
                if reserved is not None:
                    reserved.add((int(sx), int(sy)))
                placed += 1

        def _stamp_outdoor_decor(
            self,
            tiles: list[int],
            props: list["HardcoreSurvivalState._WorldProp"],
            cx: int,
            cy: int,
            *,
            rng: random.Random,
        ) -> None:
            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            base_tx = int(cx) * int(self.state.CHUNK_SIZE)
            base_ty = int(cy) * int(self.state.CHUNK_SIZE)

            def far_from_existing(px: float, py: float, *, min_d: float) -> bool:
                md2 = float(min_d) * float(min_d)
                for p in props:
                    pos = getattr(p, "pos", None)
                    if pos is None:
                        continue
                    d2 = float((pygame.Vector2(pos) - pygame.Vector2(px, py)).length_squared())
                    if d2 < md2:
                        return False
                return True

            t_sand = int(self.state.T_SAND)
            t_board = int(self.state.T_BOARDWALK)
            t_water = int(self.state.T_WATER)
            t_highway = int(self.state.T_HIGHWAY)

            # Beach amusements: place a couple of abandoned toys near the boardwalk.
            beach_cand: list[tuple[int, int]] = []
            for y in range(2, int(self.state.CHUNK_SIZE) - 2):
                for x in range(2, int(self.state.CHUNK_SIZE) - 2):
                    t = int(tiles[idx(int(x), int(y))])
                    if t not in (t_sand, t_board):
                        continue
                    near = False
                    for nx, ny in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
                        nt = int(tiles[idx(int(nx), int(ny))])
                        if nt in (t_board, t_water):
                            near = True
                            break
                    if near:
                        beach_cand.append((int(x), int(y)))
            if len(beach_cand) >= 36:
                rng.shuffle(beach_cand)
                want = int(rng.randint(1, 3))
                toy_pool = ["toy_seesaw", "toy_carousel", "toy_swing"]
                for x, y in beach_cand:
                    if want <= 0:
                        break
                    wx = int(base_tx + int(x))
                    wy = int(base_ty + int(y))
                    px = (float(wx) + 0.5) * float(self.state.TILE_SIZE)
                    py = (float(wy) + 0.5) * float(self.state.TILE_SIZE)
                    if not far_from_existing(px, py, min_d=30.0):
                        continue
                    props.append(
                        HardcoreSurvivalState._WorldProp(
                            pos=pygame.Vector2(px, py),
                            prop_id=str(rng.choice(toy_pool)),
                            variant=int(rng.randint(0, 7)),
                            dir=str(rng.choice(["left", "right", "up", "down"])),
                        )
                    )
                    want -= 1

            # Abandoned highways: occasional billboards near the shoulder.
            bill_cand: list[tuple[int, int]] = []
            for y in range(2, int(self.state.CHUNK_SIZE) - 2):
                for x in range(2, int(self.state.CHUNK_SIZE) - 2):
                    t = int(tiles[idx(int(x), int(y))])
                    if t in (t_highway, int(self.state.T_WALL), int(self.state.T_DOOR)):
                        continue
                    if not (
                        int(tiles[idx(int(x) + 1, int(y))]) == t_highway
                        or int(tiles[idx(int(x) - 1, int(y))]) == t_highway
                        or int(tiles[idx(int(x), int(y) + 1)]) == t_highway
                        or int(tiles[idx(int(x), int(y) - 1)]) == t_highway
                    ):
                        continue
                    tdef = self.state._TILES.get(int(t))
                    if tdef is not None and bool(getattr(tdef, "solid", False)):
                        continue
                    bill_cand.append((int(x), int(y)))

            if bill_cand and rng.random() < 0.55:
                rng.shuffle(bill_cand)
                want = 1 if len(bill_cand) >= 18 else 0
                for x, y in bill_cand:
                    if want <= 0:
                        break
                    wx = int(base_tx + int(x))
                    wy = int(base_ty + int(y))
                    px = (float(wx) + 0.5) * float(self.state.TILE_SIZE)
                    py = (float(wy) + 0.5) * float(self.state.TILE_SIZE)
                    if not far_from_existing(px, py, min_d=26.0):
                        continue
                    props.append(
                        HardcoreSurvivalState._WorldProp(
                            pos=pygame.Vector2(px, py),
                            prop_id="billboard",
                            variant=int(rng.randint(0, 7)),
                            dir=str(rng.choice(["left", "right", "up", "down"])),
                        )
                    )
                    want -= 1

        def _stamp_city_decor(
            self,
            tiles: list[int],
            props: list["HardcoreSurvivalState._WorldProp"],
            cx: int,
            cy: int,
            *,
            rng: random.Random,
        ) -> None:
            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            base_tx = int(cx) * int(self.state.CHUNK_SIZE)
            base_ty = int(cy) * int(self.state.CHUNK_SIZE)

            # Billboards near streets (non-blocking decoration).
            bill_cand: list[tuple[int, int]] = []
            for y in range(2, int(self.state.CHUNK_SIZE) - 2):
                for x in range(2, int(self.state.CHUNK_SIZE) - 2):
                    t = int(tiles[idx(int(x), int(y))])
                    if t not in (
                        int(self.state.T_SIDEWALK),
                        int(self.state.T_PAVEMENT),
                        int(self.state.T_CONCRETE),
                        int(self.state.T_BRICK),
                        int(self.state.T_PARKING),
                    ):
                        continue
                    near_road = False
                    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        if int(tiles[idx(int(x + dx), int(y + dy))]) == int(self.state.T_ROAD):
                            near_road = True
                            break
                    if not near_road:
                        continue
                    bill_cand.append((int(x), int(y)))
            rng.shuffle(bill_cand)

            want_bill = 0
            if bill_cand and rng.random() < 0.55:
                want_bill = 1 if rng.random() < 0.75 else 2

            def far_from_existing(px: float, py: float, *, min_d: float) -> bool:
                md2 = float(min_d) * float(min_d)
                for pr in props:
                    dx = float(pr.pos.x) - float(px)
                    dy = float(pr.pos.y) - float(py)
                    if dx * dx + dy * dy < md2:
                        return False
                return True

            for x, y in bill_cand:
                if want_bill <= 0:
                    break
                wx = int(base_tx + int(x))
                wy = int(base_ty + int(y))
                px = (float(wx) + 0.5) * float(self.state.TILE_SIZE)
                py = (float(wy) + 0.5) * float(self.state.TILE_SIZE)
                if not far_from_existing(px, py, min_d=26.0):
                    continue
                props.append(
                    HardcoreSurvivalState._WorldProp(
                        pos=pygame.Vector2(px, py),
                        prop_id="billboard",
                        variant=int(rng.randint(0, 7)),
                        dir=str(rng.choice(["left", "right", "up", "down"])),
                    )
                )
                want_bill -= 1

            # Park toys: only inside 3x3 grass/forest clusters.
            park_cand: list[tuple[int, int]] = []
            for y in range(3, int(self.state.CHUNK_SIZE) - 3):
                for x in range(3, int(self.state.CHUNK_SIZE) - 3):
                    t0 = int(tiles[idx(int(x), int(y))])
                    if t0 not in (int(self.state.T_GRASS), int(self.state.T_FOREST)):
                        continue
                    ok = True
                    for yy in range(int(y) - 1, int(y) + 2):
                        for xx in range(int(x) - 1, int(x) + 2):
                            tt = int(tiles[idx(int(xx), int(yy))])
                            if tt not in (int(self.state.T_GRASS), int(self.state.T_FOREST)):
                                ok = False
                                break
                        if not ok:
                            break
                    if ok:
                        park_cand.append((int(x), int(y)))
            rng.shuffle(park_cand)

            want_toys = 0
            if len(park_cand) >= 70:
                want_toys = int(rng.randint(1, 3))
            elif len(park_cand) >= 36:
                want_toys = int(rng.randint(0, 2))
            elif len(park_cand) >= 20:
                want_toys = int(rng.randint(0, 1))

            toy_pool = ["toy_seesaw", "toy_carousel", "toy_swing"]
            for x, y in park_cand:
                if want_toys <= 0:
                    break
                wx = int(base_tx + int(x))
                wy = int(base_ty + int(y))
                px = (float(wx) + 0.5) * float(self.state.TILE_SIZE)
                py = (float(wy) + 0.5) * float(self.state.TILE_SIZE)
                if not far_from_existing(px, py, min_d=30.0):
                    continue
                props.append(
                    HardcoreSurvivalState._WorldProp(
                        pos=pygame.Vector2(px, py),
                        prop_id=str(rng.choice(toy_pool)),
                        variant=int(rng.randint(0, 7)),
                        dir=str(rng.choice(["left", "right", "up", "down"])),
                    )
                )
                want_toys -= 1

        def _stamp_buildings(
            self,
            tiles: list[int],
            items: list["HardcoreSurvivalState._WorldItem"],
            buildings: list[tuple[int, int, int, int, int, int]],
            special_buildings: list["HardcoreSurvivalState._SpecialBuilding"],  
            props: list["HardcoreSurvivalState._WorldProp"],
            cx: int,
            cy: int,
            rng: random.Random,
            town_kind: str,
            reserved: set[tuple[int, int]] | None = None,
        ) -> None:
            tries = 0
            placed = 0
            want = 1
            mh_out: list[HardcoreSurvivalState._MultiHouse] | None = getattr(self, "_multi_houses_out", None)
            max_tries = 120 if town_kind in ("大型超市", "大型监狱", "高层住宅", "高层住宅大") else 60

            def idx(x: int, y: int) -> int:
                return y * self.state.CHUNK_SIZE + x

            base_tx = int(cx) * int(self.state.CHUNK_SIZE)
            base_ty = int(cy) * int(self.state.CHUNK_SIZE)
            allow_overwrite_city_street = town_kind in ("大型超市", "大型监狱", "高层住宅大")

            while placed < want and tries < max_tries:
                tries += 1
                building_floors = 0
                if town_kind == "大型超市":
                    w = rng.randint(20, 28)
                    h = rng.randint(14, 22)
                elif town_kind == "超市":
                    w = rng.randint(13, 19)
                    h = rng.randint(10, 16)
                elif town_kind == "新华书店":
                    w = rng.randint(12, 18)
                    h = rng.randint(10, 15)
                elif town_kind == "枪械店":
                    w = rng.randint(10, 15)
                    h = rng.randint(8, 12)
                elif town_kind == "医院":
                    w = rng.randint(14, 20)
                    h = rng.randint(12, 18)
                elif town_kind == "学校":
                    w = rng.randint(16, 23)
                    h = rng.randint(13, 19)
                elif town_kind == "高层住宅大":
                    w = rng.randint(22, 27)
                    h = rng.randint(22, 28)
                elif town_kind == "高层住宅":
                    # Larger footprint so 2/3-unit apartments feel like real homes.
                    w = rng.randint(20, 24)
                    h = rng.randint(20, 26)
                elif town_kind == "大型监狱":
                    w = rng.randint(22, 28)
                    h = rng.randint(20, 28)
                elif town_kind == "监狱":
                    w = rng.randint(14, 20)
                    h = rng.randint(13, 19)
                elif town_kind == "中式建筑":
                    w = rng.randint(9, 15)
                    h = rng.randint(8, 13)
                elif town_kind == "住宅":
                    # Residential houses: keep them small (typical 1–2 story size).
                    w = rng.randint(6, 9)
                    h = rng.randint(6, 9)
                else:
                    w = rng.randint(8, 12)
                    h = rng.randint(7, 12)
                x0 = rng.randint(2, self.state.CHUNK_SIZE - w - 2)
                y0 = rng.randint(2, self.state.CHUNK_SIZE - h - 2)

                blocked = False
                for y in range(y0, y0 + h):
                    for x in range(x0, x0 + w):
                        if reserved is not None and (int(x), int(y)) in reserved:
                            blocked = True
                            break
                        t = tiles[idx(x, y)]
                        if int(t) == int(self.state.T_ROAD):
                            wx = int(base_tx + int(x))
                            wy = int(base_ty + int(y))
                            is_main = bool(self.is_road(wx, wy))
                            is_city_minor = bool(self.is_city_street(wx, wy)) and not is_main
                            if allow_overwrite_city_street and is_city_minor:
                                continue
                            blocked = True
                            break
                        if t not in (
                            self.state.T_GRASS,
                            self.state.T_FOREST,
                            self.state.T_WATER,
                            self.state.T_PAVEMENT,
                            self.state.T_PARKING,
                            self.state.T_COURT,
                            self.state.T_SIDEWALK,
                            self.state.T_BRICK,
                            self.state.T_CONCRETE,
                        ):
                            blocked = True
                            break
                    if blocked:
                        break
                if blocked:
                    continue

                is_highrise = town_kind in ("高层住宅", "高层住宅大")
                roof_var_hint: int | None = None
                core_h = int(h) - 2
                if is_highrise:
                    tx0w = int(base_tx + x0)
                    ty0w = int(base_ty + y0)
                    roof_var_hint = int(self.state._hash2_u32(int(tx0w), int(ty0w), int(self.seed) ^ 0x7A11C1D3) & 0xFF)
                    max_f = int(max(2, int(getattr(self.state, "HIGHRISE_MAX_FLOORS", 10))))
                    lo = 8 if town_kind == "高层住宅大" else 6
                    lo = int(max(2, min(int(lo), int(max_f))))
                    building_floors = int(rng.randint(int(lo), int(max_f)))
                    cut_px = int(self.state._roof_cut_px(style=6, w=int(w), h=int(h), var=int(roof_var_hint), floors=int(building_floors)))
                    cut_tiles = int(cut_px) // int(max(1, int(self.state.TILE_SIZE)))
                    core_h = int(max(2, int(h) - 2 - int(cut_tiles)))
                    min_core_h = int(max(6, int(getattr(self.state, "HIGHRISE_MIN_FLOOR_TILES", 9))))
                    core_h = int(min(int(max(int(core_h), int(min_core_h))), int(max(2, int(h) - 2))))

                # Always use south-facing entrances so the single "front facade"
                # (bottom/S) matches the actual doorway + collision.
                door_side = "S"
                door_tiles: list[tuple[int, int]] = []
                if door_side == "N":
                    dx = rng.randint(x0 + 1, x0 + w - 3)
                    dy = y0
                    door_tiles = [(dx, dy), (dx + 1, dy)]
                elif door_side == "S":
                    dy = y0 + h - 1

                    def approach_clear(ddx0: int, ddy0: int) -> bool:
                        for ddx, ddy in ((ddx0, ddy0), (ddx0 + 1, ddy0)):
                            for step in range(1, 9):
                                px = int(ddx)
                                py = int(ddy + step)
                                if not (0 <= px < int(self.state.CHUNK_SIZE) and 0 <= py < int(self.state.CHUNK_SIZE)):
                                    break
                                tcur = int(tiles[idx(int(px), int(py))])
                                if tcur in (
                                    int(self.state.T_WALL),
                                    int(self.state.T_FLOOR),
                                    int(self.state.T_DOOR),
                                ):
                                    return False
                        return True

                    door_x_candidates = [int(x) for x in range(int(x0 + 1), int(x0 + w - 2))]
                    rng.shuffle(door_x_candidates)
                    door_x_candidates = [int(x) for x in door_x_candidates if approach_clear(int(x), int(dy))]
                    if not door_x_candidates:
                        continue
                    dx = int(rng.choice(door_x_candidates))
                    door_tiles = [(dx, dy), (dx + 1, dy)]
                elif door_side == "W":
                    dx = x0
                    dy = rng.randint(y0 + 1, y0 + h - 3)
                    door_tiles = [(dx, dy), (dx, dy + 1)]
                else:
                    dx = x0 + w - 1
                    dy = rng.randint(y0 + 1, y0 + h - 3)
                    door_tiles = [(dx, dy), (dx, dy + 1)]

                for y in range(y0, y0 + h):
                    for x in range(x0, x0 + w):
                        border = x in (x0, x0 + w - 1) or y in (y0, y0 + h - 1)
                        tiles[idx(x, y)] = self.state.T_WALL if border else self.state.T_FLOOR

                if is_highrise:
                    # Keep the 1F footprint pressed against the south facade:
                    # cut rows from the *top* of the interior, not the bottom.
                    top_cut = int(max(0, (int(h) - 2) - int(core_h)))
                    if top_cut > 0:
                        cut_y0 = int(y0 + 1)
                        cut_y1 = int(min(int(y0 + h - 1), int(cut_y0 + top_cut)))
                        for yy in range(int(cut_y0), int(cut_y1)):
                            for xx in range(int(x0 + 1), int(x0 + w - 1)):
                                tiles[idx(int(xx), int(yy))] = int(self.state.T_WALL)

                for dx, dy in door_tiles:
                    tiles[idx(dx, dy)] = self.state.T_DOOR

                # Carve a small approach path outside the door so buildings are
                # always reachable even if terrain noise produced water nearby.
                if door_side == "N":
                    ox, oy = 0, -1
                elif door_side == "S":
                    ox, oy = 0, 1
                elif door_side == "W":
                    ox, oy = -1, 0
                else:
                    ox, oy = 1, 0
                path_tile = int(self.state.T_SIDEWALK) if bool(self._is_city_chunk(int(cx), int(cy))) else int(self.state.T_ROAD)
                for dx, dy in door_tiles:
                    for step in range(1, 9):
                        px = dx + ox * step
                        py = dy + oy * step
                        if not (0 <= px < self.state.CHUNK_SIZE and 0 <= py < self.state.CHUNK_SIZE):
                            break
                        tcur = int(tiles[idx(int(px), int(py))])
                        if tcur in (int(self.state.T_WALL), int(self.state.T_FLOOR), int(self.state.T_DOOR)):
                            break
                        tiles[idx(px, py)] = path_tile
                        if reserved is not None:
                            reserved.add((int(px), int(py)))

                # Exterior signage so building type reads from outside.
                sign_id = "sign_home"
                if town_kind == "医院":
                    sign_id = "sign_hospital"
                elif town_kind == "超市":
                    sign_id = "sign_shop"
                elif town_kind == "大型超市":
                    sign_id = "sign_shop_big"
                elif town_kind == "新华书店":
                    sign_id = "sign_bookstore"
                elif town_kind == "枪械店":
                    sign_id = "sign_gunshop"
                elif town_kind == "学校":
                    sign_id = "sign_school"
                elif town_kind in ("监狱", "大型监狱"):
                    sign_id = "sign_prison"
                elif town_kind in ("高层住宅", "高层住宅大"):
                    sign_id = "sign_highrise"
                elif town_kind == "中式建筑":
                    sign_id = "sign_chinese"

                door_mx = int(round(sum(int(p[0]) for p in door_tiles) / max(1, len(door_tiles))))
                door_my = int(round(sum(int(p[1]) for p in door_tiles) / max(1, len(door_tiles))))
                out_x = door_mx + int(ox)
                out_y = door_my + int(oy)
                # Avoid placing a sign directly in front of the doorway (looks like it blocks the entrance).
                sign_candidates: list[tuple[int, int]] = []
                xs0 = [p[0] for p in door_tiles]
                ys0 = [p[1] for p in door_tiles]
                dx0 = int(min(xs0)) if xs0 else int(door_mx)
                dx1 = int(max(xs0)) if xs0 else int(door_mx)
                dy0 = int(max(ys0)) if ys0 else int(door_my)

                # Prefer placing signs on the ground outside the entrance (never on wall tiles),
                # so they don't look like they're floating on the facade.

                if door_side in ("N", "S"):
                    sign_candidates += [
                        (int(out_x) - 1, int(out_y)),
                        (int(out_x) + 1, int(out_y)),
                        (int(out_x) - 2, int(out_y)),
                        (int(out_x) + 2, int(out_y)),
                    ]
                else:
                    sign_candidates += [
                        (int(out_x), int(out_y) - 1),
                        (int(out_x), int(out_y) + 1),
                        (int(out_x), int(out_y) - 2),
                        (int(out_x), int(out_y) + 2),
                    ]

                for sx, sy in sign_candidates:
                    if not (0 <= int(sx) < int(self.state.CHUNK_SIZE) and 0 <= int(sy) < int(self.state.CHUNK_SIZE)):
                        continue
                    tdef = self.state._TILES.get(int(tiles[idx(int(sx), int(sy))]))
                    if tdef is not None and bool(getattr(tdef, "solid", False)):
                        continue
                    wx = int(base_tx + int(sx))
                    wy = int(base_ty + int(sy))
                    px = (float(wx) + 0.5) * float(self.state.TILE_SIZE)
                    py = (float(wy) + 0.5) * float(self.state.TILE_SIZE)
                    props.append(
                        HardcoreSurvivalState._WorldProp(
                            pos=pygame.Vector2(px, py),
                            prop_id=str(sign_id),
                            variant=int(rng.randint(0, 7)),
                            dir=str({"N": "up", "S": "down", "W": "left", "E": "right"}.get(str(door_side), "down")),
                        )
                    )
                    break

                def near_door(x: int, y: int) -> bool:
                    for ddx, ddy in door_tiles:
                        if abs(int(x) - int(ddx)) <= 1 and abs(int(y) - int(ddy)) <= 1:
                            return True
                    return False

                # Interior layout (rooms + props). Keep a clear corridor so the
                # entrance always feels navigable.
                in_left = x0 + 1
                in_right = x0 + w - 2
                in_top = y0 + 1
                in_bottom = y0 + h - 2

                door_cx = sum(int(p[0]) for p in door_tiles) / max(1, len(door_tiles))
                door_cy = sum(int(p[1]) for p in door_tiles) / max(1, len(door_tiles))

                corridor: set[tuple[int, int]] = set()

                def mark_corridor(x: int, y: int) -> None:
                    if in_left <= int(x) <= in_right and in_top <= int(y) <= in_bottom:
                        corridor.add((int(x), int(y)))

                def set_interior(x: int, y: int, tile_id: int) -> None:
                    if not (in_left <= int(x) <= in_right and in_top <= int(y) <= in_bottom):
                        return
                    if near_door(int(x), int(y)):
                        return
                    if (int(x), int(y)) in corridor:
                        return
                    tiles[idx(int(x), int(y))] = int(tile_id)

                def clear_interior(x: int, y: int) -> None:
                    if not (in_left <= int(x) <= in_right and in_top <= int(y) <= in_bottom):
                        return
                    tiles[idx(int(x), int(y))] = self.state.T_FLOOR

                # Main corridor based on entrance side.
                if door_side in ("N", "S"):
                    cx_line = int(clamp(int(round(door_cx)), in_left, in_right))
                    for y in range(in_top, in_bottom + 1):
                        mark_corridor(cx_line, y)
                        mark_corridor(cx_line + 1, y)
                else:
                    cy_line = int(clamp(int(round(door_cy)), in_top, in_bottom))
                    for x in range(in_left, in_right + 1):
                        mark_corridor(x, cy_line)
                        mark_corridor(x, cy_line + 1)

                # Ensure the immediate area behind the door is clear.
                if door_side == "N":
                    for dx, _dy in door_tiles:
                        mark_corridor(dx, y0 + 1)
                        mark_corridor(dx, y0 + 2)
                elif door_side == "S":
                    for dx, _dy in door_tiles:
                        mark_corridor(dx, y0 + h - 2)
                        mark_corridor(dx, y0 + h - 3)
                elif door_side == "W":
                    for _dx, dy in door_tiles:
                        mark_corridor(x0 + 1, dy)
                        mark_corridor(x0 + 2, dy)
                else:
                    for _dx, dy in door_tiles:
                        mark_corridor(x0 + w - 2, dy)
                        mark_corridor(x0 + w - 3, dy)

                def build_room(rx: int, ry: int, rw: int, rh: int) -> tuple[int, int] | None:
                    # rx/ry are interior-floor top-left; walls wrap around.
                    rw = int(max(2, rw))
                    rh = int(max(2, rh))
                    rx = int(clamp(rx, in_left + 1, in_right - rw))
                    ry = int(clamp(ry, in_top + 1, in_bottom - rh))

                    for y in range(ry, ry + rh):
                        for x in range(rx, rx + rw):
                            clear_interior(x, y)

                    # Walls (only inside the building border).
                    for x in range(rx - 1, rx + rw + 1):
                        set_interior(x, ry - 1, self.state.T_WALL)
                        set_interior(x, ry + rh, self.state.T_WALL)
                    for y in range(ry - 1, ry + rh + 1):
                        set_interior(rx - 1, y, self.state.T_WALL)
                        set_interior(rx + rw, y, self.state.T_WALL)

                    # Door on the side facing the center.
                    cx = x0 + w / 2.0
                    cy = y0 + h / 2.0
                    side: str
                    if abs((rx + rw / 2.0) - cx) >= abs((ry + rh / 2.0) - cy):
                        side = "W" if (rx + rw / 2.0) > cx else "E"
                    else:
                        side = "N" if (ry + rh / 2.0) > cy else "S"

                    if side == "N":
                        dx = rx + rw // 2
                        dy = ry - 1
                    elif side == "S":
                        dx = rx + rw // 2
                        dy = ry + rh
                    elif side == "W":
                        dx = rx - 1
                        dy = ry + rh // 2
                    else:
                        dx = rx + rw
                        dy = ry + rh // 2

                    if in_left <= dx <= in_right and in_top <= dy <= in_bottom and not near_door(dx, dy):
                        tiles[idx(dx, dy)] = self.state.T_DOOR
                        # Clear a tiny landing outside the door.
                        if side == "N":
                            clear_interior(dx, dy + 1)
                        elif side == "S":
                            clear_interior(dx, dy - 1)
                        elif side == "W":
                            clear_interior(dx + 1, dy)
                        else:
                            clear_interior(dx - 1, dy)
                        mark_corridor(dx, dy)
                        return dx, dy
                    return None

                if town_kind == "新华书店":
                    # Bookstore: shelves in aisles + a small reading area.
                    backroom: tuple[int, int, int, int] | None = None
                    if w >= 12 and h >= 9 and rng.random() < 0.75:
                        rw = min(4, int(w) - 6)
                        rh = min(3, int(h) - 5)
                        rx = x0 + 2 if door_side in ("N", "S") else (x0 + w - rw - 2)
                        ry = y0 + h - rh - 2 if door_side == "N" else (y0 + 2)
                        backroom = (int(rx), int(ry), int(rw), int(rh))
                        build_room(int(rx), int(ry), int(rw), int(rh))

                    # Shelf islands (leave walkable aisles).
                    for y in range(y0 + 3, y0 + h - 3, 3):
                        for x in range(x0 + 2, x0 + w - 3, 4):
                            if backroom is not None:
                                bx, by, bw, bh = backroom
                                if (bx - 1) <= int(x) <= (bx + bw) and (by - 1) <= int(y) <= (by + bh):
                                    continue
                            if tiles[idx(int(x), int(y))] == self.state.T_FLOOR:
                                set_interior(int(x), int(y), self.state.T_SHELF)
                            if tiles[idx(int(x) + 1, int(y))] == self.state.T_FLOOR:
                                set_interior(int(x) + 1, int(y), self.state.T_SHELF)

                    # Reading tables nearer the entrance.
                    if door_side in ("N", "S"):
                        y = y0 + 3 if door_side == "N" else y0 + h - 4
                        for x in range(x0 + 3, x0 + w - 3, 5):
                            if tiles[idx(int(x), int(y))] == self.state.T_FLOOR:
                                set_interior(int(x), int(y), self.state.T_TABLE)

                    # Checkout counter near entrance.
                    if door_side in ("N", "S"):
                        y = y0 + 2 if door_side == "N" else y0 + h - 3
                        x0c = int(round(door_cx)) - 1
                        x1c = int(round(door_cx)) + 1
                        for x in range(x0c, x1c + 1):
                            if (int(x), int(y)) in corridor or near_door(int(x), int(y)):
                                continue
                            set_interior(int(x), int(y), self.state.T_TABLE)
                    else:
                        x = x0 + 2 if door_side == "W" else x0 + w - 3
                        y0c = int(round(door_cy)) - 1
                        y1c = int(round(door_cy)) + 1
                        for y in range(y0c, y1c + 1):
                            if (int(x), int(y)) in corridor or near_door(int(x), int(y)):
                                continue
                            set_interior(int(x), int(y), self.state.T_TABLE)

                    # Backroom storage shelves.
                    if backroom is not None:
                        bx, by, bw, bh = backroom
                        for x in range(bx, bx + bw):
                            if (x - bx) % 2 == 0:
                                for y in range(by, by + bh):
                                    if tiles[idx(x, y)] == self.state.T_FLOOR:
                                        tiles[idx(x, y)] = self.state.T_SHELF

                elif town_kind == "枪械店":
                    # Gun shop: wall racks + a counter + optional backroom.    
                    backroom: tuple[int, int, int, int] | None = None
                    if w >= 11 and h >= 9 and rng.random() < 0.85:
                        rw = min(4, int(w) - 6)
                        rh = min(3, int(h) - 5)
                        rx = x0 + 2 if door_side in ("N", "S") else (x0 + w - rw - 2)
                        ry = y0 + h - rh - 2 if door_side == "N" else (y0 + 2)
                        backroom = (int(rx), int(ry), int(rw), int(rh))
                        build_room(int(rx), int(ry), int(rw), int(rh))

                    # Wall racks (leave the main corridor clear).
                    for x in range(in_left + 1, in_right, 2):
                        set_interior(int(x), int(in_top + 1), self.state.T_SHELF)
                        set_interior(int(x), int(in_bottom - 1), self.state.T_SHELF)
                    for y in range(in_top + 2, in_bottom - 1, 2):
                        set_interior(int(in_left + 1), int(y), self.state.T_SHELF)
                        set_interior(int(in_right - 1), int(y), self.state.T_SHELF)

                    # A couple of display islands.
                    for y in range(y0 + 3, y0 + h - 3, 4):
                        for x in range(x0 + 3, x0 + w - 3, 5):
                            if backroom is not None:
                                bx, by, bw, bh = backroom
                                if (bx - 1) <= int(x) <= (bx + bw) and (by - 1) <= int(y) <= (by + bh):
                                    continue
                            if tiles[idx(int(x), int(y))] == self.state.T_FLOOR:
                                set_interior(int(x), int(y), self.state.T_SHELF)

                    # Counter near entrance.
                    if door_side in ("N", "S"):
                        y = y0 + 2 if door_side == "N" else y0 + h - 3
                        x0c = int(round(door_cx)) - 2
                        x1c = int(round(door_cx)) + 2
                        for x in range(x0c, x1c + 1):
                            if (int(x), int(y)) in corridor or near_door(int(x), int(y)):
                                continue
                            set_interior(int(x), int(y), self.state.T_TABLE)
                    else:
                        x = x0 + 2 if door_side == "W" else x0 + w - 3
                        y0c = int(round(door_cy)) - 2
                        y1c = int(round(door_cy)) + 2
                        for y in range(y0c, y1c + 1):
                            if (int(x), int(y)) in corridor or near_door(int(x), int(y)):
                                continue
                            set_interior(int(x), int(y), self.state.T_TABLE)

                    # Backroom storage shelves.
                    if backroom is not None:
                        bx, by, bw, bh = backroom
                        for x in range(bx, bx + bw):
                            if (x - bx) % 2 == 0:
                                for y in range(by, by + bh):
                                    if tiles[idx(x, y)] == self.state.T_FLOOR:
                                        tiles[idx(x, y)] = self.state.T_SHELF

                elif town_kind in ("超市", "大型超市"):
                    # Optional back room.
                    backroom: tuple[int, int, int, int] | None = None
                    if w >= 12 and h >= 9:
                        rw = min(5, int(w) - 6)
                        rh = min(4, int(h) - 5)
                        rx = x0 + 2 if door_side in ("N", "S") else (x0 + w - rw - 2)
                        ry = y0 + h - rh - 2 if door_side == "N" else (y0 + 2)
                        backroom = (int(rx), int(ry), int(rw), int(rh))
                        build_room(int(rx), int(ry), int(rw), int(rh))

                    cross_y = int(clamp(int(y0 + h // 2), in_top + 1, in_bottom - 1))
                    for x in range(x0 + 2, x0 + w - 2, 3):
                        for y in range(y0 + 2, y0 + h - 2):
                            if (int(x), int(y)) in corridor:
                                continue
                            if abs(int(y) - int(cross_y)) <= 0:
                                continue
                            if near_door(int(x), int(y)):
                                continue
                            if backroom is not None:
                                bx, by, bw, bh = backroom
                                if (bx - 1) <= int(x) <= (bx + bw) and (by - 1) <= int(y) <= (by + bh):
                                    continue
                            tiles[idx(int(x), int(y))] = self.state.T_SHELF

                    # Checkout counter near entrance.
                    if door_side in ("N", "S"):
                        y = y0 + 2 if door_side == "N" else y0 + h - 3
                        x0c = int(round(door_cx)) - 2
                        x1c = int(round(door_cx)) + 2
                        for x in range(x0c, x1c + 1):
                            if (int(x), int(y)) in corridor or near_door(int(x), int(y)):
                                continue
                            set_interior(int(x), int(y), self.state.T_TABLE)
                    else:
                        x = x0 + 2 if door_side == "W" else x0 + w - 3
                        y0c = int(round(door_cy)) - 2
                        y1c = int(round(door_cy)) + 2
                        for y in range(y0c, y1c + 1):
                            if (int(x), int(y)) in corridor or near_door(int(x), int(y)):
                                continue
                            set_interior(int(x), int(y), self.state.T_TABLE)

                    # Backroom storage shelves.
                    if backroom is not None:
                        bx, by, bw, bh = backroom
                        for x in range(bx, bx + bw):
                            if (x - bx) % 2 == 0:
                                for y in range(by, by + bh):
                                    if tiles[idx(x, y)] == self.state.T_FLOOR:
                                        tiles[idx(x, y)] = self.state.T_SHELF

                elif town_kind == "中式建筑":
                    # Chinese-style small house: bed + table + side storage.
                    bx = in_left + 1
                    if door_side in ("N", "S"):
                        if int(round(door_cx)) <= int((in_left + in_right) // 2):
                            bx = in_right - 2
                        else:
                            bx = in_left + 1
                    by = in_top + 1
                    if tiles[idx(bx, by)] == self.state.T_FLOOR and tiles[idx(bx + 1, by)] == self.state.T_FLOOR:
                        tiles[idx(bx, by)] = self.state.T_BED
                        tiles[idx(bx + 1, by)] = self.state.T_BED

                    tx0c = int(clamp(int(round((in_left + in_right) / 2.0)), in_left + 1, in_right - 1))
                    ty0c = int(clamp(int(round((in_top + in_bottom) / 2.0)), in_top + 1, in_bottom - 1))
                    if tiles[idx(tx0c, ty0c)] == self.state.T_FLOOR:
                        tiles[idx(tx0c, ty0c)] = self.state.T_TABLE

                    shelf_x = in_left if bx > int((in_left + in_right) // 2) else in_right
                    for y in range(in_top + 2, in_bottom - 1, 2):
                        set_interior(int(shelf_x), int(y), self.state.T_SHELF)

                elif town_kind == "住宅":
                    # Residential: 2F houses stay on the world-map (no full-screen portal).
                    is_city = bool(self._is_city_chunk(int(cx), int(cy)))
                    r = float(rng.random())
                    floors = 1
                    if is_city:
                        if r < 0.35:
                            floors = 2
                    else:
                        # Some 2F houses also exist outside the dense city blocks.
                        if r < 0.18:
                            floors = 2
                    # Tiny footprints read better as 1F.
                    if int(w) < 7 or int(h) < 7:
                        floors = 1
                    building_floors = int(floors)

                    if False and floors > 1:
                        # Seal the world-map interior; enter via the door portal.
                        for y in range(int(y0 + 1), int(y0 + h - 1)):
                            for x in range(int(x0 + 1), int(x0 + w - 1)):
                                tiles[idx(int(x), int(y))] = self.state.T_WALL

                        tx0w = cx * self.state.CHUNK_SIZE + x0
                        ty0w = cy * self.state.CHUNK_SIZE + y0
                        doors_w = tuple(
                            (cx * self.state.CHUNK_SIZE + int(dx), cy * self.state.CHUNK_SIZE + int(dy))
                            for dx, dy in door_tiles
                        )
                        special_buildings.append(
                            HardcoreSurvivalState._SpecialBuilding(
                                kind="house",
                                name="住宅",
                                tx0=int(tx0w),
                                ty0=int(ty0w),
                                w=int(w),
                                h=int(h),
                                door_tiles=doors_w,
                                floors=int(floors),
                            )
                        )
                    else:
                        # Single-floor house: bed + table + shelf.
                        bx = in_left + 1
                        if door_side in ("N", "S"):
                            if int(round(door_cx)) <= int((in_left + in_right) // 2):
                                bx = in_right - 2
                            else:
                                bx = in_left + 1
                        by = in_top + 1
                        if tiles[idx(bx, by)] == self.state.T_FLOOR and tiles[idx(bx + 1, by)] == self.state.T_FLOOR:
                            tiles[idx(bx, by)] = self.state.T_BED
                            tiles[idx(bx + 1, by)] = self.state.T_BED

                        tx0c = int(clamp(int(round((in_left + in_right) / 2.0)), in_left + 1, in_right - 1))
                        ty0c = int(clamp(int(round((in_top + in_bottom) / 2.0)), in_top + 1, in_bottom - 1))
                        if tiles[idx(tx0c, ty0c)] == self.state.T_FLOOR:
                            tiles[idx(tx0c, ty0c)] = self.state.T_TABLE

                        shelf_x = in_left if bx > int((in_left + in_right) // 2) else in_right
                        for y in range(in_top + 2, in_bottom - 1, 2):
                            set_interior(int(shelf_x), int(y), self.state.T_SHELF)

                        if int(floors) > 1:
                            # Add a simple staircase for 2F houses and register a 2F tile snapshot.
                            stair_pos: tuple[int, int] | None = None
                            cand = [
                                (int(tx0c), int(ty0c) - 2),
                                (int(tx0c) - 2, int(ty0c)),
                                (int(tx0c) + 2, int(ty0c)),
                                (int(in_left + 2), int(in_bottom - 2)),
                                (int(in_right - 2), int(in_bottom - 2)),
                            ]
                            for sx, sy in cand:
                                if not (int(in_left) <= int(sx) <= int(in_right) and int(in_top) <= int(sy) <= int(in_bottom)):
                                    continue
                                if tiles[idx(int(sx), int(sy))] != int(self.state.T_FLOOR):
                                    continue
                                tiles[idx(int(sx), int(sy))] = int(self.state.T_STAIRS_UP)
                                stair_pos = (int(sx), int(sy))
                                break

                            if stair_pos is None:
                                # No space: fall back to a normal 1F house.
                                building_floors = 1
                            else:
                                tx0w = cx * self.state.CHUNK_SIZE + x0
                                ty0w = cy * self.state.CHUNK_SIZE + y0
                                f1: list[int] = []
                                for yy in range(int(h)):
                                    for xx in range(int(w)):
                                        f1.append(int(tiles[idx(int(x0 + xx), int(y0 + yy))]))
                                f2 = list(f1)
                                for i2 in range(len(f2)):
                                    tcur = int(f2[i2])
                                    if tcur == int(self.state.T_DOOR):
                                        f2[i2] = int(self.state.T_WALL)
                                    elif tcur == int(self.state.T_STAIRS_UP):
                                        f2[i2] = int(self.state.T_STAIRS_DOWN)

                                if mh_out is not None:
                                    mh_out.append(
                                        HardcoreSurvivalState._MultiHouse(
                                            tx0=int(tx0w),
                                            ty0=int(ty0w),
                                            w=int(w),
                                            h=int(h),
                                            floors=int(building_floors),
                                            cur_floor=1,
                                            floor_tiles={1: f1, 2: f2},
                                        )
                                    )

                elif town_kind == "医院":
                    # Reception + ward split.
                    if door_side in ("N", "S"):
                        wy = y0 + 4 if door_side == "N" else y0 + h - 5
                        if in_top + 1 <= wy <= in_bottom - 1:
                            for x in range(in_left, in_right + 1):
                                if not near_door(x, wy):
                                    tiles[idx(x, wy)] = self.state.T_WALL
                            dx = int(clamp(int(round(door_cx)), in_left + 1, in_right - 1))
                            tiles[idx(dx, wy)] = self.state.T_DOOR
                            mark_corridor(dx, wy)

                        # Reception desks.
                        ry0 = in_top if door_side == "N" else (wy + 1)
                        ry1 = wy - 1 if door_side == "N" else in_bottom
                        desk_y = ry0 + 1 if door_side == "N" else ry1 - 1
                        for x in range(in_left + 1, in_right):
                            if (x, desk_y) in corridor or near_door(x, desk_y):
                                continue
                            if (x - (in_left + 1)) % 2 == 0:
                                set_interior(x, desk_y, self.state.T_TABLE)
                        # Ward beds (opposite side).
                        wy0 = wy + 1 if door_side == "N" else in_top
                        wy1 = in_bottom if door_side == "N" else wy - 1
                        for y in range(wy0 + 1, wy1, 2):
                            for x in (in_left + 1, in_right - 2):
                                if (x, y) in corridor or near_door(x, y):
                                    continue
                                if tiles[idx(x, y)] == self.state.T_FLOOR and tiles[idx(x + 1, y)] == self.state.T_FLOOR:
                                    tiles[idx(x, y)] = self.state.T_BED
                                    tiles[idx(x + 1, y)] = self.state.T_BED
                        # Supply closet.
                        if w >= 11 and h >= 9:
                            cxr = x0 + w - 6 if door_side in ("N", "S") else x0 + 2
                            cyr = y0 + h - 5 if door_side == "N" else (y0 + 2)
                            room = build_room(int(cxr), int(cyr), 3, 2)
                            if room is not None:
                                rx, ry, rw, rh = int(cxr), int(cyr), 3, 2
                                for x in range(rx, rx + rw):
                                    for y in range(ry, ry + rh):
                                        if tiles[idx(x, y)] == self.state.T_FLOOR:
                                            tiles[idx(x, y)] = self.state.T_SHELF
                    else:
                        wx = x0 + 4 if door_side == "W" else x0 + w - 5
                        if in_left + 1 <= wx <= in_right - 1:
                            for y in range(in_top, in_bottom + 1):
                                if not near_door(wx, y):
                                    tiles[idx(wx, y)] = self.state.T_WALL
                            dy = int(clamp(int(round(door_cy)), in_top + 1, in_bottom - 1))
                            tiles[idx(wx, dy)] = self.state.T_DOOR
                            mark_corridor(wx, dy)

                        # Reception desks.
                        rx0 = in_left if door_side == "W" else (wx + 1)
                        rx1 = wx - 1 if door_side == "W" else in_right
                        desk_x = rx0 + 1 if door_side == "W" else rx1 - 1
                        for y in range(in_top + 1, in_bottom):
                            if (desk_x, y) in corridor or near_door(desk_x, y):
                                continue
                            if (y - (in_top + 1)) % 2 == 0:
                                set_interior(desk_x, y, self.state.T_TABLE)

                        # Ward beds.
                        wx0 = wx + 1 if door_side == "W" else in_left
                        wx1 = in_right if door_side == "W" else wx - 1
                        for x in range(wx0 + 1, wx1, 3):
                            for y in (in_top + 1, in_bottom - 2):
                                if (x, y) in corridor or near_door(x, y):  
                                    continue
                                if tiles[idx(x, y)] == self.state.T_FLOOR and tiles[idx(x + 1, y)] == self.state.T_FLOOR:
                                    tiles[idx(x, y)] = self.state.T_BED    
                                    tiles[idx(x + 1, y)] = self.state.T_BED

                elif town_kind == "学校":
                    # School: some schools are multi-floor and become a portal to a
                    # separate interior scene (world-map interior is sealed).
                    is_city = bool(self._is_city_chunk(int(cx), int(cy)))
                    floors = int(rng.randint(3, 6)) if is_city else int(rng.randint(2, 4))
                    if (not is_city) and rng.random() < 0.35:
                        floors = 1

                    if floors > 1:
                        for y in range(y0 + 1, y0 + h - 1):
                            for x in range(x0 + 1, x0 + w - 1):
                                if tiles[idx(x, y)] != self.state.T_DOOR:
                                    tiles[idx(x, y)] = self.state.T_WALL

                        tx0w = cx * self.state.CHUNK_SIZE + x0
                        ty0w = cy * self.state.CHUNK_SIZE + y0
                        doors_w = tuple(
                            (cx * self.state.CHUNK_SIZE + int(dx), cy * self.state.CHUNK_SIZE + int(dy))
                            for dx, dy in door_tiles
                        )
                        special_buildings.append(
                            HardcoreSurvivalState._SpecialBuilding(
                                kind="school",
                                name="学校",
                                tx0=int(tx0w),
                                ty0=int(ty0w),
                                w=int(w),
                                h=int(h),
                                door_tiles=doors_w,
                                floors=int(floors),
                            )
                        )
                    else:
                        # Single-floor school: keep corridor clear, add desks + lockers.
                        # Lockers along one side.
                        if door_side in ("N", "S"):
                            lx = in_left + 1
                            for y in range(in_top + 1, in_bottom):
                                if (lx, y) in corridor or near_door(lx, y):
                                    continue
                                if (y - (in_top + 1)) % 2 == 0:
                                    set_interior(lx, y, self.state.T_SHELF)
                        else:
                            ly = in_top + 1
                            for x in range(in_left + 1, in_right):
                                if (x, ly) in corridor or near_door(x, ly):
                                    continue
                                if (x - (in_left + 1)) % 2 == 0:
                                    set_interior(x, ly, self.state.T_SHELF)

                        # Desks in rows (reads as classrooms).
                        for y in range(in_top + 2, in_bottom, 2):
                            for x in range(in_left + 2, in_right, 3):
                                set_interior(x, y, self.state.T_TABLE)

                        # Small office/storage room.
                        if w >= 12 and h >= 9:
                            rx = x0 + w - 6 if door_side in ("N", "S") else x0 + 2
                            ry = y0 + 2 if door_side in ("N", "S") else y0 + h - 5
                            room = build_room(int(rx), int(ry), 3, 2)
                            if room is not None:
                                for x in range(int(rx), int(rx) + 3):
                                    for y in range(int(ry), int(ry) + 2):
                                        if tiles[idx(x, y)] == self.state.T_FLOOR and ((x + y) % 2 == 0):
                                            tiles[idx(x, y)] = self.state.T_SHELF

                elif town_kind in ("高层住宅", "高层住宅大"):
                    # High-rise: keep world-map interior walkable (no full-screen portal).
                    tx0w = cx * self.state.CHUNK_SIZE + x0
                    ty0w = cy * self.state.CHUNK_SIZE + y0
                    doors_w = tuple((cx * self.state.CHUNK_SIZE + int(dx), cy * self.state.CHUNK_SIZE + int(dy)) for dx, dy in door_tiles)
                    floors = int(building_floors)
                    apt_doors: list[tuple[int, int, bool]] = []

                    # Elevator tile inside the lobby (world-map multi-floor switching).
                    try:
                        if door_tiles:
                            door_xs = [int(p[0]) for p in door_tiles]
                            door_y = int(max(int(p[1]) for p in door_tiles))
                            door_cx = int(round(sum(int(x) for x in door_xs) / max(1, len(door_xs))))
                            elev_x = int(clamp(int(door_cx), int(x0 + 1), int(x0 + w - 2)))
                            top_cut = int(max(0, (int(h) - 2) - int(core_h)))
                            floor_y0 = int(y0 + 1 + int(top_cut))
                            elev_y = int(clamp(int(door_y - 3), int(floor_y0), int(y0 + h - 2)))
                            if tiles[idx(int(elev_x), int(elev_y))] != int(self.state.T_WALL):
                                tiles[idx(int(elev_x), int(elev_y))] = int(self.state.T_ELEVATOR)
                    except Exception:
                        pass

                    # Interior: elevator lobby + 2/3 apartments (never single-unit).
                    try:
                        top_cut = int(max(0, (int(h) - 2) - int(core_h)))
                        floor_y0 = int(y0 + 1 + int(top_cut))
                        in_left = int(x0 + 1)
                        in_right = int(x0 + w - 2)
                        in_top = int(floor_y0)
                        in_bottom = int(y0 + h - 2)
                        usable_h = int(in_bottom - in_top + 1)
                        usable_w = int(in_right - in_left + 1)

                        if int(usable_h) >= 6 and int(usable_w) >= 7 and door_tiles:
                            door_xs = [int(p[0]) for p in door_tiles]
                            door_cx_i = int(round(sum(int(x) for x in door_xs) / max(1, len(door_xs))))

                            # Lobby takes the bottom slice; apartments sit above it.
                            # Keep the lobby compact so apartments feel like real homes.
                            lobby_h = int(clamp(int(round(float(usable_h) * 0.18)), 2, 3))
                            min_apt_h = 4
                            lobby_h = int(clamp(int(lobby_h), 2, max(2, int(usable_h) - int(min_apt_h))))
                            sep_y = int(in_bottom - int(lobby_h))
                            sep_y = int(clamp(int(sep_y), int(in_top + min_apt_h - 1), int(in_bottom - 2)))

                            # Keep a single elevator tile inside the lobby.
                            for yy in range(int(in_top), int(in_bottom) + 1):
                                for xx in range(int(in_left), int(in_right) + 1):
                                    if int(tiles[idx(int(xx), int(yy))]) == int(self.state.T_ELEVATOR):
                                        tiles[idx(int(xx), int(yy))] = int(self.state.T_FLOOR)

                            elev_x = int(clamp(int(door_cx_i), int(in_left + 1), int(in_right - 1)))
                            elev_y = int(clamp(int(sep_y + 1), int(sep_y + 1), int(in_bottom - 1)))
                            if int(tiles[idx(int(elev_x), int(elev_y))]) != int(self.state.T_WALL):
                                tiles[idx(int(elev_x), int(elev_y))] = int(self.state.T_ELEVATOR)

                            lobby_area: set[tuple[int, int]] = set()
                            for dy in (-1, 0, 1):
                                for dx in (-1, 0, 1):
                                    lobby_area.add((int(elev_x + dx), int(elev_y + dy)))

                            # Horizontal separator: lobby (south) vs apartments (north).
                            for xx in range(int(in_left), int(in_right) + 1):
                                tiles[idx(int(xx), int(sep_y))] = int(self.state.T_WALL)

                            # Always 2 units (一梯两户).
                            units = 2
                            min_unit_w = 5 if int(usable_w) >= 11 else 3
                            if int(units) == 3:
                                min_unit_w = 5
                            unit_ranges: list[tuple[int, int]] = []
                            split_xs: list[int] = []
                            if int(units) == 2:
                                split_x = int(clamp(int(elev_x), int(in_left + min_unit_w), int(in_right - min_unit_w)))
                                split_xs = [int(split_x)]
                                unit_ranges = [(int(in_left), int(split_x - 1)), (int(split_x + 1), int(in_right))]
                            else:
                                x1 = int(in_left + (int(usable_w) // 3))
                                x2 = int(in_left + (int(usable_w) * 2) // 3)
                                x1 = int(clamp(int(x1), int(in_left + min_unit_w), int(in_right - 2 * min_unit_w - 1)))
                                x2 = int(clamp(int(x2), int(x1 + min_unit_w + 1), int(in_right - min_unit_w)))
                                split_xs = [int(x1), int(x2)]
                                unit_ranges = [
                                    (int(in_left), int(x1 - 1)),
                                    (int(x1 + 1), int(x2 - 1)),
                                    (int(x2 + 1), int(in_right)),
                                ]

                            # Vertical separators between units (only above the lobby line).
                            for sx in split_xs:
                                for yy in range(int(in_top), int(sep_y)):
                                    tiles[idx(int(sx), int(yy))] = int(self.state.T_WALL)

                            reserved: set[tuple[int, int]] = set(lobby_area)
                            # Apartment doors on the separator line.
                            seed_base = int(self.seed) ^ 0x6B8B4567
                            for ux0, ux1 in unit_ranges:
                                if int(ux1 - ux0 + 1) < 3:
                                    continue
                                dx = int(clamp(int((ux0 + ux1) // 2), int(ux0 + 1), int(ux1 - 1)))
                                # 1F: always locked; upper floors may have broken doors.
                                wx = int(base_tx + int(dx))
                                wy = int(base_ty + int(sep_y))
                                hh = int(self.state._hash2_u32(int(wx), int(wy), int(seed_base)))
                                broken_up = int(hh % 100) < 18
                                tiles[idx(int(dx), int(sep_y))] = int(self.state.T_DOOR_LOCKED)
                                apt_doors.append((int(dx), int(sep_y), bool(broken_up)))
                                for ddy in (-1, 0, 1):
                                    for ddx in (-1, 0, 1):
                                        reserved.add((int(dx + ddx), int(sep_y + ddy)))

                    except Exception:
                        pass

                    special_buildings.append(
                        HardcoreSurvivalState._SpecialBuilding(
                            kind="highrise",
                            name="高层住宅",
                            tx0=int(tx0w),
                            ty0=int(ty0w),
                            w=int(w),
                            h=int(h),
                            door_tiles=doors_w,
                            floors=floors,
                        )
                    )

                    # Register as a multi-floor building so facade slicing + floor switching works.
                    if mh_out is not None and int(floors) > 1:
                        f1: list[int] = []
                        for yy in range(int(h)):
                            for xx in range(int(w)):
                                f1.append(int(tiles[idx(int(x0 + xx), int(y0 + yy))]))

                        f_up = list(f1)
                        for dx, dy in door_tiles:
                            i2 = int(dy - y0) * int(w) + int(dx - x0)
                            if 0 <= i2 < len(f_up):
                                f_up[int(i2)] = int(self.state.T_WALL)
                        # Upper floors: apply the broken/locked state for unit-entry doors.
                        try:
                            for dx, dy, broken_up in list(apt_doors):
                                i2 = int(dy - y0) * int(w) + int(dx - x0)
                                if 0 <= i2 < len(f_up):
                                    f_up[int(i2)] = int(self.state.T_DOOR_BROKEN) if bool(broken_up) else int(self.state.T_DOOR_LOCKED)
                        except Exception:
                            pass

                        floor_tiles: dict[int, list[int]] = {1: f1}
                        for fl in range(2, int(floors) + 1):
                            floor_tiles[int(fl)] = f_up

                        mh_out.append(
                            HardcoreSurvivalState._MultiHouse(
                                tx0=int(tx0w),
                                ty0=int(ty0w),
                                w=int(w),
                                h=int(h),
                                floors=int(floors),
                                cur_floor=1,
                                floor_tiles=floor_tiles,
                            )
                        )

                else:
                    # Prison: split into cell block + common area.        
                    if w >= h:
                        split_x = int(clamp(int(x0 + w // 2), in_left + 2, in_right - 2))
                        for y in range(in_top, in_bottom + 1):
                            if near_door(split_x, y):
                                continue
                            tiles[idx(split_x, y)] = self.state.T_WALL

                        cell_n = 3 if (in_bottom - in_top + 1) >= 7 else 2
                        total_h = int(in_bottom - in_top + 1)
                        # Horizontal separators for cells.
                        for i in range(1, cell_n):
                            by = in_top + (i * total_h) // cell_n
                            if not (in_top + 1 <= by <= in_bottom - 1):
                                continue
                            for x in range(in_left, split_x + 1):
                                if near_door(x, by):
                                    continue
                                tiles[idx(x, by)] = self.state.T_WALL

                        for i in range(cell_n):
                            y0c = in_top + (i * total_h) // cell_n
                            y1c = in_top + ((i + 1) * total_h) // cell_n - 1
                            dy = int(clamp((y0c + y1c) // 2, in_top + 1, in_bottom - 1))
                            if not near_door(split_x, dy):
                                tiles[idx(split_x, dy)] = self.state.T_DOOR
                                clear_interior(split_x + 1, dy)
                                mark_corridor(split_x, dy)

                            bx = in_left + 1
                            by = int(clamp(dy, in_top + 1, in_bottom - 1))
                            if tiles[idx(bx, by)] == self.state.T_FLOOR and tiles[idx(bx + 1, by)] == self.state.T_FLOOR:
                                tiles[idx(bx, by)] = self.state.T_BED
                                tiles[idx(bx + 1, by)] = self.state.T_BED
                            if rng.random() < 0.55:
                                tx = in_left + 1
                                ty = int(clamp(by - 1, in_top + 1, in_bottom - 1))
                                if tiles[idx(tx, ty)] == self.state.T_FLOOR:
                                    tiles[idx(tx, ty)] = self.state.T_TABLE

                        # Common tables on the right side.
                        for y in range(in_top + 1, in_bottom, 2):
                            for x in range(split_x + 2, in_right - 1, 3):
                                if (x, y) in corridor or near_door(x, y):
                                    continue
                                if tiles[idx(x, y)] == self.state.T_FLOOR:
                                    tiles[idx(x, y)] = self.state.T_TABLE
                    else:
                        split_y = int(clamp(int(y0 + h // 2), in_top + 2, in_bottom - 2))
                        for x in range(in_left, in_right + 1):
                            if near_door(x, split_y):
                                continue
                            tiles[idx(x, split_y)] = self.state.T_WALL

                        cell_n = 3 if (in_right - in_left + 1) >= 9 else 2
                        total_w = int(in_right - in_left + 1)
                        for i in range(1, cell_n):
                            bx = in_left + (i * total_w) // cell_n
                            if not (in_left + 1 <= bx <= in_right - 1):
                                continue
                            for y in range(in_top, split_y + 1):
                                if near_door(bx, y):
                                    continue
                                tiles[idx(bx, y)] = self.state.T_WALL

                        for i in range(cell_n):
                            x0c = in_left + (i * total_w) // cell_n
                            x1c = in_left + ((i + 1) * total_w) // cell_n - 1
                            dx = int(clamp((x0c + x1c) // 2, in_left + 1, in_right - 1))
                            if not near_door(dx, split_y):
                                tiles[idx(dx, split_y)] = self.state.T_DOOR
                                clear_interior(dx, split_y + 1)
                                mark_corridor(dx, split_y)

                            bx = int(clamp(dx, in_left + 1, in_right - 2))
                            by = in_top + 1
                            if tiles[idx(bx, by)] == self.state.T_FLOOR and tiles[idx(bx + 1, by)] == self.state.T_FLOOR:
                                tiles[idx(bx, by)] = self.state.T_BED
                                tiles[idx(bx + 1, by)] = self.state.T_BED
                            if rng.random() < 0.55:
                                tx = int(clamp(bx - 1, in_left + 1, in_right - 1))
                                ty = in_top + 1
                                if tiles[idx(tx, ty)] == self.state.T_FLOOR:
                                    tiles[idx(tx, ty)] = self.state.T_TABLE

                        for x in range(in_left + 1, in_right, 2):
                            for y in range(split_y + 2, in_bottom - 1, 3):
                                if (x, y) in corridor or near_door(x, y):
                                    continue
                                if tiles[idx(x, y)] == self.state.T_FLOOR:
                                    tiles[idx(x, y)] = self.state.T_TABLE

                # Prevent "see it but cannot enter" interior gaps: ensure all passable
                # tiles (floor/door) inside the building are reachable from the entrance.
                entrance_set: set[tuple[int, int]] = {(int(dx), int(dy)) for dx, dy in door_tiles}

                def passable(t: int) -> bool:
                    return int(t) in (
                        int(self.state.T_FLOOR),
                        int(self.state.T_DOOR),
                        int(self.state.T_ELEVATOR),
                    )

                # Start tiles: door tiles + the tile just inside the entrance.
                starts: list[tuple[int, int]] = []
                starts.extend([(int(dx), int(dy)) for dx, dy in door_tiles])
                if door_side == "N":
                    starts.extend([(int(dx), int(dy) + 1) for dx, dy in door_tiles])
                elif door_side == "S":
                    starts.extend([(int(dx), int(dy) - 1) for dx, dy in door_tiles])
                elif door_side == "W":
                    starts.extend([(int(dx) + 1, int(dy)) for dx, dy in door_tiles])
                else:
                    starts.extend([(int(dx) - 1, int(dy)) for dx, dy in door_tiles])
                starts = [
                    (sx, sy)
                    for (sx, sy) in starts
                    if (int(x0) <= int(sx) < int(x0 + w) and int(y0) <= int(sy) < int(y0 + h) and passable(tiles[idx(int(sx), int(sy))]))
                ]

                if starts:
                    passable_tiles: set[tuple[int, int]] = set()
                    for py in range(int(y0), int(y0 + h)):
                        for px in range(int(x0), int(x0 + w)):
                            if passable(tiles[idx(px, py)]):
                                passable_tiles.add((int(px), int(py)))

                    def flood(start_list: list[tuple[int, int]]) -> set[tuple[int, int]]:
                        seen: set[tuple[int, int]] = set()
                        stack: list[tuple[int, int]] = list(start_list)
                        while stack:
                            x, y = stack.pop()
                            x = int(x)
                            y = int(y)
                            if (x, y) in seen:
                                continue
                            if not (int(x0) <= x < int(x0 + w) and int(y0) <= y < int(y0 + h)):
                                continue
                            if not passable(tiles[idx(x, y)]):
                                continue
                            seen.add((x, y))
                            stack.extend([(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)])
                        return seen

                    solids = {
                        int(self.state.T_WALL),
                        int(self.state.T_TABLE),
                        int(self.state.T_SHELF),
                        int(self.state.T_BED),
                    }

                    # Try to connect unreachable pockets by opening a wall (door) or clearing a blocking prop.
                    for _ in range(40):
                        reachable = flood(starts)
                        unreachable = passable_tiles.difference(reachable)
                        if not unreachable:
                            break

                        opened = False
                        for py in range(int(in_top), int(in_bottom) + 1):
                            for px in range(int(in_left), int(in_right) + 1):
                                t = int(tiles[idx(px, py)])
                                if t not in solids:
                                    continue

                                has_reach = False
                                has_unreach = False
                                for nx, ny in ((px + 1, py), (px - 1, py), (px, py + 1), (px, py - 1)):
                                    if not (int(x0) <= nx < int(x0 + w) and int(y0) <= ny < int(y0 + h)):
                                        continue
                                    if not passable(tiles[idx(nx, ny)]):
                                        continue
                                    if (int(nx), int(ny)) in reachable:
                                        has_reach = True
                                    elif (int(nx), int(ny)) in unreachable:
                                        has_unreach = True
                                if has_reach and has_unreach:
                                    tiles[idx(px, py)] = self.state.T_DOOR if t == int(self.state.T_WALL) else self.state.T_FLOOR
                                    passable_tiles.add((int(px), int(py)))
                                    opened = True
                                    break
                            if opened:
                                break

                        if not opened:
                            # Fallback: seal unreachable walkable tiles so players never see fake rooms.
                            for ux, uy in unreachable:
                                if (int(ux), int(uy)) in entrance_set:
                                    continue
                                tiles[idx(int(ux), int(uy))] = self.state.T_WALL
                            break

                    # Remove dead-end internal doors (doors must connect >=2 passable neighbors).
                    for py in range(int(in_top), int(in_bottom) + 1):
                        for px in range(int(in_left), int(in_right) + 1):
                            if int(tiles[idx(px, py)]) != int(self.state.T_DOOR):
                                continue
                            if (int(px), int(py)) in entrance_set:
                                continue
                            n_pass = 0
                            for nx, ny in ((px + 1, py), (px - 1, py), (px, py + 1), (px, py - 1)):
                                if not (int(x0) <= nx < int(x0 + w) and int(y0) <= ny < int(y0 + h)):
                                    continue
                                if passable(tiles[idx(nx, ny)]):
                                    n_pass += 1
                            if n_pass < 2:
                                tiles[idx(px, py)] = self.state.T_WALL

                def pick_kind(kind: str, *, prefix: str | None = None, k: int = 10) -> list[str]:
                    kind = str(kind)
                    pool: list[str] = []
                    for iid, idef in self.state._ITEMS.items():
                        if idef is None:
                            continue
                        if str(getattr(idef, "kind", "")) != kind:
                            continue
                        if prefix is not None and not str(iid).startswith(str(prefix)):
                            continue
                        pool.append(str(iid))
                    if not pool:
                        return []
                    rng.shuffle(pool)
                    k = int(clamp(int(k), 0, len(pool)))
                    return pool[:k]

                foods = pick_kind("food", prefix="food_", k=18)
                drinks = pick_kind("drink", prefix="drink_", k=12)       
                meds = pick_kind("med", prefix="med_", k=12)
                mats = pick_kind("mat", k=8)
                tools = pick_kind("tool", k=6)
                melees = pick_kind("melee", prefix="melee_", k=5)
                clothes = pick_kind("clothes", prefix="clothes_", k=8)
                fuels = pick_kind("fuel", k=2)
                keys = pick_kind("key", k=2)

                loot_choices: list[str]
                if town_kind == "医院":
                    loot_choices = ["bandage", "medkit", "water"] + meds
                elif town_kind in ("超市", "大型超市"):
                    loot_choices = ["food_can", "water", "cola", "bandage", "medkit"] + foods + drinks + mats + tools + melees + clothes
                elif town_kind == "新华书店":
                    loot_choices = ["book", "paper", "map", "water", "cola", "bandage"] + foods + drinks
                elif town_kind == "枪械店":
                    loot_choices = [
                        "pistol",
                        "uzi",
                        "ak47",
                        "scar_l",
                        "ammo_9mm",
                        "ammo_9mm",
                        "ammo_556",
                        "ammo_556",
                        "ammo_762",
                        "ammo_762",
                        "ammo_rocket",
                        "mod_optic_reddot",
                        "mod_optic_4x",
                        "mod_optic_holo",
                        "mod_muzzle_suppressor_9mm",
                        "mod_muzzle_suppressor_rifle",
                        "mod_muzzle_comp_rifle",
                        "mod_muzzle_flash_hider_rifle",
                        "mod_undergrip_stab",
                        "mod_undergrip_bipod",
                        "mod_stock_tactical",
                        "mod_trigger_light",
                        "mod_mag_ext_pistol",
                        "mod_mag_ext_9mm",
                        "mod_mag_ext_rifle",
                        "mod_mag_drum_9mm",
                        "mod_mag_drum_rifle",
                        "scrap",
                        "bandage",
                        "knife",
                        "crowbar",
                    ] + mats + tools + melees + clothes
                    # Heavy weapons are rare even in gun shops.
                    if rng.random() < 0.07:
                        loot_choices.append("rpg")
                elif town_kind in ("监狱", "大型监狱"):
                    loot_choices = ["pistol", "ak47", "ammo_9mm", "ammo_762", "ammo_762", "scrap", "bandage", "crowbar"] + mats + melees + clothes
                elif town_kind == "学校":
                    loot_choices = ["food_can", "water", "cola", "bandage", "book", "paper"] + foods + drinks
                elif town_kind in ("高层住宅", "高层住宅大"):
                    loot_choices = [
                        "food_can",
                        "water",
                        "cola",
                        "bandage",
                        "scrap",
                        "ammo_9mm",
                        "ammo_556",
                        "ammo_762",
                        "mod_optic_reddot",
                        "mod_muzzle_suppressor_9mm",
                        "mod_mag_ext_pistol",
                    ] + foods + drinks + mats + melees + clothes
                else:
                    loot_choices = ["food_can", "water", "cola", "bandage"] + foods[:8] + drinks[:6] + mats + melees + clothes

                # Vehicle keys / fuel are rare, but exist in the world so the hardcore loop works.
                key_ch = 0.08
                fuel_ch = 0.10
                if town_kind in ("高层住宅", "高层住宅大", "住宅"):
                    key_ch = 0.35
                    fuel_ch = 0.16
                elif town_kind in ("超市", "大型超市"):
                    key_ch = 0.12
                    fuel_ch = 0.28
                if keys and rng.random() < float(key_ch):
                    loot_choices += keys
                if fuels and rng.random() < float(fuel_ch):
                    loot_choices += fuels
                if not loot_choices:
                    loot_choices = ["food_can", "water"]

                loot_n = rng.randint(2, 4) if town_kind in ("超市", "大型超市", "新华书店", "医院", "枪械店") else rng.randint(2, 3)

                # Place loot only on tiles reachable from the entrance, so we
                # don't create "see the item but cannot enter" situations.
                start: tuple[int, int] | None = None
                entrance_candidates: list[tuple[int, int]] = []
                if door_side == "N":
                    entrance_candidates = [(int(dx), int(dy) + 1) for dx, dy in door_tiles] + list(door_tiles)
                elif door_side == "S":
                    entrance_candidates = [(int(dx), int(dy) - 1) for dx, dy in door_tiles] + list(door_tiles)
                elif door_side == "W":
                    entrance_candidates = [(int(dx) + 1, int(dy)) for dx, dy in door_tiles] + list(door_tiles)
                else:
                    entrance_candidates = [(int(dx) - 1, int(dy)) for dx, dy in door_tiles] + list(door_tiles)

                for sx, sy in entrance_candidates:
                    if not (int(x0) <= int(sx) < int(x0 + w) and int(y0) <= int(sy) < int(y0 + h)):
                        continue
                    if tiles[idx(int(sx), int(sy))] in (self.state.T_FLOOR, self.state.T_DOOR):
                        start = (int(sx), int(sy))
                        break

                reachable_floor: list[tuple[int, int]] = []
                if start is not None:
                    seen: set[tuple[int, int]] = set()
                    stack: list[tuple[int, int]] = [start]
                    while stack:
                        x, y = stack.pop()
                        x = int(x)
                        y = int(y)
                        if (x, y) in seen:
                            continue
                        if not (int(x0) <= x < int(x0 + w) and int(y0) <= y < int(y0 + h)):
                            continue
                        t = tiles[idx(x, y)]
                        if t not in (self.state.T_FLOOR, self.state.T_DOOR):
                            continue
                        seen.add((x, y))
                        if t == self.state.T_FLOOR and not near_door(x, y):
                            reachable_floor.append((x, y))
                        stack.extend([(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)])

                if reachable_floor:
                    rng.shuffle(reachable_floor)

                # Multi-floor houses share the same world-tile footprint for 1F/2F.
                # To avoid items appearing on the "wrong" floor, don't spawn loot
                # inside 2F houses for now.
                if int(building_floors) > 1 and town_kind in ("住宅", "高层住宅", "高层住宅大"):
                    reachable_floor = []

                spot_i = 0
                for _ in range(loot_n):
                    if spot_i >= len(reachable_floor):
                        break
                    ix, iy = reachable_floor[spot_i]
                    spot_i += 1

                    item_id = rng.choice(loot_choices)
                    idef = self.state._ITEMS.get(item_id)
                    if idef is None:
                        continue
                    if idef.kind == "ammo":
                        qty = rng.randint(12, 28)
                    elif idef.kind == "mat":
                        qty = rng.randint(2, 6)
                    else:
                        qty = 1
                    qty = int(clamp(qty, 1, idef.stack))

                    tx = cx * self.state.CHUNK_SIZE + ix
                    ty = cy * self.state.CHUNK_SIZE + iy
                    px = (tx + 0.5) * self.state.TILE_SIZE
                    py = (ty + 0.5) * self.state.TILE_SIZE
                    items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(px, py), item_id=item_id, qty=qty))

                if town_kind in ("监狱", "大型监狱") and spot_i < len(reachable_floor):
                    ix, iy = reachable_floor[spot_i]
                    tx = cx * self.state.CHUNK_SIZE + ix
                    ty = cy * self.state.CHUNK_SIZE + iy
                    px = (tx + 0.5) * self.state.TILE_SIZE
                    py = (ty + 0.5) * self.state.TILE_SIZE
                    items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(px, py), item_id="pistol", qty=1))
                    items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(px, py + 6), item_id="ammo_9mm", qty=rng.randint(18, 34)))

                if town_kind == "枪械店" and spot_i < len(reachable_floor):
                    ix, iy = reachable_floor[spot_i]
                    tx = cx * self.state.CHUNK_SIZE + ix
                    ty = cy * self.state.CHUNK_SIZE + iy
                    px = (tx + 0.5) * self.state.TILE_SIZE
                    py = (ty + 0.5) * self.state.TILE_SIZE
                    items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(px, py), item_id="pistol", qty=1))
                    items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(px, py + 6), item_id="ammo_9mm", qty=rng.randint(20, 40)))

                roof_style = 0
                if town_kind == "住宅":
                    roof_style = 1
                elif town_kind in ("超市", "大型超市"):
                    roof_style = 2
                elif town_kind == "新华书店":
                    roof_style = 7
                elif town_kind == "枪械店":
                    roof_style = 9
                elif town_kind == "医院":
                    roof_style = 3
                elif town_kind in ("监狱", "大型监狱"):
                    roof_style = 4
                elif town_kind == "学校":
                    roof_style = 5
                elif town_kind in ("高层住宅", "高层住宅大"):
                    roof_style = 6
                elif town_kind == "中式建筑":
                    roof_style = 8
                roof_var = int(rng.randrange(0, 256))
                if int(roof_style) == 6 and roof_var_hint is not None:
                    roof_var = int(roof_var_hint) & 0xFF
                roof_kind = (int(roof_style) << 8) | int(roof_var)
                buildings.append(
                    (
                        cx * self.state.CHUNK_SIZE + x0,
                        cy * self.state.CHUNK_SIZE + y0,
                        w,
                        h,
                        int(roof_kind),
                        int(building_floors),
                    )
                )
                placed += 1

    @dataclass
    class _Player:
        pos: pygame.Vector2
        vel: pygame.Vector2
        facing: pygame.Vector2
        w: int = 8
        h: int = 12
        body_h: int = 12
        collider_h: int = 12
        hp: int = 100
        hunger: float = 100.0
        thirst: float = 100.0
        condition: float = 100.0
        morale: float = 100.0
        stamina: float = 100.0
        walk_phase: float = 0.0
        dir: str = "down"

        def rect_at(self, pos: pygame.Vector2 | None = None) -> pygame.Rect:
            p = self.pos if pos is None else pos
            h = int(getattr(self, "collider_h", self.h))
            return pygame.Rect(
                iround(float(p.x) - float(self.w) / 2.0),
                iround(float(p.y) - float(h) / 2.0),
                int(self.w),
                int(h),
            )

    def on_enter(self) -> None:
        self.seed = int(time.time()) & 0xFFFFFFFF
        self.world = HardcoreSurvivalState._World(self, seed=self.seed)
        spawn_tx, spawn_ty = self.world.spawn_tile()
        # Preload the main city area so POI icons (e.g., gunshop/bookstore) show up
        # quickly on the minimap/world-map without requiring long travel.
        try:
            ccx = int(getattr(self.world, "city_cx", 0))
            ccy = int(getattr(self.world, "city_cy", 0))
            cr = max(0, int(getattr(self.world, "city_radius", 0)))
            for cy in range(int(ccy) - int(cr), int(ccy) + int(cr) + 1):
                for cx in range(int(ccx) - int(cr), int(ccx) + int(cr) + 1):
                    self.world.request_chunk(int(cx), int(cy))
        except Exception:
            pass

        # POI cache for minimap edge-indicators.
        self._poi_cache: dict[str, list[tuple[int, int]]] = {}
        self._poi_scanned_chunks: set[tuple[int, int]] = set()
        self._poi_cache_t = 0.0
        spawn_px = (spawn_tx + 0.5) * self.TILE_SIZE
        spawn_py = (spawn_ty + 0.5) * self.TILE_SIZE
        self.avatar = getattr(self, "avatar", None) or SurvivalAvatar()
        self.avatar.clamp_all()
        self.clothes_id: str | None = None
        try:
            starter = self._OUTFIT_TO_CLOTHES.get(int(getattr(self.avatar, "outfit", 0)))
            self.clothes_id = str(starter) if starter else None
        except Exception:
            self.clothes_id = None
        self.player = HardcoreSurvivalState._Player(
            pos=pygame.Vector2(spawn_px, spawn_py),
            vel=pygame.Vector2(0, 0),
            facing=pygame.Vector2(1, 0),
        )
        # Apply appearance + body size.
        self.player_frames = HardcoreSurvivalState.build_avatar_player_frames(self.avatar, run=False)
        self.player_frames_run = HardcoreSurvivalState.build_avatar_player_frames(self.avatar, run=True)
        self.cyclist_frames = HardcoreSurvivalState.build_avatar_cyclist_frames(self.avatar)
        self.player_sprinting = False
        gender = int(self.avatar.gender) % len(SURVIVAL_GENDER_OPTIONS)
        height = int(self.avatar.height) % len(SURVIVAL_HEIGHT_OPTIONS)
        self.player.w = 8 if gender == 0 else 7
        body_h = int((11, 12, 13)[height])
        self.player.body_h = int(body_h)
        self.player.h = int(body_h)
        self.player.collider_h = int(clamp(int(body_h) - 3, 8, int(self.TILE_SIZE) - 1))
        # Shared player collider used in full-screen interiors (house/school/high-rise).
        self.int_player_w = (10 if gender == 0 else 9)
        self.int_player_h = 14 + (height - 1)
        self.inventory = HardcoreSurvivalState._Inventory(slots=[None] * 16)
        self.inv_open = False
        self.inv_index = 0
        self.pause_open = False
        self.pause_rects: list[tuple[pygame.Rect, str]] = []
        self.rv_storage = HardcoreSurvivalState._Inventory(slots=[None] * 24, cols=6)
        # Apartment home storage (openable cabinets).
        self.home_storage = HardcoreSurvivalState._Inventory(slots=[None] * 30, cols=6)
        self.fridge_storage = HardcoreSurvivalState._Inventory(slots=[None] * 12, cols=4)
        # High-rise rooms (home + break-in apartments) share the same storage UI.
        self.hr_current_room = ""
        self.hr_room_storages: dict[str, tuple[HardcoreSurvivalState._Inventory, HardcoreSurvivalState._Inventory]] = {}
        self.hr_room_floor_items: dict[str, list[HardcoreSurvivalState._WorldItem]] = {}
        self.hr_floor_items: list[HardcoreSurvivalState._WorldItem] = []
        self.hr_room_lights: dict[str, bool] = {}
        self.home_ui_open = False
        self.home_ui_focus: str = "storage"  # player | storage
        self.home_ui_storage_kind: str = "cabinet"  # cabinet | fridge   
        self.home_ui_player_index = 0
        self.home_ui_storage_index = 0
        self.home_ui_status = ""
        self.home_ui_status_left = 0.0
        self.home_ui_open_block: tuple[int, int, int, int] | None = None
        # Some starter supplies at home.
        self.home_storage.add("food_can", 4, self._ITEMS)
        self.home_storage.add("bandage", 6, self._ITEMS)
        self.home_storage.add("cup", 1, self._ITEMS)
        self.inventory.add("key_rv", 1, self._ITEMS)
        self.home_storage.add("key_moto", 1, self._ITEMS)
        self.inventory.add("key_house", 1, self._ITEMS)
        self.fridge_storage.add("water", 2, self._ITEMS)
        self.fridge_storage.add("cola", 2, self._ITEMS)
        # Some visible "snacks" so home doesn't feel empty.
        for iid, qty in (
            ("food_chips_bbq", 2),
            ("food_candy_sweet", 2),
            ("food_chocolate_plain", 2),
            ("food_nuts_plain", 2),
        ):
            self.home_storage.add(iid, int(qty), self._ITEMS)
        for iid, qty in (
            ("drink_water_mineral_plain", 2),
            ("drink_tea_lemon", 1),
        ):
            self.fridge_storage.add(iid, int(qty), self._ITEMS)
        # Simple pose / action state (sit / sleep) used in interiors.
        self.player_pose: str | None = None  # sit | sleep
        self.player_pose_space: str = ""  # hr | rv
        self.player_pose_left = 0.0
        self.player_pose_anchor: tuple[float, float] | None = None
        self.player_pose_phase = 0.0
        self.hint_text = ""
        self.hint_left = 0.0
        self.gun: HardcoreSurvivalState._Gun | None = None
        self.melee_weapon_id: str | None = None
        self.bullets: list[HardcoreSurvivalState._Bullet] = []
        self.thrown_furniture: list[HardcoreSurvivalState._ThrownFurniture] = []
        self.zombies: list[HardcoreSurvivalState._Zombie] = []
        self.spawn_left = 8.0
        self.zombie_cap = 8
        self.zombie_frozen = False
        self.dead_left = 0.0
        self.starve_accum = 0.0
        # Bleeding / wounds (simple hardcore layer).
        # Stored as: body_part -> HP/sec bleed rate.
        self.bleed_accum = 0.0
        self.bleed_wounds: dict[str, float] = {}
        self.mount: str | None = None
        self.rv = HardcoreSurvivalState._RV(
            pos=pygame.Vector2(self.player.pos) + pygame.Vector2(34, 0),  
            vel=pygame.Vector2(0, 0),
            model_id="rv",
            fuel=100.0,
        )
        self._apply_rv_model()
        self.rv_dir = "right"
        self.rv_anim = 0.0
        self.rv_headlights_on = True
        self.bike = HardcoreSurvivalState._Bike(
            pos=pygame.Vector2(self.player.pos) + pygame.Vector2(-28, 10),
            vel=pygame.Vector2(0, 0),
            model_id="bike_mountain",
        )
        self._apply_bike_model()
        self._place_spawn_vehicles_safely()
        self.bike_dir = "right"
        self.bike_anim = 0.0
        self.aim_dir = pygame.Vector2(1, 0)
        self.cam_x = 0
        self.cam_y = 0
        self._reload_lock_dir: pygame.Vector2 | None = None
        # RV "interior" (world-map camera, NOT full-screen panel).
        self.rv_world_interior = False
        self._rv_world_return_pos: pygame.Vector2 | None = None
        self._rv_world_int_size = (9, 4)  # w, h (tiles)
        self._rv_world_int_active_key: tuple[int, int, int, int] | None = None
        self._rv_world_int_restore_tiles: dict[tuple[int, int], int] | None = None
        self._rv_world_int_exit_tile: tuple[int, int] | None = None
        self._rv_world_floor_base: dict[tuple[int, int], int] | None = None
        self._rv_world_fixed_furniture: set[tuple[int, int]] = set()
        self._rv_world_dash_tile: tuple[int, int] | None = None

        # High-rise interior (multi-floor apartment).
        self.hr_interior = False
        self.hr_int_pos = pygame.Vector2(0, 0)
        self.hr_int_vel = pygame.Vector2(0, 0)
        self.hr_int_facing = pygame.Vector2(0, 1)
        self.hr_int_walk_phase = 0.0
        self.hr_mode = "lobby"  # lobby | hall | home
        self.hr_floor = 1
        self.hr_layout: list[str] = list(self._HR_INT_LOBBY_LAYOUT)
        self.hr_building: HardcoreSurvivalState._SpecialBuilding | None = None
        self.hr_world_return = pygame.Vector2(self.player.pos)
        self.hr_auto_walk_to_elevator = False
        self.hr_auto_walk_delay = 0.0

        self.home_highrise_door: tuple[int, int] | None = None
        self.home_highrise_floor = 0
        self.home_highrise_door_index = 0
        self.home_highrise_unit = 0
        self.home_highrise_room = ""
        self.home_highrise_dialog_armed = True

        # Home lighting / in-world furniture moving (NO full-screen floorplan).
        self.home_light_on = True
        self.home_move_mode = False
        self.home_move_cursor = (0, 0)
        self.home_move_carry = None
        # World furniture durability (keyed by space/building-floor + tile).
        self.world_furniture_hp: dict[tuple[object, ...], int] = {}
        self.world_ctx_open = False
        self.world_ctx_target = None
        self.world_ctx_rects = []
        self.world_ctx_cooldown_left = 0.0
        self.world_ctx_idle_s = 0.0
        self.world_ctx_idle_target = None
        self.world_ctx_suppressed = None
        self.lamp_cfg_open = False
        self.lamp_cfg_target: tuple[int, int] | None = None
        self._rv_mode_btn_rects: dict[str, pygame.Rect] = {}
        self.lamp_cfg_rects: list[tuple[pygame.Rect, str]] = []
        self._last_cam_draw = (0, 0)
        self.world_tv_states: dict[tuple[int, int], bool] = {}

        self.hr_elevator_ui_open = False
        self.hr_elevator_sel = 0
        self.hr_elevator_cols = 4
        self.hr_max_floors = int(self._HR_INT_MAX_FLOORS_DEFAULT)
        self.hr_travel_active = False
        self.hr_travel_kind = ""
        self.hr_travel_from = 1
        self.hr_travel_to = 1
        self.hr_travel_display = 1
        self.hr_travel_dir = 1
        self.hr_travel_step_s = 0.35
        self.hr_travel_acc = 0.0
        self.hr_travel_done_left = -1.0
        self.hr_travel_spawn_at = "elevator"
        # World-map elevator UI (high-rise floors).
        self.world_elevator_ui_open = False
        self.world_elevator_sel = 0
        self.world_elevator_cols = 4
        self.world_elevator_input = ""
        self.world_elevator_options: list[int] = [1]
        self.world_elevator_chunk: HardcoreSurvivalState._Chunk | None = None
        self.world_elevator_mh: HardcoreSurvivalState._MultiHouse | None = None
        self.world_elevator_elev_tile: tuple[int, int] | None = None

        # School interior (multi-floor).
        self.sch_interior = False
        self.sch_int_pos = pygame.Vector2(0, 0)
        self.sch_int_vel = pygame.Vector2(0, 0)
        self.sch_int_facing = pygame.Vector2(0, 1)
        self.sch_int_walk_phase = 0.0
        self.sch_floor = 1
        self.sch_layout: list[str] = list(self._SCH_INT_LOBBY_LAYOUT)
        self.sch_building: HardcoreSurvivalState._SpecialBuilding | None = None
        self.sch_world_return = pygame.Vector2(self.player.pos)
        self.sch_elevator_ui_open = False
        self.sch_elevator_sel = 0
        self.sch_elevator_cols = 4
        self.sch_max_floors = int(self._SCH_INT_MAX_FLOORS_DEFAULT)
        self.sch_elevator_input = ""

        # House interior (2–3 floors).
        self.house_interior = False
        self.house_int_pos = pygame.Vector2(0, 0)
        self.house_int_vel = pygame.Vector2(0, 0)
        self.house_int_facing = pygame.Vector2(0, 1)
        self.house_int_walk_phase = 0.0
        self.house_floor = 1
        self.house_layout: list[str] = list(self._HOUSE_INT_F1_LAYOUT)
        self.house_building: HardcoreSurvivalState._SpecialBuilding | None = None
        self.house_world_return = pygame.Vector2(self.player.pos)
        self.house_max_floors = int(self._HOUSE_INT_MAX_FLOORS_DEFAULT)

        tx = int(math.floor(self.player.pos.x / self.TILE_SIZE))
        ty = int(math.floor(self.player.pos.y / self.TILE_SIZE))
        spawn_chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
        # Pick a reliable home entrance near spawn (guarantees the map marker exists).
        spawn_cx = int(spawn_tx) // self.CHUNK_SIZE
        spawn_cy = int(spawn_ty) // self.CHUNK_SIZE
        best_home: tuple[int, int, int, int] | None = None  # (d2, tx, ty, floors)
        # Search a few chunks around spawn so it also finds the nearby compound towers.
        search_r = 4
        for cy2 in range(int(spawn_cy) - int(search_r), int(spawn_cy) + int(search_r) + 1):
            for cx2 in range(int(spawn_cx) - int(search_r), int(spawn_cx) + int(search_r) + 1):
                chunk2 = self.world.get_chunk(int(cx2), int(cy2))
                for sb in getattr(chunk2, "special_buildings", []):
                    if getattr(sb, "kind", "") != "highrise":
                        continue
                    floors2 = int(getattr(sb, "floors", 0) or 0)
                    if floors2 <= 0:
                        floors2 = int(self._HR_INT_MAX_FLOORS_DEFAULT)
                    for dtile in tuple(getattr(sb, "door_tiles", ()) or ()):
                        hx, hy = int(dtile[0]), int(dtile[1])
                        d2 = (hx - int(spawn_tx)) ** 2 + (hy - int(spawn_ty)) ** 2
                        if best_home is None or d2 < int(best_home[0]):
                            best_home = (int(d2), int(hx), int(hy), int(floors2))

        floors = int(self._HR_INT_MAX_FLOORS_DEFAULT)
        if best_home is not None:
            _d2, hx, hy, floors = best_home
            self.home_highrise_door = (int(hx), int(hy))
        else:
            # Fallback: still show a marker instead of having "no home".
            self.home_highrise_door = (int(spawn_tx), int(spawn_ty))

        # Fixed "Chinese community" home for now: 6F room 602.
        self.home_highrise_floor = int(clamp(6, 2, int(floors)))
        # Unit numbering follows the door list order: 01..N
        self.home_highrise_unit = 2
        door_count = int(max(1, len(self._HR_INT_APT_DOORS)))
        self.home_highrise_unit = int(clamp(int(self.home_highrise_unit), 1, door_count))
        self.home_highrise_door_index = int(self.home_highrise_unit - 1)
        self.home_highrise_room = f"{int(self.home_highrise_floor)}{int(self.home_highrise_unit):02d}"
        try:
            if str(self.home_highrise_room).strip():
                self.hr_room_storages[str(self.home_highrise_room)] = (self.home_storage, self.fridge_storage)
        except Exception:
            pass
        self._set_hint(f"你的家：{self.home_highrise_room}", seconds=2.0)
        self._setup_home_highrise_world()

        # Ensure the starter vehicles don't spawn "inside" a building.
        def vehicle_clear(p: pygame.Vector2, w: int, h: int) -> bool:
            r = pygame.Rect(int(round(p.x - w / 2)), int(round(p.y - h / 2)), int(w), int(h))
            return len(self._collide_rect_world_vehicle(r)) == 0

        def find_clear_vehicle_pos(desired: pygame.Vector2, *, w: int, h: int, max_r_tiles: int = 18) -> pygame.Vector2:
            base_tx = int(math.floor(float(desired.x) / float(self.TILE_SIZE)))
            base_ty = int(math.floor(float(desired.y) / float(self.TILE_SIZE)))
            if vehicle_clear(desired, int(w), int(h)):
                return pygame.Vector2(desired)
            for r in range(1, int(max_r_tiles) + 1):
                for dy2 in (-r, r):
                    for dx2 in range(-r, r + 1):
                        tx2 = int(base_tx + dx2)
                        ty2 = int(base_ty + dy2)
                        px = (float(tx2) + 0.5) * float(self.TILE_SIZE)
                        py = (float(ty2) + 0.5) * float(self.TILE_SIZE)
                        cand = pygame.Vector2(px, py)
                        if vehicle_clear(cand, int(w), int(h)):
                            return cand
                for dx2 in (-r, r):
                    for dy2 in range(-r + 1, r):
                        tx2 = int(base_tx + dx2)
                        ty2 = int(base_ty + dy2)
                        px = (float(tx2) + 0.5) * float(self.TILE_SIZE)
                        py = (float(ty2) + 0.5) * float(self.TILE_SIZE)
                        cand = pygame.Vector2(px, py)
                        if vehicle_clear(cand, int(w), int(h)):
                            return cand
            return pygame.Vector2(desired)

        self.rv.pos = find_clear_vehicle_pos(pygame.Vector2(self.rv.pos), w=int(self.rv.w), h=int(self.rv.h))
        self.bike.pos = find_clear_vehicle_pos(pygame.Vector2(self.bike.pos), w=int(self.bike.w), h=int(self.bike.h))
        spawn_chunk.items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(self.player.pos) + pygame.Vector2(18, 0), item_id="pistol", qty=1))
        spawn_chunk.items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(self.player.pos) + pygame.Vector2(18, 10), item_id="ammo_9mm", qty=24))
        # Default start: spring morning (season is derived from day index).
        self.world_time_s = float(self.DAY_LENGTH_S) * float(self.START_DAY_FRACTION)
        self._debug = False
        self._gallery_open = False
        self._gallery_page = 0  # 0=cars, 1=bike
        self._roof_cache: dict[tuple[int, int, int, int], pygame.Surface] = {}
        self._sprite_outline_cache: dict[tuple[int, int, int, int], pygame.Surface] = {}
        self._door_open_anim: dict[tuple[int, int], float] = {}
        self._hover_tooltip: tuple[list[str], tuple[int, int]] | None = None
        # Simple dialog / typewriter box (used for home guidance, etc).
        self.dialog_open = False
        self.dialog_title = ""
        self.dialog_text_full = ""
        self.dialog_reveal = 0.0  # float char cursor
        self.dialog_speed = 42.0  # chars/sec
        self.dialog_blink = 0.0
        # Non-blocking speech bubble (doesn't swallow input).
        self.speech_text = ""
        self.speech_left = 0.0
        # Timed "use toilet" action (world-map home).
        self.toilet_task: dict[str, object] | None = None
        # Simple "held in hand" item (for carrying tools like cups).
        self.held_item: HardcoreSurvivalState._ItemStack | None = None
        self.muzzle_flash_left = 0.0
        self.noise_left = 0.0
        self.noise_radius = 0.0
        self.punch_left = 0.0
        self.punch_cooldown_left = 0.0
        self.punch_hit_done = False
        self.punch_dir = pygame.Vector2(1, 0)
        self.punch_hand = 0  # 0=left, 1=right (alternates each punch)
        self._melee_swing_id = "fist"
        self.hit_fx: list[HardcoreSurvivalState._HitFX] = []
        # Visual-only RNG: keep it separate so FX doesn't affect gameplay RNG.
        self.fx_rng = random.Random(self.seed ^ 0x51C0B1A7)

        # Weather (visual-first prototype).
        self.weather_kind = "clear"  # clear | cloudy | rain | storm | snow
        self.weather_intensity = 0.0  # 0..1
        self.weather_target_kind = "clear"
        self.weather_target_intensity = 0.0
        self.weather_day = 0
        self.weather_wind = 0.0  # px/s (screen-space drift)
        self.weather_wind_target = 0.0
        self.weather_flash_left = 0.0
        self.weather_rng = random.Random(self.seed ^ 0xA53C9F17)
        self._rain_drops: list[list[float]] = []  # [x, y, speed]
        self._snow_flakes: list[list[float]] = []  # [x, y, speed, drift]
        self._weather_layer = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        self._set_weather_targets_for_day(int(self.world_time_s / self.DAY_LENGTH_S) + 1)
        self.weather_kind = str(self.weather_target_kind)
        self.weather_intensity = float(self.weather_target_intensity)
        self.weather_wind = float(self.weather_wind_target)
        self.weather_day = int(self.world_time_s / self.DAY_LENGTH_S) + 1       
        self._sync_weather_particles()

        # Map UI.
        self.minimap_rect: pygame.Rect | None = None
        self.world_map_open = False
        self.world_map_scale = 3  # px per tile (big map)
        self.world_map_legend_open = True
        self.world_map_center = self._player_tile()
        self.world_map_markers: list[HardcoreSurvivalState._MapMarker] = []
        self.world_map_marker_next = 0
        self._world_map_cache_key: tuple[int, int, int, int, int, int] | None = None
        self._world_map_cache_scaled: pygame.Surface | None = None
        self._world_map_draw_rect: pygame.Rect | None = None
        self._world_map_start_tile: tuple[int, int] = (0, 0)
        self.world_map_dragging = False
        self.world_map_drag_start: tuple[int, int] = (0, 0)
        self.world_map_drag_center: tuple[int, int] = (0, 0)

    def handle_event(self, event: pygame.event.Event) -> None:
        if bool(getattr(self, "pause_open", False)):
            if event.type == pygame.KEYDOWN and int(event.key) in (pygame.K_ESCAPE,):
                self._pause_close_menu()
                return
            if event.type == pygame.KEYDOWN and int(event.key) in (pygame.K_RETURN, pygame.K_SPACE):
                self._pause_activate("resume")
                return
            if event.type == pygame.MOUSEBUTTONDOWN and int(getattr(event, "button", 0)) == 1:
                self._handle_pause_menu_mouse(event)
                return
            return

        if bool(getattr(self, "lamp_cfg_open", False)):
            if event.type == pygame.KEYDOWN and int(event.key) in (pygame.K_ESCAPE,):
                self._lamp_cfg_close()
                return
            if event.type == pygame.MOUSEBUTTONDOWN and int(getattr(event, "button", 0)) == 1:
                self._handle_lamp_cfg_mouse(event)
                return

        if getattr(self, "world_map_open", False):
            if event.type == pygame.KEYDOWN:
                self._handle_world_map_key(int(event.key))
                return
            if event.type in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION, pygame.MOUSEWHEEL):
                self._handle_world_map_mouse(event)
                return

        # High-rise travel (elevator/stairs) blocks input while the timer runs.
        if bool(getattr(self, "hr_interior", False)) and bool(getattr(self, "hr_travel_active", False)):
            return

        if getattr(self, "dialog_open", False):
            if event.type == pygame.KEYDOWN:
                if int(event.key) in (pygame.K_ESCAPE,):
                    self._dialog_close()
                    return
                if int(event.key) in (pygame.K_SPACE, pygame.K_RETURN, pygame.K_e):
                    if not self._dialog_finished():
                        self._dialog_finish()
                    else:
                        self._dialog_close()
                    return
                # Swallow other UI keys while the dialog is up.
                return
            if event.type == pygame.MOUSEBUTTONDOWN and int(getattr(event, "button", 0)) == 1:
                if not self._dialog_finished():
                    self._dialog_finish()
                else:
                    self._dialog_close()
                return

        if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1 and not bool(getattr(self, "home_ui_open", False)):
            internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
            if internal is not None and isinstance(getattr(self, "minimap_rect", None), pygame.Rect):
                if self.minimap_rect.collidepoint(internal):
                    self._toggle_world_map(open=True)
                    return
            if self._handle_hr_interior_ui_mouse(event):
                return

        if getattr(self, "home_ui_open", False):
            if event.type == pygame.KEYDOWN:
                self._handle_home_ui_key(int(event.key))
                return
            if event.type in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION, pygame.MOUSEWHEEL):
                self._handle_home_ui_mouse(event)
                return

        if getattr(self, "world_elevator_ui_open", False):
            if event.type == pygame.KEYDOWN:
                self._handle_world_elevator_ui_key(int(event.key))
                return
            if event.type == pygame.MOUSEWHEEL:
                self._handle_world_elevator_ui_wheel(event)
                return
            if event.type in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION):
                self._handle_world_elevator_ui_mouse(event)
                return
            return

        if getattr(self, "sch_elevator_ui_open", False):
            if event.type == pygame.KEYDOWN:
                self._handle_sch_elevator_ui_key(int(event.key))        
                return
            if event.type == pygame.MOUSEWHEEL:
                self._handle_sch_elevator_ui_wheel(event)
                return
            if event.type in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION):
                self._handle_sch_elevator_ui_mouse(event)
                return
            return

        if getattr(self, "hr_elevator_ui_open", False):
            if event.type == pygame.KEYDOWN:
                self._handle_hr_elevator_ui_key(int(event.key))
                return
            if event.type == pygame.MOUSEWHEEL:
                self._handle_hr_elevator_ui_wheel(event)
                return
            if event.type in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION):
                self._handle_hr_elevator_ui_mouse(event)
                return
            return

        if getattr(self, "hr_interior", False) and bool(getattr(self, "hr_edit_mode", False)):
            if self._hr_edit_handle_mouse(event):
                return

        if self.inv_open:
            if event.type == pygame.MOUSEBUTTONDOWN:
                self._handle_inventory_mouse(event)
                return

        if event.type == pygame.MOUSEBUTTONDOWN:
            if self._handle_rv_mode_buttons_mouse(event):
                return
            if self._handle_world_furniture_carry_mouse(event):
                return
            if self._handle_world_context_menu_mouse(event):
                return

        if event.type == pygame.KEYDOWN:
            if getattr(self, "_gallery_open", False):
                if event.key in (pygame.K_ESCAPE, pygame.K_F2):
                    self._gallery_open = False
                    return
                if event.key in (pygame.K_TAB, pygame.K_RIGHT, pygame.K_d):
                    self._gallery_page = (int(self._gallery_page) + 1) % 2
                    return
                if event.key in (pygame.K_LEFT, pygame.K_a):
                    self._gallery_page = (int(self._gallery_page) - 1) % 2
                    return
                return
            if bool(getattr(self, "home_move_mode", False)):
                self._handle_home_move_mode_key(int(event.key))
                return
            if self._world_furniture_carry_active() and event.key in (pygame.K_ESCAPE, pygame.K_q):
                self._home_move_cancel()
                self._set_hint("已取消", seconds=0.8)
                return
            if event.key in (pygame.K_m,):
                self._toggle_world_map()
                return
            if getattr(self, "house_interior", False):
                if event.key in (pygame.K_ESCAPE,):
                    self._house_interior_exit()
                    return
                if event.key in (pygame.K_e, pygame.K_RETURN, pygame.K_SPACE):
                    self._house_interior_interact()
                    return
                if event.key in (pygame.K_f, pygame.K_v, pygame.K_h, pygame.K_b):
                    return
            if getattr(self, "sch_interior", False):
                if event.key in (pygame.K_ESCAPE,):
                    self._sch_interior_exit()
                    return
                if event.key in (pygame.K_e, pygame.K_RETURN, pygame.K_SPACE):
                    self._sch_interior_interact()
                    return
                if event.key in (pygame.K_f, pygame.K_v, pygame.K_h, pygame.K_b):
                    return
            if getattr(self, "hr_interior", False):
                if event.key in (pygame.K_ESCAPE,):
                    if str(getattr(self, "hr_mode", "lobby")) == "home":
                        self._hr_leave_home()
                    else:
                        self._hr_interior_exit()
                    return
                if event.key in (pygame.K_r,) and str(getattr(self, "hr_mode", "lobby")) == "home":
                    self._hr_toggle_edit_mode()
                    return
                if getattr(self, "hr_edit_mode", False):
                    if event.key in (pygame.K_TAB,):
                        self._hr_edit_cycle(1)
                        return
                    if event.key in (pygame.K_LEFT, pygame.K_a):
                        self._hr_edit_move(-1, 0)
                        return
                    if event.key in (pygame.K_RIGHT, pygame.K_d):
                        self._hr_edit_move(1, 0)
                        return
                    if event.key in (pygame.K_UP, pygame.K_w):
                        self._hr_edit_move(0, -1)
                        return
                    if event.key in (pygame.K_DOWN, pygame.K_s):
                        self._hr_edit_move(0, 1)
                        return
                    if event.key in (pygame.K_e, pygame.K_RETURN, pygame.K_SPACE):
                        return
                if event.key in (pygame.K_e, pygame.K_RETURN, pygame.K_SPACE):
                    self._hr_interior_interact()
                    return
                if event.key in (pygame.K_f, pygame.K_v, pygame.K_h, pygame.K_b):
                    return
            if event.key in (pygame.K_ESCAPE,):
                if self.inv_open:
                    self.inv_open = False
                else:
                    self._pause_open_menu()
                return
            if event.key in (pygame.K_TAB,):
                self.inv_open = not self.inv_open
                return
            if not self.inv_open and event.key in (pygame.K_g,):
                self._toggle_home_move_mode()
                return
            if event.key in (pygame.K_F2,):
                self.inv_open = False
                self._gallery_page = 0
                self._gallery_open = not bool(getattr(self, "_gallery_open", False))
                return
            if event.key in (pygame.K_e,):
                self._interact_primary()
                return
            if not self.inv_open and event.key in (pygame.K_l,):
                self._toggle_door_lock()
                return
            if not self.inv_open and event.key in (pygame.K_b,):
                self._toggle_barricade()
                return
            if not self.inv_open and event.key in (pygame.K_h,):
                # H: driving RV -> toggle headlights; otherwise near RV -> enter/exit RV interior; elsewhere -> quick home teleport.
                if self.mount == "rv":
                    self.rv_headlights_on = not bool(getattr(self, "rv_headlights_on", True))
                    self._set_hint("车灯：开" if bool(self.rv_headlights_on) else "车灯：关", seconds=0.9)
                elif (bool(getattr(self, "rv_world_interior", False)) or self._can_access_rv()) and str(getattr(self.rv, "model_id", "rv")) == "rv":
                    self._rv_world_interior_toggle()
                else:
                    self._teleport_to_bathroom()
                return
            if not self.inv_open and event.key in (pygame.K_f,):
                if bool(getattr(self, "rv_world_interior", False)):
                    # In RV world-interior: start driving immediately (no need to find the seat).
                    self._rv_world_try_drive_from_anywhere()
                    return
                self._toggle_vehicle()
                return
            if not self.inv_open and event.key in (pygame.K_r,):
                self._start_reload()
                return
            if not self.inv_open and event.key in (pygame.K_j,):
                self._start_punch()
                return
            if not self.inv_open and event.key in (pygame.K_v,):
                self._cycle_rv_model()
                return
            if self.inv_open and event.key in (pygame.K_q,):
                self._drop_selected()
                return
            if self.inv_open and event.key in (pygame.K_LEFT, pygame.K_a):
                self.inv_index = (self.inv_index - 1) % len(self.inventory.slots)
                return
            if self.inv_open and event.key in (pygame.K_RIGHT, pygame.K_d):
                self.inv_index = (self.inv_index + 1) % len(self.inventory.slots)
                return
            if self.inv_open and event.key in (pygame.K_UP, pygame.K_w):
                self.inv_index = (self.inv_index - self.inventory.cols) % len(self.inventory.slots)
                return
            if self.inv_open and event.key in (pygame.K_DOWN, pygame.K_s):
                self.inv_index = (self.inv_index + self.inventory.cols) % len(self.inventory.slots)
                return
            if self.inv_open and event.key in (pygame.K_RETURN, pygame.K_SPACE):
                self._equip_selected()
                return
            if event.key in (pygame.K_F3,):
                self._debug = not self._debug
                return

    def _handle_inventory_mouse(self, event: pygame.event.Event) -> None:
        if not self.inv_open:
            return
        if event.type != pygame.MOUSEBUTTONDOWN:
            return
        if not hasattr(event, "pos"):
            return
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return
        mx, my = int(internal[0]), int(internal[1])
        btn = int(getattr(event, "button", 0))
        if btn not in (1, 3):
            return

        # Mirror the layout math in _draw_inventory_ui() so hit-testing matches.
        cols = max(1, int(self.inventory.cols))
        rows = int(math.ceil(len(self.inventory.slots) / cols))
        slot = 30
        gap = 4
        grid_w = cols * slot + (cols - 1) * gap
        grid_h = rows * slot + (rows - 1) * gap
        x0 = (INTERNAL_W - grid_w) // 2
        y0 = (INTERNAL_H - grid_h) // 2 - 10
        grid = pygame.Rect(int(x0), int(y0), int(grid_w), int(grid_h))
        if not grid.collidepoint(mx, my):
            return

        cell = int(slot + gap)
        if cell <= 0:
            return
        lx = int(mx - int(x0))
        ly = int(my - int(y0))
        cx = int(lx // cell)
        cy = int(ly // cell)
        if cx < 0 or cy < 0 or cx >= int(cols):
            return
        # Ignore clicks on the gap area.
        if int(lx % cell) >= int(slot) or int(ly % cell) >= int(slot):
            return
        idx = int(cy * int(cols) + cx)
        if not (0 <= idx < len(self.inventory.slots)):
            return

        # Left-click selects; double-click uses/equips. Right-click uses/equips.
        if btn == 1:
            now_ms = int(pygame.time.get_ticks())
            last_ms = int(getattr(self, "_inv_last_click_ms", -999999))
            last_idx = int(getattr(self, "_inv_last_click_idx", -1))
            self.inv_index = int(idx)
            if int(idx) == int(last_idx) and (now_ms - last_ms) <= 320:
                self._equip_selected()
            self._inv_last_click_ms = int(now_ms)
            self._inv_last_click_idx = int(idx)
            return

        if btn == 3:
            self.inv_index = int(idx)
            self._equip_selected()
            return

    def _apply_rv_model(self) -> None:
        mid = getattr(self.rv, "model_id", "schoolbus")
        model = self._CAR_MODELS.get(str(mid))
        if model is None:
            model = self._CAR_MODELS["schoolbus"]
            self.rv.model_id = model.id
        self.rv.w = int(model.collider[0])
        self.rv.h = int(model.collider[1])

    def _two_wheel_name(self, model_id: str) -> str:
        model_id = str(model_id)
        name_map = {
            "bike": "自行车",
            "bike_lady": "女士自行车",
            "bike_mountain": "山地车",
            "bike_auto": "自动自行车",
            "moto": "摩托车",
            "moto_lux": "豪华摩托车",
            "moto_long": "加长摩托车",
        }
        return str(name_map.get(model_id, model_id))

    def _two_wheel_collider_px(self, model_id: str) -> tuple[int, int]:
        mid = str(model_id)
        collider_map: dict[str, tuple[int, int]] = {
            "bike": (14, 10),
            "bike_lady": (14, 10),
            "bike_mountain": (14, 10),
            "bike_auto": (14, 10),
            "moto": (16, 12),
            "moto_lux": (16, 12),
            "moto_long": (18, 12),
        }
        return collider_map.get(mid, (14, 10))

    def _apply_bike_model(self) -> None:
        if not hasattr(self, "bike") or self.bike is None:
            return
        mid = str(getattr(self.bike, "model_id", "bike"))
        if mid not in self._TWO_WHEEL_FRAMES:
            mid = "bike"
            self.bike.model_id = mid

        w, h = self._two_wheel_collider_px(mid)
        self.bike.w = int(w)
        self.bike.h = int(h)

    def _place_spawn_vehicles_safely(self) -> None:
        # Ensure the spawned RV/bike don't start overlapped with buildings/walls,
        # which would make vehicles appear "unable to move".
        if not hasattr(self, "world") or self.world is None:
            return
        if not hasattr(self, "player") or self.player is None:
            return
        rv_obj = getattr(self, "rv", None)
        bike_obj = getattr(self, "bike", None)
        if rv_obj is None and bike_obj is None:
            return

        try:
            base_tx = int(math.floor(float(self.player.pos.x) / float(self.TILE_SIZE)))
            base_ty = int(math.floor(float(self.player.pos.y) / float(self.TILE_SIZE)))
        except Exception:
            return

        player_rect = self.player.rect_at(self.player.pos)
        ts = int(self.TILE_SIZE)
        if ts <= 0:
            return

        prefer_score = {
            int(self.T_ROAD): 0,
            int(self.T_HIGHWAY): 0,
            int(self.T_PARKING): 1,
            int(self.T_PAVEMENT): 1,
            int(self.T_CONCRETE): 1,
            int(self.T_SIDEWALK): 1,
            int(self.T_BRICK): 1,
        }

        def find_free_center_for_mount(mount: str, *, w: int, h: int, min_r: int, max_r: int) -> pygame.Vector2 | None:
            w = int(w)
            h = int(h)
            if w <= 0 or h <= 0:
                return None
            min_r = int(max(0, int(min_r)))
            max_r = int(max(int(min_r), int(max_r)))

            saved_mount = getattr(self, "mount", None)
            self.mount = str(mount)
            try:
                best: pygame.Vector2 | None = None
                best_key: tuple[int, int, int] | None = None
                for r in range(int(min_r), int(max_r) + 1):
                    for dy in range(-int(r), int(r) + 1):
                        for dx in range(-int(r), int(r) + 1):
                            if max(abs(int(dx)), abs(int(dy))) != int(r):
                                continue
                            tx = int(base_tx + int(dx))
                            ty = int(base_ty + int(dy))
                            try:
                                tid = int(self.world.get_tile(int(tx), int(ty)))
                            except Exception:
                                tid = int(self.T_GRASS)
                            score = int(prefer_score.get(int(tid), 3))

                            cx = (float(tx) + 0.5) * float(ts)
                            cy = (float(ty) + 0.5) * float(ts)
                            rect = pygame.Rect(
                                iround(float(cx) - float(w) / 2.0),
                                iround(float(cy) - float(h) / 2.0),
                                int(w),
                                int(h),
                            )
                            if rect.colliderect(player_rect.inflate(8, 8)):
                                continue
                            if self._collide_rect_world_vehicle(rect):
                                continue

                            key = (int(score), int(r), int(abs(int(dx)) + abs(int(dy))))
                            if best_key is None or key < best_key:
                                best_key = key
                                best = pygame.Vector2(float(cx), float(cy))

                    # Early exit if we found a very good candidate.
                    if best is not None and best_key is not None and int(best_key[0]) == 0 and int(r) <= int(min_r) + 2:
                        break
                return best
            finally:
                self.mount = saved_mount

        # Place RV first (bike is treated as solid during the search).
        if rv_obj is not None:
            try:
                rv_w0 = int(getattr(rv_obj, "w", 0))
                rv_h0 = int(getattr(rv_obj, "h", 0))
                rv_sizes: list[tuple[int, int]] = []
                if rv_w0 > 0 and rv_h0 > 0:
                    rv_sizes.append((int(rv_w0), int(rv_h0)))
                # Fallback: if the visual footprint is too large to fit common roads,
                # search using the driving collider (tighter).
                try:
                    mid = str(getattr(rv_obj, "model_id", "rv"))
                    model = self._CAR_MODELS.get(mid) or self._CAR_MODELS.get("rv")
                    dc = getattr(model, "drive_collider", None) if model is not None else None
                    if isinstance(dc, tuple) and len(dc) == 2:
                        dcw, dch = int(dc[0]), int(dc[1])
                        if dcw > 0 and dch > 0:
                            rv_sizes.append((int(dcw), int(dch)))
                except Exception:
                    pass
                # De-dup while preserving order.
                seen_sz: set[tuple[int, int]] = set()
                rv_sizes2: list[tuple[int, int]] = []
                for s in rv_sizes:
                    key = (int(s[0]), int(s[1]))
                    if key in seen_sz:
                        continue
                    seen_sz.add(key)
                    rv_sizes2.append(key)

                for w, h in rv_sizes2:
                    rv_pos = find_free_center_for_mount("rv", w=int(w), h=int(h), min_r=3, max_r=40)
                    if rv_pos is not None:
                        rv_obj.pos.update(rv_pos)
                        break
            except Exception:
                pass

        # Then place the bike (RV treated as solid).
        if bike_obj is not None:
            try:
                bike_w = int(getattr(bike_obj, "w", 0))
                bike_h = int(getattr(bike_obj, "h", 0))
                bike_pos = find_free_center_for_mount("bike", w=bike_w, h=bike_h, min_r=2, max_r=24)
                if bike_pos is not None:
                    bike_obj.pos.update(bike_pos)
            except Exception:
                pass

    def _rv_try_unstuck_nearby(self) -> bool:
        """Try to relocate the RV to a nearby free road-ish tile.

        This is a safety net for situations where the RV can become effectively immobile
        due to dense city facades/props or unlucky placement near solid geometry.
        """
        if not hasattr(self, "world") or self.world is None:
            return False
        if not hasattr(self, "rv") or self.rv is None:
            return False
        try:
            ts = int(self.TILE_SIZE)
            if ts <= 0:
                return False
            base_tx = int(math.floor(float(self.rv.pos.x) / float(ts)))
            base_ty = int(math.floor(float(self.rv.pos.y) / float(ts)))
        except Exception:
            return False

        # Use the driving collider if defined; it better represents the "drivable" envelope.
        try:
            mid = str(getattr(self.rv, "model_id", "rv"))
            model = self._CAR_MODELS.get(mid) or self._CAR_MODELS.get("rv")
        except Exception:
            model = None

        w = int(max(2, int(getattr(self.rv, "w", 0))))
        h = int(max(2, int(getattr(self.rv, "h", 0))))
        try:
            dc = getattr(model, "drive_collider", None) if model is not None else None
            if isinstance(dc, tuple) and len(dc) == 2:
                dw, dh = int(dc[0]), int(dc[1])
                if dw > 0 and dh > 0:
                    w = int(max(2, min(int(w), int(dw))))
                    h = int(max(2, min(int(h), int(dh))))
        except Exception:
            pass

        prefer_score = {
            int(self.T_ROAD): 0,
            int(self.T_HIGHWAY): 0,
            int(self.T_PARKING): 1,
            int(self.T_PAVEMENT): 2,
            int(self.T_CONCRETE): 2,
            int(self.T_SIDEWALK): 3,
            int(self.T_BRICK): 3,
            int(self.T_GRASS): 4,
        }

        def rect_at_center(cx: float, cy: float) -> pygame.Rect:
            return pygame.Rect(
                iround(float(cx) - float(w) / 2.0),
                iround(float(cy) - float(h) / 2.0),
                int(w),
                int(h),
            )

        def rect_at_center_wh(cx: float, cy: float, ww: int, hh: int) -> pygame.Rect:
            ww = int(max(2, int(ww)))
            hh = int(max(2, int(hh)))
            return pygame.Rect(
                iround(float(cx) - float(ww) / 2.0),
                iround(float(cy) - float(hh) / 2.0),
                int(ww),
                int(hh),
            )

        def ang_diff(a: float, b: float) -> float:
            d = float((float(a) - float(b) + math.pi) % (math.tau) - math.pi)
            return abs(float(d))

        def corridor_ok(cx: float, cy: float, heading: float, ww: int, hh: int) -> bool:
            try:
                base = rect_at_center_wh(float(cx), float(cy), int(ww), int(hh))
                if self._collide_rect_world_vehicle(base):
                    return False
                fwd = pygame.Vector2(math.cos(float(heading)), math.sin(float(heading)))
                if fwd.length_squared() <= 0.001:
                    fwd = pygame.Vector2(1, 0)
                else:
                    fwd = fwd.normalize()
                step = float(max(6.0, float(ts) * 0.85))
                for sgn in (1.0, -1.0):
                    nx = float(cx) + float(fwd.x) * float(step) * float(sgn)
                    ny = float(cy) + float(fwd.y) * float(step) * float(sgn)
                    r2 = rect_at_center_wh(float(nx), float(ny), int(ww), int(hh))
                    if not self._collide_rect_world_vehicle(r2):
                        return True
                return False
            except Exception:
                return False

        best: tuple[pygame.Vector2, float, int, int] | None = None  # (pos, heading, score, r)
        best_key: tuple[int, int, int, int] | None = None
        max_r = 16  # tiles
        cur_heading = float(getattr(self.rv, "heading", 0.0))
        headings = (0.0, math.pi / 2.0, math.pi, 3.0 * math.pi / 2.0)
        for r in range(0, int(max_r) + 1):
            for dy in range(-int(r), int(r) + 1):
                for dx in range(-int(r), int(r) + 1):
                    if max(abs(int(dx)), abs(int(dy))) != int(r):
                        continue
                    tx = int(base_tx + int(dx))
                    ty = int(base_ty + int(dy))
                    try:
                        tid = int(self.world.get_tile(int(tx), int(ty)))
                    except Exception:
                        tid = int(self.T_GRASS)
                    score = int(prefer_score.get(int(tid), 5))

                    cx = (float(tx) + 0.5) * float(ts)
                    cy = (float(ty) + 0.5) * float(ts)
                    # Pick a cardinal heading that has some forward/back clearance so the RV
                    # can actually start moving immediately after relocation.
                    picked_heading: float | None = None
                    picked_diff: float | None = None
                    for hd in headings:
                        # Driving uses a stable AABB; swap dims when driving mostly vertical.
                        if hd in (math.pi / 2.0, 3.0 * math.pi / 2.0):
                            ww, hh = int(h), int(w)
                        else:
                            ww, hh = int(w), int(h)
                        if not corridor_ok(float(cx), float(cy), float(hd), int(ww), int(hh)):
                            continue
                        diff = float(ang_diff(float(cur_heading), float(hd)))
                        if picked_diff is None or diff < float(picked_diff):
                            picked_diff = float(diff)
                            picked_heading = float(hd)

                    if picked_heading is None:
                        continue

                    key = (int(score), int(r), int(abs(int(dx)) + abs(int(dy))), int(round(float(picked_diff or 0.0) * 1000.0)))
                    if best_key is None or key < best_key:
                        best_key = key
                        best = (pygame.Vector2(float(cx), float(cy)), float(picked_heading), int(score), int(r))

            # Early exit if we found a great road/highway candidate quickly.
            if best is not None and best_key is not None and int(best_key[0]) == 0 and int(r) <= 5:
                break

        if best is None:
            return False

        try:
            pos, hd, _score, _r = best
            self.rv.pos.update(pos)
            self.rv.heading = float(hd)
            # Keep the axis hint consistent with the snapped heading.
            self._rv_drive_axis = 1 if float(hd) in (math.pi / 2.0, 3.0 * math.pi / 2.0) else 0
            self.rv.vel.update(0, 0)
            self.rv.speed = 0.0
            self.rv.steer = 0.0
        except Exception:
            return False
        return True

    def _bike_base_speed(self) -> float:
        mid = str(getattr(getattr(self, "bike", None), "model_id", "bike"))
        speed_map: dict[str, float] = {
            "bike": 92.0,
            "bike_lady": 90.0,
            "bike_mountain": 96.0,
            "bike_auto": 108.0,
            "moto": 148.0,
            "moto_lux": 158.0,
            "moto_long": 152.0,
        }
        return float(speed_map.get(mid, 92.0))

    def _bike_uses_stamina(self) -> bool:
        mid = str(getattr(getattr(self, "bike", None), "model_id", "bike"))
        if mid.startswith("moto"):
            return False
        if mid == "bike_auto":
            return False
        return True

    def _sprite_baseline_y(self, spr: pygame.Surface) -> int:
        cache = getattr(self, "_sprite_baseline_cache", None)
        if cache is None:
            cache = {}
            self._sprite_baseline_cache = cache
        key = int(id(spr))
        by = cache.get(key)
        if by is not None:
            return int(by)

        w, h = spr.get_size()
        baseline = int(h - 1)
        for y in range(int(h) - 1, -1, -1):
            for x in range(int(w)):
                if int(spr.get_at((int(x), int(y))).a) > 0:
                    baseline = int(y)
                    cache[key] = int(baseline)
                    return int(baseline)
        cache[key] = int(baseline)
        return int(baseline)

    def _two_wheel_shadow_rect(
        self,
        spr_rect: pygame.Rect,
        d: str,
        *,
        ground_y: int | None = None,
    ) -> pygame.Rect:
        d = str(d)
        if d in ("left", "right"):
            shadow_w = max(12, int(spr_rect.w) - 3)
        else:
            shadow_w = max(10, int(spr_rect.w) - 6)
        shadow_h = 4
        shadow = pygame.Rect(0, 0, int(shadow_w), int(shadow_h))
        cy = int(spr_rect.bottom - 2) if ground_y is None else int(ground_y - 2)
        shadow.center = (int(spr_rect.centerx), int(cy))
        return shadow

    def _cycle_rv_model(self) -> None:
        if not hasattr(self, "rv") or self.rv is None:
            return
        rv_d2 = float((self.player.pos - self.rv.pos).length_squared())
        can_change = self.mount == "rv" or rv_d2 <= (36.0 * 36.0)
        if not can_change:
            return

        ids = list(self._CAR_MODELS.keys())
        if not ids:
            return
        cur = str(getattr(self.rv, "model_id", ids[0]))
        try:
            idx = ids.index(cur)
        except ValueError:
            idx = 0
        self.rv.model_id = ids[(idx + 1) % len(ids)]
        self._apply_rv_model()
        model = self._CAR_MODELS.get(str(self.rv.model_id))
        name = model.name if model is not None else str(self.rv.model_id)
        self._set_hint(f"房车型号：{name}", seconds=1.5)

    def _set_home_ui_status(self, text: str, *, seconds: float = 1.6) -> None:
        self.home_ui_status = str(text)
        self.home_ui_status_left = float(max(0.0, seconds))

    def _clear_player_pose(self) -> None:
        prev_pose = str(getattr(self, "player_pose", "") or "")
        prev_space = str(getattr(self, "player_pose_space", "") or "")
        self.player_pose = None
        self.player_pose_space = ""
        self.player_pose_left = 0.0
        self.player_pose_anchor = None
        self.player_pose_phase = 0.0
        if prev_space == "world" and prev_pose in ("sleep", "sit"):
            self.world_ctx_cooldown_left = max(float(getattr(self, "world_ctx_cooldown_left", 0.0)), 1.0)

    def _set_player_pose(
        self,
        pose: str,
        *,
        space: str,
        anchor: tuple[float, float],
        seconds: float = 0.0,
    ) -> None:
        self.player_pose = str(pose)
        self.player_pose_space = str(space)
        self.player_pose_anchor = (float(anchor[0]), float(anchor[1]))
        self.player_pose_left = float(max(0.0, seconds))
        self.player_pose_phase = 0.0

    def _get_pose_sprite(self, pose: str, *, direction: str = "down", frame: int = 0) -> pygame.Surface:
        av = getattr(self, "avatar", None) or SurvivalAvatar()
        av.clamp_all()
        direction = str(direction)
        if direction not in ("down", "up", "right", "left"):
            direction = "down"
        key = (
            str(pose),
            str(direction),
            int(frame) % 2,
            int(av.gender),
            int(av.height),
            int(av.face),
            int(av.eyes),
            int(av.hair),
            int(av.nose),
            int(av.outfit),
        )
        cache = getattr(self, "_pose_sprite_cache", None)
        if not isinstance(cache, dict):
            cache = {}
            self._pose_sprite_cache = cache
        spr = cache.get(key)
        if isinstance(spr, pygame.Surface):
            return spr
        if str(pose) == "sleep":
            spr = HardcoreSurvivalState._make_avatar_pose_sleep_sprite(int(frame), avatar=av)
        else:
            spr = HardcoreSurvivalState._make_avatar_pose_sit_sprite(str(direction), avatar=av)
        cache[key] = spr
        return spr

    def _rv_collider_rect_at(self, pos: pygame.Vector2 | None = None) -> pygame.Rect:
        # RV sprite rotates, but collisions used to stay as a fixed axis-aligned box.
        # That made it feel like you can't walk close to the RV (especially when the
        # RV faces up/down). Use the rotated AABB instead.
        try:
            if pos is None:
                pos = pygame.Vector2(getattr(self.rv, "pos", pygame.Vector2(0, 0)))
            else:
                pos = pygame.Vector2(pos)
            w0 = float(getattr(self.rv, "w", 0.0))
            h0 = float(getattr(self.rv, "h", 0.0))
            heading = float(getattr(self.rv, "heading", 0.0))
            if w0 <= 0.0 or h0 <= 0.0:
                return pygame.Rect(int(round(float(pos.x))), int(round(float(pos.y))), 1, 1)
            c = abs(math.cos(float(heading)))
            s = abs(math.sin(float(heading)))
            ww = w0 * c + h0 * s
            hh = w0 * s + h0 * c
            w = int(max(1, int(round(float(ww)))))
            h = int(max(1, int(round(float(hh)))))
            return pygame.Rect(
                iround(float(pos.x) - float(w) / 2.0),
                iround(float(pos.y) - float(h) / 2.0),
                int(w),
                int(h),
            )
        except Exception:
            try:
                if pos is None:
                    pos = pygame.Vector2(getattr(self.rv, "pos", pygame.Vector2(0, 0)))
                w = int(max(1, int(getattr(self.rv, "w", 1))))
                h = int(max(1, int(getattr(self.rv, "h", 1))))
                return pygame.Rect(
                    iround(float(pos.x) - float(w) / 2.0),
                    iround(float(pos.y) - float(h) / 2.0),
                    int(w),
                    int(h),
                )
            except Exception:
                return pygame.Rect(0, 0, 1, 1)

    def _can_access_rv(self) -> bool:
        if self.mount == "rv":
            return True
        try:
            pad = 24
            r = self._rv_collider_rect_at().inflate(int(pad * 2), int(pad * 2))
            return bool(r.collidepoint(int(round(float(self.player.pos.x))), int(round(float(self.player.pos.y)))))
        except Exception:
            return (self.player.pos - self.rv.pos).length_squared() <= (36.0 * 36.0)

    def _ensure_rv_world_interior_built(self) -> bool:
        # Build a temporary RV room on the world map (same camera/tile mode).
        # The stamped tiles are restored on exit so the outside world is unchanged.
        if isinstance(getattr(self, "_rv_world_int_restore_tiles", None), dict) and isinstance(getattr(self, "_rv_world_int_active_key", None), tuple):
            return True

        size = getattr(self, "_rv_world_int_size", (16, 10))
        try:
            w, h = int(size[0]), int(size[1])
        except Exception:
            w, h = 16, 10
        w = int(max(6, min(28, int(w))))
        # Allow smaller RVs to still have a walkable interior.
        h = int(max(3, min(20, int(h))))

        # Stamp the room inside the RV's own footprint (not a separate far-away area).
        rv_rect = self.rv.rect()
        rv_tx0 = int(math.floor(float(rv_rect.left) / float(self.TILE_SIZE)))
        rv_ty0 = int(math.floor(float(rv_rect.top) / float(self.TILE_SIZE)))
        rv_tx1 = int(math.floor(float(rv_rect.right - 1) / float(self.TILE_SIZE)))
        rv_ty1 = int(math.floor(float(rv_rect.bottom - 1) / float(self.TILE_SIZE)))
        rv_w_tiles = int(rv_tx1 - rv_tx0 + 1)
        rv_h_tiles = int(rv_ty1 - rv_ty0 + 1)
        if int(rv_w_tiles) < int(w) or int(rv_h_tiles) < int(h):
            self._set_hint("房车太小，无法生成内部空间", seconds=1.2)
            return False

        tx0 = int(rv_tx0 + max(0, (int(rv_w_tiles) - int(w)) // 2))
        ty0 = int(rv_ty0 + max(0, (int(rv_h_tiles) - int(h)) // 2))

        # Safety: if the RV is parked overlapping buildings/water, don't stamp.
        for yy in range(int(h)):
            for xx in range(int(w)):
                wx = int(tx0 + xx)
                wy = int(ty0 + yy)
                if self._peek_building_at_tile(int(wx), int(wy)) is not None:
                    self._set_hint("房车离建筑太近，换个地方停", seconds=1.2)
                    return False
                t = int(self.world.peek_tile(int(wx), int(wy), default=int(self.T_GRASS)))
                if int(t) == int(self.T_WATER):
                    self._set_hint("房车停在水上了", seconds=1.2)
                    return False

        key = (int(tx0), int(ty0), int(w), int(h))

        restore: dict[tuple[int, int], int] = {}
        for yy in range(int(h)):
            for xx in range(int(w)):
                wx = int(tx0 + xx)
                wy = int(ty0 + yy)
                restore[(int(wx), int(wy))] = int(self.world.get_tile(int(wx), int(wy)))

        self._rv_world_int_restore_tiles = restore
        self._rv_world_int_active_key = key

        # Reset RV interior helpers (rebuilt each time).
        self._rv_world_floor_base = None
        self._rv_world_fixed_furniture = set()
        self._rv_world_dash_tile = None

        # Stamp: floor everywhere. The RV room is "enclosed" via thin collision bounds
        # (so the 1-tile wall border doesn't eat 2/3 of the usable space on small RVs).
        for yy in range(int(h)):
            for xx in range(int(w)):
                wx = int(tx0 + xx)
                wy = int(ty0 + yy)
                self._world_set_tile(int(wx), int(wy), int(self.T_FLOOR))

        # Exit marker tile (press E/H to leave).
        # Place the door on the living (rear) side so it doesn't collide with the cabin partition.
        exit_tx = int(tx0 + 1)
        exit_ty = int(ty0 + h - 2)
        self._rv_world_int_exit_tile = (int(exit_tx), int(exit_ty))
        self._world_set_tile(int(exit_tx), int(exit_ty), int(self.T_DOOR))

        fx0 = int(tx0 + 1)
        fx1 = int(tx0 + int(w) - 2)
        fy0 = int(ty0 + 1)
        fy1 = int(ty0 + int(h) - 2)

        # Driver cabin: vertical partition + distinct floor tone (cockpit).
        part_x: int | None = None
        cabin_x0: int | None = None
        try:
            inner_w = int(max(1, int(w) - 2))
            cabin_inner_w = int(clamp(int(inner_w // 3), 3, 5))
            cabin_x0 = int(fx1 - cabin_inner_w + 1)
            cand_part = int(cabin_x0 - 1)
            if int(fx0 + 2) <= int(cand_part) <= int(fx1 - 2):
                part_x = int(cand_part)
                # Door opening near the middle of the usable interior band.
                door_y = int((int(fy0) + int(fy1)) // 2)
                door_y = int(clamp(int(door_y), int(fy0), int(fy1)))
                for yy in range(int(fy0), int(fy1) + 1):
                    if int(yy) == int(door_y):
                        continue
                    self._world_set_tile(int(part_x), int(yy), int(self.T_WALL))
                # Mark the opening as a (passable) door/curtain so the separation reads visually.
                try:
                    if int(self.world.peek_tile(int(part_x), int(door_y), default=int(self.T_FLOOR))) == int(self.T_FLOOR):
                        self._world_set_tile(int(part_x), int(door_y), int(self.T_DOOR_BROKEN))
                except Exception:
                    pass
        except Exception:
            part_x = None
            cabin_x0 = None

        # Cabin floor tone: make the cockpit read as a different material.
        try:
            if cabin_x0 is not None:
                for yy in range(int(fy0), int(fy1) + 1):
                    # Include one extra column at the very front edge so the steering
                    # wheel can sit "more forward" without looking outside the cockpit.
                    for xx in range(int(cabin_x0), int(fx1) + 2):
                        if int(self.world.peek_tile(int(xx), int(yy), default=int(self.T_FLOOR))) == int(self.T_FLOOR):
                            self._world_set_tile(int(xx), int(yy), int(self.T_CONCRETE))
        except Exception:
            pass

        living_x1 = int(fx1 if part_x is None else int(part_x - 1))

        # Base floor map (for RV furniture moving): record the intended walkable tile under furniture.
        try:
            base: dict[tuple[int, int], int] = {}
            for yy in range(int(h)):
                for xx in range(int(w)):
                    wx = int(tx0 + xx)
                    wy = int(ty0 + yy)
                    tid = int(self.world.peek_tile(int(wx), int(wy), default=int(self.T_FLOOR)))
                    if tid in (int(self.T_FLOOR), int(self.T_BOARDWALK), int(self.T_CONCRETE)):
                        base[(int(wx), int(wy))] = int(tid)
            self._rv_world_floor_base = base
        except Exception:
            self._rv_world_floor_base = None

        # Bed (2 tiles, living area).
        bed_y = int(clamp(int(fy0 + 1), int(fy0), int(fy1)))
        bed_x0 = int(clamp(int(fx0 + 1), int(fx0), int(living_x1 - 1)))
        if int(bed_x0 + 1) <= int(living_x1) and int(fy0) <= int(bed_y) <= int(fy1):
            for bx in (int(bed_x0), int(bed_x0 + 1)):
                if int(self.world.peek_tile(int(bx), int(bed_y))) in (
                    int(self.T_FLOOR),
                    int(self.T_BOARDWALK),
                    int(self.T_CONCRETE),
                ):
                    self._world_set_tile(int(bx), int(bed_y), int(self.T_BED))

        # Cabinet (living area, away from the exit tile).
        cab_x = int(clamp(int(fx0 + 1), int(fx0), int(living_x1)))
        cab_y = int(clamp(int(fy1 - 1), int(fy0), int(fy1)))
        if (int(cab_x), int(cab_y)) != (int(exit_tx), int(exit_ty)):
            if int(self.world.peek_tile(int(cab_x), int(cab_y))) in (
                int(self.T_FLOOR),
                int(self.T_BOARDWALK),
                int(self.T_CONCRETE),
            ):
                self._world_set_tile(int(cab_x), int(cab_y), int(self.T_CABINET))

        # Cabin: seats + steering wheel at the very front (right side).
        # These tiles are fixed (not movable).
        self._rv_world_driver_seat_tile = None
        try:
            fixed: set[tuple[int, int]] = getattr(self, "_rv_world_fixed_furniture", set())
            driver_y = int(fy0)
            pass_y = int(fy1)

            cab_start = int(fx0)
            try:
                if cabin_x0 is not None:
                    cab_start = int(cabin_x0)
                elif part_x is not None:
                    cab_start = int(part_x + 1)
            except Exception:
                cab_start = int(fx0)
            cab_end = int(fx1)

            # Push the steering wheel 1 tile further forward (to the right/front edge).
            # Keep the seats just behind it so they still "face the windshield".
            wheel_x = int(cab_end + 1)
            seat_x = int(max(int(cab_start), int(wheel_x) - 1))

            if int(self.world.peek_tile(int(seat_x), int(driver_y))) in (
                int(self.T_FLOOR),
                int(self.T_BOARDWALK),
                int(self.T_CONCRETE),
            ):
                self._world_set_tile(int(seat_x), int(driver_y), int(self.T_CHAIR))
                self._rv_world_driver_seat_tile = (int(seat_x), int(driver_y))
                fixed.add((int(seat_x), int(driver_y)))
            if int(self.world.peek_tile(int(seat_x), int(pass_y))) in (
                int(self.T_FLOOR),
                int(self.T_BOARDWALK),
                int(self.T_CONCRETE),
            ):
                if (int(seat_x), int(pass_y)) != (int(exit_tx), int(exit_ty)) and (int(seat_x), int(pass_y)) != (int(seat_x), int(driver_y)):
                    self._world_set_tile(int(seat_x), int(pass_y), int(self.T_CHAIR))
                    fixed.add((int(seat_x), int(pass_y)))

            # Steering wheel at the very front (by the "windshield").
            if (int(wheel_x), int(driver_y)) not in ((int(exit_tx), int(exit_ty)), (int(seat_x), int(driver_y)), (int(seat_x), int(pass_y))):
                if int(self.world.peek_tile(int(wheel_x), int(driver_y))) in (
                    int(self.T_FLOOR),
                    int(self.T_BOARDWALK),
                    int(self.T_CONCRETE),
                ):
                    self._world_set_tile(int(wheel_x), int(driver_y), int(self.T_STEER))
                    fixed.add((int(wheel_x), int(driver_y)))

            # Dash/console: keep it at the very front (passenger side) so the
            # cockpit reads as "seats facing the front window".
            self._rv_world_dash_tile = None
            dash_tx, dash_ty = int(wheel_x), int(pass_y)
            if (int(dash_tx), int(dash_ty)) not in (
                (int(exit_tx), int(exit_ty)),
                (int(seat_x), int(driver_y)),
                (int(seat_x), int(pass_y)),
                (int(wheel_x), int(driver_y)),
            ):
                if int(self.world.peek_tile(int(dash_tx), int(dash_ty))) in (
                    int(self.T_FLOOR),
                    int(self.T_BOARDWALK),
                    int(self.T_CONCRETE),
                ):
                    self._world_set_tile(int(dash_tx), int(dash_ty), int(self.T_TABLE))
                    fixed.add((int(dash_tx), int(dash_ty)))
                    self._rv_world_dash_tile = (int(dash_tx), int(dash_ty))
            self._rv_world_fixed_furniture = set(fixed)
        except Exception:
            self._rv_world_driver_seat_tile = None
            self._rv_world_dash_tile = None
            self._rv_world_fixed_furniture = set()

        return True

    def _rv_world_try_drive_from_seat(self) -> bool:
        if not bool(getattr(self, "rv_world_interior", False)):
            return False
        seat = getattr(self, "_rv_world_driver_seat_tile", None)
        if not (isinstance(seat, tuple) and len(seat) == 2):
            # Fallback: if the seat marker is missing for any reason, still allow driving.
            return bool(self._rv_world_try_drive_from_anywhere())
        tx, ty = self._player_tile()
        sx, sy = int(seat[0]), int(seat[1])
        if abs(int(tx) - int(sx)) > 1 or abs(int(ty) - int(sy)) > 1:
            self._set_hint("到驾驶座旁按F开车", seconds=1.2)
            return True
        if int(self.inventory.count("key_rv")) <= 0:
            self._set_hint("需要车钥匙", seconds=1.1)
            return True

        # Teardown interior tiles but keep the player on the RV so driving starts immediately.
        self._clear_player_pose()
        self.rv_world_interior = False
        self.player.vel.update(0, 0)

        restore = getattr(self, "_rv_world_int_restore_tiles", None)
        if isinstance(restore, dict):
            for (rtx, rty), tid in list(restore.items()):
                try:
                    self._world_set_tile(int(rtx), int(rty), int(tid))
                except Exception:
                    pass
        self._rv_world_int_restore_tiles = None
        self._rv_world_int_active_key = None
        self._rv_world_int_exit_tile = None
        self._rv_world_return_pos = None

        self.mount = "rv"
        self.rv.vel.update(0, 0)
        self.rv.speed = 0.0
        self.player.pos.update(self.rv.pos)
        self.player.vel.update(0, 0)
        self._set_hint("开始驾驶", seconds=0.9)
        return True

    def _rv_world_try_drive_from_anywhere(self) -> bool:
        if not bool(getattr(self, "rv_world_interior", False)):
            return False
        if int(self.inventory.count("key_rv")) <= 0:
            self._set_hint("需要车钥匙", seconds=1.1)
            return True

        # Teardown interior tiles but keep the player on the RV so driving starts immediately.
        self._clear_player_pose()
        self.rv_world_interior = False
        self.player.vel.update(0, 0)

        restore = getattr(self, "_rv_world_int_restore_tiles", None)
        if isinstance(restore, dict):
            for (rtx, rty), tid in list(restore.items()):
                try:
                    self._world_set_tile(int(rtx), int(rty), int(tid))
                except Exception:
                    pass
        self._rv_world_int_restore_tiles = None
        self._rv_world_int_active_key = None
        self._rv_world_int_exit_tile = None
        self._rv_world_return_pos = None

        self.mount = "rv"
        self.rv.vel.update(0, 0)
        self.rv.speed = 0.0
        self.player.pos.update(self.rv.pos)
        self.player.vel.update(0, 0)
        self._set_hint("开始驾驶", seconds=0.9)
        return True

    def _rv_world_interior_toggle(self) -> None:
        if bool(getattr(self, "rv_world_interior", False)):
            self._rv_world_interior_exit()
            return
        if str(getattr(self.rv, "model_id", "rv")) != "rv":
            self._set_hint("只有房车能进内部", seconds=1.1)
            return
        if not self._can_access_rv():
            self._set_hint("靠近房车再按H", seconds=1.2)
            return
        if self.mount == "rv" and abs(float(getattr(self.rv, "speed", 0.0))) > 1.0:
            self._set_hint("先停好车再进去", seconds=1.2)
            return
        self._rv_world_interior_enter()

    def _rv_world_interior_enter(self) -> None:
        if str(getattr(self.rv, "model_id", "rv")) != "rv":
            self._set_hint("只有房车能进内部", seconds=1.1)
            return
        self.inv_open = False
        self.world_map_open = False
        self._gallery_open = False
        self.rv_ui_open = False
        self._clear_player_pose()
        self.player.vel.update(0, 0)
        self.player.walk_phase *= 0.85

        # Remember where to return when leaving the RV interior.
        # If we entered from driving mode, the player is at the RV center (inside its collider),
        # so pick a safe "outside the RV" return position.
        was_driving = getattr(self, "mount", None) == "rv"
        ret_pos = pygame.Vector2(self.player.pos)
        if was_driving:
            try:
                vehicle_pos = pygame.Vector2(self.rv.pos)
                vw, vh = float(getattr(self.rv, "w", 0)), float(getattr(self.rv, "h", 0))
                ph = float(max(int(self.player.w), int(getattr(self.player, "collider_h", self.player.h)))) / 2.0
                heading = float(getattr(self.rv, "heading", 0.0))
                fwd = pygame.Vector2(math.cos(float(heading)), math.sin(float(heading)))
                if fwd.length_squared() < 0.001:
                    fwd = pygame.Vector2(1, 0)
                fwd = fwd.normalize()
                right = pygame.Vector2(-float(fwd.y), float(fwd.x))
                side_margin = float(vh) / 2.0 + float(ph) + 8.0
                fwd_margin = float(vw) / 2.0 + float(ph) + 8.0
                candidates = [
                    right * float(side_margin),
                    -right * float(side_margin),
                    fwd * float(fwd_margin),
                    -fwd * float(fwd_margin),
                    pygame.Vector2(float(vw) / 2.0 + float(ph) + 10.0, 0),
                    pygame.Vector2(-(float(vw) / 2.0 + float(ph) + 10.0), 0),
                    pygame.Vector2(0, float(vh) / 2.0 + float(ph) + 10.0),
                    pygame.Vector2(0, -(float(vh) / 2.0 + float(ph) + 10.0)),
                ]
                # Make the RV solid for collision checks.
                self.mount = None
                ignore_rect: pygame.Rect | None = None
                try:
                    ignore_rect = self._rv_collider_rect_at(vehicle_pos)
                except Exception:
                    ignore_rect = None

                def path_clear(dst: pygame.Vector2) -> bool:
                    try:
                        a = pygame.Vector2(vehicle_pos)
                        b = pygame.Vector2(dst)
                        d = b - a
                        dist = float(d.length())
                        if dist <= 0.5:
                            return True
                        step_len = max(1.0, float(self.TILE_SIZE) / 4.0)
                        steps = int(clamp(int(math.ceil(dist / step_len)), 1, 80))
                        for i in range(1, int(steps) + 1):
                            t = float(i) / float(steps)
                            p2 = a + d * t
                            hits = self._collide_rect_world(self.player.rect_at(p2))
                            if not hits:
                                continue
                            for hh in hits:
                                if ignore_rect is not None and hh == ignore_rect:
                                    continue
                                return False
                        return True
                    except Exception:
                        return False

                for off in candidates:
                    p = vehicle_pos + off
                    if not self._collide_rect_world(self.player.rect_at(p)) and path_clear(p):
                        ret_pos = pygame.Vector2(p)
                        break
            except Exception:
                pass

        if was_driving:
            # If we couldn't find a safe "outside" spot, don't enter the interior.
            # Otherwise the player can end up clipped into walls/buildings when exiting.
            try:
                vehicle_pos = pygame.Vector2(self.rv.pos)
                if (pygame.Vector2(ret_pos) - vehicle_pos).length_squared() <= 0.75:
                    self.mount = "rv"
                    self.player.pos.update(self.rv.pos)
                    self._set_hint("No space to leave RV here", seconds=1.2)
                    return
            except Exception:
                pass

        self._rv_world_return_pos = pygame.Vector2(ret_pos)
        self.mount = None
        self.rv.vel.update(0, 0)
        self.bike.vel.update(0, 0)

        if not self._ensure_rv_world_interior_built():
            # Keep the detailed reason set by _ensure_rv_world_interior_built().
            if not str(getattr(self, "hint_text", "")).strip():
                self._set_hint("房车内部生成失败", seconds=1.2)
            return

        ex = getattr(self, "_rv_world_int_exit_tile", None)
        spawn: tuple[int, int] | None = None
        if isinstance(ex, tuple) and len(ex) == 2:
            exx, exy = int(ex[0]), int(ex[1])
            for tx, ty in (
                (exx, exy - 1),
                (exx - 1, exy - 1),
                (exx + 1, exy - 1),
                (exx, exy),
            ):
                if not bool(self._tile_solid(int(self.world.peek_tile(int(tx), int(ty), default=int(self.T_WALL))))):
                    spawn = (int(tx), int(ty))
                    break
        if spawn is None:
            spawn = self._player_tile()

        spawn_tx, spawn_ty = spawn
        self.player.pos.update((float(spawn_tx) + 0.5) * float(self.TILE_SIZE), (float(spawn_ty) + 0.5) * float(self.TILE_SIZE))
        self.rv_world_interior = True
        self._set_hint("房车驾驶舱：E互动 / F开车 / H退出", seconds=1.4)

    def _rv_world_interior_exit(self) -> None:
        if not bool(getattr(self, "rv_world_interior", False)):
            return
        self._clear_player_pose()
        self.rv_world_interior = False
        self.player.vel.update(0, 0)

        # Restore the outside world tiles we overwrote.
        restore = getattr(self, "_rv_world_int_restore_tiles", None)
        if isinstance(restore, dict):
            for (tx, ty), tid in list(restore.items()):
                try:
                    self._world_set_tile(int(tx), int(ty), int(tid))
                except Exception:
                    pass
        self._rv_world_int_restore_tiles = None
        self._rv_world_int_active_key = None
        self._rv_world_int_exit_tile = None

        ret = getattr(self, "_rv_world_return_pos", None)
        if isinstance(ret, pygame.Vector2):
            self.player.pos.update(ret)
        self._rv_world_return_pos = None
        self._set_hint("离开房车", seconds=0.9)

    def _try_exit_rv_world_interior(self) -> bool:
        if not bool(getattr(self, "rv_world_interior", False)):
            return False
        ex = getattr(self, "_rv_world_int_exit_tile", None)
        if not (isinstance(ex, tuple) and len(ex) == 2):
            return False
        tx, ty = self._player_tile()
        if abs(int(tx) - int(ex[0])) <= 1 and abs(int(ty) - int(ex[1])) <= 1:
            self._rv_world_interior_exit()
            return True
        return False

    def _sch_int_set_layout(self, layout: list[str]) -> None:
        self.sch_layout = [str(r) for r in layout]

    def _sch_int_find(self, ch: str, *, layout: list[str] | None = None) -> tuple[int, int] | None:
        ch = str(ch)[:1]
        rows = self.sch_layout if layout is None else layout
        for y, row in enumerate(rows):
            x = str(row).find(ch)
            if x >= 0:
                return int(x), int(y)
        return None

    def _sch_int_char_at(self, x: int, y: int) -> str:
        x = int(x)
        y = int(y)
        if not (0 <= x < int(self._SCH_INT_W) and 0 <= y < int(self._SCH_INT_H)):
            return "W"
        row = self.sch_layout[y] if 0 <= y < len(self.sch_layout) else ""
        if 0 <= x < len(row):
            return row[x]
        return "W"

    def _sch_int_solid_tile(self, ch: str) -> bool:
        ch = str(ch)[:1]
        return ch not in (".", "D", "E", "^", "v")

    def _sch_int_move_box(self, pos: pygame.Vector2, vel: pygame.Vector2, dt: float, *, w: int, h: int) -> pygame.Vector2:
        tile = int(self._SCH_INT_TILE_SIZE)
        rect = pygame.Rect(int(round(pos.x - w / 2)), int(round(pos.y - h / 2)), int(w), int(h))
        dx = float(vel.x * dt)
        dy = float(vel.y * dt)

        def collide(r: pygame.Rect) -> list[pygame.Rect]:
            left = int(math.floor(r.left / tile))
            right = int(math.floor((r.right - 1) / tile))
            top = int(math.floor(r.top / tile))
            bottom = int(math.floor((r.bottom - 1) / tile))
            hits: list[pygame.Rect] = []
            for ty in range(top, bottom + 1):
                for tx in range(left, right + 1):
                    ch = self._sch_int_char_at(tx, ty)
                    if not self._sch_int_solid_tile(ch):
                        continue
                    tr = pygame.Rect(tx * tile, ty * tile, tile, tile)
                    if r.colliderect(tr):
                        hits.append(tr)
            return hits

        if dx != 0.0:
            rect.x += int(round(dx))
            for hit in collide(rect):
                if dx > 0:
                    rect.right = hit.left
                else:
                    rect.left = hit.right

        if dy != 0.0:
            rect.y += int(round(dy))
            for hit in collide(rect):
                if dy > 0:
                    rect.bottom = hit.top
                else:
                    rect.top = hit.bottom

        pad = 3
        half_w = float(w) / 2.0
        half_h = float(h) / 2.0
        min_x = tile + half_w + pad
        min_y = tile + half_h + pad
        max_x = int(self._SCH_INT_W) * tile - tile - half_w - pad
        max_y = int(self._SCH_INT_H) * tile - tile - half_h - pad
        rect.centerx = int(clamp(rect.centerx, min_x, max_x))
        rect.centery = int(clamp(rect.centery, min_y, max_y))

        return pygame.Vector2(rect.centerx, rect.centery)

    def _sch_int_player_tile(self) -> tuple[int, int]:
        tile = int(self._SCH_INT_TILE_SIZE)
        tx = int(math.floor(float(self.sch_int_pos.x) / tile))
        ty = int(math.floor(float(self.sch_int_pos.y) / tile))
        return tx, ty

    def _sch_set_floor(self, floor: int, *, spawn_at: str = "elevator") -> None:
        max_f = int(max(1, int(getattr(self, "sch_max_floors", int(self._SCH_INT_MAX_FLOORS_DEFAULT)))))
        floor = int(clamp(int(floor), 1, max_f))
        self.sch_floor = int(floor)
        if floor <= 1:
            self._sch_int_set_layout(self._SCH_INT_LOBBY_LAYOUT)
        else:
            self._sch_int_set_layout(self._SCH_INT_FLOOR_LAYOUT)

        tile = int(self._SCH_INT_TILE_SIZE)
        target = "E"
        if spawn_at == "stairs_up":
            target = "^"
        elif spawn_at == "stairs_down":
            target = "v"
        elif spawn_at == "door_inside":
            target = "D"

        pt = self._sch_int_find(target)
        if pt is None:
            self.sch_int_pos = pygame.Vector2((self._SCH_INT_W / 2.0) * tile, (self._SCH_INT_H / 2.0) * tile)
        else:
            sx, sy = pt
            if spawn_at == "door_inside":
                spawn = (sx - 1, sy) if sx >= int(self._SCH_INT_W) - 1 else (sx + 1, sy)
                px, py = int(spawn[0]), int(spawn[1])
                if self._sch_int_solid_tile(self._sch_int_char_at(px, py)):
                    px, py = int(sx), int(sy)
                self.sch_int_pos = pygame.Vector2((px + 0.5) * tile, (py + 0.5) * tile)
            else:
                self.sch_int_pos = pygame.Vector2((sx + 0.5) * tile, (sy + 0.5) * tile)
        self.sch_int_vel = pygame.Vector2(0, 0)
        self.sch_int_facing = pygame.Vector2(0, 1)
        self.sch_int_walk_phase = 0.0

    def _sch_elevator_open(self) -> None:
        if not getattr(self, "sch_interior", False):
            return
        max_f = int(max(1, int(getattr(self, "sch_max_floors", int(self._SCH_INT_MAX_FLOORS_DEFAULT)))))
        options = list(range(max_f, 0, -1))
        self.sch_elevator_options = options
        cur = int(getattr(self, "sch_floor", 1))
        try:
            self.sch_elevator_sel = int(options.index(cur))
        except ValueError:
            self.sch_elevator_sel = 0
        self.sch_elevator_input = ""
        self.sch_elevator_ui_open = True
        self._set_hint("学校电梯：方向键选择 | PgUp/PgDn翻页 | 数字直达 | Enter确认", seconds=1.8)

    def _handle_sch_elevator_ui_wheel(self, event: pygame.event.Event) -> None:
        if not getattr(self, "sch_elevator_ui_open", False):
            return
        options: list[int] = list(getattr(self, "sch_elevator_options", []))
        if not options:
            options = [1]
            self.sch_elevator_options = options
        n = len(options)
        cols = max(1, int(getattr(self, "sch_elevator_cols", 4)))
        rows_per_page = 4
        page_size = max(1, cols * rows_per_page)
        step = cols
        if pygame.key.get_mods() & pygame.KMOD_SHIFT:
            step = page_size
        dy = int(getattr(event, "y", 0))
        if dy == 0:
            return
        sel = int(getattr(self, "sch_elevator_sel", 0)) % n
        sel = (sel - step) % n if dy > 0 else (sel + step) % n
        self.sch_elevator_sel = int(sel)
        self.sch_elevator_input = ""

    def _handle_sch_elevator_ui_mouse(self, event: pygame.event.Event) -> None:
        if not getattr(self, "sch_elevator_ui_open", False):
            return

        et = int(getattr(event, "type", 0))
        button = int(getattr(event, "button", 0))
        if et == int(pygame.MOUSEBUTTONDOWN) and button == 3:
            self.sch_elevator_ui_open = False
            self.sch_elevator_input = ""
            return

        if et not in (int(pygame.MOUSEMOTION), int(pygame.MOUSEBUTTONDOWN)):
            return
        if et == int(pygame.MOUSEBUTTONDOWN) and button != 1:
            return

        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return
        mx, my = int(internal[0]), int(internal[1])

        options: list[int] = list(getattr(self, "sch_elevator_options", []))
        if not options:
            options = [1]
            self.sch_elevator_options = options
        cols = max(1, int(getattr(self, "sch_elevator_cols", 4)))
        rows_per_page = 4
        n = len(options)
        page_size = max(1, cols * rows_per_page)
        sel_i = int(getattr(self, "sch_elevator_sel", 0)) % max(1, n)
        page = int(sel_i // page_size)
        start = int(page * page_size)
        end = int(min(int(n), int(start + page_size)))
        page_opts = list(options[start:end])
        rows = int(max(1, int(math.ceil(float(len(page_opts)) / float(cols)))))

        btn_w = 56
        btn_h = 28
        gap = 8
        grid_w = cols * btn_w + (cols - 1) * gap
        grid_h = rows * btn_h + (rows - 1) * gap
        panel = pygame.Rect(0, 0, grid_w + 40, grid_h + 98)
        panel.center = (INTERNAL_W // 2, INTERNAL_H // 2)

        x0 = panel.centerx - grid_w // 2
        y0 = panel.top + 66
        hit_i: int | None = None
        hit_floor: int | None = None
        for local_i, f in enumerate(page_opts):
            r = int(local_i) // cols
            c = int(local_i) % cols
            x = x0 + c * (btn_w + gap)
            y = y0 + r * (btn_h + gap)
            br = pygame.Rect(x, y, btn_w, btn_h)
            if br.collidepoint(mx, my):
                hit_i = int(start) + int(local_i)
                hit_floor = int(f)
                break

        if hit_i is None or hit_floor is None:
            return

        self.sch_elevator_sel = int(hit_i)
        self.sch_elevator_input = ""
        if et == int(pygame.MOUSEBUTTONDOWN) and button == 1:
            self.sch_elevator_ui_open = False
            self._sch_set_floor(int(hit_floor), spawn_at="elevator")

    def _handle_sch_elevator_ui_key(self, key: int) -> None:
        if not getattr(self, "sch_elevator_ui_open", False):
            return
        options: list[int] = list(getattr(self, "sch_elevator_options", []))
        if not options:
            options = [1]
            self.sch_elevator_options = options
        n = len(options)
        cols = max(1, int(getattr(self, "sch_elevator_cols", 4)))
        rows_per_page = 4
        page_size = max(1, cols * rows_per_page)
        sel = int(getattr(self, "sch_elevator_sel", 0)) % n

        digit = self._key_digit(int(key))
        if digit is not None:
            cur = str(getattr(self, "sch_elevator_input", ""))
            if len(cur) < 3:
                self.sch_elevator_input = cur + digit
            return
        if key in (pygame.K_BACKSPACE, pygame.K_DELETE):
            cur = str(getattr(self, "sch_elevator_input", ""))
            self.sch_elevator_input = cur[:-1]
            return

        if key in (pygame.K_ESCAPE,):
            self.sch_elevator_ui_open = False
            self.sch_elevator_input = ""
            return
        if key in (pygame.K_RETURN, pygame.K_SPACE, pygame.K_e):
            self.sch_elevator_ui_open = False
            typed = str(getattr(self, "sch_elevator_input", "")).strip()
            self.sch_elevator_input = ""
            if typed:
                try:
                    target = int(typed)
                except ValueError:
                    target = int(options[sel])
                self._sch_set_floor(int(target), spawn_at="elevator")
            else:
                self._sch_set_floor(int(options[sel]), spawn_at="elevator")
            return

        if key in (pygame.K_PAGEUP,):
            self.sch_elevator_sel = int((sel - page_size) % n)
            self.sch_elevator_input = ""
            return
        if key in (pygame.K_PAGEDOWN,):
            self.sch_elevator_sel = int((sel + page_size) % n)
            self.sch_elevator_input = ""
            return
        if key in (pygame.K_HOME,):
            self.sch_elevator_sel = 0
            self.sch_elevator_input = ""
            return
        if key in (pygame.K_END,):
            self.sch_elevator_sel = int(n - 1)
            self.sch_elevator_input = ""
            return

        if key in (pygame.K_LEFT, pygame.K_a):
            self.sch_elevator_sel = int((sel - 1) % n)
        elif key in (pygame.K_RIGHT, pygame.K_d):
            self.sch_elevator_sel = int((sel + 1) % n)
        elif key in (pygame.K_UP, pygame.K_w):
            self.sch_elevator_sel = int((sel - cols) % n)
        elif key in (pygame.K_DOWN, pygame.K_s):
            self.sch_elevator_sel = int((sel + cols) % n)
        self.sch_elevator_input = ""

    def _sch_interior_enter(self, sb: HardcoreSurvivalState._SpecialBuilding) -> None:
        self.inv_open = False
        self.rv_ui_open = False
        self.hr_elevator_ui_open = False
        self._gallery_open = False
        self.sch_interior = True
        self.sch_elevator_ui_open = False
        self.mount = None
        self.player.vel.update(0, 0)
        self.player.walk_phase *= 0.85
        self.rv.vel.update(0, 0)
        self.bike.vel.update(0, 0)

        self.sch_building = sb
        self.sch_max_floors = int(getattr(sb, "floors", 0) or int(self._SCH_INT_MAX_FLOORS_DEFAULT))
        if self.sch_max_floors <= 0:
            self.sch_max_floors = int(self._SCH_INT_MAX_FLOORS_DEFAULT)
        self.sch_world_return = pygame.Vector2(self.player.pos)
        self._sch_set_floor(1, spawn_at="door_inside")
        self._set_hint("学校：E互动楼梯/电梯 | Esc退出", seconds=1.6)

    def _sch_interior_exit(self) -> None:
        if not getattr(self, "sch_interior", False):
            return
        self.sch_interior = False
        self.sch_elevator_ui_open = False
        self.sch_building = None
        self.sch_floor = 1
        self._sch_int_set_layout(self._SCH_INT_LOBBY_LAYOUT)
        self.player.pos.update(self.sch_world_return)
        self._set_hint("离开学校", seconds=1.0)

    def _sch_interior_interact(self) -> None:
        if not getattr(self, "sch_interior", False):
            return
        tx, ty = self._sch_int_player_tile()
        candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
        chosen: tuple[int, int, str] | None = None
        for cx, cy in candidates:
            ch = self._sch_int_char_at(cx, cy)
            if ch in ("D", "E", "^", "v"):
                chosen = (int(cx), int(cy), str(ch))
                break
        if chosen is None:
            self._set_hint("这里没有可互动", seconds=1.0)
            return
        _cx, _cy, ch = chosen
        if ch == "E":
            self._sch_elevator_open()
            return
        if ch == "D":
            self._sch_interior_exit()
            return

        floor = int(getattr(self, "sch_floor", 1))
        max_f = int(max(1, int(getattr(self, "sch_max_floors", int(self._SCH_INT_MAX_FLOORS_DEFAULT)))))
        if ch == "^":
            if floor >= max_f:
                self._set_hint("已经是顶层", seconds=1.2)
                return
            self._sch_set_floor(int(floor + 1), spawn_at="stairs_down")
            self._set_hint(f"上楼：{int(floor + 1)}F", seconds=0.9)
            return
        if ch == "v":
            if floor <= 1:
                self._set_hint("已经是一楼", seconds=1.2)
                return
            self._sch_set_floor(int(floor - 1), spawn_at="stairs_up")   
            self._set_hint(f"下楼：{int(floor - 1)}F", seconds=0.9)     
            return
        self._set_hint("这里没有可互动", seconds=1.0)

    def _house_int_set_layout(self, layout: list[str]) -> None:
        self.house_layout = [str(r) for r in layout]

    def _house_int_find(self, ch: str, *, layout: list[str] | None = None) -> tuple[int, int] | None:
        ch = str(ch)[:1]
        rows = self.house_layout if layout is None else layout
        for y, row in enumerate(rows):
            x = str(row).find(ch)
            if x >= 0:
                return int(x), int(y)
        return None

    def _house_int_char_at(self, x: int, y: int) -> str:
        x = int(x)
        y = int(y)
        if not (0 <= x < int(self._HOUSE_INT_W) and 0 <= y < int(self._HOUSE_INT_H)):
            return "W"
        row = self.house_layout[y] if 0 <= y < len(self.house_layout) else ""
        if 0 <= x < len(row):
            return row[x]
        return "W"

    def _house_int_solid_tile(self, ch: str) -> bool:
        ch = str(ch)[:1]
        return ch not in (".", "D", "^", "v", ",", "d")

    def _house_int_move_box(self, pos: pygame.Vector2, vel: pygame.Vector2, dt: float, *, w: int, h: int) -> pygame.Vector2:
        tile = int(self._HOUSE_INT_TILE_SIZE)
        rect = pygame.Rect(int(round(pos.x - w / 2)), int(round(pos.y - h / 2)), int(w), int(h))
        dx = float(vel.x * dt)
        dy = float(vel.y * dt)

        def collide(r: pygame.Rect) -> list[pygame.Rect]:
            left = int(math.floor(r.left / tile))
            right = int(math.floor((r.right - 1) / tile))
            top = int(math.floor(r.top / tile))
            bottom = int(math.floor((r.bottom - 1) / tile))
            hits: list[pygame.Rect] = []
            for ty in range(top, bottom + 1):
                for tx in range(left, right + 1):
                    ch = self._house_int_char_at(tx, ty)
                    if not self._house_int_solid_tile(ch):
                        continue
                    tr = pygame.Rect(tx * tile, ty * tile, tile, tile)
                    if r.colliderect(tr):
                        hits.append(tr)
            return hits

        if dx != 0.0:
            rect.x += int(round(dx))
            for hit in collide(rect):
                if dx > 0:
                    rect.right = hit.left
                else:
                    rect.left = hit.right

        if dy != 0.0:
            rect.y += int(round(dy))
            for hit in collide(rect):
                if dy > 0:
                    rect.bottom = hit.top
                else:
                    rect.top = hit.bottom

        pad = 3
        half_w = float(w) / 2.0
        half_h = float(h) / 2.0
        min_x = tile + half_w + pad
        min_y = tile + half_h + pad
        max_x = int(self._HOUSE_INT_W) * tile - tile - half_w - pad
        max_y = int(self._HOUSE_INT_H) * tile - tile - half_h - pad
        rect.centerx = int(clamp(rect.centerx, min_x, max_x))
        rect.centery = int(clamp(rect.centery, min_y, max_y))

        return pygame.Vector2(rect.centerx, rect.centery)

    def _house_int_player_tile(self) -> tuple[int, int]:
        tile = int(self._HOUSE_INT_TILE_SIZE)
        tx = int(math.floor(float(self.house_int_pos.x) / tile))
        ty = int(math.floor(float(self.house_int_pos.y) / tile))
        return tx, ty

    def _house_set_floor(self, floor: int, *, spawn_at: str = "door_inside") -> None:
        max_f = int(max(1, int(getattr(self, "house_max_floors", int(self._HOUSE_INT_MAX_FLOORS_DEFAULT)))))
        floor = int(clamp(int(floor), 1, max_f))
        self.house_floor = int(floor)
        if floor <= 1:
            self._house_int_set_layout(self._HOUSE_INT_F1_LAYOUT)
        else:
            self._house_int_set_layout(self._HOUSE_INT_FLOOR_LAYOUT)

        tile = int(self._HOUSE_INT_TILE_SIZE)
        target = "^"
        if spawn_at == "stairs_up":
            target = "^"
        elif spawn_at == "stairs_down":
            target = "v"
        elif spawn_at == "door_inside":
            target = "D"

        pt = self._house_int_find(target)
        if pt is None:
            self.house_int_pos = pygame.Vector2((self._HOUSE_INT_W / 2.0) * tile, (self._HOUSE_INT_H / 2.0) * tile)
        else:
            sx, sy = pt
            if spawn_at == "door_inside":
                spawn = (sx - 1, sy) if sx >= int(self._HOUSE_INT_W) - 1 else (sx + 1, sy)
                px, py = int(spawn[0]), int(spawn[1])
                if self._house_int_solid_tile(self._house_int_char_at(px, py)):
                    px, py = int(sx), int(sy)
                self.house_int_pos = pygame.Vector2((px + 0.5) * tile, (py + 0.5) * tile)
            else:
                self.house_int_pos = pygame.Vector2((sx + 0.5) * tile, (sy + 0.5) * tile)

        self.house_int_vel = pygame.Vector2(0, 0)
        self.house_int_facing = pygame.Vector2(0, 1)
        self.house_int_walk_phase = 0.0

    def _house_interior_enter(self, sb: HardcoreSurvivalState._SpecialBuilding) -> None:
        self.inv_open = False
        self.rv_ui_open = False
        self.home_ui_open = False
        self.hr_elevator_ui_open = False
        self.sch_elevator_ui_open = False
        self._gallery_open = False
        self.house_interior = True
        self.mount = None
        self.player.vel.update(0, 0)
        self.player.walk_phase *= 0.85
        self.rv.vel.update(0, 0)
        self.bike.vel.update(0, 0)

        self.house_building = sb
        self.house_max_floors = int(getattr(sb, "floors", 0) or int(self._HOUSE_INT_MAX_FLOORS_DEFAULT))
        if self.house_max_floors <= 0:
            self.house_max_floors = int(self._HOUSE_INT_MAX_FLOORS_DEFAULT)
        self.house_world_return = pygame.Vector2(self.player.pos)
        self._house_set_floor(1, spawn_at="door_inside")
        self._set_hint("住宅：E上下楼 | Esc退出", seconds=1.6)

    def _house_interior_exit(self) -> None:
        if not getattr(self, "house_interior", False):
            return
        self._clear_player_pose()
        self.house_interior = False
        self.house_building = None
        self.house_floor = 1
        self._house_int_set_layout(self._HOUSE_INT_F1_LAYOUT)
        self.player.pos.update(self.house_world_return)
        self._set_hint("离开住宅", seconds=1.0)

    def _house_interior_interact(self) -> None:
        if not getattr(self, "house_interior", False):
            return
        tx, ty = self._house_int_player_tile()
        candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
        chosen: tuple[int, int, str] | None = None
        for cx, cy in candidates:
            ch = self._house_int_char_at(cx, cy)
            if ch in ("D", "^", "v"):
                chosen = (int(cx), int(cy), str(ch))
                break
        if chosen is None:
            self._set_hint("这里没有可互动", seconds=1.0)
            return
        _cx, _cy, ch = chosen

        floor = int(getattr(self, "house_floor", 1))
        max_f = int(max(1, int(getattr(self, "house_max_floors", int(self._HOUSE_INT_MAX_FLOORS_DEFAULT)))))

        if ch == "D":
            if floor > 1:
                self._set_hint("请先下楼再出去", seconds=1.2)
                return
            self._house_interior_exit()
            return

        if ch == "^":
            if floor >= max_f:
                self._set_hint("已经是顶层", seconds=1.2)
                return
            self._house_set_floor(int(floor + 1), spawn_at="stairs_down")
            self._set_hint(f"上楼：{int(floor + 1)}F", seconds=0.9)
            return

        if ch == "v":
            if floor <= 1:
                self._set_hint("已经是一楼", seconds=1.2)
                return
            self._house_set_floor(int(floor - 1), spawn_at="stairs_up")
            self._set_hint(f"下楼：{int(floor - 1)}F", seconds=0.9)
            return

        self._set_hint("这里没有可互动", seconds=1.0)

    def _hr_int_set_layout(self, layout: list[str]) -> None:
        self.hr_layout = [str(r) for r in layout]

    def _hr_int_find(self, ch: str, *, layout: list[str] | None = None) -> tuple[int, int] | None:
        ch = str(ch)[:1]
        rows = self.hr_layout if layout is None else layout
        for y, row in enumerate(rows):
            x = str(row).find(ch)
            if x >= 0:
                return int(x), int(y)
        return None

    def _hr_int_char_at(self, x: int, y: int) -> str:
        x = int(x)
        y = int(y)
        if not (0 <= x < int(self._HR_INT_W) and 0 <= y < int(self._HR_INT_H)):
            return "W"
        row = self.hr_layout[y] if 0 <= y < len(self.hr_layout) else ""
        if 0 <= x < len(row):
            return row[x]
        return "W"

    def _hr_int_solid_tile(self, ch: str) -> bool:
        ch = str(ch)[:1]
        return ch not in (".", ",", "D", "E", "L", "^", "v")

    def _hr_int_move_box(self, pos: pygame.Vector2, vel: pygame.Vector2, dt: float, *, w: int, h: int) -> pygame.Vector2:
        # Match the collision/slide behavior of other interior scenes (house/school/RV).
        tile = int(self._HR_INT_TILE_SIZE)
        rect = pygame.Rect(int(round(pos.x - w / 2)), int(round(pos.y - h / 2)), int(w), int(h))
        dx = float(vel.x * dt)
        dy = float(vel.y * dt)

        def collide(r: pygame.Rect) -> list[pygame.Rect]:
            left = int(math.floor(r.left / tile))
            right = int(math.floor((r.right - 1) / tile))
            top = int(math.floor(r.top / tile))
            bottom = int(math.floor((r.bottom - 1) / tile))
            hits: list[pygame.Rect] = []
            for ty in range(top, bottom + 1):
                for tx in range(left, right + 1):
                    ch = self._hr_int_char_at(tx, ty)
                    if not self._hr_int_solid_tile(ch):
                        continue
                    tr = pygame.Rect(tx * tile, ty * tile, tile, tile)
                    if r.colliderect(tr):
                        hits.append(tr)
            return hits

        if dx != 0.0:
            rect.x += int(round(dx))
            for hit in collide(rect):
                if dx > 0:
                    rect.right = hit.left
                else:
                    rect.left = hit.right

        if dy != 0.0:
            rect.y += int(round(dy))
            for hit in collide(rect):
                if dy > 0:
                    rect.bottom = hit.top
                else:
                    rect.top = hit.bottom

        pad = 3
        half_w = float(w) / 2.0
        half_h = float(h) / 2.0
        min_x = tile + half_w + pad
        min_y = tile + half_h + pad
        max_x = int(self._HR_INT_W) * tile - tile - half_w - pad
        max_y = int(self._HR_INT_H) * tile - tile - half_h - pad
        rect.centerx = int(clamp(rect.centerx, min_x, max_x))
        rect.centery = int(clamp(rect.centery, min_y, max_y))

        return pygame.Vector2(rect.centerx, rect.centery)

    def _hr_int_player_tile(self) -> tuple[int, int]:
        tile = int(self._HR_INT_TILE_SIZE)
        tx = int(math.floor(float(self.hr_int_pos.x) / tile))
        ty = int(math.floor(float(self.hr_int_pos.y) / tile))
        return tx, ty

    def _hr_int_block_bounds(self, x: int, y: int, ch: str) -> tuple[int, int, int, int] | None:
        ch = str(ch)[:1]
        x = int(x)
        y = int(y)
        w = int(self._HR_INT_W)
        h = int(self._HR_INT_H)
        if not (0 <= x < w and 0 <= y < h):
            return None
        if str(self._hr_int_char_at(x, y))[:1] != ch:
            return None
        seen: set[tuple[int, int]] = set()
        stack = [(x, y)]
        cells: list[tuple[int, int]] = []
        while stack:
            cx, cy = stack.pop()
            cx = int(cx)
            cy = int(cy)
            if (cx, cy) in seen:
                continue
            if not (0 <= cx < w and 0 <= cy < h):
                continue
            if str(self._hr_int_char_at(cx, cy))[:1] != ch:
                continue
            seen.add((cx, cy))
            cells.append((cx, cy))
            stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
        if not cells:
            return None
        min_x = min(int(p[0]) for p in cells)
        max_x = max(int(p[0]) for p in cells)
        min_y = min(int(p[1]) for p in cells)
        max_y = max(int(p[1]) for p in cells)
        return (int(min_x), int(min_y), int(max_x), int(max_y))

    def _hr_edit_rebuild_blocks(self) -> None:
        if not getattr(self, "hr_interior", False):
            self.hr_edit_blocks = []
            return
        if str(getattr(self, "hr_mode", "lobby")) != "home":
            self.hr_edit_blocks = []
            return
        layout = getattr(self, "hr_layout", None)
        if not isinstance(layout, list):
            self.hr_edit_blocks = []
            return

        movable = {"B", "S", "F", "K", "T", "C", "P", "X", "L"}
        w = int(self._HR_INT_W)
        h = int(self._HR_INT_H)
        seen: set[tuple[int, int]] = set()
        blocks: list[tuple[str, list[tuple[int, int]]]] = []

        for y in range(h):
            for x in range(w):
                ch = str(self._hr_int_char_at(x, y))[:1]
                if ch not in movable:
                    continue
                if (x, y) in seen:
                    continue
                cells: list[tuple[int, int]] = []
                stack = [(int(x), int(y))]
                while stack:
                    cx, cy = stack.pop()
                    cx = int(cx)
                    cy = int(cy)
                    if (cx, cy) in seen:
                        continue
                    if not (0 <= cx < w and 0 <= cy < h):
                        continue
                    if str(self._hr_int_char_at(cx, cy))[:1] != ch:
                        continue
                    seen.add((cx, cy))
                    cells.append((cx, cy))
                    stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
                if cells:
                    blocks.append((ch, cells))

        def sort_key(b: tuple[str, list[tuple[int, int]]]) -> tuple:
            ch, cells = b
            miny = min(int(p[1]) for p in cells)
            minx = min(int(p[0]) for p in cells)
            return (ch, miny, minx, len(cells))

        blocks.sort(key=sort_key)
        self.hr_edit_blocks = blocks
        self.hr_edit_index = int(clamp(int(getattr(self, "hr_edit_index", 0)), 0, max(0, len(blocks) - 1)))

    def _hr_toggle_edit_mode(self) -> None:
        if not getattr(self, "hr_interior", False):
            return
        if str(getattr(self, "hr_mode", "lobby")) != "home":
            return
        home_room = str(getattr(self, "home_highrise_room", "")).strip()
        cur_room = str(getattr(self, "hr_current_room", "")).strip()
        if home_room and cur_room and cur_room != home_room:
            self._set_hint("只有自己家能摆放", seconds=1.1)
            return
        self.hr_edit_mode = not bool(getattr(self, "hr_edit_mode", False))
        self.hr_edit_dragging = False
        if self.hr_edit_mode:
            self._hr_edit_rebuild_blocks()
            if not getattr(self, "hr_edit_blocks", None):
                self.hr_edit_mode = False
                self._set_hint("没有可挪动的家具", seconds=1.0)
                return
            self.hr_edit_index = int(
                clamp(int(getattr(self, "hr_edit_index", 0)), 0, len(self.hr_edit_blocks) - 1)
            )
            self._set_hint("摆放模式：Tab 选中 / 方向键移动 / 左键拖拽 / R 退出", seconds=1.8)
        else:
            self._set_hint("退出摆放模式", seconds=1.0)

    def _hr_edit_cycle(self, delta: int = 1) -> None:
        blocks = getattr(self, "hr_edit_blocks", None)
        if not isinstance(blocks, list) or not blocks:
            return
        self.hr_edit_index = (int(getattr(self, "hr_edit_index", 0)) + int(delta)) % len(blocks)

    def _hr_edit_move(self, dx: int, dy: int) -> None:
        if not bool(getattr(self, "hr_edit_mode", False)):
            return
        if str(getattr(self, "hr_mode", "lobby")) != "home":
            return
        blocks = getattr(self, "hr_edit_blocks", None)
        if not isinstance(blocks, list) or not blocks:
            return
        idx = int(getattr(self, "hr_edit_index", 0)) % len(blocks)
        ch, cells = blocks[idx]
        w = int(self._HR_INT_W)
        h = int(self._HR_INT_H)
        dx = int(dx)
        dy = int(dy)
        if dx == 0 and dy == 0:
            return

        cell_set = set((int(x), int(y)) for x, y in cells)
        new_cells = [(int(x) + dx, int(y) + dy) for x, y in cell_set]

        for nx, ny in new_cells:
            if not (0 <= int(nx) < w and 0 <= int(ny) < h):
                return
            if (int(nx), int(ny)) in cell_set:
                continue
            dst = str(self._hr_int_char_at(nx, ny))[:1]
            if dst != ".":
                return

        rows = [list(str(r)) for r in getattr(self, "hr_layout", [])]
        if len(rows) < h:
            rows.extend([list("." * w) for _ in range(h - len(rows))])
        for oy in range(min(len(rows), h)):
            if len(rows[oy]) < w:
                rows[oy].extend(list("." * (w - len(rows[oy]))))

        for ox, oy in cell_set:
            if 0 <= int(oy) < h and 0 <= int(ox) < w:
                rows[int(oy)][int(ox)] = "."
        for nx, ny in new_cells:
            rows[int(ny)][int(nx)] = str(ch)[:1]

        self.hr_layout = ["".join(r[:w]) for r in rows[:h]]
        self.hr_home_layout = list(self.hr_layout)
        blocks[idx] = (str(ch)[:1], [(int(x), int(y)) for x, y in new_cells])

    def _hr_edit_handle_mouse(self, event: pygame.event.Event) -> bool:
        if not bool(getattr(self, "hr_edit_mode", False)):
            return False
        if not getattr(self, "hr_interior", False):
            return False
        if str(getattr(self, "hr_mode", "lobby")) != "home":
            return False
        if event.type not in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION):
            return False
        if not hasattr(event, "pos"):
            return False
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return False

        tile = int(self._HR_INT_TILE_SIZE)
        full_map_w = int(self._HR_INT_W) * tile
        full_map_h = int(self._HR_INT_H) * tile
        map_y0 = 38
        map_w = int(min(int(full_map_w), max(1, int(INTERNAL_W) - 20)))
        map_h = int(min(int(full_map_h), max(1, int(INTERNAL_H) - int(map_y0) - 10)))
        map_x0 = (INTERNAL_W - map_w) // 2
        map_rect = pygame.Rect(int(map_x0), int(map_y0), int(map_w), int(map_h))

        # Same camera math as the renderer (layout may exceed the viewport).
        cam = getattr(self, "_hr_int_draw_cam", None)
        if isinstance(cam, tuple) and len(cam) >= 2:
            cam_x, cam_y = int(cam[0]), int(cam[1])
        else:
            pose = str(getattr(self, "player_pose", "")).strip()
            pose_space = str(getattr(self, "player_pose_space", "")).strip()
            pose_anchor = getattr(self, "player_pose_anchor", None)
            use_pose = bool(pose and pose_space == "hr" and pose_anchor is not None)
            if use_pose:
                focus = pygame.Vector2(float(pose_anchor[0]), float(pose_anchor[1]))
            else:
                focus = pygame.Vector2(self.hr_int_pos)
            if int(full_map_w) <= int(map_w):
                cam_x = 0
            else:
                cam_x = int(clamp(float(focus.x) - float(map_w) / 2.0, 0.0, float(full_map_w - map_w)))
            if int(full_map_h) <= int(map_h):
                cam_y = 0
            else:
                cam_y = int(clamp(float(focus.y) - float(map_h) / 2.0, 0.0, float(full_map_h - map_h)))

        map_x = int(map_x0) - int(cam_x)
        map_y = int(map_y0) - int(cam_y)

        movable = {"B", "S", "F", "K", "T", "C", "P", "X"}

        if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
            if not map_rect.collidepoint(internal):
                return False
            ix = int((int(internal[0]) - int(map_x)) // max(1, int(tile)))
            iy = int((int(internal[1]) - int(map_y)) // max(1, int(tile)))
            ch = str(self._hr_int_char_at(ix, iy))[:1]
            if ch not in movable:
                return False
            blocks = getattr(self, "hr_edit_blocks", None)
            if not isinstance(blocks, list) or not blocks:
                self._hr_edit_rebuild_blocks()
                blocks = getattr(self, "hr_edit_blocks", None)
            if not isinstance(blocks, list) or not blocks:
                return False

            hit_i: int | None = None
            for i, (bch, cells) in enumerate(blocks):
                if str(bch)[:1] != ch:
                    continue
                for cx, cy in cells:
                    if int(cx) == int(ix) and int(cy) == int(iy):
                        hit_i = int(i)
                        break
                if hit_i is not None:
                    break
            if hit_i is None:
                return False

            self.hr_edit_index = int(hit_i)
            _bch, cells = blocks[hit_i]
            min_x = min(int(p[0]) for p in cells)
            min_y = min(int(p[1]) for p in cells)
            self.hr_edit_dragging = True
            self.hr_edit_drag_offset = (int(ix - min_x), int(iy - min_y))
            return True

        if event.type == pygame.MOUSEBUTTONUP and getattr(event, "button", 0) == 1:
            if bool(getattr(self, "hr_edit_dragging", False)):
                self.hr_edit_dragging = False
                return True
            return False

        if event.type == pygame.MOUSEMOTION:
            if not bool(getattr(self, "hr_edit_dragging", False)):
                return False
            if not map_rect.collidepoint(internal):
                return True
            ix = int((int(internal[0]) - int(map_x)) // max(1, int(tile)))
            iy = int((int(internal[1]) - int(map_y)) // max(1, int(tile)))
            off = getattr(self, "hr_edit_drag_offset", (0, 0))
            offx, offy = int(off[0]), int(off[1])
            target_min_x = int(ix - offx)
            target_min_y = int(iy - offy)

            blocks = getattr(self, "hr_edit_blocks", None)
            if not isinstance(blocks, list) or not blocks:
                return True
            idx = int(getattr(self, "hr_edit_index", 0)) % len(blocks)
            _ch, cells = blocks[idx]
            cur_min_x = min(int(p[0]) for p in cells)
            cur_min_y = min(int(p[1]) for p in cells)
            dx = int(target_min_x - cur_min_x)
            dy = int(target_min_y - cur_min_y)
            if dx != 0 or dy != 0:
                self._hr_edit_move(dx, dy)
            return True

        return False

    def _handle_hr_interior_ui_mouse(self, event: pygame.event.Event) -> bool:
        if not getattr(self, "hr_interior", False):
            return False
        if str(getattr(self, "hr_mode", "lobby")) != "home":
            return False
        if bool(getattr(self, "hr_edit_mode", False)):
            return False
        if event.type != pygame.MOUSEBUTTONDOWN or int(getattr(event, "button", 0)) != 1:
            return False
        if (
            bool(getattr(self, "inv_open", False))
            or bool(getattr(self, "home_ui_open", False))
            or bool(getattr(self, "hr_elevator_ui_open", False))
            or bool(getattr(self, "world_map_open", False))
        ):
            return False
        if not hasattr(event, "pos"):
            return False
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return False
        mx, my = int(internal[0]), int(internal[1])
        buttons = getattr(self, "_hr_int_ui_buttons", None)
        if not isinstance(buttons, list) or not buttons:
            return False
        for entry in list(buttons):
            if not isinstance(entry, tuple) or len(entry) < 3:
                continue
            action, room_id, rect = entry[0], entry[1], entry[2]
            payload = entry[3] if len(entry) >= 4 else None
            if not isinstance(rect, pygame.Rect):
                continue
            if not rect.collidepoint(mx, my):
                continue
            if str(action) == "toggle_lamp":
                self._hr_room_toggle_light(str(room_id))
                return True
            if str(action) == "hr_move":
                if not (isinstance(payload, tuple) and len(payload) == 2):
                    return True
                sel_tx, sel_ty = int(payload[0]), int(payload[1])
                if not bool(getattr(self, "hr_edit_mode", False)):
                    self._hr_toggle_edit_mode()
                if not bool(getattr(self, "hr_edit_mode", False)):
                    return True
                blocks = getattr(self, "hr_edit_blocks", None)
                if not isinstance(blocks, list) or not blocks:
                    return True
                for i, (_ch, cells) in enumerate(blocks):
                    for cx, cy in cells:
                        if int(cx) == int(sel_tx) and int(cy) == int(sel_ty):
                            self.hr_edit_index = int(i)
                            return True
                return True
        return False

    def _hr_make_hall_layout(self, floor: int) -> list[str]:
        doors = list(getattr(self, "_HR_INT_APT_DOORS", []))
        if not doors:
            return [str(r) for r in self._HR_INT_HALL_BASE]

        base = [str(r) for r in self._HR_INT_HALL_BASE]
        rows = [list(r) for r in base]

        # Mark the player's home door (green) on the home floor.
        home_floor = int(getattr(self, "hr_home_floor", -1))
        if int(floor) == int(home_floor):
            idx = int(getattr(self, "hr_home_door_index", 0)) % len(doors)
            hx, hy = doors[idx]
            if 0 <= int(hy) < len(rows) and 0 <= int(hx) < len(rows[int(hy)]):
                rows[int(hy)][int(hx)] = "H"

        # Mark some other unit doors as broken (enterable) so players can tell why it opens.
        states = getattr(self, "hr_apt_door_broken", None)
        if not isinstance(states, dict):
            states = {}
            self.hr_apt_door_broken = states
        sb = getattr(self, "hr_building", None)
        if isinstance(sb, HardcoreSurvivalState._SpecialBuilding):
            bkey = (int(sb.tx0), int(sb.ty0), int(sb.w), int(sb.h))
        else:
            bkey = (0, 0, 0, 0)
        seed_base = int(self.seed) ^ 0x6B8B4567
        for i, (dx, dy) in enumerate(doors):
            unit = int(i) + 1
            dx = int(dx)
            dy = int(dy)
            if not (0 <= dy < len(rows) and 0 <= dx < len(rows[dy])):
                continue
            if rows[dy][dx] == "H":
                continue
            door_key = (int(bkey[0]), int(bkey[1]), int(bkey[2]), int(bkey[3]), int(floor), int(unit))
            if door_key in states:
                broken = bool(states.get(door_key, False))
            else:
                hh = int(
                    self._hash2_u32(
                        int(bkey[0]) + int(floor) * 37 + int(unit) * 11,
                        int(bkey[1]) + int(floor) * 17 + int(unit) * 29,
                        int(seed_base),
                    )
                )
                broken = int(hh % 100) < 18
                states[door_key] = bool(broken)
            if broken and rows[dy][dx] == "A":
                rows[dy][dx] = "a"
        return ["".join(r) for r in rows]

    def _hr_set_floor(self, floor: int, *, spawn_at: str = "elevator") -> None:
        max_f = int(max(1, int(getattr(self, "hr_max_floors", int(self._HR_INT_MAX_FLOORS_DEFAULT)))))
        floor = int(clamp(int(floor), 1, max_f))
        self.hr_floor = int(floor)
        if floor <= 1:
            self.hr_mode = "lobby"
            self._hr_int_set_layout(self._HR_INT_LOBBY_LAYOUT)
        else:
            self.hr_mode = "hall"
            self._hr_int_set_layout(self._hr_make_hall_layout(floor))

        spawn_at = str(spawn_at)
        spawn_ch = "E"
        if spawn_at == "stairs_up":
            spawn_ch = "^"
        elif spawn_at == "stairs_down":
            spawn_ch = "v"

        elev = self._hr_int_find(str(spawn_ch)[:1])
        if elev is None:
            elev = self._hr_int_find("E")
        tile = int(self._HR_INT_TILE_SIZE)
        if elev is None:
            self.hr_int_pos = pygame.Vector2((self._HR_INT_W / 2.0) * tile, (self._HR_INT_H / 2.0) * tile)
        else:
            ex, ey = elev
            self.hr_int_pos = pygame.Vector2((ex + 0.5) * tile, (ey + 0.5) * tile)
        self.hr_int_vel = pygame.Vector2(0, 0)
        self.hr_int_facing = pygame.Vector2(0, 1)
        self.hr_int_walk_phase = 0.0

    def _hr_travel_start(self, target_floor: int, *, kind: str, spawn_at: str = "elevator") -> None:
        if not bool(getattr(self, "hr_interior", False)):
            return
        if bool(getattr(self, "hr_travel_active", False)):
            return
        kind = str(kind).strip() or "elevator"

        max_f = int(max(1, int(getattr(self, "hr_max_floors", int(self._HR_INT_MAX_FLOORS_DEFAULT)))))
        cur = int(getattr(self, "hr_floor", 1))
        target = int(clamp(int(target_floor), 1, int(max_f)))
        if int(target) == int(cur):
            self._set_hint(f"已在 {int(cur)}F", seconds=0.8)
            return

        step = 0.35
        if kind != "elevator":
            step = 0.60

        self.inv_open = False
        self.home_ui_open = False
        self.home_ui_open_block = None
        self.world_map_open = False
        self._gallery_open = False
        self.hr_elevator_ui_open = False
        self.hr_elevator_input = ""
        self.hr_auto_walk_to_elevator = False
        self.hr_auto_walk_delay = 0.0
        self._clear_player_pose()

        self.hr_travel_active = True
        self.hr_travel_kind = kind
        self.hr_travel_from = int(cur)
        self.hr_travel_to = int(target)
        self.hr_travel_display = int(cur)
        self.hr_travel_dir = 1 if int(target) > int(cur) else -1
        self.hr_travel_step_s = float(max(0.10, float(step)))
        self.hr_travel_acc = 0.0
        self.hr_travel_done_left = -1.0
        self.hr_travel_spawn_at = str(spawn_at)
        self.hr_int_vel = pygame.Vector2(0, 0)

    def _hr_travel_update(self, dt: float) -> None:
        if not bool(getattr(self, "hr_travel_active", False)):
            return
        dt = float(dt)
        cur = int(getattr(self, "hr_travel_display", int(getattr(self, "hr_floor", 1))))
        target = int(getattr(self, "hr_travel_to", cur))
        step = float(getattr(self, "hr_travel_step_s", 0.35))
        step = float(max(0.06, step))
        direction = 1 if int(getattr(self, "hr_travel_dir", 1)) >= 0 else -1

        if int(cur) == int(target):
            done_left = float(getattr(self, "hr_travel_done_left", -1.0))
            if done_left < 0.0:
                self.hr_travel_done_left = 0.25
                return
            done_left = done_left - dt
            self.hr_travel_done_left = done_left
            if done_left <= 0.0:
                spawn_at = str(getattr(self, "hr_travel_spawn_at", "elevator"))
                self.hr_travel_active = False
                self.hr_travel_kind = ""
                self._hr_set_floor(int(target), spawn_at=spawn_at)
            return

        acc = float(getattr(self, "hr_travel_acc", 0.0)) + dt
        while acc >= step and int(cur) != int(target):
            acc -= step
            cur = int(cur) + int(direction)
            # Clamp so we never step beyond target.
            if direction > 0 and int(cur) > int(target):
                cur = int(target)
            elif direction < 0 and int(cur) < int(target):
                cur = int(target)
            self.hr_travel_display = int(cur)
        self.hr_travel_acc = float(acc)
        if int(cur) == int(target):
            self.hr_travel_done_left = 0.25

    def _hr_elevator_open(self) -> None:
        if not getattr(self, "hr_interior", False):
            return
        max_f = int(max(1, int(getattr(self, "hr_max_floors", int(self._HR_INT_MAX_FLOORS_DEFAULT)))))
        options = list(range(max_f, 0, -1))
        self.hr_elevator_options = options
        cur = int(getattr(self, "hr_floor", 1))
        try:
            self.hr_elevator_sel = int(options.index(cur))
        except ValueError:
            self.hr_elevator_sel = 0
        self.hr_elevator_input = ""
        self.hr_elevator_ui_open = True
        self._set_hint("电梯：方向键选择 | PgUp/PgDn翻页 | 数字直达 | Enter确认", seconds=1.8)

    def _key_digit(self, key: int) -> str | None:
        key = int(key)
        if int(pygame.K_0) <= key <= int(pygame.K_9):
            return chr(key)
        if int(pygame.K_KP0) <= key <= int(pygame.K_KP9):
            return str(int(key) - int(pygame.K_KP0))
        return None

    def _handle_hr_elevator_ui_wheel(self, event: pygame.event.Event) -> None:
        if not getattr(self, "hr_elevator_ui_open", False):
            return
        options: list[int] = list(getattr(self, "hr_elevator_options", []))
        if not options:
            options = [1]
            self.hr_elevator_options = options
        n = len(options)
        cols = max(1, int(getattr(self, "hr_elevator_cols", 4)))
        rows_per_page = 4
        page_size = max(1, cols * rows_per_page)
        step = cols
        if pygame.key.get_mods() & pygame.KMOD_SHIFT:
            step = page_size
        dy = int(getattr(event, "y", 0))
        if dy == 0:
            return
        sel = int(getattr(self, "hr_elevator_sel", 0)) % n
        sel = (sel - step) % n if dy > 0 else (sel + step) % n
        self.hr_elevator_sel = int(sel)
        self.hr_elevator_input = ""

    def _handle_hr_elevator_ui_mouse(self, event: pygame.event.Event) -> None:
        if not getattr(self, "hr_elevator_ui_open", False):
            return

        et = int(getattr(event, "type", 0))
        button = int(getattr(event, "button", 0))
        if et == int(pygame.MOUSEBUTTONDOWN) and button == 3:
            self.hr_elevator_ui_open = False
            self.hr_elevator_input = ""
            return

        if et not in (int(pygame.MOUSEMOTION), int(pygame.MOUSEBUTTONDOWN)):
            return
        if et == int(pygame.MOUSEBUTTONDOWN) and button != 1:
            return

        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return
        mx, my = int(internal[0]), int(internal[1])

        options: list[int] = list(getattr(self, "hr_elevator_options", []))
        if not options:
            options = [0]
            self.hr_elevator_options = options
        cols = max(1, int(getattr(self, "hr_elevator_cols", 4)))
        rows_per_page = 4
        n = len(options)
        page_size = max(1, cols * rows_per_page)
        sel_i = int(getattr(self, "hr_elevator_sel", 0)) % max(1, n)
        page = int(sel_i // page_size)
        start = int(page * page_size)
        end = int(min(int(n), int(start + page_size)))
        page_opts = list(options[start:end])
        rows = int(max(1, int(math.ceil(float(len(page_opts)) / float(cols)))))

        btn_w = 56
        btn_h = 28
        gap = 8
        grid_w = cols * btn_w + (cols - 1) * gap
        grid_h = rows * btn_h + (rows - 1) * gap
        panel = pygame.Rect(0, 0, grid_w + 40, grid_h + 98)
        panel.center = (INTERNAL_W // 2, INTERNAL_H // 2)

        x0 = panel.centerx - grid_w // 2
        y0 = panel.top + 66
        hit_i: int | None = None
        hit_floor: int | None = None
        for local_i, f in enumerate(page_opts):
            r = int(local_i) // cols
            c = int(local_i) % cols
            x = x0 + c * (btn_w + gap)
            y = y0 + r * (btn_h + gap)
            br = pygame.Rect(x, y, btn_w, btn_h)
            if br.collidepoint(mx, my):
                hit_i = int(start) + int(local_i)
                hit_floor = int(f)
                break

        if hit_i is None or hit_floor is None:
            return

        self.hr_elevator_sel = int(hit_i)
        self.hr_elevator_input = ""
        if et == int(pygame.MOUSEBUTTONDOWN) and button == 1:
            self.hr_elevator_ui_open = False
            self._hr_travel_start(int(hit_floor), kind="elevator", spawn_at="elevator")

    def _handle_hr_elevator_ui_key(self, key: int) -> None:
        if not getattr(self, "hr_elevator_ui_open", False):
            return
        options: list[int] = list(getattr(self, "hr_elevator_options", []))
        if not options:
            options = [0]
            self.hr_elevator_options = options
        n = len(options)
        cols = max(1, int(getattr(self, "hr_elevator_cols", 4)))
        rows_per_page = 4
        page_size = max(1, cols * rows_per_page)
        sel = int(getattr(self, "hr_elevator_sel", 0)) % n

        digit = self._key_digit(int(key))
        if digit is not None:
            cur = str(getattr(self, "hr_elevator_input", ""))
            if len(cur) < 3:
                self.hr_elevator_input = cur + digit
            return
        if key in (pygame.K_BACKSPACE, pygame.K_DELETE):
            cur = str(getattr(self, "hr_elevator_input", ""))
            self.hr_elevator_input = cur[:-1]
            return

        if key in (pygame.K_ESCAPE,):
            self.hr_elevator_ui_open = False
            self.hr_elevator_input = ""
            return
        if key in (pygame.K_RETURN, pygame.K_SPACE, pygame.K_e):
            self.hr_elevator_ui_open = False
            typed = str(getattr(self, "hr_elevator_input", "")).strip()
            self.hr_elevator_input = ""
            if typed:
                try:
                    target = int(typed)
                except ValueError:
                    target = int(options[sel])
                self._hr_travel_start(int(target), kind="elevator", spawn_at="elevator")
            else:
                self._hr_travel_start(int(options[sel]), kind="elevator", spawn_at="elevator")
            return

        if key in (pygame.K_PAGEUP,):
            self.hr_elevator_sel = int((sel - page_size) % n)
            self.hr_elevator_input = ""
            return
        if key in (pygame.K_PAGEDOWN,):
            self.hr_elevator_sel = int((sel + page_size) % n)
            self.hr_elevator_input = ""
            return
        if key in (pygame.K_HOME,):
            self.hr_elevator_sel = 0
            self.hr_elevator_input = ""
            return
        if key in (pygame.K_END,):
            self.hr_elevator_sel = int(n - 1)
            self.hr_elevator_input = ""
            return

        if key in (pygame.K_LEFT, pygame.K_a):
            self.hr_elevator_sel = int((sel - 1) % n)
        elif key in (pygame.K_RIGHT, pygame.K_d):
            self.hr_elevator_sel = int((sel + 1) % n)
        elif key in (pygame.K_UP, pygame.K_w):
            self.hr_elevator_sel = int((sel - cols) % n)
        elif key in (pygame.K_DOWN, pygame.K_s):
            self.hr_elevator_sel = int((sel + cols) % n)
        self.hr_elevator_input = ""

    def _world_elevator_open(self, chunk: "_Chunk", mh: "_MultiHouse", *, elev_tile: tuple[int, int]) -> None:
        floors = int(max(1, int(getattr(mh, "floors", 1))))
        floors = int(min(int(floors), int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
        if floors <= 1:
            self._set_hint("只有一层", seconds=1.0)
            return
        options = list(range(int(floors), 0, -1))
        self.world_elevator_options = options
        cur = int(max(1, int(getattr(mh, "cur_floor", 1))))
        cur = int(clamp(int(cur), 1, int(floors)))
        try:
            self.world_elevator_sel = int(options.index(int(cur)))
        except ValueError:
            self.world_elevator_sel = 0
        self.world_elevator_input = ""
        self.world_elevator_ui_open = True
        self.world_elevator_chunk = chunk
        self.world_elevator_mh = mh
        self.world_elevator_elev_tile = (int(elev_tile[0]), int(elev_tile[1]))
        self._set_hint("电梯：方向键选择 | PgUp/PgDn翻页 | 数字直达 | Enter确认", seconds=1.6)

    def _world_elevator_close(self) -> None:
        self.world_elevator_ui_open = False
        self.world_elevator_input = ""
        self.world_elevator_chunk = None
        self.world_elevator_mh = None
        self.world_elevator_elev_tile = None

    def _world_elevator_apply_floor(self, floor: int) -> None:
        chunk = getattr(self, "world_elevator_chunk", None)
        mh = getattr(self, "world_elevator_mh", None)
        if chunk is None or mh is None:
            return
        floors = int(max(1, int(getattr(mh, "floors", 1))))
        floors = int(min(int(floors), int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
        target = int(clamp(int(floor), 1, int(floors)))
        mh.cur_floor = int(target)
        self._multi_house_apply_floor(chunk, mh)

        elev = getattr(self, "world_elevator_elev_tile", None)
        if isinstance(elev, tuple) and len(elev) >= 2:
            ex, ey = int(elev[0]), int(elev[1])
            self.player.vel.update(0, 0)
            self.player.pos.update((float(ex) + 0.5) * float(self.TILE_SIZE), (float(ey) + 0.5) * float(self.TILE_SIZE))

        self._set_hint(f"{int(target)}F", seconds=0.8)

    def _handle_world_elevator_ui_wheel(self, event: pygame.event.Event) -> None:
        if not getattr(self, "world_elevator_ui_open", False):
            return
        options: list[int] = list(getattr(self, "world_elevator_options", []))
        if not options:
            options = [1]
            self.world_elevator_options = options
        n = len(options)
        cols = max(1, int(getattr(self, "world_elevator_cols", 4)))
        rows_per_page = 4
        page_size = max(1, cols * rows_per_page)
        step = cols
        if pygame.key.get_mods() & pygame.KMOD_SHIFT:
            step = page_size
        dy = int(getattr(event, "y", 0))
        if dy == 0:
            return
        sel = int(getattr(self, "world_elevator_sel", 0)) % n
        sel = (sel - step) % n if dy > 0 else (sel + step) % n
        self.world_elevator_sel = int(sel)
        self.world_elevator_input = ""

    def _handle_world_elevator_ui_mouse(self, event: pygame.event.Event) -> None:
        if not getattr(self, "world_elevator_ui_open", False):
            return

        et = int(getattr(event, "type", 0))
        button = int(getattr(event, "button", 0))
        if et == int(pygame.MOUSEBUTTONDOWN) and button == 3:
            self._world_elevator_close()
            return

        if et not in (int(pygame.MOUSEMOTION), int(pygame.MOUSEBUTTONDOWN)):
            return
        if et == int(pygame.MOUSEBUTTONDOWN) and button != 1:
            return

        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return
        mx, my = int(internal[0]), int(internal[1])

        options: list[int] = list(getattr(self, "world_elevator_options", []))
        if not options:
            options = [1]
            self.world_elevator_options = options
        cols = max(1, int(getattr(self, "world_elevator_cols", 4)))
        rows_per_page = 4
        n = len(options)
        page_size = max(1, cols * rows_per_page)
        sel_i = int(getattr(self, "world_elevator_sel", 0)) % max(1, n)
        page = int(sel_i // page_size)
        start = int(page * page_size)
        end = int(min(int(n), int(start + page_size)))
        page_opts = list(options[start:end])
        rows = int(max(1, int(math.ceil(float(len(page_opts)) / float(cols)))))

        btn_w = 56
        btn_h = 28
        gap = 8
        grid_w = cols * btn_w + (cols - 1) * gap
        grid_h = rows * btn_h + (rows - 1) * gap
        panel = pygame.Rect(0, 0, grid_w + 40, grid_h + 98)
        panel.center = (INTERNAL_W // 2, INTERNAL_H // 2)

        x0 = panel.centerx - grid_w // 2
        y0 = panel.top + 66
        hit_i: int | None = None
        hit_floor: int | None = None
        for local_i, f in enumerate(page_opts):
            r = int(local_i) // cols
            c = int(local_i) % cols
            x = x0 + c * (btn_w + gap)
            y = y0 + r * (btn_h + gap)
            br = pygame.Rect(x, y, btn_w, btn_h)
            if br.collidepoint(mx, my):
                hit_i = int(start) + int(local_i)
                hit_floor = int(f)
                break

        if hit_i is None or hit_floor is None:
            return

        self.world_elevator_sel = int(hit_i)
        self.world_elevator_input = ""
        if et == int(pygame.MOUSEBUTTONDOWN) and button == 1:
            self._world_elevator_apply_floor(int(hit_floor))
            self._world_elevator_close()

    def _handle_world_elevator_ui_key(self, key: int) -> None:
        if not getattr(self, "world_elevator_ui_open", False):
            return
        options: list[int] = list(getattr(self, "world_elevator_options", []))
        if not options:
            options = [1]
            self.world_elevator_options = options
        n = len(options)
        cols = max(1, int(getattr(self, "world_elevator_cols", 4)))
        rows_per_page = 4
        page_size = max(1, cols * rows_per_page)
        sel = int(getattr(self, "world_elevator_sel", 0)) % n

        digit = self._key_digit(int(key))
        if digit is not None:
            cur = str(getattr(self, "world_elevator_input", ""))
            if len(cur) < 3:
                self.world_elevator_input = cur + digit
            return
        if key in (pygame.K_BACKSPACE, pygame.K_DELETE):
            cur = str(getattr(self, "world_elevator_input", ""))
            self.world_elevator_input = cur[:-1]
            return

        if key in (pygame.K_ESCAPE,):
            self._world_elevator_close()
            return
        if key in (pygame.K_RETURN, pygame.K_SPACE, pygame.K_e):
            typed = str(getattr(self, "world_elevator_input", "")).strip()
            self.world_elevator_input = ""
            if typed:
                try:
                    target = int(typed)
                except ValueError:
                    target = int(options[sel])
                self._world_elevator_apply_floor(int(target))
            else:
                self._world_elevator_apply_floor(int(options[sel]))
            self._world_elevator_close()
            return

        if key in (pygame.K_PAGEUP,):
            self.world_elevator_sel = int((sel - page_size) % n)
            self.world_elevator_input = ""
            return
        if key in (pygame.K_PAGEDOWN,):
            self.world_elevator_sel = int((sel + page_size) % n)
            self.world_elevator_input = ""
            return
        if key in (pygame.K_HOME,):
            self.world_elevator_sel = 0
            self.world_elevator_input = ""
            return
        if key in (pygame.K_END,):
            self.world_elevator_sel = int(n - 1)
            self.world_elevator_input = ""
            return

        if key in (pygame.K_LEFT, pygame.K_a):
            self.world_elevator_sel = int((sel - 1) % n)
        elif key in (pygame.K_RIGHT, pygame.K_d):
            self.world_elevator_sel = int((sel + 1) % n)
        elif key in (pygame.K_UP, pygame.K_w):
            self.world_elevator_sel = int((sel - cols) % n)
        elif key in (pygame.K_DOWN, pygame.K_s):
            self.world_elevator_sel = int((sel + cols) % n)
        self.world_elevator_input = ""

    def _hr_room_seed(self, room_id: str) -> int:
        seed = 0
        for ch in str(room_id):
            seed = (seed * 131 + ord(ch)) & 0xFFFFFFFF
        return int(seed)

    def _hr_room_storages_bind(self, room_id: str, *, populate: bool) -> None:
        room_id = str(room_id).strip()
        if not room_id:
            return
        store = getattr(self, "hr_room_storages", None)
        if not isinstance(store, dict):
            store = {}
            self.hr_room_storages = store
        pair = store.get(room_id)
        if (
            not isinstance(pair, tuple)
            or len(pair) != 2
            or not isinstance(pair[0], HardcoreSurvivalState._Inventory)
            or not isinstance(pair[1], HardcoreSurvivalState._Inventory)
        ):
            cab = HardcoreSurvivalState._Inventory(slots=[None] * 30, cols=6)
            fr = HardcoreSurvivalState._Inventory(slots=[None] * 12, cols=4)
            store[room_id] = (cab, fr)
            if populate:
                self._hr_room_storages_populate(room_id, cab=cab, fridge=fr)
            pair = store.get(room_id)
        if isinstance(pair, tuple) and len(pair) == 2:
            self.home_storage, self.fridge_storage = pair
            self.hr_current_room = str(room_id)
            lights = getattr(self, "hr_room_lights", None)
            if not isinstance(lights, dict):
                lights = {}
                self.hr_room_lights = lights
            if str(room_id) not in lights:
                lights[str(room_id)] = True

    def _hr_room_floor_items_bind(self, room_id: str, *, populate: bool) -> None:
        room_id = str(room_id).strip()
        if not room_id:
            self.hr_floor_items = []
            return
        store = getattr(self, "hr_room_floor_items", None)
        if not isinstance(store, dict):
            store = {}
            self.hr_room_floor_items = store
        items = store.get(room_id)
        if not isinstance(items, list):
            items = []
            store[room_id] = items
            if populate:
                self._hr_room_floor_items_populate(room_id, items=items)
        self.hr_floor_items = items

    def _hr_room_floor_items_populate(self, room_id: str, *, items: list["HardcoreSurvivalState._WorldItem"]) -> None:
        # Deterministic per-room floor loot (visible snacks on the ground).
        seed = self._hr_room_seed(str(room_id)) ^ (int(self.seed) & 0xFFFFFFFF) ^ 0x51F00D
        rng = random.Random(int(seed))

        cache = getattr(self, "_item_kind_cache", None)
        if not isinstance(cache, dict):
            cache = {}
            self._item_kind_cache = cache

        def pool(kind: str) -> list[str]:
            key = str(kind)
            got = cache.get(key)
            if isinstance(got, list):
                return got
            out: list[str] = []
            for iid, idef in self._ITEMS.items():
                if idef is None:
                    continue
                if str(getattr(idef, "kind", "")) == key:
                    out.append(str(iid))
            cache[key] = out
            return out

        foods = pool("food")
        drinks = pool("drink")
        meds = pool("med")

        snack_like = ("chips", "jerky", "candy", "chocolate", "nuts", "driedfruit", "seaweed", "crackers", "energybar")
        snacks = [iid for iid in foods if any(str(iid).startswith(f"food_{b}_") for b in snack_like)]
        if not snacks:
            snacks = foods

        # Prefer placing loot on clear floor tiles in the home layout.
        # (If layout changes, we still validate walkability.)
        candidates = [
            (12, 5),
            (11, 5),
            (18, 5),
            (19, 5),
            (20, 5),
            (18, 4),
            (19, 4),
        ]
        floor_tiles: list[tuple[int, int]] = []
        for tx, ty in candidates:
            ch = self._hr_int_char_at(int(tx), int(ty))
            if not self._hr_int_solid_tile(ch):
                floor_tiles.append((int(tx), int(ty)))
        if not floor_tiles:
            return

        picks: list[tuple[str, int]] = []
        if snacks:
            picks.append((rng.choice(snacks), int(rng.randint(1, 2))))
        if snacks and rng.random() < 0.75:
            picks.append((rng.choice(snacks), 1))
        if drinks and rng.random() < 0.85:
            picks.append((rng.choice(drinks), 1))
        if meds and rng.random() < 0.25:
            picks.append((rng.choice(meds), 1))

        tile = int(self._HR_INT_TILE_SIZE)
        rng.shuffle(floor_tiles)
        for (iid, qty), (tx, ty) in zip(picks, floor_tiles):
            items.append(
                HardcoreSurvivalState._WorldItem(
                    pos=pygame.Vector2((float(tx) + 0.5) * float(tile), (float(ty) + 0.5) * float(tile)),
                    item_id=str(iid),
                    qty=int(qty),
                )
            )

    def _hr_room_storages_populate(
        self,
        room_id: str,
        *,
        cab: "HardcoreSurvivalState._Inventory",
        fridge: "HardcoreSurvivalState._Inventory",
    ) -> None:
        # Deterministic per-room loot (so it doesn't change every visit).
        seed = self._hr_room_seed(str(room_id)) ^ (int(self.seed) & 0xFFFFFFFF) ^ 0xC8A19D2B
        rng = random.Random(int(seed))

        cache = getattr(self, "_item_kind_cache", None)
        if not isinstance(cache, dict):
            cache = {}
            self._item_kind_cache = cache

        def pool(kind: str) -> list[str]:
            key = str(kind)
            got = cache.get(key)
            if isinstance(got, list):
                return got
            out: list[str] = []
            for iid, idef in self._ITEMS.items():
                if idef is None:
                    continue
                if str(getattr(idef, "kind", "")) == key:
                    out.append(str(iid))
            cache[key] = out
            return out

        foods = pool("food")
        drinks = pool("drink")
        meds = pool("med")
        mats = pool("mat")
        tools = pool("tool")
        ammo = pool("ammo")
        guns = pool("gun")

        if drinks:
            for _ in range(int(rng.randint(1, 3))):
                fridge.add(rng.choice(drinks), 1, self._ITEMS)
        if foods and rng.random() < 0.75:
            for _ in range(int(rng.randint(0, 2))):
                fridge.add(rng.choice(foods), 1, self._ITEMS)

        if foods:
            for _ in range(int(rng.randint(1, 4))):
                cab.add(rng.choice(foods), 1, self._ITEMS)
        if meds and rng.random() < 0.70:
            for _ in range(int(rng.randint(0, 2))):
                cab.add(rng.choice(meds), 1, self._ITEMS)
        if mats and rng.random() < 0.55:
            for _ in range(int(rng.randint(0, 2))):
                cab.add(rng.choice(mats), int(rng.randint(2, 6)), self._ITEMS)
        if tools and rng.random() < 0.50:
            for _ in range(int(rng.randint(0, 2))):
                cab.add(rng.choice(tools), 1, self._ITEMS)
        if ammo and rng.random() < 0.45:
            for _ in range(int(rng.randint(0, 2))):
                cab.add(rng.choice(ammo), int(rng.randint(10, 36)), self._ITEMS)
        if guns and rng.random() < 0.12:
            cab.add(rng.choice(guns), 1, self._ITEMS)

    def _hr_enter_home(self) -> None:
        self.hr_hall_pos_before_home = pygame.Vector2(self.hr_int_pos)
        self.hr_mode = "home"
        self.hr_edit_mode = False
        self.hr_edit_dragging = False
        self.home_ui_open = False
        self.home_ui_open_block = None
        home_room = str(getattr(self, "home_highrise_room", "")).strip()
        if home_room:
            # Home room was pre-filled in on_enter(); still bind with populate=True so
            # we can also initialize the visible floor loot once.
            self._hr_room_storages_bind(home_room, populate=True)
        want_ver = int(getattr(self, "_HR_INT_HOME_LAYOUT_VERSION", 0))
        cur_ver = int(getattr(self, "hr_home_layout_version", 0))
        layout = getattr(self, "hr_home_layout", None)
        need_reset = bool(int(cur_ver) != int(want_ver))
        if not need_reset:
            if not isinstance(layout, list):
                need_reset = True
            else:
                norm = [str(r) for r in layout]
                if len(norm) != int(self._HR_INT_H) or any(len(r) != int(self._HR_INT_W) for r in norm):
                    need_reset = True
                # If the saved layout predates the bathroom/toilet addition, refresh it.
                if not any("O" in r for r in norm):
                    need_reset = True
                if not need_reset:
                    layout = norm
                    self.hr_home_layout = list(norm)

        if need_reset:
            layout = [str(r) for r in self._HR_INT_HOME_LAYOUT]
            self.hr_home_layout = list(layout)
            self.hr_home_layout_version = int(want_ver)

        self._hr_int_set_layout(list(layout or self._HR_INT_HOME_LAYOUT))
        if home_room:
            self._hr_room_floor_items_bind(home_room, populate=True)
        else:
            self.hr_floor_items = []

        door = self._hr_int_find("D")
        tile = int(self._HR_INT_TILE_SIZE)
        sx = int(int(self._HR_INT_W) // 2)
        sy = int(int(self._HR_INT_H) // 2)
        if door is not None:
            dx, dy = door
            spawn = (dx - 1, dy) if dx >= int(self._HR_INT_W) - 1 else (dx + 1, dy)
            sx, sy = spawn
            if self._hr_int_solid_tile(self._hr_int_char_at(sx, sy)):
                sx, sy = int(dx), int(dy)
        self.hr_int_pos = pygame.Vector2((float(sx) + 0.5) * float(tile), (float(sy) + 0.5) * float(tile))
        self.hr_int_vel = pygame.Vector2(0, 0)
        self.hr_int_walk_phase = 0.0
        self._set_hint("进入房间：E互动", seconds=1.1)

    def _hr_leave_home(self) -> None:
        floor = int(getattr(self, "hr_floor", 1))
        self._clear_player_pose()
        self.hr_mode = "hall"
        self.hr_edit_mode = False
        self.hr_edit_dragging = False
        self.home_ui_open = False
        self.home_ui_open_block = None
        self.hr_current_room = ""
        self.hr_floor_items = []
        self._hr_int_set_layout(self._hr_make_hall_layout(floor))        
        saved = getattr(self, "hr_hall_pos_before_home", None)
        if isinstance(saved, pygame.Vector2):
            self.hr_int_pos = pygame.Vector2(saved)
        self.hr_int_vel = pygame.Vector2(0, 0)
        self.hr_int_walk_phase = 0.0
        self._set_hint("离开房间", seconds=0.9)

    def _hr_interior_enter(self, sb: HardcoreSurvivalState._SpecialBuilding) -> None:
        self.inv_open = False
        self.rv_ui_open = False
        self._gallery_open = False
        self.hr_interior = True
        self.hr_elevator_ui_open = False
        self.hr_travel_active = False
        self.hr_travel_kind = ""
        self.hr_edit_mode = False
        self.hr_edit_dragging = False
        self.home_ui_open = False
        self.home_ui_open_block = None
        self.hr_edit_blocks: list[tuple[str, list[tuple[int, int]]]] = []
        self.hr_edit_index = 0
        self.mount = None
        self.player.vel.update(0, 0)
        self.player.walk_phase *= 0.85
        self.rv.vel.update(0, 0)
        self.bike.vel.update(0, 0)

        self.hr_building = sb
        self.hr_max_floors = int(getattr(sb, "floors", 0) or int(self._HR_INT_MAX_FLOORS_DEFAULT))
        if self.hr_max_floors <= 0:
            self.hr_max_floors = int(self._HR_INT_MAX_FLOORS_DEFAULT)

        home_door = getattr(self, "home_highrise_door", None)
        is_home = bool(home_door is not None and home_door in set(getattr(sb, "door_tiles", ())))
        if is_home:
            self.hr_home_floor = int(getattr(self, "home_highrise_floor", 0))
            self.hr_home_door_index = int(getattr(self, "home_highrise_door_index", 0))
        else:
            self.hr_home_floor = -1
            self.hr_home_door_index = 0

        self.hr_world_return = pygame.Vector2(self.player.pos)
        self._hr_set_floor(1)
        # Walk into the lobby, then auto-walk to the elevator and open the floor UI.
        self.hr_auto_walk_to_elevator = True
        self.hr_auto_walk_delay = 0.12

        door = self._hr_int_find("D")
        if door is not None:
            dx, dy = door
            tile = int(self._HR_INT_TILE_SIZE)
            spawn = (dx - 1, dy) if dx >= int(self._HR_INT_W) - 1 else (dx + 1, dy)
            sx, sy = spawn
            if self._hr_int_solid_tile(self._hr_int_char_at(sx, sy)):
                sx, sy = int(dx), int(dy)
            self.hr_int_pos = pygame.Vector2((sx + 0.5) * tile, (sy + 0.5) * tile)

        if is_home and int(self.hr_home_floor) > 0:
            home_room = str(getattr(self, "home_highrise_room", "")).strip()
            if home_room:
                self._set_hint(f"高层住宅：你的家 {home_room}", seconds=2.0)
            else:
                self._set_hint(f"高层住宅：你的家在 {int(self.hr_home_floor)} 层", seconds=2.0)
        else:
            self._set_hint("高层住宅：E进入电梯选择楼层", seconds=1.6)   

    def _hr_interior_exit(self) -> None:
        if not getattr(self, "hr_interior", False):
            return
        self._clear_player_pose()
        self.hr_interior = False
        self.hr_elevator_ui_open = False
        self.hr_travel_active = False
        self.hr_travel_kind = ""
        self.hr_edit_mode = False
        self.hr_edit_dragging = False
        self.home_ui_open = False
        self.home_ui_open_block = None
        self.hr_current_room = ""
        self.hr_building = None
        self.hr_mode = "lobby"
        self._hr_int_set_layout(self._HR_INT_LOBBY_LAYOUT)
        self.player.pos.update(self.hr_world_return)
        self._set_hint("离开高层住宅", seconds=1.0)

    def _hr_room_toggle_light(self, room_id: str) -> bool:
        room_id = str(room_id).strip()
        lights = getattr(self, "hr_room_lights", None)
        if not isinstance(lights, dict):
            lights = {}
            self.hr_room_lights = lights
        if room_id and room_id not in lights:
            lights[room_id] = True
        cur = bool(lights.get(room_id, True)) if room_id else True
        if room_id:
            lights[room_id] = (not cur)
        new_state = bool(lights.get(room_id, True)) if room_id else cur
        self._set_hint("灯：开" if new_state else "灯：关", seconds=0.9)
        return bool(new_state)

    def _hr_interior_interact(self) -> None:
        if not getattr(self, "hr_interior", False):
            return
        mode = str(getattr(self, "hr_mode", "lobby"))

        # Visible floor loot in apartments (snacks / supplies).
        if mode == "home":
            items = getattr(self, "hr_floor_items", None)
            if isinstance(items, list) and items:
                focus = pygame.Vector2(self.hr_int_pos)
                best_i: int | None = None
                best_d2 = float("inf")
                for i, it in enumerate(items):
                    if not isinstance(it, HardcoreSurvivalState._WorldItem):
                        continue
                    d2 = float((pygame.Vector2(it.pos) - focus).length_squared())
                    if d2 < best_d2:
                        best_d2 = d2
                        best_i = int(i)
                if best_i is not None and best_d2 <= (22.0 * 22.0):
                    it = items[int(best_i)]
                    want = int(getattr(it, "qty", 1) or 1)
                    want = max(1, want)
                    left = int(self.inventory.add(str(getattr(it, "item_id", "")), want, self._ITEMS))
                    took = int(want - left)
                    if took > 0:
                        if left <= 0:
                            items.pop(int(best_i))
                        else:
                            it.qty = int(left)
                        idef = self._ITEMS.get(str(getattr(it, "item_id", "")))
                        name = str(getattr(idef, "name", getattr(it, "item_id", "")))
                        self._set_hint(f"+{took} {name}", seconds=0.9)
                        return
        tx, ty = self._hr_int_player_tile()
        candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
        chosen: tuple[int, int, str] | None = None
        interact = {"D", "E", "H", "A", "a", "B", "^", "v"}
        if mode == "home":
            interact.update({"S", "F", "C", "P", "X", "L", "O"})
        for cx, cy in candidates:
            ch = self._hr_int_char_at(cx, cy)
            if ch in interact:
                chosen = (cx, cy, ch)
                break
        if chosen is None:
            self._set_hint("这里没有可互动", seconds=1.0)
            return

        # While sitting, prefer PC/TV over the seat tile so "E" doesn't just stand up.
        if (
            mode == "home"
            and str(getattr(self, "player_pose", "")) == "sit"
            and str(getattr(self, "player_pose_space", "")) == "hr"
            and chosen[2] == "C"
        ):
            for cx, cy in candidates:
                ch2 = self._hr_int_char_at(cx, cy)
                if ch2 in ("P", "X"):
                    chosen = (cx, cy, ch2)
                    break
        _cx, _cy, ch = chosen
        if ch == "E":
            self._hr_elevator_open()
            return
        if ch == "D":
            if mode == "home":
                self._hr_leave_home()
                return
            self._hr_interior_exit()
            return
        if ch == "L" and mode == "home":
            self._hr_room_toggle_light(str(getattr(self, "hr_current_room", "")).strip())
            return
        if ch in ("^", "v"):
            floor = int(getattr(self, "hr_floor", 1))
            max_f = int(max(1, int(getattr(self, "hr_max_floors", int(self._HR_INT_MAX_FLOORS_DEFAULT)))))
            if ch == "^":
                if floor >= max_f:
                    self._set_hint("已经是顶层", seconds=1.0)
                    return
                self._hr_travel_start(int(floor + 1), kind="stairs", spawn_at="stairs_down")
                return
            if floor <= 1:
                self._set_hint("已经是一楼", seconds=1.0)
                return
            self._hr_travel_start(int(floor - 1), kind="stairs", spawn_at="stairs_up")
            return
        if ch == "S" and mode == "home":
            w = int(self._HR_INT_W)
            h = int(self._HR_INT_H)
            seen: set[tuple[int, int]] = set()
            stack = [(int(_cx), int(_cy))]
            cells: list[tuple[int, int]] = []
            while stack:
                cx, cy = stack.pop()
                cx = int(cx)
                cy = int(cy)
                if (cx, cy) in seen:
                    continue
                if not (0 <= cx < w and 0 <= cy < h):
                    continue
                if str(self._hr_int_char_at(cx, cy))[:1] != "S":
                    continue
                seen.add((cx, cy))
                cells.append((cx, cy))
                stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
            if cells:
                min_x = min(int(p[0]) for p in cells)
                max_x = max(int(p[0]) for p in cells)
                min_y = min(int(p[1]) for p in cells)
                max_y = max(int(p[1]) for p in cells)
                self._home_ui_open(open_block=(int(min_x), int(min_y), int(max_x), int(max_y)), storage_kind="cabinet")
            else:
                self._home_ui_open(open_block=(int(_cx), int(_cy), int(_cx), int(_cy)), storage_kind="cabinet")
            return
        if ch == "F" and mode == "home":
            w = int(self._HR_INT_W)
            h = int(self._HR_INT_H)
            seen: set[tuple[int, int]] = set()
            stack = [(int(_cx), int(_cy))]
            cells: list[tuple[int, int]] = []
            while stack:
                cx, cy = stack.pop()
                cx = int(cx)
                cy = int(cy)
                if (cx, cy) in seen:
                    continue
                if not (0 <= cx < w and 0 <= cy < h):
                    continue
                if str(self._hr_int_char_at(cx, cy))[:1] != "F":
                    continue
                seen.add((cx, cy))
                cells.append((cx, cy))
                stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
            if cells:
                min_x = min(int(p[0]) for p in cells)
                max_x = max(int(p[0]) for p in cells)
                min_y = min(int(p[1]) for p in cells)
                max_y = max(int(p[1]) for p in cells)
                self._home_ui_open(open_block=(int(min_x), int(min_y), int(max_x), int(max_y)), storage_kind="fridge")
            else:
                self._home_ui_open(open_block=(int(_cx), int(_cy), int(_cx), int(_cy)), storage_kind="fridge")
            return
        if ch == "P" and mode == "home":
            if str(getattr(self, "player_pose", "")) != "sit" or str(getattr(self, "player_pose_space", "")) != "hr":
                self._set_hint("坐下再用电脑", seconds=1.0)
                return
            dx = int(_cx) - int(tx)
            dy = int(_cy) - int(ty)
            if abs(int(dx)) >= abs(int(dy)):
                self.hr_int_facing = pygame.Vector2(1 if int(dx) > 0 else -1 if int(dx) < 0 else 0, 0)
            else:
                self.hr_int_facing = pygame.Vector2(0, 1 if int(dy) > 0 else -1 if int(dy) < 0 else 0)
            self._toggle_world_map(open=True)
            self._set_hint("电脑：地图", seconds=1.0)
            return
        if ch == "X" and mode == "home":
            dx = int(_cx) - int(tx)
            dy = int(_cy) - int(ty)
            if abs(int(dx)) >= abs(int(dy)):
                self.hr_int_facing = pygame.Vector2(1 if int(dx) > 0 else -1 if int(dx) < 0 else 0, 0)
            else:
                self.hr_int_facing = pygame.Vector2(0, 1 if int(dy) > 0 else -1 if int(dy) < 0 else 0)
            room_id = str(getattr(self, "hr_current_room", "")).strip()
            tv_states = getattr(self, "hr_room_tvs", None)
            if not isinstance(tv_states, dict):
                tv_states = {}
                self.hr_room_tvs = tv_states
            if room_id:
                tv_states[room_id] = not bool(tv_states.get(room_id, False))
            tv_now = bool(tv_states.get(room_id, False)) if room_id else False
            if tv_now:
                self.player.morale = float(clamp(float(self.player.morale) + 2.0, 0.0, 100.0))
            self._gallery_open = False
            self._set_hint("电视：开" if tv_now else "电视：关", seconds=1.0)
            return
        if ch == "O" and mode == "home":
            mods = pygame.key.get_mods()
            is_shift = bool(int(mods) & int(pygame.KMOD_SHIFT))
            if is_shift:
                self.player.morale = float(clamp(float(self.player.morale) + 1.0, 0.0, 100.0))
                self._set_hint("拉屎完成", seconds=1.0)
            else:
                self.player.morale = float(clamp(float(self.player.morale) + 0.5, 0.0, 100.0))
                self._set_hint("小便完成（Shift+E 拉屎）", seconds=1.2)
            return
        if ch == "C" and mode == "home":
            if str(getattr(self, "player_pose", "")) == "sit" and str(getattr(self, "player_pose_space", "")) == "hr":
                self._clear_player_pose()
                self._set_hint("起身", seconds=0.8)
                return
            w = int(self._HR_INT_W)
            h = int(self._HR_INT_H)
            seen: set[tuple[int, int]] = set()
            stack = [(int(_cx), int(_cy))]
            cells: list[tuple[int, int]] = []
            while stack:
                cx, cy = stack.pop()
                cx = int(cx)
                cy = int(cy)
                if (cx, cy) in seen:
                    continue
                if not (0 <= cx < w and 0 <= cy < h):
                    continue
                if str(self._hr_int_char_at(cx, cy))[:1] != "C":
                    continue
                seen.add((cx, cy))
                cells.append((cx, cy))
                stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
            tile = int(self._HR_INT_TILE_SIZE)
            if cells:
                min_x = min(int(p[0]) for p in cells)
                max_x = max(int(p[0]) for p in cells)
                min_y = min(int(p[1]) for p in cells)
                max_y = max(int(p[1]) for p in cells)
                ax = (float(min_x + max_x + 1) * float(tile)) * 0.5
                ay = (float(min_y + max_y + 1) * float(tile)) * 0.5
            else:
                ax = (float(_cx) + 0.5) * float(tile)
                ay = (float(_cy) + 0.5) * float(tile)
            # Prefer a nearby walkable tile so sitting never snaps into walls/outside.
            prefer = pygame.Vector2(self.hr_int_pos)
            cand: list[tuple[float, int, int]] = []
            for sx, sy in (cells if cells else [(int(_cx), int(_cy))]):
                for dx2, dy2 in (
                    (1, 0),
                    (-1, 0),
                    (0, 1),
                    (0, -1),
                    (1, 1),
                    (1, -1),
                    (-1, 1),
                    (-1, -1),
                ):
                    nx = int(sx) + int(dx2)
                    ny = int(sy) + int(dy2)
                    if not (0 <= int(nx) < int(w) and 0 <= int(ny) < int(h)):
                        continue
                    if self._hr_int_solid_tile(self._hr_int_char_at(int(nx), int(ny))):
                        continue
                    cxp = (float(nx) + 0.5) * float(tile)
                    cyp = (float(ny) + 0.5) * float(tile)
                    d2 = float((cxp - prefer.x) ** 2 + (cyp - prefer.y) ** 2)
                    cand.append((d2, int(nx), int(ny)))
            if cand:
                cand.sort(key=lambda v: v[0])
                nx, ny = int(cand[0][1]), int(cand[0][2])
                ax = (float(nx) + 0.5) * float(tile)
                ay = (float(ny) + 0.5) * float(tile)
            self._set_player_pose("sit", space="hr", anchor=(ax, ay), seconds=0.0)
            self._set_hint("坐下休息：移动键起身", seconds=1.4)
            return
        if ch == "B":
            self.player.stamina = 100.0
            self.player.morale = float(clamp(self.player.morale + 15.0, 0.0, 100.0))
            w = int(self._HR_INT_W)
            h = int(self._HR_INT_H)
            seen: set[tuple[int, int]] = set()
            stack = [(int(_cx), int(_cy))]
            cells: list[tuple[int, int]] = []
            while stack:
                cx, cy = stack.pop()
                cx = int(cx)
                cy = int(cy)
                if (cx, cy) in seen:
                    continue
                if not (0 <= cx < w and 0 <= cy < h):
                    continue
                if str(self._hr_int_char_at(cx, cy))[:1] != "B":
                    continue
                seen.add((cx, cy))
                cells.append((cx, cy))
                stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
            tile = int(self._HR_INT_TILE_SIZE)
            if cells:
                min_x = min(int(p[0]) for p in cells)
                max_x = max(int(p[0]) for p in cells)
                min_y = min(int(p[1]) for p in cells)
                max_y = max(int(p[1]) for p in cells)
                ax = (float(min_x + max_x + 1) * float(tile)) * 0.5
                ay = (float(min_y + max_y + 1) * float(tile)) * 0.5
            else:
                ax = (float(_cx) + 0.5) * float(tile)
                ay = (float(_cy) + 0.5) * float(tile)
            self._set_player_pose("sleep", space="hr", anchor=(ax, ay), seconds=2.6)
            self._set_hint("躺床休息：体力恢复 / 心态提升", seconds=1.4)
            return
        if ch == "H":
            if mode == "hall" and int(getattr(self, "hr_floor", 1)) == int(getattr(self, "hr_home_floor", -1)):
                self._hr_enter_home()
                return
            self._set_hint("这不是你的家", seconds=1.2)
            return
        if ch in ("A", "a"):
            doors = list(getattr(self, "_HR_INT_APT_DOORS", []))
            unit = 0
            for i, (dx, dy) in enumerate(doors):
                if int(dx) == int(_cx) and int(dy) == int(_cy):
                    unit = int(i) + 1
                    break
            floor = int(getattr(self, "hr_floor", 1))
            base_room_id = f"{int(floor)}{int(unit):02d}" if unit > 0 else f"{int(floor)}??"
            home_room = str(getattr(self, "home_highrise_room", "")).strip()
            if home_room and base_room_id == home_room:
                if int(self.inventory.count("key_house")) <= 0:
                    self._set_hint("需要我家的钥匙", seconds=1.1)
                    return
                self._hr_enter_home()
                return

            # Other units: locked unless the door is broken ('a').
            if ch != "a":
                self._set_hint("别人的门锁住了", seconds=1.2)
                return

            room_id = str(base_room_id)
            sb = getattr(self, "hr_building", None)
            if isinstance(sb, HardcoreSurvivalState._SpecialBuilding):
                room_id = f"{int(sb.tx0)}_{int(sb.ty0)}_{base_room_id}"

            # Break-in room: use the default apartment layout + per-room storage.
            self.hr_hall_pos_before_home = pygame.Vector2(self.hr_int_pos)
            self.hr_mode = "home"
            self.hr_edit_mode = False
            self.hr_edit_dragging = False
            self.home_ui_open = False
            self.home_ui_open_block = None
            self._hr_room_storages_bind(room_id, populate=True)
            self._hr_int_set_layout([str(r) for r in self._HR_INT_HOME_LAYOUT])
            self._hr_room_floor_items_bind(room_id, populate=True)

            door = self._hr_int_find("D")
            tile = int(self._HR_INT_TILE_SIZE)
            if door is None:
                self.hr_int_pos = pygame.Vector2((self._HR_INT_W / 2.0) * tile, (self._HR_INT_H / 2.0) * tile)
            else:
                dx, dy = door
                spawn = (dx - 1, dy) if dx >= int(self._HR_INT_W) - 1 else (dx + 1, dy)
                sx, sy = spawn
                if self._hr_int_solid_tile(self._hr_int_char_at(sx, sy)):
                    sx, sy = int(dx), int(dy)
                self.hr_int_pos = pygame.Vector2((sx + 0.5) * tile, (sy + 0.5) * tile)
            self.hr_int_vel = pygame.Vector2(0, 0)
            self.hr_int_walk_phase = 0.0
            self._set_hint(f"进入{base_room_id}", seconds=1.0)
            return
        self._set_hint("这里没有可互动", seconds=1.0)

    def _update_gun_timers(self, dt: float, *, allow_fire: bool) -> None:
        if self.gun is None:
            return
        self.gun.cooldown_left = max(0.0, float(self.gun.cooldown_left) - dt)
        if self.gun.reload_left > 0.0:
            self.gun.reload_left = max(0.0, float(self.gun.reload_left) - dt)
            if self.gun.reload_left <= 0.0:
                self._reload_lock_dir = None
                gun_def = self._gun_effective_def(self.gun)
                if gun_def is not None:
                    need = int(gun_def.mag_size) - int(self.gun.mag)
                    if need > 0:
                        got = self.inventory.remove(gun_def.ammo_item, need)
                        self.gun.mag = int(self.gun.mag) + int(got)
            return
        if allow_fire and self.mount is None and pygame.mouse.get_pressed()[0]:
            self._fire()

    def _interior_floor_surface(self, w: int, h: int, *, kind: str) -> pygame.Surface:
        w = int(w)
        h = int(h)
        kind = str(kind)
        key = (kind, w, h)

        cache = getattr(self, "_int_floor_cache", None)
        if not isinstance(cache, dict):
            cache = {}
            self._int_floor_cache = cache
        cached = cache.get(key)
        if isinstance(cached, pygame.Surface):
            return cached

        def _tint(c: tuple[int, int, int], add: tuple[int, int, int]) -> tuple[int, int, int]:
            return (
                int(clamp(int(c[0]) + int(add[0]), 0, 255)),
                int(clamp(int(c[1]) + int(add[1]), 0, 255)),
                int(clamp(int(c[2]) + int(add[2]), 0, 255)),
            )

        surf = pygame.Surface((w, h))

        if kind == "rv":
            # RV interior: perfectly uniform floor color (no seams/boards), per user request.
            surf.fill((92, 82, 68))
        elif kind in ("home", "wood"):
            base = (102, 90, 72) if kind == "home" else (92, 82, 68)
            seam = _tint(base, (-20, -20, -22))
            seam2 = _tint(base, (-10, -10, -12))
            knot = _tint(base, (-28, -22, -18))
            hi = _tint(base, (18, 16, 14))
            board_h = 6
            surf.fill(base)

            for y0 in range(0, h, board_h):
                row = int(y0 // board_h)
                row_col = _tint(base, (2, 1, 0) if (row % 2 == 0) else (-2, -2, -3))
                surf.fill(row_col, pygame.Rect(0, y0, w, min(board_h, h - y0)))
                surf.fill(seam, pygame.Rect(0, y0, w, 1))

                # Staggered vertical seams so it reads like boards.
                off = (row * 17) % 29
                board_len = 46
                x = -off
                while x < w:
                    sx = int(x + board_len)
                    if 0 <= sx < w:
                        surf.fill(seam2, pygame.Rect(sx, y0 + 1, 1, min(board_h - 1, h - y0 - 1)))
                    x += board_len

                # Subtle grain / knots (deterministic).
                for gx in range((row * 13) % 31, w, 37):
                    gy = y0 + 2 + ((gx + row * 7) % 2)
                    if 0 <= gy < h:
                        surf.fill(knot, pygame.Rect(gx, gy, 2, 1))
                        if gx + 10 < w and row % 3 == 0:
                            surf.fill(hi, pygame.Rect(gx + 10, gy, 1, 1))

        elif kind in ("school", "linoleum"):
            # School: dirty linoleum tiles (checker + grout + specks).
            base1 = (74, 74, 82)
            base2 = (66, 66, 74)
            grout = (52, 52, 60)
            speck1 = (84, 84, 92)
            speck2 = (58, 58, 66)
            cell = 10
            for y0 in range(0, h, cell):
                for x0 in range(0, w, cell):
                    col = base1 if (((x0 // cell) + (y0 // cell)) % 2 == 0) else base2
                    surf.fill(col, pygame.Rect(x0, y0, min(cell, w - x0), min(cell, h - y0)))
            for x in range(0, w, cell):
                surf.fill(grout, pygame.Rect(x, 0, 1, h))
            for y in range(0, h, cell):
                surf.fill(grout, pygame.Rect(0, y, w, 1))
            for y in range(2, h, 11):
                for x in range((y * 7) % 13, w, 29):
                    surf.fill(speck1 if ((x + y) % 2 == 0) else speck2, pygame.Rect(x, y, 1, 1))
        else:
            # Lobby / hall: stone tile with subtle grid + speckles.      
            base = (70, 72, 78)
            grid = (56, 58, 64)
            speck1 = (82, 84, 90)
            speck2 = (60, 62, 68)
            surf.fill(base)
            cell = 20
            for x in range(0, w, cell):
                surf.fill(grid, pygame.Rect(x, 0, 1, h))
            for y in range(0, h, cell):
                surf.fill(grid, pygame.Rect(0, y, w, 1))
            for y in range(2, h, 9):
                for x in range((y * 7) % 11, w, 23):
                    surf.fill(speck1 if ((x + y) % 2 == 0) else speck2, pygame.Rect(x, y, 1, 1))

        cache[key] = surf
        return surf

    def _marble_surface(
        self,
        w: int,
        h: int,
        *,
        seed: int,
        base: tuple[int, int, int] = (220, 222, 228),
    ) -> pygame.Surface:
        w = int(max(1, w))
        h = int(max(1, h))
        seed = int(seed) & 0xFFFFFFFF
        base = (int(base[0]), int(base[1]), int(base[2]))
        key = (w, h, seed, base)

        cache = getattr(self, "_marble_cache", None)
        if not isinstance(cache, dict):
            cache = {}
            self._marble_cache = cache
        cached = cache.get(key)
        if isinstance(cached, pygame.Surface):
            return cached

        surf = pygame.Surface((w, h))
        surf.fill(base)

        rnd = random.Random(int(seed) ^ (int(w) << 16) ^ int(h) ^ 0xBADC0FFE)

        # Specks (reads like stone).
        specks = int(clamp((w * h) // 45, 10, 160))
        for _ in range(specks):
            x = int(rnd.randrange(w))
            y = int(rnd.randrange(h))
            d = int(rnd.randrange(-16, 10))
            col = (
                int(clamp(int(base[0]) + d, 0, 255)),
                int(clamp(int(base[1]) + d, 0, 255)),
                int(clamp(int(base[2]) + d, 0, 255)),
            )
            surf.set_at((x, y), col)

        vein_dark = (
            int(clamp(int(base[0]) - 28, 0, 255)),
            int(clamp(int(base[1]) - 28, 0, 255)),
            int(clamp(int(base[2]) - 24, 0, 255)),
        )
        vein_light = (
            int(clamp(int(base[0]) - 12, 0, 255)),
            int(clamp(int(base[1]) - 12, 0, 255)),
            int(clamp(int(base[2]) - 10, 0, 255)),
        )

        # A few drifting veins (deterministic, cached so no flicker).
        vein_count = int(clamp((w + h) // 28, 2, 5))
        for i in range(vein_count):
            x0 = int(rnd.randrange(-w // 2, w))
            y0 = int(rnd.randrange(0, h))
            x1 = int(rnd.randrange(w, int(w * 2.0)))
            y1 = int(clamp(int(y0 + rnd.randrange(-h // 2, h // 2)), 0, h - 1))

            steps = int(max(3, w // 10))
            px, py = x0, y0
            for s in range(steps):
                t = float(s + 1) / float(steps)
                nx = int(round(float(x0) + (float(x1) - float(x0)) * t + rnd.randrange(-2, 3)))
                ny = int(round(float(y0) + (float(y1) - float(y0)) * t + rnd.randrange(-2, 3)))
                pygame.draw.line(surf, vein_light, (px, py), (nx, ny), 1)
                if i % 2 == 0:
                    pygame.draw.line(surf, vein_dark, (px + 1, py), (nx + 1, ny), 1)
                px, py = nx, ny

        cache[key] = surf
        return surf

    def _window_view_surface(self, w: int, h: int) -> pygame.Surface:
        w = int(w)
        h = int(h)
        daylight, tday = self._daylight_amount()
        season = self._season_index()
        wkind = str(getattr(self, "weather_kind", "clear"))
        inten = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))

        tbin = int(clamp(int(tday * 64.0), 0, 63))
        dbin = int(clamp(int(daylight * 16.0), 0, 16))
        ibin = int(clamp(int(inten * 10.0), 0, 10))
        key = (w, h, int(season), str(wkind), int(tbin), int(dbin), int(ibin))

        cache = getattr(self, "_window_view_cache", None)
        if not isinstance(cache, dict):
            cache = {}
            self._window_view_cache = cache
        cached = cache.get(key)
        if isinstance(cached, pygame.Surface):
            return cached

        def _lerp(a: float, b: float, t: float) -> float:
            return float(a + (b - a) * t)

        def _lerp_c(a: tuple[int, int, int], b: tuple[int, int, int], t: float) -> tuple[int, int, int]:
            return (
                int(round(_lerp(float(a[0]), float(b[0]), t))),
                int(round(_lerp(float(a[1]), float(b[1]), t))),
                int(round(_lerp(float(a[2]), float(b[2]), t))),
            )

        def _mul_c(c: tuple[int, int, int], m: float) -> tuple[int, int, int]:
            return (
                int(clamp(int(round(float(c[0]) * m)), 0, 255)),
                int(clamp(int(round(float(c[1]) * m)), 0, 255)),
                int(clamp(int(round(float(c[2]) * m)), 0, 255)),
            )

        day_sky_top = (78, 146, 224)
        day_sky_bot = (166, 214, 252)
        night_sky_top = (8, 10, 18)
        night_sky_bot = (24, 28, 44)
        sky_top = _lerp_c(night_sky_top, day_sky_top, float(daylight))
        sky_bot = _lerp_c(night_sky_bot, day_sky_bot, float(daylight))

        gloom = 1.0
        if wkind == "cloudy":
            gloom = 1.0 - 0.22 * inten
        elif wkind == "rain":
            gloom = 1.0 - 0.30 * inten
        elif wkind == "storm":
            gloom = 1.0 - 0.44 * inten
        elif wkind == "snow":
            gloom = 1.0 - 0.18 * inten
        sky_top = _mul_c(sky_top, gloom)
        sky_bot = _mul_c(sky_bot, gloom)
        if wkind == "snow" and inten > 0.05:
            sky_top = _lerp_c(sky_top, (200, 210, 230), 0.18 * inten)
            sky_bot = _lerp_c(sky_bot, (230, 240, 250), 0.24 * inten)

        if season == 0:  # spring
            ground = (74, 150, 78)
        elif season == 1:  # summer
            ground = (58, 135, 66)
        elif season == 2:  # autumn
            ground = (122, 118, 70)
        else:  # winter
            ground = (160, 162, 176)
        ground = _mul_c(ground, 0.85 + 0.15 * daylight)
        if wkind == "snow" and inten > 0.15:
            ground = _lerp_c(ground, (210, 214, 224), 0.45 * inten)

        base = pygame.Surface((w, h))
        for yy in range(h):
            t = float(yy) / max(1.0, float(h - 1))
            base.fill(_lerp_c(sky_top, sky_bot, t), pygame.Rect(0, yy, w, 1))
        gh = max(3, int(h // 3))
        base.fill(ground, pygame.Rect(0, h - gh, w, gh))
        base.fill((16, 16, 22), pygame.Rect(0, h - gh, w, 1))

        # Dawn / dusk warm stripe near horizon.
        if 0.0 < daylight < 1.0:
            warm = (220, 150, 96) if tday < 0.5 else (226, 140, 86)
            warm_y = int(h - gh - 2)
            if 0 <= warm_y < h:
                base.fill(_mul_c(warm, 0.65), pygame.Rect(0, warm_y, w, 1))

        # Tiny silhouettes (reads as distant trees/buildings).
        if w >= 10 and h >= 8:
            base.fill((18, 18, 22), pygame.Rect(2, int(h - gh - 3), 2, 3))
            base.fill((18, 18, 22), pygame.Rect(int(w - 5), int(h - gh - 4), 3, 4))

        view = pygame.Surface((w, h), pygame.SRCALPHA)
        view.blit(base, (0, 0))

        # Glass tint + simple reflection lines.
        tint = pygame.Surface((w, h), pygame.SRCALPHA)
        tint.fill((60, 86, 120, 55))
        pygame.draw.line(tint, (240, 244, 255, 70), (1, 1), (w - 2, 1), 1)
        pygame.draw.line(tint, (210, 220, 240, 45), (1, 2), (w - 3, 2), 1)
        view.blit(tint, (0, 0))

        cache[key] = view
        return view

    def _draw_window_precip(self, surface: pygame.Surface, rect: pygame.Rect, *, kind: str, intensity: float) -> None:
        kind = str(kind)
        intensity = float(clamp(float(intensity), 0.0, 1.0))
        if intensity <= 0.05:
            return

        w = int(rect.w)
        h = int(rect.h)
        if w <= 0 or h <= 0:
            return

        t = float(getattr(self, "world_time_s", 0.0))
        overlay = pygame.Surface((w, h), pygame.SRCALPHA)

        if kind in ("rain", "storm"):
            alpha = int(clamp(int(70 + 140 * intensity), 0, 220))
            col = (220, 232, 255, alpha)
            step = max(4, int(round(8 - 3 * intensity)))
            speed = 140.0 if kind == "rain" else 220.0
            off = int((t * speed) % step)
            dx = max(5, int(round(h * 0.55)))
            for x in range(-h, w + h, step):
                xx = int(x + off)
                pygame.draw.line(overlay, col, (xx, 0), (xx + dx, h), 1)
            # A few bigger drops.
            if kind == "storm" and intensity > 0.35:
                for i in range(0, w, 9):
                    yy = int((i * 7 + int(t * 60)) % max(1, h))
                    overlay.fill((240, 246, 255, alpha), pygame.Rect(i, yy, 1, 2))

        elif kind == "snow":
            alpha = int(clamp(int(60 + 120 * intensity), 0, 210))
            col = (240, 244, 250, alpha)
            for y in range(1, h, 5):
                for x in range((y * 7 + int(t * 30)) % 9, w, 11):
                    overlay.fill(col, pygame.Rect(x, y, 1, 1))

        else:
            return

        surface.blit(overlay, rect.topleft)

    def _draw_rv_interior_scene(self, surface: pygame.Surface) -> None:
        # Removed: full-screen RV interior scene. The RV interior is now only
        # supported in world-camera mode via `_rv_world_interior`.
        return
        tile = int(self._RV_INT_TILE_SIZE)
        map_w = int(self._RV_INT_W) * tile
        map_h = int(self._RV_INT_H) * tile
        map_x = (INTERNAL_W - map_w) // 2
        map_y = 92
        panel = pygame.Rect(map_x - 10, map_y - 10, map_w + 20, map_h + 20)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (70, 70, 86), panel, 2, border_radius=12)

        # Cozier interior rendering (less grid, more furniture detail) inspired by the
        # user's reference screenshot.
        map_rect = pygame.Rect(map_x, map_y, map_w, map_h)
        surface.blit(self._interior_floor_surface(map_w, map_h, kind="rv"), map_rect.topleft)

        wall = (26, 26, 32)
        wall_hi = (56, 56, 70)
        wall_edge = (12, 12, 16)
        frame = (88, 80, 70)
        frame2 = (62, 56, 48)
        outline = (10, 10, 12)

        bed_matt = (186, 170, 156)
        bed_blank = (132, 154, 112)
        bed_blank2 = (108, 130, 92)
        pillow = (238, 238, 244)
        wood = (98, 78, 56)
        wood2 = (74, 58, 42)
        steel = (216, 220, 228)
        steel2 = (134, 140, 152)
        seat = (72, 86, 148)
        seat2 = (54, 64, 118)

        wkind = str(getattr(self, "weather_kind", "clear"))
        inten = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))
        glass_w = max(4, int(tile - 6))
        glass_h = max(4, int(tile - 8))
        win_view = self._window_view_surface(glass_w, glass_h)
        layout = self._vehicle_int_layout()

        bed_done: set[tuple[int, int]] = set()
        k_done: set[tuple[int, int]] = set()
        for y, row in enumerate(layout):
            for x in range(int(self._RV_INT_W)):
                ch = row[x] if x < len(row) else "W"
                r = pygame.Rect(map_x + x * tile, map_y + y * tile, tile, tile)

                if ch in ("W", "V"):
                    pygame.draw.rect(surface, wall, r)
                    pygame.draw.rect(surface, wall_hi, pygame.Rect(r.x, r.y, r.w, 4))
                    pygame.draw.rect(surface, wall_edge, r, 1)
                    pygame.draw.rect(surface, frame2, pygame.Rect(r.x, r.bottom - 4, r.w, 2))
                    if ch == "V":
                        glass = pygame.Rect(r.x + 3, r.y + 4, r.w - 6, r.h - 8)
                        wv = win_view
                        if wv.get_width() != glass.w or wv.get_height() != glass.h:
                            wv = pygame.transform.scale(wv, (int(glass.w), int(glass.h)))
                        surface.blit(wv, glass.topleft)
                        pygame.draw.rect(surface, frame, glass.inflate(4, 4), 1, border_radius=2)
                        pygame.draw.rect(surface, outline, glass, 1)
                        pygame.draw.line(surface, (40, 40, 50), (glass.centerx, glass.top + 1), (glass.centerx, glass.bottom - 2), 1)
                    continue

                if ch == "D":
                    dr = pygame.Rect(r.x + 4, r.y + 3, r.w - 8, r.h - 6)
                    pygame.draw.rect(surface, wood, dr, border_radius=2)
                    pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                    pygame.draw.rect(surface, wood2, pygame.Rect(dr.x + 2, dr.y + 2, dr.w - 4, 4))
                    pygame.draw.circle(surface, outline, (dr.right - 4, dr.centery), 2)
                    continue

                if ch == "B":
                    if (int(x), int(y)) in bed_done:
                        continue

                    bw = 1
                    while self._rv_int_char_at(int(x) + int(bw), int(y)) == "B":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._rv_int_char_at(int(x), int(ny)) != "B":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._rv_int_char_at(int(x) + int(dx), int(ny)) != "B":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1

                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            bed_done.add((int(x) + int(dx), int(y) + int(dy)))

                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    bed_r = br.inflate(-4, -8)
                    sh = pygame.Surface((bed_r.w, bed_r.h), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 90), sh.get_rect(), border_radius=6)
                    surface.blit(sh, (bed_r.x + 2, bed_r.y + 3))

                    pygame.draw.rect(surface, bed_matt, bed_r, border_radius=6)
                    pygame.draw.rect(surface, outline, bed_r, 1, border_radius=6)

                    hb = pygame.Rect(bed_r.x, bed_r.y, 8, bed_r.h)
                    pygame.draw.rect(surface, wood2, hb, border_radius=5)
                    pygame.draw.rect(surface, outline, hb, 1, border_radius=5)

                    p1 = pygame.Rect(bed_r.x + 10, bed_r.y + 4, max(10, bed_r.w // 5), 7)
                    p2 = pygame.Rect(p1.x, p1.y + 10, p1.w, 7)
                    pygame.draw.rect(surface, pillow, p1, border_radius=3)
                    pygame.draw.rect(surface, pillow, p2, border_radius=3)
                    pygame.draw.rect(surface, outline, p1, 1, border_radius=3)
                    pygame.draw.rect(surface, outline, p2, 1, border_radius=3)

                    bl = pygame.Rect(bed_r.x + 10, bed_r.y + 20, bed_r.w - 14, max(10, bed_r.h - 24))
                    pygame.draw.rect(surface, bed_blank, bl, border_radius=5)
                    pygame.draw.rect(surface, outline, bl, 1, border_radius=5)
                    for sx in range(bl.x + 6, bl.right - 4, 10):
                        pygame.draw.line(surface, bed_blank2, (sx, bl.y + 2), (sx, bl.bottom - 3), 1)
                    # Bed legs/frame (so it doesn't look like it floats).
                    floor_y = int(br.bottom - 3)
                    leg_y0 = int(bed_r.bottom - 2)
                    leg_h = int(floor_y - leg_y0)
                    if leg_h > 0:
                        leg_col = self._tint(wood2, add=(-12, -12, -12))
                        for lx in (int(bed_r.x + 6), int(bed_r.right - 8)):
                            leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                            surface.fill(leg_col, leg)
                            pygame.draw.rect(surface, outline, leg, 1)
                            surface.fill(leg_col, pygame.Rect(int(lx - 1), int(floor_y), 4, 1))
                    continue

                if ch == "S":
                    cab = pygame.Rect(r.x + 2, r.y + 6, r.w - 4, r.h - 10)
                    sh = pygame.Surface((cab.w, cab.h), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 80), sh.get_rect(), border_radius=4)
                    surface.blit(sh, (cab.x + 2, cab.y + 3))

                    pygame.draw.rect(surface, wood, cab, border_radius=3)
                    pygame.draw.rect(surface, outline, cab, 1, border_radius=3)
                    pygame.draw.rect(surface, wood2, pygame.Rect(cab.x + 1, cab.y + 1, cab.w - 2, 3))
                    pygame.draw.rect(surface, wood2, pygame.Rect(cab.x + 1, cab.bottom - 4, cab.w - 2, 3))

                    is_open = bool(getattr(self, "rv_ui_open", False)) and str(getattr(self, "rv_ui_focus", "map")) == "storage"
                    if is_open:
                        inner = cab.inflate(-4, -6)
                        pygame.draw.rect(surface, (20, 20, 24), inner, border_radius=2)
                        pygame.draw.rect(surface, outline, inner, 1, border_radius=2)
                        for sy in range(inner.y + 3, inner.bottom - 1, 5):
                            pygame.draw.line(surface, (44, 44, 52), (inner.x + 2, sy), (inner.right - 3, sy), 1)

                        door_w = max(4, int(cab.w // 4))
                        ld = pygame.Rect(cab.x + 1, cab.y + 3, door_w, cab.h - 6)
                        rd = pygame.Rect(cab.right - door_w - 1, cab.y + 3, door_w, cab.h - 6)
                        pygame.draw.rect(surface, wood, ld, border_radius=2)
                        pygame.draw.rect(surface, outline, ld, 1, border_radius=2)
                        pygame.draw.rect(surface, wood, rd, border_radius=2)
                        pygame.draw.rect(surface, outline, rd, 1, border_radius=2)
                        # Tiny visible supplies.
                        can = pygame.Rect(inner.x + 3, inner.y + 4, 3, 5)
                        surface.fill((180, 60, 70), can)
                        pygame.draw.rect(surface, outline, can, 1)
                        jar = pygame.Rect(inner.right - 7, inner.y + 5, 4, 4)
                        surface.fill((90, 140, 190), jar)
                        pygame.draw.rect(surface, outline, jar, 1)
                    else:
                        midx = int(cab.centerx)
                        pygame.draw.line(surface, wood2, (midx, cab.y + 4), (midx, cab.bottom - 5), 2)
                        pygame.draw.line(surface, outline, (midx, cab.y + 4), (midx, cab.bottom - 5), 1)
                        for hx in (midx - 4, midx + 3):
                            hrect = pygame.Rect(int(hx), cab.y + 8, 2, 5)
                            surface.fill((220, 220, 230), hrect)
                            pygame.draw.rect(surface, outline, hrect, 1)
                    continue

                if ch == "T":
                    top = pygame.Rect(r.x + 2, r.y + 7, r.w - 4, r.h - 12)
                    pygame.draw.rect(surface, wood, top, border_radius=2)
                    pygame.draw.rect(surface, outline, top, 1, border_radius=2)
                    pygame.draw.rect(surface, wood2, pygame.Rect(top.x + 1, top.y + 1, top.w - 2, 3))
                    # Table legs/frame (so it reads like real furniture).
                    floor_y = int(r.bottom - 3)
                    leg_y0 = int(top.bottom - 1)
                    leg_h = int(floor_y - leg_y0)
                    if leg_h > 0 and top.w >= 10:
                        leg_col = self._tint(wood2, add=(-10, -10, -10))
                        for lx in (int(top.x + 2), int(top.right - 4)):
                            leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                            surface.fill(leg_col, leg)
                            pygame.draw.rect(surface, outline, leg, 1)
                            surface.fill(leg_col, pygame.Rect(int(lx - 1), int(floor_y), 4, 1))
                    if (x + y) % 3 == 0:
                        mug = pygame.Rect(top.centerx - 2, top.y + 4, 4, 4)
                        pygame.draw.rect(surface, (230, 230, 240), mug, border_radius=1)
                        pygame.draw.rect(surface, outline, mug, 1, border_radius=1)
                    elif (x + y) % 3 == 1:
                        screen = pygame.Rect(top.centerx - 5, top.y + 2, 10, 6)
                        pygame.draw.rect(surface, (36, 38, 44), screen, border_radius=2)
                        pygame.draw.rect(surface, steel2, screen, 1, border_radius=2)
                    continue

                if ch == "K":
                    if (x, y) in k_done:
                        continue

                    bw = 1
                    while self._rv_int_char_at(int(x) + int(bw), int(y)) == "K":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._rv_int_char_at(int(x), int(ny)) != "K":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._rv_int_char_at(int(x) + int(dx), int(ny)) != "K":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            k_done.add((int(x) + int(dx), int(y) + int(dy)))

                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    obj = br.inflate(-6, -10)
                    sh = pygame.Surface((obj.w, obj.h), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 70), sh.get_rect(), border_radius=5)
                    surface.blit(sh, (obj.x + 2, obj.y + 3))

                    # Long counter: top (lighter) + front face (darker) to read as a continuous kitchen.
                    top_h = int(clamp(int(obj.h * 0.28), 7, 10))
                    top_r = pygame.Rect(obj.x, obj.y, obj.w, top_h)
                    front_r = pygame.Rect(obj.x, obj.y + top_h - 1, obj.w, obj.h - (top_h - 1))
                    pygame.draw.rect(surface, wood2, front_r, border_radius=6)
                    pygame.draw.rect(surface, outline, front_r, 1, border_radius=6)
                    pygame.draw.rect(surface, wood, top_r, border_radius=6)
                    pygame.draw.rect(surface, outline, top_r, 1, border_radius=6)
                    pygame.draw.line(surface, frame2, (top_r.x + 2, top_r.top + 1), (top_r.right - 3, top_r.top + 1), 1)
                    pygame.draw.line(surface, frame2, (top_r.x + 2, top_r.bottom - 2), (top_r.right - 3, top_r.bottom - 2), 1)

                    # Cabinet doors + handles on the front face (depth cues).
                    modules = int(max(2, int(bw)))
                    for i in range(1, modules):
                        xline = int(front_r.x + (front_r.w * i) / modules)
                        pygame.draw.line(surface, frame2, (xline, front_r.y + 4), (xline, front_r.bottom - 5), 2)
                        pygame.draw.line(surface, outline, (xline, front_r.y + 4), (xline, front_r.bottom - 5), 1)
                    for i in range(modules):
                        cx = int(front_r.x + (front_r.w * (i + 0.5)) / modules)
                        hrect = pygame.Rect(cx - 1, front_r.y + 8, 2, 7)
                        surface.fill((220, 220, 230), hrect)
                        pygame.draw.rect(surface, outline, hrect, 1)

                    # Sink + stove placed once across the whole block.
                    sink_w = int(clamp(int(top_r.w * 0.18), 12, 18))
                    sink_h = int(clamp(int(top_r.h - 3), 5, 7))
                    sink = pygame.Rect(top_r.x + int(top_r.w * 0.16), top_r.y + 2, sink_w, sink_h)
                    pygame.draw.rect(surface, steel, sink, border_radius=3)
                    pygame.draw.rect(surface, outline, sink, 1, border_radius=3)
                    pygame.draw.circle(surface, (60, 60, 70), (sink.right - 3, sink.y + 3), 1)
                    pygame.draw.line(surface, steel2, (sink.x + 2, sink.y + 1), (sink.x + 2, sink.y - 3), 1)
                    pygame.draw.line(surface, steel2, (sink.x + 2, sink.y - 3), (sink.x + 6, sink.y - 3), 1)

                    stove_w = int(clamp(int(top_r.w * 0.20), 12, 18))
                    stove_h = sink_h
                    stove = pygame.Rect(top_r.right - int(top_r.w * 0.18) - stove_w, top_r.y + 2, stove_w, stove_h)
                    pygame.draw.rect(surface, (40, 40, 50), stove, border_radius=3)
                    pygame.draw.rect(surface, outline, stove, 1, border_radius=3)
                    pygame.draw.circle(surface, (80, 80, 90), (stove.x + stove_w // 3, stove.centery), 2)
                    pygame.draw.circle(surface, (80, 80, 90), (stove.right - stove_w // 3, stove.centery), 2)

                    # Pots / bowls / plates on the countertop.
                    plate = pygame.Rect(top_r.right - 14, top_r.y + 2, 12, 5)
                    pygame.draw.ellipse(surface, (232, 232, 238), plate)
                    pygame.draw.ellipse(surface, outline, plate, 1)
                    bowl = pygame.Rect(top_r.x + 8, top_r.y + 2, 10, 5)
                    pygame.draw.ellipse(surface, (200, 210, 220), bowl)
                    pygame.draw.ellipse(surface, outline, bowl, 1)
                    pot = pygame.Rect(top_r.centerx - 8, top_r.y + 1, 16, 6)
                    pygame.draw.rect(surface, (40, 40, 50), pot, border_radius=3)
                    pygame.draw.rect(surface, outline, pot, 1, border_radius=3)
                    pygame.draw.line(surface, steel2, (pot.x + 2, pot.y + 2), (pot.right - 3, pot.y + 2), 1)
                    pygame.draw.line(surface, outline, (pot.x + 3, pot.y + 1), (pot.right - 4, pot.y + 1), 1)

                    # Small rack cue above the counter.
                    rack_y = int(top_r.y - 6)
                    if rack_y >= int(br.y) + 1:
                        pygame.draw.line(surface, outline, (top_r.x + 2, rack_y), (top_r.right - 3, rack_y), 1)
                        for ux in (top_r.x + 8, top_r.centerx, top_r.right - 10):
                            pygame.draw.line(surface, steel2, (int(ux), rack_y + 1), (int(ux), rack_y + 4), 1)
                    continue

                if ch == "H":
                    bench = pygame.Rect(r.x + 2, r.y + 7, r.w - 4, r.h - 11)
                    pygame.draw.rect(surface, wood2, bench, border_radius=2)
                    pygame.draw.rect(surface, outline, bench, 1, border_radius=2)
                    pygame.draw.rect(surface, wood, pygame.Rect(bench.x + 1, bench.y + 1, bench.w - 2, 3))
                    pygame.draw.line(surface, steel2, (bench.x + 2, bench.y), (bench.right - 3, bench.y + 5), 1)
                    pygame.draw.rect(surface, steel2, pygame.Rect(bench.x + 4, bench.y + 6, 5, 2), border_radius=1)
                    continue

                if ch == "R":
                    # Steering wheel + dashboard (cab).
                    wheel = (34, 34, 42)
                    wheel_hi = self._tint(wheel, add=(34, 34, 40))
                    wheel_lo = self._tint(wheel, add=(-18, -18, -18))

                    cx = int(r.centerx - 2)
                    cy = int(r.centery + 1)
                    outer = 7
                    try:
                        bg = surface.get_at((int(cx), int(cy)))[:3]
                    except Exception:
                        bg = (48, 46, 44)

                    pygame.draw.circle(surface, wheel, (cx, cy), int(outer))
                    pygame.draw.circle(surface, outline, (cx, cy), int(outer), 1)
                    pygame.draw.circle(surface, bg, (cx, cy), int(max(1, outer - 3)))

                    pygame.draw.line(surface, wheel_lo, (cx, cy), (cx, cy - outer + 2), 2)
                    pygame.draw.line(surface, wheel_lo, (cx, cy), (cx - outer + 2, cy + 1), 2)
                    pygame.draw.line(surface, wheel_lo, (cx, cy), (cx + outer - 2, cy + 1), 2)

                    hub = pygame.Rect(cx - 2, cy - 2, 5, 5)
                    pygame.draw.rect(surface, wheel_hi, hub, border_radius=2)
                    pygame.draw.rect(surface, outline, hub, 1, border_radius=2)

                    dash = pygame.Rect(r.right - 6, r.y + 6, 5, r.h - 12)
                    pygame.draw.rect(surface, (28, 28, 34), dash, border_radius=3)
                    pygame.draw.rect(surface, outline, dash, 1, border_radius=3)
                    pygame.draw.circle(surface, (180, 200, 220), (dash.centerx, dash.y + 4), 2)
                    pygame.draw.circle(surface, outline, (dash.centerx, dash.y + 4), 2, 1)
                    continue

                if ch == "C":
                    # Choose a facing direction so cabin seats read as facing the windshield / steering wheel.
                    facing = "down"
                    try:
                        if self._rv_int_char_at(int(x) + 1, int(y)) == "R":
                            facing = "right"
                        elif self._rv_int_char_at(int(x) - 1, int(y)) == "R":
                            facing = "left"
                        elif self._rv_int_char_at(int(x), int(y) - 1) == "R":
                            facing = "up"
                        elif self._rv_int_char_at(int(x), int(y) + 1) == "R":
                            facing = "down"
                        else:
                            if self._rv_int_char_at(int(x) + 1, int(y)) == "V":
                                facing = "right"
                            elif self._rv_int_char_at(int(x) - 1, int(y)) == "V":
                                facing = "left"
                            elif self._rv_int_char_at(int(x), int(y) - 1) == "V":
                                facing = "up"
                            elif self._rv_int_char_at(int(x), int(y) + 1) == "V":
                                facing = "down"
                    except Exception:
                        facing = "down"
                    # If still ambiguous, aim the seat toward the steering wheel (even if not adjacent).
                    if facing == "down":
                        try:
                            rpos = self._rv_int_find("R")
                        except Exception:
                            rpos = None
                        if isinstance(rpos, tuple) and len(rpos) == 2:
                            rx, ry = int(rpos[0]), int(rpos[1])
                            dx = int(rx) - int(x)
                            dy = int(ry) - int(y)
                            # Only affect seats reasonably close to the cockpit.
                            if abs(int(dx)) + abs(int(dy)) <= 8:
                                if abs(int(dx)) > abs(int(dy)):
                                    facing = "right" if int(dx) > 0 else "left"
                                else:
                                    facing = "down" if int(dy) > 0 else "up"

                    seat_surf = pygame.Surface((int(tile), int(tile)), pygame.SRCALPHA)
                    back = pygame.Rect(4, 5, int(tile) - 8, 7)
                    base = pygame.Rect(4, 11, int(tile) - 8, 6)
                    pygame.draw.rect(seat_surf, seat2, back, border_radius=3)
                    pygame.draw.rect(seat_surf, outline, back, 1, border_radius=3)
                    pygame.draw.rect(seat_surf, seat, base, border_radius=3)
                    pygame.draw.rect(seat_surf, outline, base, 1, border_radius=3)
                    pygame.draw.rect(
                        seat_surf,
                        self._tint(seat, add=(16, 16, 16)),
                        pygame.Rect(int(base.x + 1), int(base.y + 1), int(base.w - 2), 2),
                        border_radius=2,
                    )

                    arm_l = pygame.Rect(int(base.x - 1), int(base.y - 1), 3, 3)
                    arm_r = pygame.Rect(int(base.right - 2), int(base.y - 1), 3, 3)
                    pygame.draw.rect(seat_surf, seat2, arm_l, border_radius=2)
                    pygame.draw.rect(seat_surf, seat2, arm_r, border_radius=2)
                    pygame.draw.rect(seat_surf, outline, arm_l, 1, border_radius=2)
                    pygame.draw.rect(seat_surf, outline, arm_r, 1, border_radius=2)

                    head = pygame.Rect(int(back.centerx - 3), int(back.y - 3), 6, 3)
                    pygame.draw.rect(seat_surf, seat2, head, border_radius=2)
                    pygame.draw.rect(seat_surf, outline, head, 1, border_radius=2)

                    floor_y = int(tile - 3)
                    leg_y0 = int(base.bottom - 1)
                    leg_h = int(floor_y - leg_y0)
                    if leg_h > 0:
                        leg_col = self._tint(seat2, add=(-24, -24, -24))
                        for lx in (int(base.x + 2), int(base.right - 4)):
                            leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                            seat_surf.fill(leg_col, leg)
                            pygame.draw.rect(seat_surf, outline, leg, 1)

                    if facing == "up":
                        seat_surf = pygame.transform.rotate(seat_surf, 180)
                    elif facing == "left":
                        seat_surf = pygame.transform.rotate(seat_surf, 90)
                    elif facing == "right":
                        seat_surf = pygame.transform.rotate(seat_surf, -90)
                    surface.blit(seat_surf, r.topleft)
                    continue

        if getattr(self, "rv_edit_mode", False):
            blocks = getattr(self, "rv_edit_blocks", None)
            if isinstance(blocks, list) and blocks:
                sel_i = int(getattr(self, "rv_edit_index", 0)) % len(blocks)
                _ch, cells = blocks[sel_i]
                min_x = min(int(p[0]) for p in cells)
                max_x = max(int(p[0]) for p in cells)
                min_y = min(int(p[1]) for p in cells)
                max_y = max(int(p[1]) for p in cells)
                sel = pygame.Rect(
                    int(map_x + min_x * tile),
                    int(map_y + min_y * tile),
                    int((max_x - min_x + 1) * tile),
                    int((max_y - min_y + 1) * tile),
                )
                ov = pygame.Surface((sel.w, sel.h), pygame.SRCALPHA)
                ov.fill((255, 220, 140, 50))
                pygame.draw.rect(ov, (255, 220, 140, 120), ov.get_rect(), 2, border_radius=8)
                surface.blit(ov, sel.topleft)

        face = pygame.Vector2(self.rv_int_facing)
        if face.length_squared() <= 0.001:
            face = pygame.Vector2(0, 1)
        if abs(face.y) >= abs(face.x):
            d = "down" if face.y >= 0 else "up"
        else:
            d = "right" if face.x >= 0 else "left"
        pose = str(getattr(self, "player_pose", "")).strip()
        pose_space = str(getattr(self, "player_pose_space", "")).strip()
        pose_anchor = getattr(self, "player_pose_anchor", None)
        use_pose = bool(pose and pose_space == "rv" and pose_anchor is not None)
        if use_pose:
            p = pygame.Vector2(float(pose_anchor[0]), float(pose_anchor[1]))
            if pose == "sleep":
                frame = int(float(getattr(self, "player_pose_phase", 0.0)) * 2.0) % 2
                base = self._get_pose_sprite("sleep", frame=frame)
            else:
                base = self._get_pose_sprite("sit", direction=d, frame=0)
        else:
            p = pygame.Vector2(self.rv_int_pos)
            speed2 = float(self.rv_int_vel.length_squared())
            pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
            pf_run = getattr(self, "player_frames_run", None)
            is_run = bool(getattr(self, "player_sprinting", False))
            pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
            frames = pf.get(d, pf["down"])
            if speed2 <= 0.2 or len(frames) <= 1:
                base = frames[0]
            else:
                walk = frames[1:]
                phase = (float(self.rv_int_walk_phase) % math.tau) / math.tau
                idx = int(phase * len(walk)) % len(walk)
                base = walk[idx]

        scale = int(max(1, int(self._RV_INT_SPRITE_SCALE)))
        spr = pygame.transform.scale(base, (int(base.get_width()) * scale, int(base.get_height()) * scale))
        sx = int(round(map_x + p.x))
        sy = int(round(map_y + p.y))
        if use_pose and pose == "sleep":
            shadow = pygame.Rect(0, 0, 20, 8)
            shadow.center = (sx, sy + 4)
            sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
            pygame.draw.ellipse(sh, (0, 0, 0, 90), sh.get_rect())
            surface.blit(sh, shadow.topleft)
            rect = spr.get_rect(center=(sx, sy + 2))
            surface.blit(spr, rect)
            self._last_player_screen_rect = pygame.Rect(rect)
        elif use_pose and pose == "sit":
            shadow = pygame.Rect(0, 0, 16, 7)
            shadow.center = (sx, sy + 6)
            sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
            pygame.draw.ellipse(sh, (0, 0, 0, 110), sh.get_rect())
            surface.blit(sh, shadow.topleft)
            rect = spr.get_rect(center=(sx, sy + 4))
            surface.blit(spr, rect)
            self._last_player_screen_rect = pygame.Rect(rect)
        else:
            shadow = pygame.Rect(0, 0, 14, 6)
            shadow.center = (sx, sy + 8)
            sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
            pygame.draw.ellipse(sh, (0, 0, 0, 120), sh.get_rect())
            surface.blit(sh, shadow.topleft)
            rect = spr.get_rect()
            rect.midbottom = (sx, sy + 12)
            surface.blit(spr, rect)
            self._last_player_screen_rect = pygame.Rect(rect)

        # Hover: furniture details + outline.
        mouse = None
        if (
            not self.inv_open
            and not bool(getattr(self, "rv_ui_open", False))
            and not bool(getattr(self, "world_map_open", False))
        ):
            mouse = self.app.screen_to_internal(pygame.mouse.get_pos())
        if mouse is not None:
            mx, my = int(mouse[0]), int(mouse[1])
            if map_rect.collidepoint(mx, my):
                ix = int((mx - int(map_x)) // int(tile))
                iy = int((my - int(map_y)) // int(tile))
                ch = str(self._rv_int_char_at(ix, iy))[:1]
                movable = {"B", "S", "K", "H", "T", "C"}
                if ch in movable:
                    w = int(self._RV_INT_W)
                    h = int(self._RV_INT_H)
                    seen: set[tuple[int, int]] = set()
                    stack = [(int(ix), int(iy))]
                    cells: list[tuple[int, int]] = []
                    while stack:
                        cx, cy = stack.pop()
                        cx = int(cx)
                        cy = int(cy)
                        if (cx, cy) in seen:
                            continue
                        if not (0 <= cx < w and 0 <= cy < h):
                            continue
                        if str(self._rv_int_char_at(cx, cy))[:1] != ch:
                            continue
                        seen.add((cx, cy))
                        cells.append((cx, cy))
                        stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
                    if cells:
                        min_x = min(int(p[0]) for p in cells)
                        max_x = max(int(p[0]) for p in cells)
                        min_y = min(int(p[1]) for p in cells)
                        max_y = max(int(p[1]) for p in cells)
                        sel = pygame.Rect(
                            int(map_x + min_x * tile),
                            int(map_y + min_y * tile),
                            int((max_x - min_x + 1) * tile),
                            int((max_y - min_y + 1) * tile),
                        )
                        ov = pygame.Surface((sel.w, sel.h), pygame.SRCALPHA)
                        ov.fill((255, 220, 140, 20))
                        pygame.draw.rect(ov, (255, 220, 140, 150), ov.get_rect(), 2, border_radius=8)
                        surface.blit(ov, sel.topleft)

                        meta: dict[str, tuple[str, str]] = {
                            "B": ("床", "躺下可恢复体力与心情"),
                            "S": ("储物柜", "打开后可存取物资"),
                            "T": ("桌子", "临时放置/整理物品（规划）"),
                            "K": ("厨房", "台面上有锅碗瓢盆（烹饪/净水规划）"),
                            "H": ("工作台", "枪械加工/修理（规划）"),
                            "C": ("座椅", "乘坐休息（规划）"),
                        }
                        name, desc = meta.get(ch, ("家具", ""))
                        if bool(getattr(self, "rv_edit_mode", False)):
                            hint = "左键拖拽 | 方向键微调 | R 退出摆放"
                        else:
                            hint = "R 进入摆放模式 | 左键拖拽"
                        self._hover_tooltip = ([str(name), str(desc), str(hint)], (mx, my))
        return

        floor_a = (64, 62, 58)
        floor_b = (58, 56, 52)
        wall = (22, 22, 26)
        wall_hi = (38, 38, 46)
        bed = (170, 150, 140)
        bed2 = (128, 108, 100)
        shelf = (92, 78, 62)
        shelf2 = (66, 56, 46)
        table = (88, 72, 54)
        table2 = (60, 50, 38)
        seat = (56, 72, 140)
        seat2 = (40, 52, 112)
        kitchen = (86, 78, 68)
        kitchen2 = (60, 54, 46)
        steel = (220, 220, 230)
        work = (96, 84, 66)
        work2 = (62, 54, 42)
        tool = (150, 150, 160)
        door = (240, 220, 140)

        # Window "outside view" cache (small stylized sky/ground) so the RV
        # interior feels like a real space with windows.
        daylight, tday = self._daylight_amount()
        season = self._season_index()
        wkind = str(getattr(self, "weather_kind", "clear"))
        inten = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))

        def _lerp(a: float, b: float, t: float) -> float:
            return float(a + (b - a) * t)

        def _lerp_c(a: tuple[int, int, int], b: tuple[int, int, int], t: float) -> tuple[int, int, int]:
            return (
                int(round(_lerp(float(a[0]), float(b[0]), t))),
                int(round(_lerp(float(a[1]), float(b[1]), t))),
                int(round(_lerp(float(a[2]), float(b[2]), t))),
            )

        def _mul_c(c: tuple[int, int, int], m: float) -> tuple[int, int, int]:
            return (
                int(clamp(int(round(float(c[0]) * m)), 0, 255)),
                int(clamp(int(round(float(c[1]) * m)), 0, 255)),
                int(clamp(int(round(float(c[2]) * m)), 0, 255)),
            )

        glass_w = max(4, int(tile - 6))
        glass_h = max(4, int(tile - 8))
        tbin = int(clamp(int(tday * 64.0), 0, 63))
        dbin = int(clamp(int(daylight * 16.0), 0, 16))
        ibin = int(clamp(int(inten * 10.0), 0, 10))
        wkey = (glass_w, glass_h, int(season), str(wkind), int(tbin), int(dbin), int(ibin))

        win_view: pygame.Surface | None = getattr(self, "_rv_win_view_cache", None)
        if (
            win_view is None
            or getattr(self, "_rv_win_view_cache_key", None) != wkey
            or win_view.get_width() != glass_w
            or win_view.get_height() != glass_h
        ):
            day_sky_top = (78, 146, 224)
            day_sky_bot = (166, 214, 252)
            night_sky_top = (8, 10, 18)
            night_sky_bot = (24, 28, 44)
            sky_top = _lerp_c(night_sky_top, day_sky_top, float(daylight))
            sky_bot = _lerp_c(night_sky_bot, day_sky_bot, float(daylight))

            gloom = 1.0
            if wkind == "cloudy":
                gloom = 1.0 - 0.22 * inten
            elif wkind == "rain":
                gloom = 1.0 - 0.30 * inten
            elif wkind == "storm":
                gloom = 1.0 - 0.44 * inten
            elif wkind == "snow":
                gloom = 1.0 - 0.18 * inten
            sky_top = _mul_c(sky_top, gloom)
            sky_bot = _mul_c(sky_bot, gloom)
            if wkind == "snow" and inten > 0.05:
                sky_top = _lerp_c(sky_top, (200, 210, 230), 0.18 * inten)
                sky_bot = _lerp_c(sky_bot, (230, 240, 250), 0.24 * inten)

            if season == 0:  # spring
                ground = (74, 150, 78)
            elif season == 1:  # summer
                ground = (58, 135, 66)
            elif season == 2:  # autumn
                ground = (122, 118, 70)
            else:  # winter
                ground = (160, 162, 176)
            ground = _mul_c(ground, 0.85 + 0.15 * daylight)
            if wkind == "snow" and inten > 0.15:
                ground = _lerp_c(ground, (210, 214, 224), 0.45 * inten)

            base = pygame.Surface((glass_w, glass_h))
            for yy in range(int(glass_h)):
                t = float(yy) / max(1.0, float(glass_h - 1))
                base.fill(_lerp_c(sky_top, sky_bot, t), pygame.Rect(0, int(yy), int(glass_w), 1))
            gh = max(3, int(glass_h // 3))
            base.fill(ground, pygame.Rect(0, int(glass_h - gh), int(glass_w), int(gh)))
            base.fill((16, 16, 22), pygame.Rect(0, int(glass_h - gh), int(glass_w), 1))

            # Dawn / dusk warm stripe near horizon.
            if 0.0 < daylight < 1.0:
                warm = (220, 150, 96) if tday < 0.5 else (226, 140, 86)
                warm_y = int(glass_h - gh - 2)
                if 0 <= warm_y < glass_h:
                    base.fill(_mul_c(warm, 0.65), pygame.Rect(0, warm_y, int(glass_w), 1))

            # Tiny silhouettes (reads as distant trees/buildings).
            if glass_w >= 10 and glass_h >= 8:
                base.fill((18, 18, 22), pygame.Rect(2, int(glass_h - gh - 3), 2, 3))
                base.fill((18, 18, 22), pygame.Rect(int(glass_w - 5), int(glass_h - gh - 4), 3, 4))

            win_view = pygame.Surface((glass_w, glass_h), pygame.SRCALPHA)
            win_view.blit(base, (0, 0))
            tint = pygame.Surface((glass_w, glass_h), pygame.SRCALPHA)
            tint.fill((60, 86, 120, 55))
            pygame.draw.line(tint, (240, 244, 255, 70), (1, 1), (int(glass_w - 2), 1), 1)
            pygame.draw.line(tint, (210, 220, 240, 45), (1, 2), (int(glass_w - 3), 2), 1)
            win_view.blit(tint, (0, 0))
            self._rv_win_view_cache = win_view
            self._rv_win_view_cache_key = wkey

        bed_done: set[tuple[int, int]] = set()
        for y, row in enumerate(self._RV_INT_LAYOUT):
            for x in range(int(self._RV_INT_W)):
                ch = row[x] if x < len(row) else "W"
                r = pygame.Rect(map_x + x * tile, map_y + y * tile, tile, tile)
                if ch in ("W", "V"):
                    pygame.draw.rect(surface, wall, r)
                    pygame.draw.rect(surface, wall_hi, pygame.Rect(r.x, r.y, r.w, 3))
                    pygame.draw.rect(surface, (0, 0, 0), r, 1)
                    if ch == "V":
                        glass = pygame.Rect(r.x + 3, r.y + 4, r.w - 6, r.h - 8)
                        if win_view is not None and glass.w > 0 and glass.h > 0:
                            wv = win_view
                            if wv.get_width() != glass.w or wv.get_height() != glass.h:
                                wv = pygame.transform.scale(wv, (int(glass.w), int(glass.h)))
                            surface.blit(wv, glass.topleft)
                        pygame.draw.rect(surface, (10, 10, 12), glass, 1)
                        pygame.draw.line(
                            surface,
                            (40, 40, 50),
                            (glass.centerx, glass.top + 1),
                            (glass.centerx, glass.bottom - 2),
                            1,
                        )
                    continue

                col = floor_a if ((x + y) % 2 == 0) else floor_b
                pygame.draw.rect(surface, col, r)
                pygame.draw.rect(surface, (0, 0, 0), r, 1)

                if ch == "D":
                    pygame.draw.rect(surface, door, pygame.Rect(r.right - 4, r.y + 3, 3, r.h - 6))
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.right - 4, r.y + 3, 3, r.h - 6), 1)
                elif ch == "B":
                    if (int(x), int(y)) in bed_done:
                        continue

                    # Find the full bed block (contiguous 'B's) and draw as one object
                    # so it reads clearly as a single bed.
                    bw = 1
                    while self._rv_int_char_at(int(x) + int(bw), int(y)) == "B":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._rv_int_char_at(int(x), int(ny)) != "B":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._rv_int_char_at(int(x) + int(dx), int(ny)) != "B":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1

                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            bed_done.add((int(x) + int(dx), int(y) + int(dy)))

                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    bed_r = pygame.Rect(br.x + 2, br.y + 3, br.w - 4, br.h - 6)
                    pygame.draw.rect(surface, bed, bed_r, border_radius=4)
                    pygame.draw.rect(surface, (10, 10, 12), bed_r, 1, border_radius=4)

                    # Pillow + blanket band.
                    pillow_w = int(clamp(int(bed_r.w // 3), 8, max(8, bed_r.w - 4)))
                    pillow = pygame.Rect(bed_r.x + 2, bed_r.y + 2, pillow_w, 6)
                    pygame.draw.rect(surface, (230, 230, 235), pillow, border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pillow, 1, border_radius=2)
                    pygame.draw.rect(surface, bed2, pygame.Rect(bed_r.x + 2, bed_r.y + 10, bed_r.w - 4, 6), border_radius=2)

                    for sx in range(bed_r.x + 6, bed_r.right - 4, 6):
                        pygame.draw.line(surface, (10, 10, 12), (sx, bed_r.y + 11), (sx, bed_r.y + 15), 1)
                    continue
                elif ch == "S":
                    pygame.draw.rect(surface, shelf, pygame.Rect(r.x + 3, r.y + 3, r.w - 6, r.h - 6), border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 3, r.y + 3, r.w - 6, r.h - 6), 1, border_radius=2)
                    pygame.draw.line(surface, shelf2, (r.x + 4, r.y + r.h // 2), (r.right - 5, r.y + r.h // 2), 2)
                elif ch == "T":
                    pygame.draw.rect(surface, table, pygame.Rect(r.x + 3, r.y + 6, r.w - 6, r.h - 10), border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 3, r.y + 6, r.w - 6, r.h - 10), 1, border_radius=2)
                    pygame.draw.rect(surface, table2, pygame.Rect(r.x + 4, r.y + 8, r.w - 8, 3))
                elif ch == "K":
                    pygame.draw.rect(surface, kitchen, pygame.Rect(r.x + 2, r.y + 5, r.w - 4, r.h - 8), border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 2, r.y + 5, r.w - 4, r.h - 8), 1, border_radius=2)
                    pygame.draw.rect(surface, kitchen2, pygame.Rect(r.x + 3, r.y + 7, r.w - 6, 3))
                    # Sink / stove hints.
                    if x % 2 == 0:
                        pygame.draw.rect(surface, steel, pygame.Rect(r.x + 6, r.y + 6, 6, 4), border_radius=1)
                        pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 6, r.y + 6, 6, 4), 1, border_radius=1)
                        pygame.draw.circle(surface, (40, 40, 50), (r.x + 9, r.y + 8), 1)
                    else:
                        pygame.draw.rect(surface, steel, pygame.Rect(r.x + 5, r.y + 6, 8, 4), border_radius=1)
                        pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 5, r.y + 6, 8, 4), 1, border_radius=1)
                        pygame.draw.circle(surface, (40, 40, 50), (r.x + 7, r.y + 8), 1)
                        pygame.draw.circle(surface, (40, 40, 50), (r.x + 11, r.y + 8), 1)
                elif ch == "H":
                    pygame.draw.rect(surface, work, pygame.Rect(r.x + 2, r.y + 6, r.w - 4, r.h - 9), border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 2, r.y + 6, r.w - 4, r.h - 9), 1, border_radius=2)
                    pygame.draw.rect(surface, work2, pygame.Rect(r.x + 3, r.y + 8, r.w - 6, 3))
                    # Tools.
                    pygame.draw.line(surface, tool, (r.x + 5, r.y + 6), (r.x + 12, r.y + 10), 1)
                    pygame.draw.line(surface, (10, 10, 12), (r.x + 5, r.y + 6), (r.x + 12, r.y + 10), 1)
                    pygame.draw.rect(surface, tool, pygame.Rect(r.x + 5, r.y + 11, 5, 2), border_radius=1)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 5, r.y + 11, 5, 2), 1, border_radius=1)
                elif ch == "C":
                    pygame.draw.rect(surface, seat, pygame.Rect(r.x + 4, r.y + 4, r.w - 8, r.h - 8), border_radius=3)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 4, r.y + 4, r.w - 8, r.h - 8), 1, border_radius=3)
                    pygame.draw.rect(surface, seat2, pygame.Rect(r.x + 6, r.y + 6, r.w - 12, 4))

        p = pygame.Vector2(self.rv_int_pos)
        speed2 = float(self.rv_int_vel.length_squared())
        face = pygame.Vector2(self.rv_int_facing)
        if face.length_squared() <= 0.001:
            face = pygame.Vector2(0, 1)
        if abs(face.y) >= abs(face.x):
            d = "down" if face.y >= 0 else "up"
        else:
            d = "right" if face.x >= 0 else "left"
        pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
        pf_run = getattr(self, "player_frames_run", None)
        is_run = bool(getattr(self, "player_sprinting", False))
        pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
        frames = pf.get(d, pf["down"])
        if speed2 <= 0.2 or len(frames) <= 1:
            base = frames[0]
        else:
            walk = frames[1:]
            phase = (float(self.rv_int_walk_phase) % math.tau) / math.tau
            idx = int(phase * len(walk)) % len(walk)
            base = walk[idx]

        scale = int(max(1, int(self._RV_INT_SPRITE_SCALE)))
        spr = pygame.transform.scale(base, (int(base.get_width()) * scale, int(base.get_height()) * scale))
        sx = int(round(map_x + p.x))
        sy = int(round(map_y + p.y))
        shadow = pygame.Rect(0, 0, 14, 6)
        shadow.center = (sx, sy + 8)
        pygame.draw.ellipse(surface, (0, 0, 0), shadow)
        rect = spr.get_rect()
        rect.midbottom = (sx, sy + 12)
        surface.blit(spr, rect)
        self._last_player_screen_rect = pygame.Rect(rect)
        self._last_player_screen_rect = pygame.Rect(rect)

    def _draw_house_interior_scene(self, surface: pygame.Surface) -> None:
        surface.fill((10, 10, 14))
        tile = int(self._HOUSE_INT_TILE_SIZE)
        map_w = int(self._HOUSE_INT_W) * tile
        map_h = int(self._HOUSE_INT_H) * tile
        map_x = (INTERNAL_W - map_w) // 2
        map_y = 38
        panel = pygame.Rect(map_x - 10, map_y - 10, map_w + 20, map_h + 20)
        # Panel (pixel style)
        pygame.draw.rect(surface, (70, 70, 86), panel.inflate(4, 4))
        pygame.draw.rect(surface, (18, 18, 22), panel)

        floor = int(getattr(self, "house_floor", 1))
        max_f = int(max(1, int(getattr(self, "house_max_floors", int(self._HOUSE_INT_MAX_FLOORS_DEFAULT)))))
        subtitle = f"{floor}F/{max_f}F" if max_f > 1 else f"{floor}F"
        draw_text(
            surface,
            self.app.font_s,
            f"住宅 - {subtitle}",
            (INTERNAL_W // 2, panel.top - 14),
            pygame.Color(240, 240, 240),
            anchor="center",
        )

        map_rect = pygame.Rect(map_x, map_y, map_w, map_h)
        surface.blit(self._interior_floor_surface(map_w, map_h, kind="home"), map_rect.topleft)

        wall = (26, 26, 32)
        wall_hi = (56, 56, 70)
        wall_edge = (12, 12, 16)
        frame = (88, 80, 70)
        outline = (10, 10, 12)

        wood = (98, 78, 56)
        wood2 = (74, 58, 42)
        steel = (216, 220, 228)
        steel2 = (134, 140, 152)

        bed_matt = (186, 170, 156)
        bed_blank = (142, 128, 170)
        pillow = (238, 238, 244)

        wkind = str(getattr(self, "weather_kind", "clear"))
        inten = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))
        win_view = self._window_view_surface(max(4, int(tile - 6)), max(4, int(tile - 8)))

        done: set[tuple[int, int]] = set()

        def block_size(x: int, y: int, ch: str) -> tuple[int, int]:
            bw = 1
            while self._house_int_char_at(int(x) + int(bw), int(y)) == ch:
                bw += 1
            bh = 1
            while True:
                ny = int(y) + int(bh)
                if self._house_int_char_at(int(x), int(ny)) != ch:
                    break
                ok = True
                for dx in range(int(bw)):
                    if self._house_int_char_at(int(x) + int(dx), int(ny)) != ch:
                        ok = False
                        break
                if not ok:
                    break
                bh += 1
            return int(bw), int(bh)

        for y in range(int(self._HOUSE_INT_H)):
            for x in range(int(self._HOUSE_INT_W)):
                ch = self._house_int_char_at(x, y)
                r = pygame.Rect(map_x + x * tile, map_y + y * tile, tile, tile)

                if ch in ("W", "V", "D"):
                    pygame.draw.rect(surface, wall, r)
                    pygame.draw.rect(surface, wall_hi, pygame.Rect(r.x, r.y, r.w, 4))
                    pygame.draw.rect(surface, wall_edge, r, 1)
                    pygame.draw.rect(surface, wood2, pygame.Rect(r.x, r.bottom - 4, r.w, 2))

                    if ch == "V":
                        glass = pygame.Rect(r.x + 3, r.y + 4, r.w - 6, r.h - 8)
                        wv = win_view
                        if wv.get_width() != glass.w or wv.get_height() != glass.h:
                            wv = pygame.transform.scale(wv, (int(glass.w), int(glass.h)))
                        surface.blit(wv, glass.topleft)
                        if wkind in ("rain", "storm", "snow"):
                            self._draw_window_precip(surface, glass, kind=wkind, intensity=inten)
                        # Window frame (pixel style)
                        pygame.draw.rect(surface, frame, glass.inflate(4, 4), 1)
                        pygame.draw.rect(surface, outline, glass, 1)
                        pygame.draw.line(surface, (40, 40, 50), (glass.centerx, glass.top + 1), (glass.centerx, glass.bottom - 2), 1)
                    elif ch == "D":
                        # Door (pixel style)
                        dr = pygame.Rect(r.x + 5, r.y + 4, r.w - 10, r.h - 8)
                        pygame.draw.rect(surface, outline, dr.inflate(2, 2))
                        pygame.draw.rect(surface, (240, 220, 140), dr)
                        pygame.draw.rect(surface, outline, pygame.Rect(dr.right - 6, dr.centery - 2, 4, 4))
                    continue

                if ch in ("^", "v"):
                    if (x, y) in done:
                        continue
                    bw, bh = block_size(x, y, ch)
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    inner = br.inflate(-4, -4)
                    # Stairs (pixel style)
                    pygame.draw.rect(surface, outline, inner.inflate(2, 2))
                    pygame.draw.rect(surface, steel, inner)
                    pygame.draw.rect(surface, steel2, pygame.Rect(inner.x + 3, inner.y + 3, inner.w - 6, 3))
                    cx = int(inner.centerx)
                    cy = int(inner.centery)
                    if ch == "^":
                        pts = [(cx, cy - 6), (cx - 6, cy + 4), (cx + 6, cy + 4)]
                    else:
                        pts = [(cx, cy + 6), (cx - 6, cy - 4), (cx + 6, cy - 4)]
                    pygame.draw.polygon(surface, (240, 220, 140), pts)
                    pygame.draw.polygon(surface, outline, pts, 1)
                    continue

                if ch in ("B", "S", "F", "K", "T") and (x, y) not in done:
                    bw, bh = block_size(x, y, ch)
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    er = br.inflate(-4, -4)

                    if ch == "B":
                        # Bed frame (pixel style)
                        pygame.draw.rect(surface, outline, er.inflate(2, 2))
                        pygame.draw.rect(surface, wood2, er)
                        matt = er.inflate(-4, -4)
                        pygame.draw.rect(surface, outline, matt.inflate(2, 2))
                        pygame.draw.rect(surface, bed_matt, matt)
                        blank = pygame.Rect(matt.x, matt.y + matt.h // 2, matt.w, matt.h // 2)
                        pygame.draw.rect(surface, outline, blank.inflate(2, 2))
                        pygame.draw.rect(surface, bed_blank, blank)
                        pil = pygame.Rect(matt.x + 2, matt.y + 2, 8, 6)
                        pygame.draw.rect(surface, outline, pil.inflate(2, 2))
                        pygame.draw.rect(surface, pillow, pil)
                    elif ch == "S":
                        # Sofa (pixel style)
                        pygame.draw.rect(surface, outline, er.inflate(2, 2))
                        pygame.draw.rect(surface, (72, 80, 108), er)
                        for yy in range(er.y + 6, er.bottom - 6, 6):
                            pygame.draw.line(surface, (40, 40, 50), (er.x + 2, yy), (er.right - 3, yy), 1)
                        handle = pygame.Rect(er.x + 3, er.y + 3, 4, 3)
                        pygame.draw.rect(surface, outline, handle.inflate(2, 2))
                        pygame.draw.rect(surface, (210, 180, 110), handle)
                    elif ch == "F":
                        # Fridge (pixel style)
                        pygame.draw.rect(surface, outline, er.inflate(2, 2))
                        pygame.draw.rect(surface, (236, 236, 242), er)
                        top_rect = pygame.Rect(er.x + 2, er.y + 2, er.w - 4, 4)
                        pygame.draw.rect(surface, (200, 200, 210), top_rect)
                        pygame.draw.rect(surface, outline, top_rect, 1)
                        pygame.draw.line(surface, outline, (er.x + 6, er.y + 6), (er.x + 6, er.bottom - 6), 1)
                    elif ch == "K":
                        # Kitchen (pixel style)
                        pygame.draw.rect(surface, outline, er.inflate(2, 2))
                        pygame.draw.rect(surface, (62, 66, 74), er)
                        top_rect = pygame.Rect(er.x + 2, er.y + 2, er.w - 4, 4)
                        pygame.draw.rect(surface, (96, 102, 112), top_rect)
                        pygame.draw.rect(surface, outline, top_rect, 1)
                        stove = pygame.Rect(er.x + 6, er.y + 6, 8, 6)
                        pygame.draw.rect(surface, outline, stove.inflate(2, 2))
                        pygame.draw.rect(surface, (18, 18, 22), stove)
                    else:  # T - Table
                        pygame.draw.rect(surface, outline, er.inflate(2, 2))
                        pygame.draw.rect(surface, wood, er)
                        top = pygame.Rect(er.x + 2, er.y + 2, er.w - 4, 4)
                        pygame.draw.rect(surface, wood2, top)
                        pygame.draw.rect(surface, outline, top, 1)
                        # Legs
                        pygame.draw.rect(surface, wood2, pygame.Rect(er.x + 3, er.bottom - 5, 2, 4))
                        pygame.draw.rect(surface, wood2, pygame.Rect(er.right - 5, er.bottom - 5, 2, 4))
                    continue

                # Bathroom door (small door to bathroom)
                if ch == "d":
                    # Draw wall background first
                    pygame.draw.rect(surface, wall, r)
                    pygame.draw.rect(surface, wall_hi, pygame.Rect(r.x, r.y, r.w, 4))
                    pygame.draw.rect(surface, wall_edge, r, 1)
                    # Door (pixel style)
                    dr = pygame.Rect(r.x + 4, r.y + 3, r.w - 8, r.h - 5)
                    pygame.draw.rect(surface, outline, dr.inflate(2, 2))
                    pygame.draw.rect(surface, (180, 160, 130), dr)
                    # Door handle
                    pygame.draw.rect(surface, outline, pygame.Rect(dr.right - 5, dr.centery - 1, 3, 3))
                    continue

                # Bathroom floor tile
                if ch == ",":
                    bath_floor = pygame.Rect(r.x + 1, r.y + 1, r.w - 2, r.h - 2)
                    pygame.draw.rect(surface, (180, 190, 200), bath_floor)
                    pygame.draw.rect(surface, outline, bath_floor, 1)
                    continue

                # Toilet
                if ch == "O":
                    # Bowl base (pixel style)
                    bowl = pygame.Rect(r.x + 4, r.y + 6, r.w - 8, r.h - 8)
                    pygame.draw.rect(surface, outline, bowl.inflate(2, 2))
                    pygame.draw.rect(surface, (240, 240, 245), bowl)
                    # Tank
                    tank = pygame.Rect(r.x + 6, r.y + 2, r.w - 12, 6)
                    pygame.draw.rect(surface, outline, tank.inflate(2, 2))
                    pygame.draw.rect(surface, (230, 230, 238), tank)
                    # Seat
                    seat = pygame.Rect(bowl.x + 2, bowl.y + 2, bowl.w - 4, bowl.h - 4)
                    pygame.draw.rect(surface, (200, 200, 210), seat)
                    continue

                # Shower
                if ch == "R":
                    # Shower base (pixel style)
                    base = pygame.Rect(r.x + 2, r.y + 2, r.w - 4, r.h - 4)
                    pygame.draw.rect(surface, outline, base.inflate(2, 2))
                    pygame.draw.rect(surface, (160, 170, 185), base)
                    # Drain
                    drain = pygame.Rect(base.centerx - 3, base.centery - 3, 6, 6)
                    pygame.draw.rect(surface, (80, 85, 95), drain)
                    pygame.draw.rect(surface, outline, drain, 1)
                    # Shower head indicator
                    head = pygame.Rect(base.x + 2, base.y + 2, 4, 4)
                    pygame.draw.rect(surface, steel, head)
                    continue

        p = pygame.Vector2(self.house_int_pos)
        speed2 = float(getattr(self, "house_int_vel", pygame.Vector2(0, 0)).length_squared())
        face = pygame.Vector2(self.house_int_facing)
        if face.length_squared() <= 0.001:
            face = pygame.Vector2(0, 1)
        if abs(face.y) >= abs(face.x):
            d = "down" if face.y >= 0 else "up"
        else:
            d = "right" if face.x >= 0 else "left"
        pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
        pf_run = getattr(self, "player_frames_run", None)
        is_run = bool(getattr(self, "player_sprinting", False))
        pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
        frames = pf.get(d, pf["down"])
        if speed2 <= 0.2 or len(frames) <= 1:
            base = frames[0]
        else:
            walk = frames[1:]
            phase = (float(self.house_int_walk_phase) % math.tau) / math.tau
            idx = int(phase * len(walk)) % len(walk)
            base = walk[idx]

        scale = int(max(1, int(self._HOUSE_INT_SPRITE_SCALE)))
        spr = pygame.transform.scale(base, (int(base.get_width()) * scale, int(base.get_height()) * scale))
        sx = int(round(map_x + p.x))
        sy = int(round(map_y + p.y))
        shadow = pygame.Rect(0, 0, 14, 6)
        shadow.center = (sx, sy + 8)
        pygame.draw.ellipse(surface, (0, 0, 0), shadow)
        rect = spr.get_rect()
        rect.midbottom = (sx, sy + 12)
        surface.blit(spr, rect)

    def _draw_sch_interior_scene(self, surface: pygame.Surface) -> None:
        surface.fill((10, 10, 14))
        tile = int(self._SCH_INT_TILE_SIZE)
        map_w = int(self._SCH_INT_W) * tile
        map_h = int(self._SCH_INT_H) * tile
        map_x = (INTERNAL_W - map_w) // 2
        map_y = 38
        panel = pygame.Rect(map_x - 10, map_y - 10, map_w + 20, map_h + 20)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (70, 70, 86), panel, 2, border_radius=12)

        floor = int(getattr(self, "sch_floor", 1))
        subtitle = "大厅" if floor <= 1 else f"{floor}F"
        draw_text(
            surface,
            self.app.font_s,
            f"学校 - {subtitle}",
            (INTERNAL_W // 2, panel.top - 14),
            pygame.Color(240, 240, 240),
            anchor="center",
        )

        map_rect = pygame.Rect(map_x, map_y, map_w, map_h)
        surface.blit(self._interior_floor_surface(map_w, map_h, kind="school"), map_rect.topleft)

        wall = (26, 26, 32)
        wall_hi = (54, 54, 68)
        edge = (12, 12, 16)
        locker = (78, 90, 96)
        locker_hi = (110, 128, 136)
        desk = (96, 78, 56)
        desk_hi = (140, 116, 86)
        elev = (62, 62, 72)
        elev_hi = (100, 100, 116)
        stairs = (56, 60, 74)
        stairs_hi = (92, 98, 120)
        door = (96, 70, 46)
        door_hi = (132, 100, 68)

        for y in range(int(self._SCH_INT_H)):
            for x in range(int(self._SCH_INT_W)):
                ch = self._sch_int_char_at(x, y)
                r = pygame.Rect(map_x + x * tile, map_y + y * tile, tile, tile)
                if ch == "W":
                    pygame.draw.rect(surface, wall, r)
                    pygame.draw.rect(surface, edge, r, 1)
                    pygame.draw.line(surface, wall_hi, (r.left + 1, r.top + 1), (r.right - 2, r.top + 1), 1)
                elif ch == "V":
                    view = self._window_view_surface(tile - 6, tile - 6)
                    surface.blit(view, (r.x + 3, r.y + 3))
                    pygame.draw.rect(surface, (20, 20, 26), pygame.Rect(r.x + 2, r.y + 2, tile - 4, tile - 4), 1)
                    pygame.draw.rect(surface, (70, 70, 86), pygame.Rect(r.x + 1, r.y + 1, tile - 2, tile - 2), 1)
                elif ch == "L":
                    pygame.draw.rect(surface, locker, pygame.Rect(r.x + 3, r.y + 2, tile - 6, tile - 4), border_radius=2)
                    pygame.draw.rect(surface, edge, pygame.Rect(r.x + 3, r.y + 2, tile - 6, tile - 4), 1, border_radius=2)
                    pygame.draw.rect(surface, locker_hi, pygame.Rect(r.x + 4, r.y + 4, tile - 8, 3))
                    pygame.draw.line(surface, edge, (r.x + tile // 2, r.y + 3), (r.x + tile // 2, r.y + tile - 3), 1)
                elif ch == "T":
                    pygame.draw.rect(surface, desk, pygame.Rect(r.x + 2, r.y + 5, tile - 4, tile - 8), border_radius=2)
                    pygame.draw.rect(surface, edge, pygame.Rect(r.x + 2, r.y + 5, tile - 4, tile - 8), 1, border_radius=2)
                    pygame.draw.rect(surface, desk_hi, pygame.Rect(r.x + 3, r.y + 6, tile - 6, 3))
                elif ch == "E":
                    pygame.draw.rect(surface, elev, pygame.Rect(r.x + 2, r.y + 2, tile - 4, tile - 4), border_radius=2)
                    pygame.draw.rect(surface, edge, pygame.Rect(r.x + 2, r.y + 2, tile - 4, tile - 4), 1, border_radius=2)
                    pygame.draw.rect(surface, elev_hi, pygame.Rect(r.x + 3, r.y + 4, tile - 6, 3))
                    pygame.draw.line(surface, edge, (r.x + tile // 2, r.y + 4), (r.x + tile // 2, r.y + tile - 4), 1)
                elif ch in ("^", "v"):
                    pygame.draw.rect(surface, stairs, pygame.Rect(r.x + 2, r.y + 2, tile - 4, tile - 4), border_radius=2)
                    pygame.draw.rect(surface, edge, pygame.Rect(r.x + 2, r.y + 2, tile - 4, tile - 4), 1, border_radius=2)
                    pygame.draw.rect(surface, stairs_hi, pygame.Rect(r.x + 3, r.y + 4, tile - 6, 3))
                    cx = r.centerx
                    cy = r.centery + (1 if ch == "v" else -1)
                    if ch == "^":
                        pygame.draw.polygon(surface, (230, 230, 240), [(cx, cy - 4), (cx - 4, cy + 3), (cx + 4, cy + 3)])
                    else:
                        pygame.draw.polygon(surface, (230, 230, 240), [(cx, cy + 4), (cx - 4, cy - 3), (cx + 4, cy - 3)])
                elif ch == "D":
                    pygame.draw.rect(surface, door, pygame.Rect(r.x + 2, r.y + 2, tile - 4, tile - 4), border_radius=2)
                    pygame.draw.rect(surface, edge, pygame.Rect(r.x + 2, r.y + 2, tile - 4, tile - 4), 1, border_radius=2)
                    pygame.draw.rect(surface, door_hi, pygame.Rect(r.x + 3, r.y + 4, tile - 6, 3))
                    pygame.draw.circle(surface, (30, 30, 34), (r.right - 6, r.centery), 1)

        p = pygame.Vector2(self.sch_int_pos)
        speed2 = float(self.sch_int_vel.length_squared())
        face = pygame.Vector2(self.sch_int_facing)
        if face.length_squared() <= 0.001:
            face = pygame.Vector2(0, 1)
        if abs(face.y) >= abs(face.x):
            d = "down" if face.y >= 0 else "up"
        else:
            d = "right" if face.x >= 0 else "left"

        pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
        frames = pf_walk.get(d, pf_walk["down"])
        if speed2 <= 0.2 or len(frames) <= 1:
            base = frames[0]
        else:
            walk = frames[1:]
            phase = (float(self.sch_int_walk_phase) % math.tau) / math.tau
            idx = int(phase * len(walk)) % len(walk)
            base = walk[idx]

        scale = int(max(1, int(self._SCH_INT_SPRITE_SCALE)))
        spr = pygame.transform.scale(base, (int(base.get_width()) * scale, int(base.get_height()) * scale))
        sx = int(round(map_x + p.x))
        sy = int(round(map_y + p.y))
        shadow = pygame.Rect(0, 0, 14, 6)
        shadow.center = (sx, sy + 8)
        pygame.draw.ellipse(surface, (0, 0, 0), shadow)
        rect = spr.get_rect()
        rect.midbottom = (sx, sy + 12)
        surface.blit(spr, rect)

    def _carve_hr_lamps_from_dim_overlay(
        self,
        overlay: pygame.Surface,
        *,
        map_rect: pygame.Rect,
        map_x: int,
        map_y: int,
        tile: int,
        lamps: list[tuple[int, int]],
        dim_alpha: int,
    ) -> None:
        if not lamps:
            return
        tile = int(tile)
        if tile <= 0:
            return
        dim_alpha = int(dim_alpha)
        if dim_alpha <= 0:
            return

        cfg = getattr(self.app, "config", None)
        radius_tiles = int(getattr(cfg, "lamp_hr_radius_tiles", 5)) if cfg is not None else 5
        radius_tiles = int(clamp(int(radius_tiles), 2, 18))
        intensity = float(getattr(cfg, "lamp_hr_intensity", 1.0)) if cfg is not None else 1.0
        intensity = float(clamp(float(intensity), 0.0, 3.0))
        if intensity <= 0.01:
            return

        radius_px = int(tile * radius_tiles)
        max_sub_alpha = int(clamp(int(round(float(dim_alpha) * 0.92 * float(intensity))), 0, int(dim_alpha)))
        if max_sub_alpha <= 0:
            return

        hole_key = (int(radius_px), int(max_sub_alpha))
        cache: dict[tuple[int, int], pygame.Surface] = getattr(self, "_hr_lamp_hole_cache", {})
        hole = cache.get(hole_key)
        if hole is None:
            g = pygame.Surface((int(radius_px) * 2 + 1, int(radius_px) * 2 + 1), pygame.SRCALPHA)
            rings = 18
            for i in range(rings):
                t = float(i) / float(max(1, rings - 1))
                r = int(round(float(radius_px) * (1.0 - t)))
                if r <= 0:
                    continue
                a = int(round(float(max_sub_alpha) * ((1.0 - t) ** 2)))
                a = int(clamp(int(a), 0, 255))
                if a <= 0:
                    continue
                pygame.draw.circle(g, (0, 0, 0, int(a)), (int(radius_px), int(radius_px)), int(r))
            cache[hole_key] = g
            self._hr_lamp_hole_cache = cache
            hole = g

        blocks = {"W", "V", "D", "A", "H", "I"}
        w = int(self._HR_INT_W)
        h = int(self._HR_INT_H)

        map_x_local = int(map_x) - int(map_rect.x)
        map_y_local = int(map_y) - int(map_rect.y)

        for lx, ly in lamps:
            lx = int(lx)
            ly = int(ly)
            seen: set[tuple[int, int]] = set()
            lit: list[tuple[int, int]] = []
            stack = [(lx, ly)]
            r2 = int(radius_tiles) * int(radius_tiles)
            while stack and len(lit) < 2400:
                x, y = stack.pop()
                x = int(x)
                y = int(y)
                if (x, y) in seen:
                    continue
                seen.add((x, y))
                if not (0 <= x < w and 0 <= y < h):
                    continue
                dx = int(x - lx)
                dy = int(y - ly)
                if int(dx * dx + dy * dy) > int(r2):
                    continue
                ch = str(self._hr_int_char_at(int(x), int(y)))[:1]
                if ch in blocks:
                    continue
                lit.append((x, y))
                stack.extend(((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)))

            base_rect = pygame.Rect(int(map_x_local + lx * tile), int(map_y_local + ly * tile), int(tile), int(tile))
            cx, cy = int(base_rect.centerx), int(base_rect.centery)
            ox = int(cx - radius_px)
            oy = int(cy - radius_px)

            mask = pygame.Surface(hole.get_size(), pygame.SRCALPHA)
            mask.fill((0, 0, 0, 0))
            mask_bounds = mask.get_rect()
            for tx, ty in lit:
                r = pygame.Rect(
                    int(map_x_local + int(tx) * tile),
                    int(map_y_local + int(ty) * tile),
                    int(tile),
                    int(tile),
                )
                lr = r.move(-int(ox), -int(oy)).clip(mask_bounds)
                if lr.w > 0 and lr.h > 0:
                    mask.fill((255, 255, 255, 255), lr)

            tmp = hole.copy()
            tmp.blit(mask, (0, 0), special_flags=pygame.BLEND_RGBA_MULT)
            overlay.blit(tmp, (int(ox), int(oy)), special_flags=pygame.BLEND_RGBA_SUB)

    def _draw_hr_interior_lamp_bloom(
        self,
        surface: pygame.Surface,
        *,
        map_rect: pygame.Rect,
        map_x: int,
        map_y: int,
        tile: int,
        lamps: list[tuple[int, int]],
    ) -> None:
        if not lamps:
            return
        tile = int(tile)
        if tile <= 0:
            return

        daylight, _tday = self._daylight_amount()

        cfg = getattr(self.app, "config", None)
        radius_tiles = int(getattr(cfg, "lamp_hr_radius_tiles", 5)) if cfg is not None else 5
        radius_tiles = int(clamp(int(radius_tiles), 2, 18))
        intensity = float(getattr(cfg, "lamp_hr_intensity", 1.0)) if cfg is not None else 1.0
        intensity = float(clamp(float(intensity), 0.0, 3.0))
        halo = float(getattr(cfg, "lamp_hr_halo", 0.35)) if cfg is not None else 0.35
        halo = float(clamp(float(halo), 0.0, 1.5))

        day_factor = float(clamp(0.45 + 0.55 * (1.0 - float(daylight)), 0.45, 1.0))
        halo_strength = float(halo) * float(day_factor) * float(clamp(float(intensity), 0.0, 1.0))
        halo_strength = float(clamp(float(halo_strength), 0.0, 1.0))
        halo_alpha = int(clamp(int(round(255.0 * float(halo_strength))), 0, 255))
        if halo_alpha <= 0:
            return

        # Warm bloom (screen blend) with a real alpha control (doesn't change radius).
        radius_px = int(tile * radius_tiles)
        cache: dict[int, pygame.Surface] = getattr(self, "_hr_lamp_bloom_cache", {})
        glow = cache.get(int(radius_px))
        if glow is None:
            grad = self._radial_gray_gradient(int(radius_px))
            g = grad.copy()
            g.fill((90, 90, 90), special_flags=pygame.BLEND_RGB_MULT)
            g.fill((232, 220, 198), special_flags=pygame.BLEND_RGB_MULT)
            cache[int(radius_px)] = g
            self._hr_lamp_bloom_cache = cache
            glow = g

        blocks = {"W", "V", "D", "A", "H", "I"}
        w = int(self._HR_INT_W)
        h = int(self._HR_INT_H)

        map_x_local = int(map_x) - int(map_rect.x)
        map_y_local = int(map_y) - int(map_rect.y)

        for lx, ly in lamps:
            lx = int(lx)
            ly = int(ly)
            seen: set[tuple[int, int]] = set()
            lit: list[tuple[int, int]] = []
            stack = [(lx, ly)]
            r2 = int(radius_tiles) * int(radius_tiles)
            while stack and len(lit) < 2400:
                x, y = stack.pop()
                x = int(x)
                y = int(y)
                if (x, y) in seen:
                    continue
                seen.add((x, y))
                if not (0 <= x < w and 0 <= y < h):
                    continue
                dx = int(x - lx)
                dy = int(y - ly)
                if int(dx * dx + dy * dy) > int(r2):
                    continue
                ch = str(self._hr_int_char_at(int(x), int(y)))[:1]
                if ch in blocks:
                    continue
                lit.append((x, y))
                stack.extend(((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)))

            base_rect = pygame.Rect(int(map_x_local + lx * tile), int(map_y_local + ly * tile), int(tile), int(tile))
            cx, cy = int(base_rect.centerx), int(base_rect.centery)
            ox = int(cx - radius_px)
            oy = int(cy - radius_px)
            mask = pygame.Surface(glow.get_size()).convert()
            mask.fill((0, 0, 0))
            bounds = mask.get_rect()
            for tx, ty in lit:
                r = pygame.Rect(
                    int(map_x_local + int(tx) * tile),
                    int(map_y_local + int(ty) * tile),
                    int(tile),
                    int(tile),
                )
                lr = r.move(-int(ox), -int(oy)).clip(bounds)
                if lr.w > 0 and lr.h > 0:
                    mask.fill((255, 255, 255), lr)

            tmp = glow.copy()
            tmp.blit(mask, (0, 0), special_flags=pygame.BLEND_RGB_MULT)
            self._blit_screen(surface, tmp, pos=(int(map_rect.x + ox), int(map_rect.y + oy)), alpha=int(halo_alpha))

    def _draw_hr_interior_lighting(
        self,
        surface: pygame.Surface,
        *,
        map_rect: pygame.Rect,
        map_x: int,
        map_y: int,
        tile: int,
        lamps: list[tuple[int, int]],
        light_on: bool,
    ) -> None:
        if int(map_rect.w) <= 0 or int(map_rect.h) <= 0:
            return
        tile = int(tile)
        if tile <= 0:
            return

        daylight, _tday = self._daylight_amount()
        # Ambient indoor darkness: night is darker; lights-off adds extra dim.
        dim_alpha = int(round(110.0 * (1.0 - float(daylight))))
        if not bool(light_on):
            dim_alpha = int(clamp(int(dim_alpha) + 110, 0, 220))
        if dim_alpha > 0:
            dim = pygame.Surface((int(map_rect.w), int(map_rect.h)), pygame.SRCALPHA)
            dim.fill((12, 14, 30, int(dim_alpha)))
            if bool(light_on) and lamps:
                try:
                    self._carve_hr_lamps_from_dim_overlay(
                        dim,
                        map_rect=map_rect,
                        map_x=int(map_x),
                        map_y=int(map_y),
                        tile=int(tile),
                        lamps=lamps,
                        dim_alpha=int(dim_alpha),
                    )
                except Exception:
                    pass
            surface.blit(dim, map_rect.topleft)

        if bool(light_on) and lamps:
            try:
                self._draw_hr_interior_lamp_bloom(
                    surface,
                    map_rect=map_rect,
                    map_x=int(map_x),
                    map_y=int(map_y),
                    tile=int(tile),
                    lamps=lamps,
                )
            except Exception:
                pass

    def _draw_hr_interior_scene(self, surface: pygame.Surface) -> None:  
        surface.fill((10, 10, 14))
        tile = int(self._HR_INT_TILE_SIZE)
        full_map_w = int(self._HR_INT_W) * tile
        full_map_h = int(self._HR_INT_H) * tile
        map_y0 = 38
        map_w = int(min(int(full_map_w), max(1, int(INTERNAL_W) - 20)))
        map_h = int(min(int(full_map_h), max(1, int(INTERNAL_H) - int(map_y0) - 10)))
        map_x0 = (INTERNAL_W - map_w) // 2
        map_y0 = int(map_y0)
        panel = pygame.Rect(int(map_x0) - 10, int(map_y0) - 10, int(map_w) + 20, int(map_h) + 20)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (70, 70, 86), panel, 2, border_radius=12)

        # Cozier indoor rendering (wood floors, furniture detail, window view).
        mode = str(getattr(self, "hr_mode", "lobby"))
        floor = int(getattr(self, "hr_floor", 1))
        room_id = str(getattr(self, "hr_current_room", "")).strip()
        lights = getattr(self, "hr_room_lights", None)
        if not isinstance(lights, dict):
            lights = {}
            self.hr_room_lights = lights
        light_on = True
        if mode == "home" and room_id:
            light_on = bool(lights.get(str(room_id), True))

        tv_states = getattr(self, "hr_room_tvs", None)
        if not isinstance(tv_states, dict):
            tv_states = {}
            self.hr_room_tvs = tv_states
        tv_on = bool(tv_states.get(str(room_id), False)) if (mode == "home" and room_id) else False

        title = "高层住宅"
        home_room = str(getattr(self, "home_highrise_room", "")).strip()
        cur_room = str(getattr(self, "hr_current_room", "")).strip()
        home_floor = int(getattr(self, "hr_home_floor", -1))
        if mode == "home":
            if cur_room and home_room and cur_room != home_room:
                subtitle = f"房间 {cur_room}"
            else:
                subtitle = f"你的家 {home_room}" if home_room else "你的家"
        elif floor <= 1:
            subtitle = "大厅"
        else:
            subtitle = f"{floor} 层"
            if home_floor == floor:
                subtitle += f"（家 {home_room}）" if home_room else "（家）"
        draw_text(
            surface,
            self.app.font_s,
            f"{title} - {subtitle}",
            (INTERNAL_W // 2, panel.top - 14),
            pygame.Color(240, 240, 240),
            anchor="center",
        )

        # Persistent home guidance (so the player always knows where the room is).
        info = ""
        if home_floor > 0:
            if home_room:
                info = f"家：{home_room}（{home_floor}F）"
            else:
                info = f"家：{home_floor}F"
            if mode == "hall":
                if floor == home_floor:
                    info += "  本层：绿色门"
                else:
                    info += f"  现在：{floor}F"
        if info:
            draw_text(
                surface,
                self.app.font_s,
                info,
                (panel.right - 8, panel.top + 6),
                pygame.Color(200, 200, 210),
                anchor="topright",
            )

        map_rect = pygame.Rect(int(map_x0), int(map_y0), int(map_w), int(map_h))
        self._hr_int_ui_buttons = []
        floor_kind = "home" if mode == "home" else "stone"
        # Camera within the interior so layouts can be larger than the viewport.
        pose = str(getattr(self, "player_pose", "")).strip()
        pose_space = str(getattr(self, "player_pose_space", "")).strip()
        pose_anchor = getattr(self, "player_pose_anchor", None)
        use_pose = bool(pose and pose_space == "hr" and pose_anchor is not None)
        if use_pose:
            focus = pygame.Vector2(float(pose_anchor[0]), float(pose_anchor[1]))
        else:
            focus = pygame.Vector2(self.hr_int_pos)
        if int(full_map_w) <= int(map_w):
            cam_x = 0
        else:
            cam_x = int(clamp(float(focus.x) - float(map_w) / 2.0, 0.0, float(full_map_w - map_w)))
        if int(full_map_h) <= int(map_h):
            cam_y = 0
        else:
            cam_y = int(clamp(float(focus.y) - float(map_h) / 2.0, 0.0, float(full_map_h - map_h)))
        self._hr_int_draw_rect = pygame.Rect(map_rect)
        self._hr_int_draw_cam = (int(cam_x), int(cam_y))
        self._hr_int_draw_origin = (int(map_x0), int(map_y0))

        # Shift the draw origin by the camera, but keep map_rect in screen space.
        map_x = int(map_x0) - int(cam_x)
        map_y = int(map_y0) - int(cam_y)

        prev_clip = surface.get_clip()
        surface.set_clip(map_rect)
        surface.blit(self._interior_floor_surface(int(full_map_w), int(full_map_h), kind=floor_kind), (int(map_x), int(map_y)))

        # "Back wall" band (front-view cue) for the player's home, per reference.
        if mode == "home":
            wall_h = int(tile * 2)
            wall_h = int(clamp(wall_h, 18, max(18, int(map_h) - 40)))
            wall_rect = pygame.Rect(int(map_rect.x), int(map_rect.y), int(map_rect.w), int(wall_h))
            wall_surf = pygame.Surface((wall_rect.w, wall_rect.h))
            wall_base = (188, 186, 182)
            wall_surf.fill(wall_base)
            # Subtle horizontal noise lines.
            for yy in range(2, wall_rect.h - 6, 6):
                col = (182, 180, 176) if ((yy // 6) % 2) == 0 else (190, 188, 184)
                wall_surf.fill(col, pygame.Rect(0, int(yy), wall_rect.w, 1))
            # Baseboard.
            base_y = int(max(0, wall_rect.h - 5))
            wall_surf.fill((74, 58, 42), pygame.Rect(0, base_y, wall_rect.w, 4))
            wall_surf.fill((12, 12, 16), pygame.Rect(0, base_y, wall_rect.w, 1))
            surface.blit(wall_surf, wall_rect.topleft)

        wall = (26, 26, 32)
        wall_hi = (56, 56, 70)
        wall_edge = (12, 12, 16)
        frame = (88, 80, 70)
        frame2 = (62, 56, 48)
        outline = (10, 10, 12)

        wood = (98, 78, 56)
        wood2 = (74, 58, 42)
        steel = (216, 220, 228)
        steel2 = (134, 140, 152)
        bed_matt = (186, 170, 156)
        bed_blank = (142, 128, 170)
        bed_blank2 = (120, 106, 144)
        pillow = (238, 238, 244)
        seat = (72, 86, 148)
        seat2 = (54, 64, 118)

        wkind = str(getattr(self, "weather_kind", "clear"))
        inten = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))
        glass_w = max(4, int(tile - 6))
        glass_h = max(4, int(tile - 8))
        win_view = self._window_view_surface(glass_w, glass_h)

        # Rug under the table block in "home" mode.
        if mode == "home":
            t_tiles: list[tuple[int, int]] = []
            for yy, row in enumerate(getattr(self, "hr_layout", [])):
                if not isinstance(row, str):
                    continue
                for xx in range(min(len(row), int(self._HR_INT_W))):
                    if row[xx] == "T":
                        t_tiles.append((int(xx), int(yy)))
            if t_tiles:
                min_tx = min(p[0] for p in t_tiles)
                max_tx = max(p[0] for p in t_tiles)
                min_ty = min(p[1] for p in t_tiles)
                max_ty = max(p[1] for p in t_tiles)
                rug = pygame.Rect(
                    map_x + min_tx * tile - 3,
                    map_y + min_ty * tile + 7,
                    (max_tx - min_tx + 1) * tile + 6,
                    (max_ty - min_ty + 1) * tile + 8,
                )
                rug.clamp_ip(map_rect.inflate(-6, -6))
                rug_s = pygame.Surface((rug.w, rug.h), pygame.SRCALPHA)
                rug_s.fill((132, 70, 82, 190))
                for y in range(2, rug.h, 5):
                    pygame.draw.line(rug_s, (210, 150, 150, 55), (2, y), (rug.w - 3, y), 1)
                pygame.draw.rect(rug_s, (40, 18, 20, 220), rug_s.get_rect(), 2, border_radius=4)
                surface.blit(rug_s, rug.topleft)

        bed_done: set[tuple[int, int]] = set()
        elev_done: set[tuple[int, int]] = set()
        s_done: set[tuple[int, int]] = set()
        f_done: set[tuple[int, int]] = set()
        k_done: set[tuple[int, int]] = set()
        t_done: set[tuple[int, int]] = set()
        c_done: set[tuple[int, int]] = set()
        p_done: set[tuple[int, int]] = set()
        x_done: set[tuple[int, int]] = set()
        r_done: set[tuple[int, int]] = set()
        lamp_tiles: list[tuple[int, int]] = []

        layout = getattr(self, "hr_layout", [])
        for y in range(int(self._HR_INT_H)):
            row = layout[y] if 0 <= y < len(layout) else ""
            for x in range(int(self._HR_INT_W)):
                ch = row[x] if x < len(row) else "W"
                r = pygame.Rect(map_x + x * tile, map_y + y * tile, tile, tile)

                if ch in ("W", "V", "D", "A", "a", "H", "I"):
                    pygame.draw.rect(surface, wall, r)
                    pygame.draw.rect(surface, wall_hi, pygame.Rect(r.x, r.y, r.w, 4))
                    pygame.draw.rect(surface, wall_edge, r, 1)
                    pygame.draw.rect(surface, frame2, pygame.Rect(r.x, r.bottom - 4, r.w, 2))

                    if ch == "V":
                        glass = pygame.Rect(r.x + 3, r.y + 4, r.w - 6, r.h - 8)
                        wv = win_view
                        if wv.get_width() != glass.w or wv.get_height() != glass.h:
                            wv = pygame.transform.scale(wv, (int(glass.w), int(glass.h)))
                        surface.blit(wv, glass.topleft)
                        if wkind in ("rain", "storm", "snow"):
                            self._draw_window_precip(surface, glass, kind=wkind, intensity=inten)
                        # Pixel-style window frame.
                        pygame.draw.rect(surface, frame, glass.inflate(4, 4), 1)
                        pygame.draw.rect(surface, outline, glass, 1)
                        pygame.draw.line(surface, (40, 40, 50), (glass.centerx, glass.top + 1), (glass.centerx, glass.bottom - 2), 1)
                    elif ch == "D":
                        # Pixel-style door.
                        dr = pygame.Rect(r.x + 5, r.y + 4, r.w - 10, r.h - 8)
                        pygame.draw.rect(surface, outline, dr.inflate(2, 2))
                        pygame.draw.rect(surface, (240, 220, 140), dr)
                        pygame.draw.circle(surface, outline, (dr.right - 5, dr.centery), 2)
                    elif ch in ("A", "a", "H"):
                        # Apartment doors: keep a solid wall frame, bottom aligned to the baseboard.
                        # Doors should be taller than one tile (player sprite is 2x inside). Pixel-style.
                        door_h = int(clamp(int(tile * 1.7), int(tile + 8), int(tile * 2 - 2)))
                        dr = pygame.Rect(r.x + 2, int(r.bottom - 2 - door_h), r.w - 4, door_h)
                        pygame.draw.rect(surface, outline, dr.inflate(2, 2))
                        pygame.draw.rect(surface, wood, dr)
                        pygame.draw.rect(surface, wood2, pygame.Rect(dr.x + 2, dr.y + 2, dr.w - 4, 4))
                        knob_y = int(dr.y + dr.h * 0.62)
                        pygame.draw.circle(surface, (240, 220, 140), (dr.right - 4, knob_y), 2)
                        if ch == "H":
                            pygame.draw.rect(surface, (120, 200, 140), pygame.Rect(dr.x + 2, dr.y + 2, dr.w - 4, 3))
                        if ch == "a":
                            # Broken door accent so players understand it's enterable.
                            pygame.draw.line(surface, outline, (dr.x + 3, dr.y + 6), (dr.right - 4, dr.bottom - 7), 2)
                            pygame.draw.line(surface, (40, 20, 20), (dr.x + 4, dr.bottom - 6), (dr.right - 5, dr.bottom - 6), 1)
                    elif ch == "I":
                        # Light switch on the wall (controls room lighting). Pixel-style.
                        plate = pygame.Rect(int(r.centerx - 4), int(r.centery - 6), 8, 12)
                        pygame.draw.rect(surface, outline, plate.inflate(2, 2))
                        pygame.draw.rect(surface, (214, 214, 222), plate)
                        knob_h = 4
                        knob = pygame.Rect(int(plate.x + 2), int(plate.y + (2 if light_on else plate.h - knob_h - 2)), int(plate.w - 4), int(knob_h))
                        pygame.draw.rect(surface, outline, knob.inflate(2, 2))
                        pygame.draw.rect(surface, (255, 220, 140) if light_on else (120, 120, 132), knob)
                    continue

                if ch in (",", "O", "U", "R"):
                    # Bathroom tile floor overlay (on top of the base floor texture).
                    tile_a = (86, 88, 96)
                    tile_b = (78, 80, 88)
                    grout = (28, 28, 34)
                    col = tile_a if ((int(x) + int(y)) % 2 == 0) else tile_b
                    surface.fill(col, r)
                    surface.fill(grout, pygame.Rect(r.x, r.y, r.w, 1))
                    surface.fill(grout, pygame.Rect(r.x, r.y, 1, r.h))

                # Objects over the floor texture.
                if ch in ("^", "v"):
                    step_r = r.inflate(-6, -6)
                    sh = pygame.Surface((step_r.w + 4, step_r.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 70), sh.get_rect())
                    surface.blit(sh, (step_r.x, step_r.y + 2))
                    # Pixel-style stairs.
                    pygame.draw.rect(surface, outline, step_r.inflate(2, 2))
                    pygame.draw.rect(surface, steel2, step_r)
                    for i in range(3):
                        yy = int(step_r.y + 4 + i * 5)
                        pygame.draw.line(surface, steel, (step_r.x + 3, yy), (step_r.right - 4, yy), 1)
                    if ch == "^":
                        arrow = [(step_r.centerx, step_r.y + 3), (step_r.centerx - 4, step_r.y + 10), (step_r.centerx + 4, step_r.y + 10)]
                    else:
                        arrow = [
                            (step_r.centerx, step_r.bottom - 3),
                            (step_r.centerx - 4, step_r.bottom - 10),
                            (step_r.centerx + 4, step_r.bottom - 10),
                        ]
                    pygame.draw.polygon(surface, (255, 220, 140), arrow)
                    pygame.draw.polygon(surface, outline, arrow, 1)
                    continue

                if ch == "L":
                    # Standing lamp (glow drawn later with wall occlusion).
                    bulb_col = (255, 230, 140) if light_on else (90, 90, 104)
                    if light_on:
                        lamp_tiles.append((int(x), int(y)))

                    base_y = int(r.bottom - 5)
                    pole_top = int(r.y + 6)
                    pygame.draw.line(surface, (90, 84, 76), (int(r.centerx), base_y), (int(r.centerx), pole_top), 2)
                    pygame.draw.circle(surface, outline, (int(r.centerx), base_y), 3, 1)
                    pygame.draw.ellipse(surface, (60, 54, 46), pygame.Rect(int(r.centerx - 5), int(base_y), 10, 4))

                    shade = pygame.Rect(int(r.centerx - 6), int(pole_top - 1), 12, 7)
                    pygame.draw.polygon(
                        surface,
                        (238, 230, 200),
                        [
                            (shade.left, shade.bottom),
                            (shade.centerx, shade.top),
                            (shade.right, shade.bottom),
                        ],
                    )
                    pygame.draw.polygon(
                        surface,
                        outline,
                        [
                            (shade.left, shade.bottom),
                            (shade.centerx, shade.top),
                            (shade.right, shade.bottom),
                        ],
                        1,
                    )
                    pygame.draw.circle(surface, bulb_col, (int(r.centerx), int(shade.bottom - 1)), 2)
                    continue

                if ch == "O":
                    # Toilet.
                    porcelain = (230, 232, 238)
                    porcelain2 = (206, 210, 220)
                    bowl = pygame.Rect(r.x + 4, r.y + 6, r.w - 8, r.h - 10)
                    tank = pygame.Rect(r.x + 6, r.y + 2, r.w - 12, 5)
                    base = pygame.Rect(r.x + 5, r.bottom - 6, r.w - 10, 4)
                    sh = pygame.Surface((bowl.w, bowl.h), pygame.SRCALPHA)
                    pygame.draw.ellipse(sh, (0, 0, 0, 80), sh.get_rect())
                    surface.blit(sh, (bowl.x + 1, bowl.y + 2))
                    pygame.draw.ellipse(surface, porcelain, bowl)
                    pygame.draw.ellipse(surface, outline, bowl, 1)
                    # Pixel-style toilet parts.
                    pygame.draw.rect(surface, outline, tank.inflate(2, 2))
                    pygame.draw.rect(surface, porcelain2, tank)
                    pygame.draw.rect(surface, steel2, pygame.Rect(tank.right - 3, tank.y + 1, 2, 2))
                    pygame.draw.rect(surface, outline, base.inflate(2, 2))
                    pygame.draw.rect(surface, porcelain2, base)
                    hole = bowl.inflate(-6, -6)
                    pygame.draw.ellipse(surface, (30, 30, 36), hole)
                    water = hole.inflate(-4, -4)
                    if water.w > 2 and water.h > 2:
                        pygame.draw.ellipse(surface, (64, 126, 190), water)
                        hl = pygame.Rect(water.x + 1, water.y + 1, max(1, water.w - 2), max(1, water.h // 2))
                        pygame.draw.ellipse(surface, (120, 184, 220), hl, 1)
                    pygame.draw.ellipse(surface, outline, hole, 1)
                    continue

                if ch == "E":
                    if (x, y) in elev_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "E":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "E":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "E":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            elev_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    er = br.inflate(-4, -4)
                    sh = pygame.Surface((er.w + 4, er.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 80), sh.get_rect())
                    surface.blit(sh, (er.x, er.y + 2))
                    # Pixel-style elevator.
                    pygame.draw.rect(surface, outline, er.inflate(2, 2))
                    pygame.draw.rect(surface, steel, er)
                    pygame.draw.rect(surface, steel2, pygame.Rect(er.x + 3, er.y + 3, er.w - 6, 3))
                    pygame.draw.line(surface, outline, (er.centerx, er.y + 4), (er.centerx, er.bottom - 5), 1)
                    pygame.draw.rect(surface, (255, 220, 140), pygame.Rect(er.right - 9, er.y + 10, 3, 5))
                    continue

                if ch == "B":
                    if (int(x), int(y)) in bed_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "B":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "B":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "B":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            bed_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    bed_r = br.inflate(-4, -8)
                    # Pixel-style outline: draw outline first, then fill.
                    sh = pygame.Surface((bed_r.w + 4, bed_r.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 90), sh.get_rect())
                    surface.blit(sh, (bed_r.x + 1, bed_r.y + 2))
                    pygame.draw.rect(surface, outline, bed_r.inflate(2, 2))
                    pygame.draw.rect(surface, bed_matt, bed_r)
                    hb = pygame.Rect(bed_r.x, bed_r.y, 8, bed_r.h)
                    pygame.draw.rect(surface, outline, hb.inflate(2, 2))
                    pygame.draw.rect(surface, wood2, hb)
                    p1 = pygame.Rect(bed_r.x + 10, bed_r.y + 4, max(10, bed_r.w // 5), 7)
                    p2 = pygame.Rect(p1.x, p1.y + 10, p1.w, 7)
                    pygame.draw.rect(surface, outline, p1.inflate(2, 2))
                    pygame.draw.rect(surface, pillow, p1)
                    pygame.draw.rect(surface, outline, p2.inflate(2, 2))
                    pygame.draw.rect(surface, pillow, p2)
                    bl = pygame.Rect(bed_r.x + 10, bed_r.y + 20, bed_r.w - 14, max(10, bed_r.h - 24))
                    pygame.draw.rect(surface, outline, bl.inflate(2, 2))
                    pygame.draw.rect(surface, bed_blank, bl)
                    for sx in range(bl.x + 6, bl.right - 4, 10):
                        pygame.draw.line(surface, bed_blank2, (sx, bl.y + 2), (sx, bl.bottom - 3), 1)
                    # Bed legs/frame (so it doesn't look like it floats).
                    floor_y = int(br.bottom - 3)
                    leg_y0 = int(bed_r.bottom - 2)
                    leg_h = int(floor_y - leg_y0)
                    if leg_h > 0:
                        leg_col = self._tint(wood2, add=(-12, -12, -12))
                        for lx in (int(bed_r.x + 6), int(bed_r.right - 8)):
                            leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                            surface.fill(leg_col, leg)
                            pygame.draw.rect(surface, outline, leg, 1)
                            surface.fill(leg_col, pygame.Rect(int(lx - 1), int(floor_y), 4, 1))
                    continue

                if ch == "K":
                    if (x, y) in k_done:
                        continue

                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "K":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "K":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "K":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            k_done.add((int(x) + int(dx), int(y) + int(dy)))

                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    # Less inset so the countertop reads flush to the block edges.
                    obj = br.inflate(-2, -6)
                    # Pixel-style outline.
                    sh = pygame.Surface((obj.w + 4, obj.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 70), sh.get_rect())
                    surface.blit(sh, (obj.x + 1, obj.y + 2))

                    # Marble countertop (big visible top, thin front face).
                    top_h = int(clamp(int(obj.h * 0.58), 12, 18))
                    top_r = pygame.Rect(obj.x, obj.y, obj.w, top_h)
                    front_r = pygame.Rect(obj.x, obj.y + top_h - 1, obj.w, obj.h - (top_h - 1))

                    stone_face = (170, 172, 178)
                    stone_face2 = (150, 152, 160)
                    marble_base = (228, 230, 236)

                    # Pixel-style outline for front face.
                    pygame.draw.rect(surface, outline, front_r.inflate(2, 2))
                    pygame.draw.rect(surface, stone_face, front_r)
                    pygame.draw.rect(surface, stone_face2, pygame.Rect(front_r.x + 1, front_r.y + 2, front_r.w - 2, 3))

                    marble = self._marble_surface(
                        int(top_r.w),
                        int(top_r.h),
                        seed=int(getattr(self, "seed", 0)) ^ (int(x) * 65537) ^ (int(y) * 9719) ^ 0x51F15EED,
                        base=marble_base,
                    )
                    # Pixel-style outline for marble top.
                    pygame.draw.rect(surface, outline, top_r.inflate(2, 2))
                    surface.blit(marble, top_r.topleft)
                    pygame.draw.line(surface, outline, (top_r.x + 2, top_r.bottom - 1), (top_r.right - 3, top_r.bottom - 1), 1)

                    # Cabinet seams / handles on the front face (stone drawers).
                    modules = int(max(2, int(bw)))
                    for i in range(1, modules):
                        xline = int(front_r.x + (front_r.w * i) / modules)
                        pygame.draw.line(surface, stone_face2, (xline, front_r.y + 5), (xline, front_r.bottom - 5), 2)
                        pygame.draw.line(surface, outline, (xline, front_r.y + 5), (xline, front_r.bottom - 5), 1)
                    for i in range(modules):
                        cx = int(front_r.x + (front_r.w * (i + 0.5)) / modules)
                        hy = int(front_r.y + front_r.h * 0.55)
                        hrect = pygame.Rect(cx - 2, hy - 1, 4, 2)
                        surface.fill((80, 82, 90), hrect)
                        pygame.draw.rect(surface, outline, hrect, 1)

                    # Sink + stove on the top.
                    sink_w = int(clamp(int(top_r.w * 0.20), 14, 22))
                    sink_h = int(clamp(int(top_r.h - 5), 6, 10))
                    sink = pygame.Rect(top_r.x + int(top_r.w * 0.18), top_r.y + 3, sink_w, sink_h)
                    # Pixel-style sink.
                    pygame.draw.rect(surface, outline, sink.inflate(2, 2))
                    pygame.draw.rect(surface, steel, sink)
                    pygame.draw.circle(surface, (60, 60, 70), (sink.right - 3, sink.y + 3), 1)
                    pygame.draw.line(surface, steel2, (sink.x + 2, sink.y + 1), (sink.x + 2, sink.y - 3), 1)
                    pygame.draw.line(surface, steel2, (sink.x + 2, sink.y - 3), (sink.x + 7, sink.y - 3), 1)

                    stove_w = int(clamp(int(top_r.w * 0.20), 14, 22))
                    stove_h = sink_h
                    stove = pygame.Rect(top_r.right - int(top_r.w * 0.16) - stove_w, top_r.y + 3, stove_w, stove_h)
                    # Pixel-style stove.
                    pygame.draw.rect(surface, outline, stove.inflate(2, 2))
                    pygame.draw.rect(surface, (40, 40, 50), stove)
                    pygame.draw.circle(surface, (80, 80, 90), (stove.x + stove_w // 3, stove.centery), 2)
                    pygame.draw.circle(surface, (80, 80, 90), (stove.right - stove_w // 3, stove.centery), 2)

                    # Small items so it reads as a real kitchen.
                    plate = pygame.Rect(top_r.right - 15, top_r.y + 3, 12, 5)
                    pygame.draw.ellipse(surface, (238, 238, 244), plate)
                    pygame.draw.ellipse(surface, outline, plate, 1)
                    bowl = pygame.Rect(top_r.x + 8, top_r.y + 3, 10, 5)
                    pygame.draw.ellipse(surface, (205, 214, 224), bowl)
                    pygame.draw.ellipse(surface, outline, bowl, 1)
                    pot = pygame.Rect(top_r.centerx - 8, top_r.y + 2, 16, 6)
                    # Pixel-style pot.
                    pygame.draw.rect(surface, outline, pot.inflate(2, 2))
                    pygame.draw.rect(surface, (40, 40, 50), pot)
                    pygame.draw.line(surface, steel2, (pot.x + 2, pot.y + 2), (pot.right - 3, pot.y + 2), 1)

                    # Subtle shelf/rack cue above the counter.
                    rack_y = int(top_r.y - 7)
                    if rack_y >= int(br.y) + 1:
                        pygame.draw.line(surface, outline, (top_r.x + 2, rack_y), (top_r.right - 3, rack_y), 1)
                        for ux in (top_r.x + 10, top_r.centerx, top_r.right - 12):
                            pygame.draw.line(surface, steel2, (int(ux), rack_y + 1), (int(ux), rack_y + 4), 1)
                    continue

                if ch == "T":
                    if (x, y) in t_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "T":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "T":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "T":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            t_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    top = br.inflate(-6, -10)
                    # Pixel-style outline.
                    sh = pygame.Surface((top.w + 4, top.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 70), sh.get_rect())
                    surface.blit(sh, (top.x + 1, top.y + 2))
                    pygame.draw.rect(surface, outline, top.inflate(2, 2))
                    pygame.draw.rect(surface, wood, top)
                    pygame.draw.rect(surface, wood2, pygame.Rect(top.x + 1, top.y + 1, top.w - 2, 4))
                    # Small TV / radio-like decoration.
                    screen = pygame.Rect(top.centerx - 10, top.y + 5, 20, 10)
                    pygame.draw.rect(surface, outline, screen.inflate(2, 2))
                    pygame.draw.rect(surface, (36, 38, 44), screen)
                    pygame.draw.rect(surface, steel2, screen, 1)
                    pygame.draw.rect(surface, (120, 200, 240), pygame.Rect(screen.x + 3, screen.y + 3, 7, 4))
                    # Table legs (front-view cue).
                    floor_y = int(br.bottom - 3)
                    leg_y0 = int(top.bottom - 1)
                    leg_h = int(floor_y - leg_y0)
                    if leg_h > 0 and top.w >= 12:
                        leg_col = self._tint(wood2, add=(-10, -10, -10))
                        for lx in (int(top.x + 4), int(top.right - 6)):
                            leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                            surface.fill(leg_col, leg)
                            pygame.draw.rect(surface, outline, leg, 1)
                        # Simple crossbar.
                        if leg_h >= 4:
                            yb = int(floor_y - 2)
                            surface.fill(leg_col, pygame.Rect(int(top.x + 4), yb, int(max(1, top.w - 8)), 1))
                    continue

                if ch == "S":
                    if (x, y) in s_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "S":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "S":  
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "S":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            s_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    # Keep cabinets tall enough even when the block is only 1 tile high (e.g., the bottom-left cabinet).
                    obj = br.inflate(-6, -4)
                    # Pixel-style outline.
                    sh = pygame.Surface((obj.w + 4, obj.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 70), sh.get_rect())
                    surface.blit(sh, (obj.x + 1, obj.y + 2))
                    # Wardrobe / cabinet: draw top + front face (two visible planes).
                    cab_top = self._tint(wood, add=(14, 12, 10))
                    cab_front = self._tint(wood2, add=(2, 2, 2))
                    cab_front2 = self._tint(cab_front, add=(-16, -14, -12))
                    hi = self._tint(cab_top, add=(22, 22, 22))
                    lo = self._tint(cab_front, add=(-26, -24, -22))

                    top_h = int(clamp(int(obj.h * 0.34), 8, 12))
                    top_r = pygame.Rect(obj.x, obj.y, obj.w, top_h)
                    front_r = pygame.Rect(obj.x, obj.y + top_h - 1, obj.w, obj.h - (top_h - 1))

                    # Pixel-style outline for front face.
                    pygame.draw.rect(surface, outline, front_r.inflate(2, 2))
                    pygame.draw.rect(surface, cab_front, front_r)
                    pygame.draw.rect(surface, cab_front2, pygame.Rect(front_r.x + 1, front_r.y + 2, front_r.w - 2, 3))

                    # Pixel-style outline for top.
                    pygame.draw.rect(surface, outline, top_r.inflate(2, 2))
                    pygame.draw.rect(surface, cab_top, top_r)
                    pygame.draw.line(surface, hi, (top_r.x + 2, top_r.y + 1), (top_r.right - 3, top_r.y + 1), 1)
                    pygame.draw.line(surface, outline, (top_r.x + 2, top_r.bottom - 1), (top_r.right - 3, top_r.bottom - 1), 1)

                    # Inset doors live on the front face (keeps the top readable).
                    door_area = front_r.inflate(-4, -6)
                    if door_area.w > 6 and door_area.h > 8:
                        pygame.draw.rect(surface, outline, door_area.inflate(2, 2))
                        pygame.draw.rect(surface, self._tint(cab_front, add=(-8, -6, -4)), door_area)
                    else:
                        door_area = pygame.Rect(front_r)

                    # Tiny feet so it doesn't look like it floats.
                    floor_y = int(br.bottom - 3)
                    leg_y0 = int(front_r.bottom - 2)
                    leg_h = int(floor_y - leg_y0)
                    if leg_h > 0:
                        leg_col = self._tint(cab_front2, add=(-16, -16, -16))
                        for lx in (int(front_r.x + 6), int(front_r.right - 8)):
                            leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                            surface.fill(leg_col, leg)
                            pygame.draw.rect(surface, outline, leg, 1)

                    open_block = getattr(self, "home_ui_open_block", None)
                    is_open = bool(getattr(self, "home_ui_open", False)) and open_block == (
                        int(x),
                        int(y),
                        int(x) + int(bw) - 1,
                        int(y) + int(bh) - 1,
                    )
                    if is_open:
                        inner = door_area.inflate(-10, -10)
                        if inner.w > 4 and inner.h > 4:
                            # Pixel-style cabinet interior.
                            pygame.draw.rect(surface, outline, inner.inflate(2, 2))
                            pygame.draw.rect(surface, (20, 20, 24), inner)
                            # Inside top surface + shelves.
                            pygame.draw.line(surface, self._tint(cab_front2, add=(18, 18, 18)), (inner.x + 2, inner.y + 2), (inner.right - 3, inner.y + 2), 1)
                            step = max(6, int(inner.h // 3))
                            for sy in range(inner.y + step, inner.bottom - 2, step):
                                pygame.draw.line(surface, cab_front2, (inner.x + 2, sy), (inner.right - 3, sy), 2)
                                pygame.draw.line(surface, outline, (inner.x + 2, sy), (inner.right - 3, sy), 1)
                            # Small visible supplies.
                            can = pygame.Rect(inner.x + 4, inner.y + 5, 5, 7)
                            surface.fill((180, 60, 70), can)
                            pygame.draw.rect(surface, outline, can, 1)
                            jar = pygame.Rect(inner.right - 10, inner.y + 6, 7, 6)
                            surface.fill((90, 140, 190), jar)
                            pygame.draw.rect(surface, outline, jar, 1)

                        # Doors "slid open" to sides. Pixel-style.
                        door_w = max(6, int(door_area.w // 5))
                        ld = pygame.Rect(door_area.x + 1, door_area.y + 3, door_w, door_area.h - 6)
                        rd = pygame.Rect(door_area.right - door_w - 1, door_area.y + 3, door_w, door_area.h - 6)
                        for d in (ld, rd):
                            pygame.draw.rect(surface, outline, d.inflate(2, 2))
                            pygame.draw.rect(surface, cab_front, d)
                            inset = d.inflate(-2, -4)
                            if inset.w > 2 and inset.h > 2:
                                pygame.draw.rect(surface, outline, inset.inflate(2, 2))
                                pygame.draw.rect(surface, self._tint(cab_front, add=(-8, -8, -8)), inset)
                                pygame.draw.line(surface, hi, (inset.x + 1, inset.y + 1), (inset.right - 2, inset.y + 1), 1)
                        for d in (ld, rd):
                            hy = int(d.y + d.h * 0.55)
                            hrect = pygame.Rect(d.centerx - 1, hy - 3, 2, 6)
                            surface.fill((220, 220, 230), hrect)
                            pygame.draw.rect(surface, outline, hrect, 1)
                    else:
                        # Closed doors + handles.
                        doors = max(2, int(door_area.w // 24))
                        doors = int(clamp(doors, 2, 4))
                        y_top = int(door_area.y + 2)
                        y_bot = int(door_area.bottom - 3)
                        for i in range(1, doors):
                            xline = int(door_area.x + (door_area.w * i) / doors)
                            pygame.draw.line(surface, cab_front2, (xline, y_top), (xline, y_bot), 2)
                            pygame.draw.line(surface, outline, (xline, y_top), (xline, y_bot), 1)
                        for i in range(doors):
                            x0 = int(door_area.x + (door_area.w * i) / doors)
                            x1 = int(door_area.x + (door_area.w * (i + 1)) / doors)
                            panel = pygame.Rect(x0 + 2, y_top + 1, (x1 - x0) - 4, max(2, int(y_bot - y_top - 2)))
                            if panel.w > 3 and panel.h > 3:
                                # Pixel-style cabinet panel.
                                pygame.draw.rect(surface, outline, panel.inflate(2, 2))
                                pygame.draw.rect(surface, self._tint(cab_front, add=(-6, -6, -6)), panel)
                                pygame.draw.line(surface, hi, (panel.x + 1, panel.y + 1), (panel.right - 2, panel.y + 1), 1)

                            hx = int(door_area.x + (door_area.w * (i + 0.5)) / doors)
                            hy = int(door_area.y + door_area.h * 0.55)
                            hrect = pygame.Rect(hx - 1, hy - 3, 2, 6)
                            surface.fill((220, 220, 230), hrect)
                            pygame.draw.rect(surface, outline, hrect, 1)
                    continue

                if ch == "F":
                    if (x, y) in f_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "F":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "F":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "F":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            f_done.add((int(x) + int(dx), int(y) + int(dy)))

                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    obj = br.inflate(-4, -4)
                    # Pixel-style outline.
                    sh = pygame.Surface((obj.w + 4, obj.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 70), sh.get_rect())
                    surface.blit(sh, (obj.x + 1, obj.y + 2))

                    fridge_top = (238, 240, 246)
                    fridge_front = (210, 214, 224)
                    fridge_front2 = (178, 182, 194)
                    hi = (248, 248, 252)

                    top_h = int(clamp(int(obj.h * 0.34), 8, 12))
                    top_r = pygame.Rect(obj.x, obj.y, obj.w, top_h)
                    front_r = pygame.Rect(obj.x, obj.y + top_h - 1, obj.w, obj.h - (top_h - 1))

                    # Pixel-style outline for fridge.
                    pygame.draw.rect(surface, outline, front_r.inflate(2, 2))
                    pygame.draw.rect(surface, fridge_front, front_r)
                    pygame.draw.rect(surface, fridge_front2, pygame.Rect(front_r.x + 1, front_r.y + 2, front_r.w - 2, 3))

                    pygame.draw.rect(surface, outline, top_r.inflate(2, 2))
                    pygame.draw.rect(surface, fridge_top, top_r)
                    pygame.draw.line(surface, hi, (top_r.x + 2, top_r.y + 1), (top_r.right - 3, top_r.y + 1), 1)
                    pygame.draw.line(surface, outline, (top_r.x + 2, top_r.bottom - 1), (top_r.right - 3, top_r.bottom - 1), 1)

                    door_area = front_r.inflate(-4, -6)
                    if door_area.w <= 6 or door_area.h <= 8:
                        door_area = pygame.Rect(front_r)

                    open_block = getattr(self, "home_ui_open_block", None)
                    is_open = bool(getattr(self, "home_ui_open", False)) and open_block == (
                        int(x),
                        int(y),
                        int(x) + int(bw) - 1,
                        int(y) + int(bh) - 1,
                    )
                    if is_open:
                        inner = door_area.inflate(-8, -8)
                        if inner.w > 4 and inner.h > 4:
                            # Pixel-style fridge interior.
                            pygame.draw.rect(surface, outline, inner.inflate(2, 2))
                            pygame.draw.rect(surface, (20, 20, 24), inner)
                            for sy in range(inner.y + 4, inner.bottom - 2, 6):
                                pygame.draw.line(surface, (44, 44, 52), (inner.x + 2, sy), (inner.right - 3, sy), 1)
                            bottle = pygame.Rect(inner.x + 3, inner.bottom - 9, 4, 7)
                            surface.fill((120, 170, 230), bottle)
                            pygame.draw.rect(surface, outline, bottle, 1)
                            can = pygame.Rect(inner.right - 8, inner.bottom - 8, 5, 6)
                            surface.fill((220, 70, 80), can)
                            pygame.draw.rect(surface, outline, can, 1)

                        # Doors slid to sides. Pixel-style.
                        door_w = max(6, int(door_area.w // 5))
                        ld = pygame.Rect(door_area.x + 1, door_area.y + 3, door_w, door_area.h - 6)
                        rd = pygame.Rect(door_area.right - door_w - 1, door_area.y + 3, door_w, door_area.h - 6)
                        for d in (ld, rd):
                            pygame.draw.rect(surface, outline, d.inflate(2, 2))
                            pygame.draw.rect(surface, fridge_front, d)
                            inset = d.inflate(-2, -4)
                            if inset.w > 2 and inset.h > 2:
                                pygame.draw.rect(surface, outline, inset.inflate(2, 2))
                                pygame.draw.rect(surface, self._tint(fridge_front, add=(-8, -8, -8)), inset)
                                pygame.draw.line(surface, hi, (inset.x + 1, inset.y + 1), (inset.right - 2, inset.y + 1), 1)
                    else:
                        # Freezer split line + handle + magnets.
                        split_y = int(door_area.y + door_area.h * 0.38)
                        pygame.draw.line(surface, fridge_front2, (door_area.x + 2, split_y), (door_area.right - 3, split_y), 2)
                        pygame.draw.line(surface, outline, (door_area.x + 2, split_y), (door_area.right - 3, split_y), 1)
                        handle = pygame.Rect(door_area.right - 5, door_area.y + 4, 2, max(6, door_area.h - 8))
                        surface.fill(steel2, handle)
                        pygame.draw.rect(surface, outline, handle, 1)
                        for mx, my, col in (
                            (door_area.x + 3, door_area.y + 4, (240, 120, 120)),
                            (door_area.x + 6, door_area.y + 7, (120, 200, 140)),
                            (door_area.x + 4, door_area.y + 10, (240, 220, 140)),
                        ):
                            mr = pygame.Rect(int(mx), int(my), 3, 3)
                            surface.fill(col, mr)
                            pygame.draw.rect(surface, outline, mr, 1)

                    # Tiny feet so it doesn't look like it floats.
                    floor_y = int(br.bottom - 3)
                    leg_y0 = int(front_r.bottom - 2)
                    leg_h = int(floor_y - leg_y0)
                    if leg_h > 0:
                        leg_col = self._tint(fridge_front2, add=(-16, -16, -16))
                        for lx in (int(front_r.x + 6), int(front_r.right - 8)):
                            leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                            surface.fill(leg_col, leg)
                            pygame.draw.rect(surface, outline, leg, 1)
                    continue

                if ch == "X":
                    if (x, y) in x_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "X":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "X":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "X":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            x_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    obj = br.inflate(-6, -10)
                    if obj.w <= 0 or obj.h <= 0:
                        continue
                    # Pixel-style outline.
                    sh = pygame.Surface((obj.w + 4, obj.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 60), sh.get_rect())
                    surface.blit(sh, (obj.x + 1, obj.y + 2))

                    stand_h = int(clamp(int(obj.h * 0.36), 6, 12))
                    stand = pygame.Rect(int(obj.x + 2), int(obj.bottom - stand_h), int(obj.w - 4), int(stand_h))
                    pygame.draw.rect(surface, outline, stand.inflate(2, 2))
                    pygame.draw.rect(surface, wood2, stand)
                    pygame.draw.rect(surface, self._tint(wood2, add=(18, 18, 18)), pygame.Rect(stand.x + 2, stand.y + 2, max(1, stand.w - 4), 3))

                    tv_w = int(clamp(int(obj.w * 0.72), 20, max(20, obj.w - 2)))
                    tv_h = int(clamp(int(obj.h * 0.58), 12, 22))
                    tv = pygame.Rect(0, 0, tv_w, tv_h)
                    tv.midtop = (obj.centerx, obj.y + 1)
                    frame = tv.inflate(4, 4)
                    # Pixel-style outline for TV.
                    pygame.draw.rect(surface, outline, frame.inflate(2, 2))
                    pygame.draw.rect(surface, (34, 36, 44), frame)
                    screen = tv.inflate(-2, -2)
                    pygame.draw.rect(surface, outline, screen.inflate(2, 2))
                    pygame.draw.rect(surface, (14, 14, 18), screen)
                    pygame.draw.rect(surface, steel2, screen, 1)
                    if tv_on:
                        # Simple animated "show" on the TV.
                        surface.fill((18, 20, 28), screen)
                        for iy in range(screen.y + 2, screen.bottom - 2, 4):
                            col = (28, 32, 44) if ((iy // 4) % 2) == 0 else (22, 26, 36)
                            surface.fill(col, pygame.Rect(screen.x + 2, iy, screen.w - 4, 1))
                        phase = int(float(self.world_time_s) * 3.0)
                        span = max(1, int(screen.w - 8))
                        px = int(screen.x + 4 + (phase * 2) % span)
                        py = int(screen.y + screen.h // 2 - 2)
                        pygame.draw.rect(surface, (200, 220, 240), pygame.Rect(px, py, 2, 2))
                        pygame.draw.rect(surface, (170, 190, 210), pygame.Rect(px, py + 2, 2, 3))
                        pygame.draw.rect(surface, (140, 160, 190), pygame.Rect(px - 1, py + 5, 4, 1))
                    else:
                        glow = pygame.Rect(screen.x + 4, screen.y + 4, max(5, int(screen.w * 0.25)), max(4, int(screen.h * 0.22)))
                        pygame.draw.rect(surface, (120, 200, 240), glow)
                    pygame.draw.line(surface, steel2, (screen.x + 2, screen.bottom - 3), (screen.right - 3, screen.bottom - 3), 1)
                    # Game console / set-top box. Pixel-style.
                    box = pygame.Rect(int(stand.centerx - 10), int(stand.y + 3), 20, 6)
                    pygame.draw.rect(surface, outline, box.inflate(2, 2))
                    pygame.draw.rect(surface, (26, 26, 32), box)
                    pygame.draw.circle(surface, (120, 200, 140), (box.right - 4, box.centery), 1)
                    continue

                if ch == "P":
                    if (x, y) in p_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "P":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "P":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "P":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            p_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    obj = br.inflate(-6, -10)
                    if obj.w <= 0 or obj.h <= 0:
                        continue
                    # Pixel-style outline.
                    sh = pygame.Surface((obj.w + 4, obj.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 70), sh.get_rect())
                    surface.blit(sh, (obj.x + 1, obj.y + 2))

                    top_h = int(clamp(int(obj.h * 0.36), 10, 18))
                    top = pygame.Rect(int(obj.x), int(obj.y), int(obj.w), int(top_h))
                    front = pygame.Rect(int(obj.x), int(obj.y + top_h - 1), int(obj.w), int(obj.h - (top_h - 1)))
                    desk_top = self._tint(wood, add=(10, 8, 6))
                    desk_front = self._tint(wood2, add=(6, 4, 2))
                    # Pixel-style outline for desk.
                    pygame.draw.rect(surface, outline, front.inflate(2, 2))
                    pygame.draw.rect(surface, desk_front, front)
                    pygame.draw.rect(surface, outline, top.inflate(2, 2))
                    pygame.draw.rect(surface, desk_top, top)
                    pygame.draw.line(surface, self._tint(desk_top, add=(26, 26, 26)), (top.x + 2, top.y + 1), (top.right - 3, top.y + 1), 1)

                    # Monitor + keyboard. Pixel-style.
                    mon_w = int(clamp(int(top.w * 0.42), 14, 30))
                    mon_h = int(clamp(int(top.h * 0.70), 10, 16))
                    mon = pygame.Rect(0, 0, mon_w, mon_h)
                    mon.center = (int(top.centerx - top.w * 0.12), int(top.centery + 1))
                    pygame.draw.rect(surface, outline, mon.inflate(2, 2))
                    pygame.draw.rect(surface, (32, 34, 40), mon)
                    # Give the monitor a tiny "thickness" so it reads 3D.
                    side = pygame.Rect(mon.right - 1, mon.y + 1, 2, max(1, mon.h - 2))
                    pygame.draw.rect(surface, (22, 22, 28), side)
                    pygame.draw.line(surface, outline, (side.x, side.y + 1), (side.x, side.bottom - 2), 1)
                    scr = mon.inflate(-3, -3)
                    pygame.draw.rect(surface, (14, 14, 18), scr)
                    pygame.draw.rect(surface, (120, 200, 240), pygame.Rect(scr.x + 2, scr.y + 2, max(3, scr.w // 3), max(3, scr.h // 3)))
                    kb = pygame.Rect(int(mon.right + 3), int(top.bottom - 6), max(12, int(top.w * 0.30)), 4)
                    pygame.draw.rect(surface, outline, kb.inflate(2, 2))
                    pygame.draw.rect(surface, (36, 36, 44), kb)
                    for xx in range(int(kb.x + 2), int(kb.right - 2), 3):
                        surface.fill((60, 60, 72), pygame.Rect(int(xx), int(kb.y + 1), 1, 1))

                    # PC tower. Pixel-style.
                    tower = pygame.Rect(int(top.right - 10), int(front.y + 4), 8, max(10, int(front.h - 8)))
                    pygame.draw.rect(surface, outline, tower.inflate(2, 2))
                    pygame.draw.rect(surface, (28, 28, 34), tower)
                    surface.fill((18, 18, 22), pygame.Rect(tower.right - 2, tower.y + 1, 1, max(1, tower.h - 2)))
                    surface.fill((56, 56, 66), pygame.Rect(tower.x + 1, tower.y + 2, max(1, tower.w - 3), 1))
                    pygame.draw.circle(surface, (120, 200, 140), (tower.centerx, tower.y + 5), 1)
                    continue

                if ch == "R":
                    if (x, y) in r_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "R":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "R":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "R":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            r_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    obj = br.inflate(-6, -10)
                    if obj.w <= 0 or obj.h <= 0:
                        continue
                    # Pixel-style outline.
                    sh = pygame.Surface((obj.w + 4, obj.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 60), sh.get_rect())
                    surface.blit(sh, (obj.x + 1, obj.y + 2))

                    tray = obj.inflate(-2, -2)
                    tray_col = (214, 216, 222)
                    tray_hi = (232, 232, 238)
                    pygame.draw.rect(surface, outline, tray.inflate(2, 2))
                    pygame.draw.rect(surface, tray_col, tray)
                    pygame.draw.rect(surface, tray_hi, pygame.Rect(tray.x + 2, tray.y + 2, tray.w - 4, 3), border_radius=3)
                    drain = pygame.Rect(tray.centerx + 4, tray.centery + 3, 4, 4)
                    pygame.draw.ellipse(surface, (40, 40, 48), drain)
                    pygame.draw.ellipse(surface, outline, drain, 1)

                    glass = tray.inflate(-6, -10)
                    if glass.w > 6 and glass.h > 6:
                        gs = pygame.Surface((glass.w, glass.h), pygame.SRCALPHA)
                        gs.fill((90, 140, 190, 55))
                        # Pixel-style glass frame.
                        pygame.draw.rect(gs, (210, 220, 235, 80), gs.get_rect(), 1)
                        surface.blit(gs, glass.topleft)
                        pygame.draw.line(surface, outline, (glass.centerx, glass.y + 2), (glass.centerx, glass.bottom - 3), 1)
                    # Showerhead hint.
                    pygame.draw.line(surface, steel2, (tray.x + 6, tray.y + 4), (tray.x + 12, tray.y + 4), 1)
                    pygame.draw.circle(surface, steel2, (tray.x + 12, tray.y + 4), 2, 1)
                    continue

                if ch == "U":
                    base = r.inflate(-6, -8)
                    if base.w > 0 and base.h > 0:
                        # Pixel-style bathroom vanity.
                        cab = pygame.Rect(base.x, base.y + 4, base.w, max(6, base.h - 4))
                        pygame.draw.rect(surface, outline, cab.inflate(2, 2))
                        pygame.draw.rect(surface, wood2, cab)
                        basin = pygame.Rect(base.x + 2, base.y + 1, base.w - 4, 6)
                        pygame.draw.rect(surface, outline, basin.inflate(2, 2))
                        pygame.draw.rect(surface, (238, 238, 244), basin)
                        pygame.draw.circle(surface, steel2, (basin.right - 4, basin.y + 2), 1)
                        pygame.draw.line(surface, steel2, (basin.right - 4, basin.y + 2), (basin.right - 4, basin.y + 5), 1)
                    continue

                if ch == "O":
                    # Pixel-style toilet (second rendering path).
                    bowl = pygame.Rect(r.x + 6, r.y + 9, r.w - 12, r.h - 10)
                    tank = pygame.Rect(r.centerx - 5, r.y + 5, 10, 6)
                    pygame.draw.ellipse(surface, (238, 238, 244), bowl)
                    pygame.draw.ellipse(surface, outline, bowl, 1)
                    pygame.draw.rect(surface, outline, tank.inflate(2, 2))
                    pygame.draw.rect(surface, (238, 238, 244), tank)
                    seat = bowl.inflate(-4, -4)
                    pygame.draw.ellipse(surface, (210, 210, 218), seat)
                    pygame.draw.ellipse(surface, outline, seat, 1)
                    continue

                if ch == "C":
                    if (x, y) in c_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "C":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "C":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "C":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            c_done.add((int(x) + int(dx), int(y) + int(dy)))

                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    obj = br.inflate(-6, -10)
                    # Pixel-style outline.
                    sh = pygame.Surface((obj.w + 4, obj.h + 4), pygame.SRCALPHA)
                    pygame.draw.rect(sh, (0, 0, 0, 60), sh.get_rect())
                    surface.blit(sh, (obj.x + 1, obj.y + 2))

                    is_sofa = bool(mode == "home" and (int(bw) >= 3 or int(bh) >= 2))
                    if is_sofa:
                        back_h = int(clamp(int(obj.h // 3), 7, 12))
                        back = pygame.Rect(obj.x + 1, obj.y + 1, obj.w - 2, back_h)
                        seat_r = pygame.Rect(obj.x, obj.y + back_h - 1, obj.w, obj.h - back_h + 1)
                        # Pixel-style outline for sofa.
                        pygame.draw.rect(surface, outline, seat_r.inflate(2, 2))
                        pygame.draw.rect(surface, seat, seat_r)
                        pygame.draw.rect(surface, outline, back.inflate(2, 2))
                        pygame.draw.rect(surface, seat2, back)
                        arm_w = int(clamp(int(obj.w // 10), 4, 8))
                        arm_l = pygame.Rect(seat_r.x, back.bottom - 2, arm_w, seat_r.h - 2)
                        arm_r = pygame.Rect(seat_r.right - arm_w, back.bottom - 2, arm_w, seat_r.h - 2)
                        pygame.draw.rect(surface, outline, arm_l.inflate(2, 2))
                        pygame.draw.rect(surface, seat2, arm_l)
                        pygame.draw.rect(surface, outline, arm_r.inflate(2, 2))
                        pygame.draw.rect(surface, seat2, arm_r)
                        for i in (1, 2):
                            xline = int(seat_r.x + (seat_r.w * i) / 3)
                            pygame.draw.line(surface, outline, (xline, seat_r.y + 3), (xline, seat_r.bottom - 4), 1)
                        if back.w >= 24:
                            # Pixel-style sofa cushions.
                            p_w = int(clamp(int(back.w // 3), 10, 18))
                            for px in (back.x + 6, back.right - p_w - 6):
                                p = pygame.Rect(int(px), back.y + 3, int(p_w), max(4, int(back.h - 5)))
                                pygame.draw.rect(surface, outline, p.inflate(2, 2))
                                pygame.draw.rect(surface, self._tint(seat, add=(18, 18, 18)), p)
                        floor_y = int(br.bottom - 3)
                        leg_y0 = int(seat_r.bottom - 1)
                        leg_h = int(floor_y - leg_y0)
                        if leg_h > 0:
                            leg_col = self._tint(seat2, add=(-22, -22, -22))
                            for lx in (int(seat_r.x + 6), int(seat_r.right - 8)):
                                leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                                surface.fill(leg_col, leg)
                                pygame.draw.rect(surface, outline, leg, 1)
                    else:
                        # Pixel-style outline for chair.
                        pygame.draw.rect(surface, outline, obj.inflate(2, 2))
                        pygame.draw.rect(surface, seat, obj)
                        back = pygame.Rect(obj.x + 2, obj.y + 2, obj.w - 4, int(clamp(int(obj.h * 0.45), 5, 10)))
                        pygame.draw.rect(surface, outline, back.inflate(2, 2))
                        pygame.draw.rect(surface, seat2, back)
                        seat_r = pygame.Rect(obj.x + 2, back.bottom - 1, obj.w - 4, obj.bottom - (back.bottom - 1))
                        pygame.draw.rect(surface, outline, seat_r.inflate(2, 2))
                        pygame.draw.rect(surface, self._tint(seat, add=(12, 12, 12)), seat_r)
                        floor_y = int(br.bottom - 3)
                        leg_y0 = int(seat_r.bottom - 1)
                        leg_h = int(floor_y - leg_y0)
                        if leg_h > 0:
                            leg_col = self._tint(seat2, add=(-18, -18, -18))
                            for lx in (int(seat_r.x + 2), int(seat_r.right - 4)):
                                leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                                surface.fill(leg_col, leg)
                                pygame.draw.rect(surface, outline, leg, 1)
                    continue

                if False and ch == "C":
                    sr = pygame.Rect(r.x + 4, r.y + 4, r.w - 8, r.h - 8)
                    sh = pygame.Surface((sr.w, sr.h), pygame.SRCALPHA)  
                    pygame.draw.rect(sh, (0, 0, 0, 60), sh.get_rect(), border_radius=4)
                    surface.blit(sh, (sr.x + 1, sr.y + 2))
                    pygame.draw.rect(surface, seat, sr, border_radius=4)
                    pygame.draw.rect(surface, outline, sr, 1, border_radius=4)
                    pygame.draw.rect(surface, seat2, pygame.Rect(sr.x + 2, sr.y + 2, sr.w - 4, 4), border_radius=2)
                    # Legs (gives the chair more readable structure).
                    leg_y0 = int(sr.bottom - 1)
                    leg_y1 = int(r.bottom - 3)
                    leg_h = int(leg_y1 - leg_y0)
                    if leg_h > 0:
                        leg_col = self._tint(seat2, add=(-18, -18, -18))        
                        for lx in (int(sr.x + 3), int(sr.right - 5)):
                            leg = pygame.Rect(int(lx), int(leg_y0), 2, int(leg_h))
                            surface.fill(leg_col, leg)
                            pygame.draw.rect(surface, outline, leg, 1)
                    continue

        # Apartment floor loot + proximity outlines.
        if mode == "home":
            items = getattr(self, "hr_floor_items", None)
            near_i: int | None = None
            near_d2 = float("inf")
            if isinstance(items, list) and items:
                focus = pygame.Vector2(self.hr_int_pos)
                for i, it in enumerate(items):
                    if not isinstance(it, HardcoreSurvivalState._WorldItem):
                        continue
                    d2 = float((pygame.Vector2(it.pos) - focus).length_squared())
                    if d2 < near_d2:
                        near_d2 = d2
                        near_i = int(i)

                for i, it in enumerate(items):
                    if not isinstance(it, HardcoreSurvivalState._WorldItem):
                        continue
                    spr = self._ITEM_SPRITES_WORLD.get(it.item_id) or self._ITEM_SPRITES.get(it.item_id)
                    if spr is None:
                        continue
                    ix = int(round(map_x + float(it.pos.x) - float(spr.get_width()) / 2.0))
                    iy = int(round(map_y + float(it.pos.y) - float(spr.get_height()) / 2.0))
                    surface.blit(spr, (ix, iy))
                    if near_i is not None and int(i) == int(near_i) and near_d2 <= (22.0 * 22.0):
                        pygame.draw.rect(
                            surface,
                            (0, 220, 80),
                            pygame.Rect(ix - 2, iy - 2, spr.get_width() + 4, spr.get_height() + 4),
                            2,
                            border_radius=3,
                        )

            tx, ty = self._hr_int_player_tile()
            candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
            interact = {"D", "B", "S", "F", "C", "O", "L"}
            pose = str(getattr(self, "player_pose", "")).strip()
            pose_space = str(getattr(self, "player_pose_space", "")).strip()
            in_pose = bool(pose_space == "hr" and pose in ("sleep", "sit"))

            def _draw_cells_outline(
                cells: list[tuple[int, int]],
                *,
                rgb: tuple[int, int, int],
                fill_alpha: int = 0,
                edge_alpha: int = 200,
            ) -> None:
                if not cells:
                    return
                min_x = min(int(p[0]) for p in cells)
                max_x = max(int(p[0]) for p in cells)
                min_y = min(int(p[1]) for p in cells)
                max_y = max(int(p[1]) for p in cells)
                w_tiles = int(max_x - min_x + 1)
                h_tiles = int(max_y - min_y + 1)
                ov = pygame.Surface((int(w_tiles) * int(tile), int(h_tiles) * int(tile)), pygame.SRCALPHA)
                cell_set = {(int(x), int(y)) for (x, y) in cells}
                if int(fill_alpha) > 0:
                    fill_col = (int(rgb[0]), int(rgb[1]), int(rgb[2]), int(clamp(int(fill_alpha), 0, 255)))
                    for cx, cy in cell_set:
                        rr = pygame.Rect(int((cx - min_x) * tile), int((cy - min_y) * tile), int(tile), int(tile))
                        ov.fill(fill_col, rr)
                edge_col = (int(rgb[0]), int(rgb[1]), int(rgb[2]), int(clamp(int(edge_alpha), 0, 255)))
                for cx, cy in cell_set:
                    rx = int((cx - min_x) * tile)
                    ry = int((cy - min_y) * tile)
                    left = int(rx)
                    right = int(rx + tile - 1)
                    top = int(ry)
                    bottom = int(ry + tile - 1)
                    if (int(cx) - 1, int(cy)) not in cell_set:
                        pygame.draw.line(ov, edge_col, (left, top), (left, bottom), 1)
                    if (int(cx) + 1, int(cy)) not in cell_set:
                        pygame.draw.line(ov, edge_col, (right, top), (right, bottom), 1)
                    if (int(cx), int(cy) - 1) not in cell_set:
                        pygame.draw.line(ov, edge_col, (left, top), (right, top), 1)
                    if (int(cx), int(cy) + 1) not in cell_set:
                        pygame.draw.line(ov, edge_col, (left, bottom), (right, bottom), 1)
                surface.blit(ov, (int(map_x + min_x * tile), int(map_y + min_y * tile)))

            near_lamp: tuple[int, int] | None = None
            for cx, cy in candidates:
                if str(self._hr_int_char_at(int(cx), int(cy)))[:1] == "L":
                    near_lamp = (int(cx), int(cy))
                    break

            chosen_ch = ""
            for cx, cy in candidates:
                ch = self._hr_int_char_at(cx, cy)
                if ch not in interact:
                    continue
                w = int(self._HR_INT_W)
                h = int(self._HR_INT_H)
                seen: set[tuple[int, int]] = set()
                stack = [(int(cx), int(cy))]
                cells: list[tuple[int, int]] = []
                while stack:
                    sx, sy = stack.pop()
                    if (int(sx), int(sy)) in seen:
                        continue
                    if not (0 <= int(sx) < int(w) and 0 <= int(sy) < int(h)):
                        continue
                    if str(self._hr_int_char_at(int(sx), int(sy)))[:1] != str(ch)[:1]:
                        continue
                    seen.add((int(sx), int(sy)))
                    cells.append((int(sx), int(sy)))
                    stack.extend([(int(sx) + 1, int(sy)), (int(sx) - 1, int(sy)), (int(sx), int(sy) + 1), (int(sx), int(sy) - 1)])
                _draw_cells_outline(cells, rgb=(0, 220, 80), fill_alpha=0, edge_alpha=220)
                chosen_ch = str(ch)[:1]
                break

            if (
                near_lamp is not None
                and not bool(in_pose)
                and str(getattr(self, "hr_mode", "lobby")) == "home"
                and str(room_id).strip()
                and not bool(getattr(self, "inv_open", False))
                and not bool(getattr(self, "home_ui_open", False))
                and not bool(getattr(self, "hr_elevator_ui_open", False))
                and not bool(getattr(self, "world_map_open", False))
                and not bool(getattr(self, "hr_edit_mode", False))
            ):
                lx, ly = int(near_lamp[0]), int(near_lamp[1])
                if str(chosen_ch) != "L":
                    _draw_cells_outline([(int(lx), int(ly))], rgb=(0, 220, 80), fill_alpha=0, edge_alpha=220)

                label_toggle = "关灯" if bool(light_on) else "开灯"
                label_move = "搬运"
                font = self.app.font_s
                btn_h = int(font.get_height()) + 4
                btn_w = int(max(30, int(max(font.size(str(label_toggle))[0], font.size(str(label_move))[0])) + 12))
                gap = 4
                opts: list[tuple[str, str, tuple[int, int] | None]] = [
                    (str(label_toggle), "toggle_lamp", None),
                    (str(label_move), "hr_move", (int(lx), int(ly))),
                ]

                panel_w = int(len(opts) * btn_w + max(0, len(opts) - 1) * gap + 10)
                panel_h = int(btn_h + 10)
                lr = pygame.Rect(int(map_x + int(lx) * tile), int(map_y + int(ly) * tile), int(tile), int(tile))
                px = int(lr.centerx - panel_w // 2)
                py = int(lr.top - panel_h - 6)
                if py < int(map_rect.top + 2):
                    py = int(lr.bottom + 6)
                panel = pygame.Rect(int(px), int(py), int(panel_w), int(panel_h))
                panel.clamp_ip(map_rect.inflate(-2, -2))
                # Pixel-style panel (no border_radius).
                pygame.draw.rect(surface, (90, 90, 110), panel.inflate(2, 2))
                pygame.draw.rect(surface, (18, 18, 22), panel)

                x0 = int(panel.x + 5)
                y0 = int(panel.y + 5)
                for i, (label, action, payload) in enumerate(opts):
                    br = pygame.Rect(int(x0 + i * (btn_w + gap)), int(y0), int(btn_w), int(btn_h))
                    # Pixel-style button (no border_radius).
                    pygame.draw.rect(surface, (160, 160, 180), br.inflate(2, 2))
                    pygame.draw.rect(surface, (28, 28, 34), br)
                    draw_text(surface, font, str(label), (br.centerx, br.centery - 1), pygame.Color(230, 230, 240), anchor="center")
                    self._hr_int_ui_buttons.append((str(action), str(room_id), pygame.Rect(br), payload))

        if str(getattr(self, "hr_mode", "lobby")) == "home" and bool(getattr(self, "hr_edit_mode", False)):
            blocks = getattr(self, "hr_edit_blocks", None)
            if isinstance(blocks, list) and blocks:
                sel_i = int(getattr(self, "hr_edit_index", 0)) % len(blocks)
                _ch, cells = blocks[sel_i]
                _draw_cells_outline([(int(p[0]), int(p[1])) for p in cells], rgb=(255, 220, 140), fill_alpha=50, edge_alpha=180)

        # Draw player on top of the interior.
        face = pygame.Vector2(self.hr_int_facing)
        if face.length_squared() <= 0.001:
            face = pygame.Vector2(0, 1)
        if abs(face.y) >= abs(face.x):
            d = "down" if face.y >= 0 else "up"
        else:
            d = "right" if face.x >= 0 else "left"
        pose = str(getattr(self, "player_pose", "")).strip()
        pose_space = str(getattr(self, "player_pose_space", "")).strip()
        pose_anchor = getattr(self, "player_pose_anchor", None)
        use_pose = bool(pose and pose_space == "hr" and pose_anchor is not None)
        if use_pose:
            p = pygame.Vector2(float(pose_anchor[0]), float(pose_anchor[1]))
            if pose == "sleep":
                frame = int(float(getattr(self, "player_pose_phase", 0.0)) * 2.0) % 2
                base = self._get_pose_sprite("sleep", frame=frame)
            else:
                base = self._get_pose_sprite("sit", direction=d, frame=0)
        else:
            p = pygame.Vector2(self.hr_int_pos)
            speed2 = float(self.hr_int_vel.length_squared())
            pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
            pf_run = getattr(self, "player_frames_run", None)
            is_run = bool(getattr(self, "player_sprinting", False))
            pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
            frames = pf.get(d, pf["down"])
            if speed2 <= 0.2 or len(frames) <= 1:
                base = frames[0]
            else:
                walk = frames[1:]
                phase = (float(self.hr_int_walk_phase) % math.tau) / math.tau
                idx = int(phase * len(walk)) % len(walk)
                base = walk[idx]

        scale = int(max(1, int(self._HR_INT_SPRITE_SCALE)))
        spr = pygame.transform.scale(base, (int(base.get_width()) * scale, int(base.get_height()) * scale))
        sx = int(round(map_x + p.x))
        sy = int(round(map_y + p.y))
        if use_pose and pose == "sleep":
            shadow = pygame.Rect(0, 0, 20, 8)
            shadow.center = (sx, sy + 4)
            sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
            pygame.draw.ellipse(sh, (0, 0, 0, 90), sh.get_rect())
            surface.blit(sh, shadow.topleft)
            rect = spr.get_rect(center=(sx, sy + 2))
            surface.blit(spr, rect)
        elif use_pose and pose == "sit":
            shadow = pygame.Rect(0, 0, 16, 7)
            shadow.center = (sx, sy + 8)
            sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
            pygame.draw.ellipse(sh, (0, 0, 0, 110), sh.get_rect())
            surface.blit(sh, shadow.topleft)
            rect = spr.get_rect(center=(sx, sy + 6))
            surface.blit(spr, rect)
        else:
            shadow = pygame.Rect(0, 0, 14, 6)
            shadow.center = (sx, sy + 8)
            sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
            pygame.draw.ellipse(sh, (0, 0, 0, 120), sh.get_rect())
            surface.blit(sh, shadow.topleft)
            rect = spr.get_rect()
            rect.midbottom = (sx, sy + 12)
            surface.blit(spr, rect)

        if mode == "home":
            self._draw_hr_interior_lighting(
                surface,
                map_rect=map_rect,
                map_x=int(map_x),
                map_y=int(map_y),
                tile=int(tile),
                lamps=lamp_tiles,
                light_on=bool(light_on),
            )

        # Hover: furniture details + outline (home only).
        if str(getattr(self, "hr_mode", "lobby")) == "home":
            mouse = None
            if (
                not self.inv_open
                and not bool(getattr(self, "hr_elevator_ui_open", False))
                and not bool(getattr(self, "home_ui_open", False))
                and not bool(getattr(self, "world_map_open", False))
            ):
                mouse = self.app.screen_to_internal(pygame.mouse.get_pos())
            if mouse is not None:
                mx, my = int(mouse[0]), int(mouse[1])
                if map_rect.collidepoint(mx, my):
                    ix = int((mx - int(map_x)) // int(tile))
                    iy = int((my - int(map_y)) // int(tile))
                    ch = str(self._hr_int_char_at(ix, iy))[:1]
                    movable = {"B", "S", "F", "K", "T", "C", "P", "X"}
                    if ch in movable:
                        w = int(self._HR_INT_W)
                        h = int(self._HR_INT_H)
                        seen: set[tuple[int, int]] = set()
                        stack = [(int(ix), int(iy))]
                        cells: list[tuple[int, int]] = []
                        while stack:
                            cx, cy = stack.pop()
                            cx = int(cx)
                            cy = int(cy)
                            if (cx, cy) in seen:
                                continue
                            if not (0 <= cx < w and 0 <= cy < h):
                                continue
                            if str(self._hr_int_char_at(cx, cy))[:1] != ch:
                                continue
                            seen.add((cx, cy))
                            cells.append((cx, cy))
                            stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
                        if cells:
                            _draw_cells_outline(cells, rgb=(255, 220, 140), fill_alpha=18, edge_alpha=220)

                            min_x = min(int(p[0]) for p in cells)
                            max_x = max(int(p[0]) for p in cells)
                            min_y = min(int(p[1]) for p in cells)
                            max_y = max(int(p[1]) for p in cells)
                            bw = int(max_x - min_x + 1)
                            bh = int(max_y - min_y + 1)
                            name = "家具"
                            desc = ""
                            if ch == "B":
                                name, desc = ("床", "躺下可恢复体力与心情")
                            elif ch == "S":
                                name, desc = ("储物柜", "打开后可存取物资")
                            elif ch == "F":
                                name, desc = ("冰箱", "存放食物/饮料（可存取）")
                            elif ch == "T":
                                name, desc = ("桌子", "临时放置/整理物品（规划）")
                            elif ch == "K":
                                name, desc = ("厨房", "台面上有锅碗瓢盆（烹饪/净水规划）")
                            elif ch == "C":
                                if bw >= 3 or bh >= 2:
                                    name, desc = ("沙发", "坐下休息（规划）")
                                else:
                                    name, desc = ("椅子", "坐下休息（规划）")
                            if bool(getattr(self, "hr_edit_mode", False)):
                                hint = "左键拖拽 | 方向键微调 | R 退出摆放"
                            else:
                                hint = "R 进入摆放模式 | 左键拖拽"
                            self._hover_tooltip = ([str(name), str(desc), str(hint)], (mx, my))
        surface.set_clip(prev_clip)
        return

        floor_a = (64, 62, 58)
        floor_b = (58, 56, 52)
        wall = (22, 22, 26)
        wall_hi = (38, 38, 46)
        door_col = (240, 220, 140)
        apt_door = (120, 92, 64)
        apt_door2 = (90, 68, 46)
        elev = (110, 112, 120)
        elev2 = (74, 76, 86)
        glass = (90, 140, 190)
        seat = (56, 72, 140)
        seat2 = (40, 52, 112)
        shelf = (92, 78, 62)
        shelf2 = (66, 56, 46)
        table = (88, 72, 54)
        table2 = (60, 50, 38)
        kitchen = (86, 78, 68)
        kitchen2 = (60, 54, 46)
        steel = (220, 220, 230)
        bed = (170, 150, 140)
        bed2 = (128, 108, 100)

        title = "高层住宅"
        mode = str(getattr(self, "hr_mode", "lobby"))
        floor = int(getattr(self, "hr_floor", 0))
        if mode == "home":
            subtitle = "你的家"
        elif floor <= 0:
            subtitle = "大堂"
        else:
            subtitle = f"{floor} 层"
            if int(getattr(self, "hr_home_floor", -1)) == floor:
                subtitle += "（家）"
        draw_text(surface, self.app.font_s, f"{title} - {subtitle}", (INTERNAL_W // 2, panel.top - 14), pygame.Color(240, 240, 240), anchor="center")

        bed_done: set[tuple[int, int]] = set()
        elev_done: set[tuple[int, int]] = set()
        for y in range(int(self._HR_INT_H)):
            row = self.hr_layout[y] if 0 <= y < len(self.hr_layout) else ""
            for x in range(int(self._HR_INT_W)):
                ch = row[x] if x < len(row) else "W"
                r = pygame.Rect(map_x + x * tile, map_y + y * tile, tile, tile)

                if ch in ("W", "V", "D", "A", "H"):
                    pygame.draw.rect(surface, wall, r)
                    pygame.draw.rect(surface, wall_hi, pygame.Rect(r.x, r.y, r.w, 3))
                    pygame.draw.rect(surface, (0, 0, 0), r, 1)
                    if ch == "V":
                        g = pygame.Rect(r.x + 3, r.y + 4, r.w - 6, r.h - 8)
                        pygame.draw.rect(surface, glass, g, border_radius=2)
                        pygame.draw.rect(surface, (10, 10, 12), g, 1, border_radius=2)
                        pygame.draw.line(surface, (180, 210, 240), (g.left + 1, g.top + 1), (g.right - 2, g.top + 1), 1)
                        pygame.draw.line(surface, (40, 40, 50), (g.centerx, g.top + 1), (g.centerx, g.bottom - 2), 1)
                    elif ch == "D":
                        dr = pygame.Rect(r.x + 5, r.y + 4, r.w - 10, r.h - 8)
                        pygame.draw.rect(surface, door_col, dr, border_radius=2)
                        pygame.draw.rect(surface, (10, 10, 12), dr, 1, border_radius=2)
                        pygame.draw.circle(surface, (10, 10, 12), (dr.right - 5, dr.centery), 2)
                    elif ch in ("A", "H"):
                        dr = pygame.Rect(r.x + 4, r.y + 5, r.w - 8, r.h - 10)
                        pygame.draw.rect(surface, apt_door, dr, border_radius=2)
                        pygame.draw.rect(surface, (10, 10, 12), dr, 1, border_radius=2)
                        pygame.draw.rect(surface, apt_door2, pygame.Rect(dr.x + 2, dr.y + 2, dr.w - 4, 3))
                        pygame.draw.circle(surface, (240, 220, 140), (dr.right - 4, dr.centery), 2)
                        if ch == "H":
                            pygame.draw.rect(surface, (120, 200, 140), pygame.Rect(dr.x + 2, dr.y - 2, dr.w - 4, 3), border_radius=1)
                    continue

                col = floor_a if ((x + y) % 2 == 0) else floor_b
                pygame.draw.rect(surface, col, r)
                pygame.draw.rect(surface, (0, 0, 0), r, 1)

                if ch == "E":
                    if (x, y) in elev_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "E":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "E":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "E":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            elev_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    er = pygame.Rect(br.x + 2, br.y + 2, br.w - 4, br.h - 4)
                    pygame.draw.rect(surface, elev, er, border_radius=3)
                    pygame.draw.rect(surface, (10, 10, 12), er, 1, border_radius=3)
                    pygame.draw.rect(surface, elev2, pygame.Rect(er.x + 3, er.y + 3, er.w - 6, 3))
                    pygame.draw.line(surface, (10, 10, 12), (er.centerx, er.y + 4), (er.centerx, er.bottom - 5), 1)
                    continue
                if ch == "C":
                    pygame.draw.rect(surface, seat, pygame.Rect(r.x + 4, r.y + 4, r.w - 8, r.h - 8), border_radius=3)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 4, r.y + 4, r.w - 8, r.h - 8), 1, border_radius=3)
                    pygame.draw.rect(surface, seat2, pygame.Rect(r.x + 6, r.y + 6, r.w - 12, 4))
                elif ch == "T":
                    pygame.draw.rect(surface, table, pygame.Rect(r.x + 3, r.y + 6, r.w - 6, r.h - 10), border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 3, r.y + 6, r.w - 6, r.h - 10), 1, border_radius=2)
                    pygame.draw.rect(surface, table2, pygame.Rect(r.x + 4, r.y + 8, r.w - 8, 3))
                elif ch == "K":
                    pygame.draw.rect(surface, kitchen, pygame.Rect(r.x + 2, r.y + 5, r.w - 4, r.h - 8), border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 2, r.y + 5, r.w - 4, r.h - 8), 1, border_radius=2)
                    pygame.draw.rect(surface, kitchen2, pygame.Rect(r.x + 3, r.y + 7, r.w - 6, 3))
                    pygame.draw.rect(surface, steel, pygame.Rect(r.x + 6, r.y + 6, 6, 4), border_radius=1)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 6, r.y + 6, 6, 4), 1, border_radius=1)
                elif ch == "B":
                    if (int(x), int(y)) in bed_done:
                        continue
                    bw = 1
                    while self._hr_int_char_at(int(x) + int(bw), int(y)) == "B":
                        bw += 1
                    bh = 1
                    while True:
                        ny = int(y) + int(bh)
                        if self._hr_int_char_at(int(x), int(ny)) != "B":
                            break
                        ok = True
                        for dx in range(int(bw)):
                            if self._hr_int_char_at(int(x) + int(dx), int(ny)) != "B":
                                ok = False
                                break
                        if not ok:
                            break
                        bh += 1
                    for dy in range(int(bh)):
                        for dx in range(int(bw)):
                            bed_done.add((int(x) + int(dx), int(y) + int(dy)))
                    br = pygame.Rect(map_x + int(x) * tile, map_y + int(y) * tile, int(bw) * tile, int(bh) * tile)
                    bed_r = pygame.Rect(br.x + 2, br.y + 3, br.w - 4, br.h - 6)
                    pygame.draw.rect(surface, bed, bed_r, border_radius=4)
                    pygame.draw.rect(surface, (10, 10, 12), bed_r, 1, border_radius=4)
                    pillow_w = int(clamp(int(bed_r.w // 3), 8, max(8, bed_r.w - 4)))
                    pillow = pygame.Rect(bed_r.x + 2, bed_r.y + 2, pillow_w, 6)
                    pygame.draw.rect(surface, (230, 230, 235), pillow, border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pillow, 1, border_radius=2)
                    pygame.draw.rect(surface, bed2, pygame.Rect(bed_r.x + 2, bed_r.y + 10, bed_r.w - 4, 6), border_radius=2)
                    continue
                elif ch == "S":
                    pygame.draw.rect(surface, shelf, pygame.Rect(r.x + 3, r.y + 3, r.w - 6, r.h - 6), border_radius=2)
                    pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(r.x + 3, r.y + 3, r.w - 6, r.h - 6), 1, border_radius=2)
                    pygame.draw.line(surface, shelf2, (r.x + 4, r.y + r.h // 2), (r.right - 5, r.y + r.h // 2), 2)

        p = pygame.Vector2(self.hr_int_pos)
        speed2 = float(self.hr_int_vel.length_squared())
        face = pygame.Vector2(self.hr_int_facing)
        if face.length_squared() <= 0.001:
            face = pygame.Vector2(0, 1)
        if abs(face.y) >= abs(face.x):
            d = "down" if face.y >= 0 else "up"
        else:
            d = "right" if face.x >= 0 else "left"
        pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
        pf_run = getattr(self, "player_frames_run", None)
        is_run = bool(getattr(self, "player_sprinting", False))
        pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
        frames = pf.get(d, pf["down"])
        if speed2 <= 0.2 or len(frames) <= 1:
            base = frames[0]
        else:
            walk = frames[1:]
            phase = (float(self.hr_int_walk_phase) % math.tau) / math.tau
            idx = int(phase * len(walk)) % len(walk)
            base = walk[idx]

        scale = int(max(1, int(self._HR_INT_SPRITE_SCALE)))
        spr = pygame.transform.scale(base, (int(base.get_width()) * scale, int(base.get_height()) * scale))
        sx = int(round(map_x + p.x))
        sy = int(round(map_y + p.y))
        shadow = pygame.Rect(0, 0, 14, 6)
        shadow.center = (sx, sy + 8)
        pygame.draw.ellipse(surface, (0, 0, 0), shadow)
        rect = spr.get_rect()
        rect.midbottom = (sx, sy + 12)
        surface.blit(spr, rect)

    def _draw_sch_elevator_ui(self, surface: pygame.Surface) -> None:
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 200))
        surface.blit(overlay, (0, 0))

        options: list[int] = list(getattr(self, "sch_elevator_options", []))
        if not options:
            options = [1]
            self.sch_elevator_options = options
        cols = max(1, int(getattr(self, "sch_elevator_cols", 4)))
        rows_per_page = 4
        n = len(options)
        page_size = max(1, cols * rows_per_page)
        sel_i = int(getattr(self, "sch_elevator_sel", 0)) % max(1, n)
        page = int(sel_i // page_size)
        page_count = int(max(1, int(math.ceil(float(n) / float(page_size)))))
        start = int(page * page_size)
        end = int(min(int(n), int(start + page_size)))
        page_opts = list(options[start:end])
        rows = int(max(1, int(math.ceil(float(len(page_opts)) / float(cols)))))

        btn_w = 56
        btn_h = 28
        gap = 8
        grid_w = cols * btn_w + (cols - 1) * gap
        grid_h = rows * btn_h + (rows - 1) * gap
        panel = pygame.Rect(0, 0, grid_w + 40, grid_h + 98)
        panel.center = (INTERNAL_W // 2, INTERNAL_H // 2)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (90, 90, 110), panel, 2, border_radius=12)

        draw_text(surface, self.app.font_m, "电梯", (panel.centerx, panel.top + 16), pygame.Color(240, 240, 240), anchor="center")
        draw_text(
            surface,
            self.app.font_s,
            f"选择楼层（{int(page) + 1}/{int(page_count)}页）",
            (panel.centerx, panel.top + 36),
            pygame.Color(180, 180, 195),
            anchor="center",
        )
        typed = str(getattr(self, "sch_elevator_input", "")).strip()
        draw_text(
            surface,
            self.app.font_s,
            f"输入: {typed if typed else '—'}",
            (panel.centerx, panel.top + 52),
            pygame.Color(200, 200, 215),
            anchor="center",
        )

        x0 = panel.centerx - grid_w // 2
        y0 = panel.top + 66
        cur_floor = int(getattr(self, "sch_floor", 1))

        for local_i, f in enumerate(page_opts):
            i = int(start) + int(local_i)
            r = int(local_i) // cols
            c = int(local_i) % cols
            x = x0 + c * (btn_w + gap)
            y = y0 + r * (btn_h + gap)
            br = pygame.Rect(x, y, btn_w, btn_h)
            selected = int(i) == int(sel_i)
            is_cur = int(f) == cur_floor
            bg = (44, 44, 52) if selected else (26, 26, 32)
            border = (240, 240, 255) if selected else (90, 90, 110)
            if is_cur and not selected:
                border = (255, 220, 140)
            pygame.draw.rect(surface, bg, br, border_radius=8)
            pygame.draw.rect(surface, border, br, 2, border_radius=8)
            label = f"{int(f)}F"
            draw_text(surface, self.app.font_s, label, (br.centerx, br.centery), pygame.Color(230, 230, 240), anchor="center")

        draw_text(
            surface,
            self.app.font_s,
            "方向键移动 | PgUp/PgDn翻页 | 数字直达 | Enter确认 | Esc取消",
            (panel.centerx, panel.bottom - 14),
            pygame.Color(160, 160, 175),
            anchor="center",
        )

    def _draw_world_elevator_ui(self, surface: pygame.Surface) -> None:
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 200))
        surface.blit(overlay, (0, 0))

        options: list[int] = list(getattr(self, "world_elevator_options", []))
        if not options:
            options = [1]
            self.world_elevator_options = options
        cols = max(1, int(getattr(self, "world_elevator_cols", 4)))
        rows_per_page = 4
        n = len(options)
        page_size = max(1, cols * rows_per_page)
        sel_i = int(getattr(self, "world_elevator_sel", 0)) % max(1, n)
        page = int(sel_i // page_size)
        page_count = int(max(1, int(math.ceil(float(n) / float(page_size)))))
        start = int(page * page_size)
        end = int(min(int(n), int(start + page_size)))
        page_opts = list(options[start:end])
        rows = int(max(1, int(math.ceil(float(len(page_opts)) / float(cols)))))

        btn_w = 56
        btn_h = 28
        gap = 8
        grid_w = cols * btn_w + (cols - 1) * gap
        grid_h = rows * btn_h + (rows - 1) * gap
        panel = pygame.Rect(0, 0, grid_w + 40, grid_h + 98)
        panel.center = (INTERNAL_W // 2, INTERNAL_H // 2)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (90, 90, 110), panel, 2, border_radius=12)

        draw_text(surface, self.app.font_m, "电梯", (panel.centerx, panel.top + 16), pygame.Color(240, 240, 240), anchor="center")
        draw_text(
            surface,
            self.app.font_s,
            f"选择楼层（{int(page) + 1}/{int(page_count)}页）",
            (panel.centerx, panel.top + 36),
            pygame.Color(180, 180, 195),
            anchor="center",
        )
        typed = str(getattr(self, "world_elevator_input", "")).strip()
        draw_text(
            surface,
            self.app.font_s,
            f"输入: {typed if typed else '—'}",
            (panel.centerx, panel.top + 52),
            pygame.Color(200, 200, 215),
            anchor="center",
        )

        x0 = panel.centerx - grid_w // 2
        y0 = panel.top + 66
        mh = getattr(self, "world_elevator_mh", None)
        cur_floor = int(getattr(mh, "cur_floor", 1)) if mh is not None else 1

        for local_i, f in enumerate(page_opts):
            i = int(start) + int(local_i)
            r = int(local_i) // cols
            c = int(local_i) % cols
            x = x0 + c * (btn_w + gap)
            y = y0 + r * (btn_h + gap)
            br = pygame.Rect(x, y, btn_w, btn_h)
            selected = int(i) == int(sel_i)
            is_cur = int(f) == cur_floor
            bg = (44, 44, 52) if selected else (26, 26, 32)
            border = (240, 240, 255) if selected else (90, 90, 110)
            if is_cur and not selected:
                border = (255, 220, 140)
            pygame.draw.rect(surface, bg, br, border_radius=8)
            pygame.draw.rect(surface, border, br, 2, border_radius=8)
            label = f"{int(f)}F"
            draw_text(surface, self.app.font_s, label, (br.centerx, br.centery), pygame.Color(230, 230, 240), anchor="center")

        draw_text(
            surface,
            self.app.font_s,
            "方向键移动 | PgUp/PgDn翻页 | 数字直达 | Enter确认 | Esc取消",
            (panel.centerx, panel.bottom - 14),
            pygame.Color(160, 160, 175),
            anchor="center",
        )

    def _draw_hr_elevator_ui(self, surface: pygame.Surface) -> None:     
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 200))
        surface.blit(overlay, (0, 0))

        options: list[int] = list(getattr(self, "hr_elevator_options", []))
        if not options:
            options = [0]
        cols = max(1, int(getattr(self, "hr_elevator_cols", 4)))
        rows_per_page = 4
        n = len(options)
        page_size = max(1, cols * rows_per_page)
        sel_i = int(getattr(self, "hr_elevator_sel", 0)) % max(1, n)
        page = int(sel_i // page_size)
        page_count = int(max(1, int(math.ceil(float(n) / float(page_size)))))
        start = int(page * page_size)
        end = int(min(int(n), int(start + page_size)))
        page_opts = list(options[start:end])
        rows = int(max(1, int(math.ceil(float(len(page_opts)) / float(cols)))))

        btn_w = 56
        btn_h = 28
        gap = 8
        grid_w = cols * btn_w + (cols - 1) * gap
        grid_h = rows * btn_h + (rows - 1) * gap
        panel = pygame.Rect(0, 0, grid_w + 40, grid_h + 98)
        panel.center = (INTERNAL_W // 2, INTERNAL_H // 2)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (90, 90, 110), panel, 2, border_radius=12)

        draw_text(surface, self.app.font_m, "电梯", (panel.centerx, panel.top + 16), pygame.Color(240, 240, 240), anchor="center")
        draw_text(
            surface,
            self.app.font_s,
            f"选择楼层（{int(page) + 1}/{int(page_count)}页）",
            (panel.centerx, panel.top + 36),
            pygame.Color(180, 180, 195),
            anchor="center",
        )
        typed = str(getattr(self, "hr_elevator_input", "")).strip()
        draw_text(
            surface,
            self.app.font_s,
            f"输入: {typed if typed else '—'}",
            (panel.centerx, panel.top + 52),
            pygame.Color(200, 200, 215),
            anchor="center",
        )

        x0 = panel.centerx - grid_w // 2
        y0 = panel.top + 66
        cur_floor = int(getattr(self, "hr_floor", 1))
        home_floor = int(getattr(self, "hr_home_floor", -1))

        for local_i, f in enumerate(page_opts):
            i = int(start) + int(local_i)
            r = int(local_i) // cols
            c = int(local_i) % cols
            x = x0 + c * (btn_w + gap)
            y = y0 + r * (btn_h + gap)
            br = pygame.Rect(x, y, btn_w, btn_h)
            selected = int(i) == int(sel_i)
            is_cur = int(f) == cur_floor
            bg = (44, 44, 52) if selected else (26, 26, 32)
            border = (240, 240, 255) if selected else (90, 90, 110)     
            if is_cur and not selected:
                border = (255, 220, 140)
            if int(f) == int(home_floor) and int(home_floor) > 0 and not selected and not is_cur:
                border = (120, 200, 140)
            pygame.draw.rect(surface, bg, br, border_radius=8)
            pygame.draw.rect(surface, border, br, 2, border_radius=8)   
            label = str(int(f))
            draw_text(surface, self.app.font_s, label, (br.centerx, br.centery), pygame.Color(230, 230, 240), anchor="center")
            if int(f) == int(home_floor) and int(home_floor) > 0:
                pygame.draw.circle(surface, (120, 200, 140), (br.right - 10, br.y + 8), 3)

        draw_text(
            surface,
            self.app.font_s,
            "方向键移动 | PgUp/PgDn翻页 | 数字直达 | Enter确认 | Esc取消",
            (panel.centerx, panel.bottom - 14),
            pygame.Color(160, 160, 175),
            anchor="center",
        )

    def _draw_hr_travel_ui(self, surface: pygame.Surface) -> None:
        if not bool(getattr(self, "hr_travel_active", False)):
            return
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 210))
        surface.blit(overlay, (0, 0))

        kind = str(getattr(self, "hr_travel_kind", "elevator"))
        title = "电梯运行中" if kind == "elevator" else "楼梯中"
        draw_text(surface, self.app.font_m, title, (INTERNAL_W // 2, INTERNAL_H // 2 - 58), pygame.Color(240, 240, 240), anchor="center")

        f0 = int(getattr(self, "hr_travel_from", int(getattr(self, "hr_floor", 1))))
        f1 = int(getattr(self, "hr_travel_to", f0))
        cur = int(getattr(self, "hr_travel_display", f0))
        direction = 1 if int(f1) >= int(f0) else -1
        floors = list(range(int(f0), int(f1) + int(direction), int(direction)))
        if not floors:
            floors = [int(cur)]

        big_font = getattr(self.app, "font_l", self.app.font_m)
        draw_text(surface, big_font, str(int(cur)), (INTERNAL_W // 2, INTERNAL_H // 2 - 18), pygame.Color(255, 220, 140), anchor="center")

        font = self.app.font_s
        labels = [str(int(f)) for f in floors]
        widths = [int(font.size(lbl)[0]) for lbl in labels]
        gap = 10
        total_w = int(sum(widths) + max(0, len(widths) - 1) * gap)
        x = int(INTERNAL_W // 2 - total_w // 2)
        y = int(INTERNAL_H // 2 + 18)
        for f, lbl, w in zip(floors, labels, widths):
            passed = (direction > 0 and int(f) < int(cur)) or (direction < 0 and int(f) > int(cur))
            if int(f) == int(cur):
                col = pygame.Color(255, 220, 140)
            elif passed:
                col = pygame.Color(220, 220, 232)
            else:
                col = pygame.Color(140, 140, 155)
            draw_text(surface, font, lbl, (int(x + w // 2), int(y)), col, anchor="center")
            x += int(w + gap)

        hint = "等待..." if kind == "elevator" else "一层一层走..."
        draw_text(surface, self.app.font_s, hint, (INTERNAL_W // 2, INTERNAL_H // 2 + 44), pygame.Color(160, 160, 175), anchor="center")

    def _home_ui_storage_kind_norm(self) -> str:
        kind = str(getattr(self, "home_ui_storage_kind", "cabinet")).strip().lower()
        return "fridge" if kind == "fridge" else "cabinet"

    def _home_ui_storage_inv(self) -> HardcoreSurvivalState._Inventory:
        if self._home_ui_storage_kind_norm() == "fridge":
            inv = getattr(self, "fridge_storage", None)
            if inv is not None:
                return inv
        return self.home_storage

    def _home_ui_storage_label(self) -> str:
        return "冰箱" if self._home_ui_storage_kind_norm() == "fridge" else "柜子"

    def _home_ui_storage_title(self) -> str:
        return "冰箱" if self._home_ui_storage_kind_norm() == "fridge" else "家中储物柜"

    def _home_ui_open(
        self,
        *,
        open_block: tuple[int, int, int, int] | None = None,
        storage_kind: str = "cabinet",
    ) -> None:
        if bool(getattr(self, "hr_interior", False)) and str(getattr(self, "hr_mode", "lobby")) != "home":
            return
        self.inv_open = False
        self.rv_ui_open = False
        self._gallery_open = False
        self.home_ui_open = True
        self.home_ui_focus = "storage"
        self.home_ui_storage_kind = "fridge" if str(storage_kind).strip().lower() == "fridge" else "cabinet"
        self.home_ui_open_block = open_block
        self.home_ui_player_index = int(
            clamp(int(getattr(self, "home_ui_player_index", 0)), 0, len(self.inventory.slots) - 1)
        )
        storage = self._home_ui_storage_inv()
        self.home_ui_storage_index = int(
            clamp(int(getattr(self, "home_ui_storage_index", 0)), 0, len(storage.slots) - 1)
        )
        title = "冰箱" if self._home_ui_storage_kind_norm() == "fridge" else "储物柜"
        target = self._home_ui_storage_label()
        self._set_home_ui_status(
            f"{title}：Tab 切换 背包/{target} | Enter 转移 | Esc 关闭",
            seconds=2.0,
        )

    def _home_ui_close(self) -> None:
        self.home_ui_open = False
        self.home_ui_focus = "storage"
        self.home_ui_open_block = None

    def _home_ui_cycle_focus(self) -> None:
        cur = str(getattr(self, "home_ui_focus", "storage"))
        self.home_ui_focus = "player" if cur != "player" else "storage"

    def _home_ui_transfer(self, *, from_player: bool) -> None:
        storage = self._home_ui_storage_inv()
        if from_player:
            src = self.inventory
            dst = storage
            idx = int(getattr(self, "home_ui_player_index", 0))
        else:
            src = storage
            dst = self.inventory
            idx = int(getattr(self, "home_ui_storage_index", 0))

        if not (0 <= idx < len(src.slots)):
            self._set_home_ui_status("槽位无效", seconds=1.2)
            return
        st = src.slots[idx]
        if st is None:
            self._set_home_ui_status("空", seconds=1.0)
            return

        idef = self._ITEMS.get(st.item_id)
        name = idef.name if idef is not None else st.item_id

        before = int(st.qty)

        # Small tools (e.g. cup) are more usable when transferred directly into the hand.
        take_hand = 0
        if not from_player and idef is not None and str(getattr(idef, "kind", "")) == "tool":
            if getattr(self, "held_item", None) is None and int(before) > 0:
                take_hand = 1

        moved_inv = 0
        left = int(before)
        if int(before - take_hand) > 0:
            left_after = int(dst.add(st.item_id, int(before - take_hand), self._ITEMS))
            moved_inv = int((before - take_hand) - left_after)
            left = int(left_after)
        else:
            left = int(before - take_hand)

        moved = int(before - left)
        if moved <= 0:
            self._set_home_ui_status("空间不足", seconds=1.2)
            return

        if take_hand > 0:
            self.held_item = HardcoreSurvivalState._ItemStack(item_id=str(st.item_id), qty=1)

        if left <= 0:
            src.slots[idx] = None
        else:
            st.qty = int(left)

        if take_hand > 0 and moved_inv <= 0:
            self._set_home_ui_status(f"拿在手上: {name}", seconds=1.2)
        else:
            self._set_home_ui_status(f"转移: {name} x{moved}", seconds=1.6)

    def _handle_home_ui_key(self, key: int) -> None:
        if key in (pygame.K_ESCAPE,):
            self._home_ui_close()
            return
        if key in (pygame.K_TAB,):
            self._home_ui_cycle_focus()
            return
        if key in (pygame.K_RETURN, pygame.K_SPACE):
            focus = str(getattr(self, "home_ui_focus", "storage"))
            if focus == "player":
                self._home_ui_transfer(from_player=True)
            else:
                self._home_ui_transfer(from_player=False)
            return

        move: tuple[int, int] | None = None
        if key in (pygame.K_LEFT, pygame.K_a):
            move = (-1, 0)
        elif key in (pygame.K_RIGHT, pygame.K_d):
            move = (1, 0)
        elif key in (pygame.K_UP, pygame.K_w):
            move = (0, -1)
        elif key in (pygame.K_DOWN, pygame.K_s):
            move = (0, 1)
        if move is None:
            return

        focus = str(getattr(self, "home_ui_focus", "storage"))
        dx, dy = int(move[0]), int(move[1])
        if focus == "player":
            cols = max(1, int(self.inventory.cols))
            if dx != 0:
                self.home_ui_player_index = (int(self.home_ui_player_index) + dx) % len(self.inventory.slots)
            else:
                self.home_ui_player_index = (int(self.home_ui_player_index) + dy * cols) % len(self.inventory.slots)
            return

        storage = self._home_ui_storage_inv()
        cols = max(1, int(storage.cols))
        if dx != 0:
            self.home_ui_storage_index = (int(self.home_ui_storage_index) + dx) % len(storage.slots)
        else:
            self.home_ui_storage_index = (int(self.home_ui_storage_index) + dy * cols) % len(storage.slots)

    def _handle_home_ui_mouse(self, event: pygame.event.Event) -> None:
        if not getattr(self, "home_ui_open", False):
            return
        if event.type not in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION):
            return
        if not hasattr(event, "pos"):
            return
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return
        mx, my = int(internal[0]), int(internal[1])

        # Mirror the layout math in _draw_home_storage_ui() so hit-testing matches.
        panel = pygame.Rect(16, 14, INTERNAL_W - 32, INTERNAL_H - 28)
        slot = 22
        gap = 4

        storage = self._home_ui_storage_inv()
        storage_label = self._home_ui_storage_label()

        pcols = max(1, int(self.inventory.cols))
        prows = int(math.ceil(len(self.inventory.slots) / pcols))
        pgrid_w = pcols * slot + (pcols - 1) * gap
        pgrid_h = prows * slot + (prows - 1) * gap

        scols = max(1, int(storage.cols))
        srows = int(math.ceil(len(storage.slots) / scols))
        sgrid_w = scols * slot + (scols - 1) * gap
        sgrid_h = srows * slot + (srows - 1) * gap

        inv_y = panel.top + 46
        left_x = panel.left + 14
        right_x = panel.right - 14 - sgrid_w

        content_h = max(pgrid_h, sgrid_h) + 20
        inv_y = int(clamp(inv_y, panel.top + 42, panel.bottom - 52 - content_h))

        pgrid = pygame.Rect(int(left_x), int(inv_y), int(pgrid_w), int(pgrid_h))
        sgrid = pygame.Rect(int(right_x), int(inv_y), int(sgrid_w), int(sgrid_h))

        # Clickable "tabs" (the labels above each grid).
        lab_y = int(inv_y - 14)
        bw, bh = self.app.font_s.size("背包")
        sw, sh = self.app.font_s.size(storage_label)
        tab_player = pygame.Rect(int(left_x), int(lab_y), int(bw), int(bh))
        tab_storage = pygame.Rect(int(right_x), int(lab_y), int(sw), int(sh))

        def hit_grid(
            *,
            grid: pygame.Rect,
            cols: int,
            count: int,
            x0: int,
            y0: int,
        ) -> int | None:
            if not grid.collidepoint(mx, my):
                return None
            lx = int(mx - int(x0))
            ly = int(my - int(y0))
            cell = int(slot + gap)
            if cell <= 0:
                return None
            cx = int(lx // cell)
            cy = int(ly // cell)
            if cx < 0 or cy < 0:
                return None
            if cx >= int(cols):
                return None
            # Ignore clicks on the gap area.
            if int(lx % cell) >= int(slot) or int(ly % cell) >= int(slot):
                return None
            idx = int(cy * int(cols) + cx)
            if not (0 <= idx < int(count)):
                return None
            return int(idx)

        if event.type == pygame.MOUSEBUTTONDOWN:
            btn = int(getattr(event, "button", 0))
            if btn == 1:
                if tab_player.collidepoint(mx, my):
                    self.home_ui_focus = "player"
                    return
                if tab_storage.collidepoint(mx, my):
                    self.home_ui_focus = "storage"
                    return
                idx = hit_grid(grid=pgrid, cols=pcols, count=len(self.inventory.slots), x0=left_x, y0=inv_y)
                if idx is not None:
                    self.home_ui_focus = "player"
                    self.home_ui_player_index = int(idx)
                    return
                idx = hit_grid(grid=sgrid, cols=scols, count=len(storage.slots), x0=right_x, y0=inv_y)
                if idx is not None:
                    self.home_ui_focus = "storage"
                    self.home_ui_storage_index = int(idx)
                    return
            # Right-click transfers for mouse-only usability.
            if btn == 3:
                idx = hit_grid(grid=pgrid, cols=pcols, count=len(self.inventory.slots), x0=left_x, y0=inv_y)
                if idx is not None:
                    self.home_ui_focus = "player"
                    self.home_ui_player_index = int(idx)
                    self._home_ui_transfer(from_player=True)
                    return
                idx = hit_grid(grid=sgrid, cols=scols, count=len(storage.slots), x0=right_x, y0=inv_y)
                if idx is not None:
                    self.home_ui_focus = "storage"
                    self.home_ui_storage_index = int(idx)
                    self._home_ui_transfer(from_player=False)
                    return

    def _tile_solid(self, tile_id: int) -> bool:
        t = self._TILES.get(int(tile_id))
        return bool(t.solid) if t is not None else False

    def _tile_slow(self, tile_id: int) -> float:
        t = self._TILES.get(int(tile_id))
        return float(t.slow) if t is not None else 1.0

    def _collide_rect_world(self, rect: pygame.Rect) -> list[pygame.Rect]:
        left = int(math.floor(rect.left / self.TILE_SIZE))
        right = int(math.floor((rect.right - 1) / self.TILE_SIZE))       
        top = int(math.floor(rect.top / self.TILE_SIZE))
        bottom = int(math.floor((rect.bottom - 1) / self.TILE_SIZE))

        # RV world-interior: ignore outside props/parked vehicles that fall inside the stamped RV room,
        # otherwise things like a sidewalk streetlamp can appear/collide "inside" the RV.
        rv_hide: tuple[int, int, int, int] | None = None
        if bool(getattr(self, "rv_world_interior", False)):
            key = getattr(self, "_rv_world_int_active_key", None)
            if isinstance(key, tuple) and len(key) == 4:
                try:
                    rv_hide = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
                except Exception:
                    rv_hide = None
        ts = int(self.TILE_SIZE)

        hits: list[pygame.Rect] = []
        for ty in range(top, bottom + 1):
            for tx in range(left, right + 1):
                tile = int(self.world.get_tile(tx, ty))
                solid = bool(self._tile_solid(tile))
                if tile == int(self.T_DOOR):
                    # Prevent stepping "onto" portal/sealed doors (e.g. high-rises),
                    # which makes it look like the player can walk on the facade.
                    leads_to_floor = False
                    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        if int(self.world.get_tile(int(tx + dx), int(ty + dy))) == int(self.T_FLOOR):
                            leads_to_floor = True
                            break
                    if not leads_to_floor:
                        solid = True
                if not solid:
                    continue
                tile_rect = pygame.Rect(tx * self.TILE_SIZE, ty * self.TILE_SIZE, self.TILE_SIZE, self.TILE_SIZE)
                if rect.colliderect(tile_rect):
                    hits.append(tile_rect)

        # Solid world props (signs/toys/etc).
        start_cx = left // self.CHUNK_SIZE
        end_cx = right // self.CHUNK_SIZE
        start_cy = top // self.CHUNK_SIZE
        end_cy = bottom // self.CHUNK_SIZE
        for cy in range(int(start_cy), int(end_cy) + 1):
            for cx in range(int(start_cx), int(end_cx) + 1):
                chunk = self.world.get_chunk(int(cx), int(cy))
                for pr in getattr(chunk, "props", []):
                    if rv_hide is not None and ts > 0:
                        try:
                            px = float(getattr(getattr(pr, "pos", pygame.Vector2(0, 0)), "x", 0.0))
                            py = float(getattr(getattr(pr, "pos", pygame.Vector2(0, 0)), "y", 0.0))
                            tx = int(math.floor(px / float(ts)))
                            ty = int(math.floor(py / float(ts)))
                            rx0, ry0, rw, rh = rv_hide
                            if int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh):
                                continue
                        except Exception:
                            pass
                    pdef = self._PROP_DEFS.get(str(getattr(pr, "prop_id", "")))
                    if pdef is None or not bool(getattr(pdef, "solid", False)):
                        continue
                    w, h = getattr(pdef, "collider", (10, 10))
                    w = max(2, int(w))
                    h = max(2, int(h))
                    prect = pygame.Rect(
                        int(round(float(pr.pos.x) - w / 2)),
                        int(round(float(pr.pos.y) - h / 2)),
                        int(w),
                        int(h),
                    )
                    if rect.colliderect(prect):
                        hits.append(prect)

                # Parked vehicles (cars + bikes) are solid in the world.
                for car in getattr(chunk, "cars", []):
                    if rv_hide is not None and ts > 0:
                        try:
                            cpos = pygame.Vector2(getattr(car, "pos", pygame.Vector2(0, 0)))
                            tx = int(math.floor(float(cpos.x) / float(ts)))
                            ty = int(math.floor(float(cpos.y) / float(ts)))
                            rx0, ry0, rw, rh = rv_hide
                            if int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh):
                                continue
                        except Exception:
                            pass
                    mid = str(getattr(car, "model_id", "rv"))
                    model = self._CAR_MODELS.get(mid) or self._CAR_MODELS.get("rv")
                    if model is None:
                        continue
                    cw, ch = int(model.collider[0]), int(model.collider[1])
                    if cw <= 0 or ch <= 0:
                        continue
                    cpos = pygame.Vector2(getattr(car, "pos", pygame.Vector2(0, 0)))
                    chead = float(getattr(car, "heading", 0.0))
                    c = abs(math.cos(float(chead)))
                    s = abs(math.sin(float(chead)))
                    ww = float(cw) * c + float(ch) * s
                    hh = float(cw) * s + float(ch) * c
                    w = int(max(2, int(round(float(ww)))))
                    h = int(max(2, int(round(float(hh)))))
                    crect = pygame.Rect(
                        int(round(float(cpos.x) - float(w) / 2.0)),
                        int(round(float(cpos.y) - float(h) / 2.0)),
                        int(w),
                        int(h),
                    )
                    if rect.colliderect(crect):
                        hits.append(crect)

                for b in getattr(chunk, "bikes", []):
                    if rv_hide is not None and ts > 0:
                        try:
                            bpos = pygame.Vector2(getattr(b, "pos", pygame.Vector2(0, 0)))
                            tx = int(math.floor(float(bpos.x) / float(ts)))
                            ty = int(math.floor(float(bpos.y) / float(ts)))
                            rx0, ry0, rw, rh = rv_hide
                            if int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh):
                                continue
                        except Exception:
                            pass
                    mid = str(getattr(b, "model_id", "bike"))
                    bw, bh = self._two_wheel_collider_px(mid)
                    d = str(getattr(b, "dir", "right"))
                    if d in ("up", "down"):
                        bw, bh = int(bh), int(bw)
                    bw = max(2, int(bw))
                    bh = max(2, int(bh))
                    bpos = pygame.Vector2(getattr(b, "pos", pygame.Vector2(0, 0)))
                    brect = pygame.Rect(
                        int(round(float(bpos.x) - float(bw) / 2.0)),
                        int(round(float(bpos.y) - float(bh) / 2.0)),
                        int(bw),
                        int(bh),
                    )
                    if rect.colliderect(brect):
                        hits.append(brect)

        # Player-owned vehicles are also solid when on foot.
        # Exception: when inside the RV world-interior, allow walking within the RV footprint.
        if self.mount != "rv" and not bool(getattr(self, "rv_world_interior", False)):
            try:
                vrect = self._rv_collider_rect_at()
                if rect.colliderect(vrect):
                    hits.append(vrect)
            except Exception:
                pass
        if self.mount != "bike":
            try:
                bw, bh = int(getattr(self.bike, "w", 0)), int(getattr(self.bike, "h", 0))
                if bw > 0 and bh > 0:
                    bpos = pygame.Vector2(getattr(self.bike, "pos", pygame.Vector2(0, 0)))
                    brect = pygame.Rect(
                        int(round(float(bpos.x) - float(bw) / 2.0)),
                        int(round(float(bpos.y) - float(bh) / 2.0)),
                        int(bw),
                        int(bh),
                    )
                    if rect.colliderect(brect):
                        hits.append(brect)
            except Exception:
                pass

        # RV world-interior: add thin boundary colliders so the stamped floor area stays enclosed,
        # without spending a full 1-tile wall border (which makes small RVs feel tiny).
        if bool(getattr(self, "rv_world_interior", False)):
            key = getattr(self, "_rv_world_int_active_key", None)
            if isinstance(key, tuple) and len(key) == 4:
                try:
                    rx0, ry0, rw, rh = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
                    pw = int(rw * int(self.TILE_SIZE))
                    ph = int(rh * int(self.TILE_SIZE))
                    if pw > 0 and ph > 0:
                        px0 = int(rx0 * int(self.TILE_SIZE))
                        py0 = int(ry0 * int(self.TILE_SIZE))
                        # Use OUTSIDE thick boundary strips. The previous 1px inside lines could
                        # "push" the player out of the RV (and can be tunneled on low FPS).
                        ts = int(max(1, int(self.TILE_SIZE)))
                        th = int(ts)
                        walls = [
                            # top / bottom
                            pygame.Rect(int(px0 - th), int(py0 - th), int(pw + 2 * th), int(th)),
                            pygame.Rect(int(px0 - th), int(py0 + ph), int(pw + 2 * th), int(th)),
                            # left / right
                            pygame.Rect(int(px0 - th), int(py0 - th), int(th), int(ph + 2 * th)),
                            pygame.Rect(int(px0 + pw), int(py0 - th), int(th), int(ph + 2 * th)),
                        ]
                        for wrect in walls:
                            if rect.colliderect(wrect):
                                hits.append(wrect)
                except Exception:
                    pass
        return hits

    def _collide_rect_world_vehicle(self, rect: pygame.Rect) -> list[pygame.Rect]:
        left = int(math.floor(rect.left / self.TILE_SIZE))
        right = int(math.floor((rect.right - 1) / self.TILE_SIZE))
        top = int(math.floor(rect.top / self.TILE_SIZE))
        bottom = int(math.floor((rect.bottom - 1) / self.TILE_SIZE))

        hits: list[pygame.Rect] = []
        for ty in range(top, bottom + 1):
            for tx in range(left, right + 1):
                tile = int(self.world.get_tile(tx, ty))
                # Vehicles must not enter buildings: treat interior floor/doors as solid.
                if tile in (
                    int(self.T_FLOOR),
                    int(self.T_DOOR),
                    int(self.T_DOOR_HOME),
                    int(self.T_DOOR_LOCKED),
                    int(self.T_DOOR_HOME_LOCKED),
                    int(self.T_DOOR_BROKEN),
                    int(self.T_ELEVATOR),
                    int(self.T_STAIRS_UP),
                    int(self.T_STAIRS_DOWN),
                ):
                    solid = True
                else:
                    solid = bool(self._tile_solid(tile))
                if not solid:
                    continue
                tile_rect = pygame.Rect(
                    int(tx * self.TILE_SIZE),
                    int(ty * self.TILE_SIZE),
                    int(self.TILE_SIZE),
                    int(self.TILE_SIZE),
                )
                if rect.colliderect(tile_rect):
                    hits.append(tile_rect)

        # Building roofs/facades: block vehicles from entering building footprints.
        try:
            ts = int(self.TILE_SIZE)
            if ts > 0:
                # If the current vehicle is using a smaller "driving" collider (e.g. RV),
                # inflate building footprints so the *visual* vehicle can't clip into walls.
                inflate_x = 0
                inflate_y = 0
                try:
                    if self.mount == "rv":
                        mid = str(getattr(self.rv, "model_id", "rv"))
                        model = self._CAR_MODELS.get(mid) or self._CAR_MODELS.get("rv")
                        if model is not None:
                            fw, fh = int(model.collider[0]), int(model.collider[1])
                            # Match the same axis-orientation that driving uses (swap when near-vertical).
                            axis = int(getattr(self, "_rv_drive_axis", 0))
                            if axis == 1:
                                fw, fh = int(fh), int(fw)
                            inflate_x = max(0, (int(fw) - int(rect.w)) // 2)
                            inflate_y = max(0, (int(fh) - int(rect.h)) // 2)
                            # Keep it bounded; we only want to compensate for drive_collider.
                            inflate_x = int(clamp(int(inflate_x), 0, int(ts) * 3))
                            inflate_y = int(clamp(int(inflate_y), 0, int(ts) * 3))
                except Exception:
                    inflate_x = 0
                    inflate_y = 0

                start_cx = left // self.CHUNK_SIZE
                end_cx = right // self.CHUNK_SIZE
                start_cy = top // self.CHUNK_SIZE
                end_cy = bottom // self.CHUNK_SIZE
                seen_buildings: set[tuple[int, int, int, int]] = set()
                for cy in range(int(start_cy) - 1, int(end_cy) + 2):
                    for cx in range(int(start_cx) - 1, int(end_cx) + 2):
                        chunk = self.world.get_chunk(int(cx), int(cy))
                        for b in getattr(chunk, "buildings", []):
                            bx0, by0, bw, bh = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                            key = (int(bx0), int(by0), int(bw), int(bh))
                            if key in seen_buildings:
                                continue
                            seen_buildings.add(key)
                            brect = pygame.Rect(int(bx0 * ts), int(by0 * ts), int(bw * ts), int(bh * ts))
                            if inflate_x > 0 or inflate_y > 0:
                                brect = brect.inflate(int(inflate_x) * 2, int(inflate_y) * 2)
                            if rect.colliderect(brect):
                                hits.append(brect)
        except Exception:
            pass

        # Solid world props (signs/toys/etc) still block vehicles.
        start_cx = left // self.CHUNK_SIZE
        end_cx = right // self.CHUNK_SIZE
        start_cy = top // self.CHUNK_SIZE
        end_cy = bottom // self.CHUNK_SIZE
        for cy in range(int(start_cy), int(end_cy) + 1):
            for cx in range(int(start_cx), int(end_cx) + 1):
                chunk = self.world.get_chunk(int(cx), int(cy))
                for pr in getattr(chunk, "props", []):
                    pdef = self._PROP_DEFS.get(str(getattr(pr, "prop_id", "")))
                    if pdef is None or not bool(getattr(pdef, "solid", False)):
                        continue
                    w, h = getattr(pdef, "collider", (10, 10))
                    w = max(2, int(w))
                    h = max(2, int(h))
                    prect = pygame.Rect(
                        int(round(float(pr.pos.x) - w / 2)),
                        int(round(float(pr.pos.y) - h / 2)),
                        int(w),
                        int(h),
                    )
                    if rect.colliderect(prect):
                        hits.append(prect)

                # Parked vehicles block drivable vehicles too.
                for car in getattr(chunk, "cars", []):
                    mid = str(getattr(car, "model_id", "rv"))
                    model = self._CAR_MODELS.get(mid) or self._CAR_MODELS.get("rv")
                    if model is None:
                        continue
                    cw, ch = int(model.collider[0]), int(model.collider[1])
                    if cw <= 0 or ch <= 0:
                        continue
                    cpos = pygame.Vector2(getattr(car, "pos", pygame.Vector2(0, 0)))
                    chead = float(getattr(car, "heading", 0.0))
                    c = abs(math.cos(float(chead)))
                    s = abs(math.sin(float(chead)))
                    ww = float(cw) * c + float(ch) * s
                    hh = float(cw) * s + float(ch) * c
                    w = int(max(2, int(round(float(ww)))))
                    h = int(max(2, int(round(float(hh)))))
                    crect = pygame.Rect(
                        int(round(float(cpos.x) - float(w) / 2.0)),
                        int(round(float(cpos.y) - float(h) / 2.0)),
                        int(w),
                        int(h),
                    )
                    if rect.colliderect(crect):
                        hits.append(crect)

                for b in getattr(chunk, "bikes", []):
                    mid = str(getattr(b, "model_id", "bike"))
                    bw, bh = self._two_wheel_collider_px(mid)
                    d = str(getattr(b, "dir", "right"))
                    if d in ("up", "down"):
                        bw, bh = int(bh), int(bw)
                    bw = max(2, int(bw))
                    bh = max(2, int(bh))
                    bpos = pygame.Vector2(getattr(b, "pos", pygame.Vector2(0, 0)))
                    brect = pygame.Rect(
                        int(round(float(bpos.x) - float(bw) / 2.0)),
                        int(round(float(bpos.y) - float(bh) / 2.0)),
                        int(bw),
                        int(bh),
                    )
                    if rect.colliderect(brect):
                        hits.append(brect)

        # Player-owned vehicles block other vehicles (but never collide with themselves).
        if self.mount != "rv":
            try:
                vrect = self._rv_collider_rect_at()
                if rect.colliderect(vrect):
                    hits.append(vrect)
            except Exception:
                pass
        if self.mount != "bike":
            try:
                bw, bh = int(getattr(self.bike, "w", 0)), int(getattr(self.bike, "h", 0))
                if bw > 0 and bh > 0:
                    bpos = pygame.Vector2(getattr(self.bike, "pos", pygame.Vector2(0, 0)))
                    brect = pygame.Rect(
                        int(round(float(bpos.x) - float(bw) / 2.0)),
                        int(round(float(bpos.y) - float(bh) / 2.0)),
                        int(bw),
                        int(bh),
                    )
                    if rect.colliderect(brect):
                        hits.append(brect)
            except Exception:
                pass
        return hits

    def _move_with_collisions(self, pos: pygame.Vector2, vel: pygame.Vector2, dt: float) -> pygame.Vector2:
        rect = self.player.rect_at(pos)
        dx = float(vel.x * dt)
        dy = float(vel.y * dt)

        if dx != 0.0:
            rect.x += int(round(dx))
            for hit in self._collide_rect_world(rect):
                if dx > 0:
                    rect.right = hit.left
                else:
                    rect.left = hit.right

        if dy != 0.0:
            rect.y += int(round(dy))
            for hit in self._collide_rect_world(rect):
                if dy > 0:
                    rect.bottom = hit.top
                else:
                    rect.top = hit.bottom

        return pygame.Vector2(rect.centerx, rect.centery)

    def _move_box(self, pos: pygame.Vector2, vel: pygame.Vector2, dt: float, *, w: int, h: int) -> pygame.Vector2:
        # Use float movement (sub-pixel accumulation) then resolve collisions
        # with an int rect. This keeps pixel-art rendering crisp while allowing
        # slow entities (e.g., zombies) to actually move.
        w = int(w)
        h = int(h)
        p = pygame.Vector2(pos)
        dt = float(dt)
        if dt > 0.25:
            dt = 0.25
        dx_total = float(vel.x) * dt
        dy_total = float(vel.y) * dt

        def rect_at(px: float, py: float) -> pygame.Rect:
            return pygame.Rect(
                iround(float(px) - float(w) / 2.0),
                iround(float(py) - float(h) / 2.0),
                int(w),
                int(h),
            )

        def depenetrate(r: pygame.Rect, *, prefer_axis: str | None = None) -> pygame.Rect:
            prefer_axis = None if prefer_axis is None else str(prefer_axis)
            r = pygame.Rect(r)
            axis_penalty = int(clamp(int(self.TILE_SIZE) // 5, 1, 3))
            for _ in range(10):
                hits = self._collide_rect_world(r)
                if not hits:
                    break
                best: tuple[int, int, int, int, int] | None = None  # score, absd, prio, ox, oy
                for hit in hits:
                    if not r.colliderect(hit):
                        continue
                    dx_l = int(hit.left - r.right)
                    dx_r = int(hit.right - r.left)
                    dy_u = int(hit.top - r.bottom)
                    dy_d = int(hit.bottom - r.top)
                    for absd, ox, oy in (
                        (abs(dx_l), dx_l, 0),
                        (abs(dx_r), dx_r, 0),
                        (abs(dy_u), 0, dy_u),
                        (abs(dy_d), 0, dy_d),
                    ):
                        if absd <= 0:
                            continue
                        axis = "x" if int(ox) != 0 else "y"
                        prio = 0 if (prefer_axis is not None and axis == prefer_axis) else 1
                        score = int(absd) + (0 if prefer_axis is None or axis == prefer_axis else int(axis_penalty))
                        if best is None or (score, prio, int(absd)) < (best[0], best[2], best[1]):
                            best = (int(score), int(absd), int(prio), int(ox), int(oy))
                if best is None:
                    break
                _score, _absd, _prio, ox, oy = best
                r.move_ip(int(ox), int(oy))
            return r

        def depenetrate_axis(r: pygame.Rect, *, axis: str) -> pygame.Rect:
            axis = str(axis)
            r = pygame.Rect(r)
            for _ in range(10):
                hits = self._collide_rect_world(r)
                if not hits:
                    break
                best: tuple[int, int] | None = None
                for hit in hits:
                    if not r.colliderect(hit):
                        continue
                    if axis == "x":
                        dx_l = int(hit.left - r.right)
                        dx_r = int(hit.right - r.left)
                        for absd, ox in ((abs(dx_l), dx_l), (abs(dx_r), dx_r)):
                            if absd <= 0:
                                continue
                            if best is None or absd < best[0]:
                                best = (int(absd), int(ox))
                    else:
                        dy_u = int(hit.top - r.bottom)
                        dy_d = int(hit.bottom - r.top)
                        for absd, oy in ((abs(dy_u), dy_u), (abs(dy_d), dy_d)):
                            if absd <= 0:
                                continue
                            if best is None or absd < best[0]:
                                best = (int(absd), int(oy))
                if best is None:
                    break
                _absd, o = best
                if axis == "x":
                    r.move_ip(int(o), 0)
                else:
                    r.move_ip(0, int(o))
            return r

        def filter_hits_axis(hits: list[pygame.Rect], r: pygame.Rect, *, axis: str) -> list[pygame.Rect]:
            axis = str(axis)
            # "Skin" lets the player slide along horizontal/vertical walls without
            # getting caught on 1px corner overlaps (fixes right->left sticking).
            skin = int(clamp(int(self.TILE_SIZE) // 6, 1, 2))
            kept: list[pygame.Rect] = []
            for h in hits:
                if not r.colliderect(h):
                    continue
                inter = r.clip(h)
                if int(inter.w) <= 0 or int(inter.h) <= 0:
                    continue
                # Ignore tiny 1-2px corner overlaps; treating them as "blocking"
                # causes visible jitter when sliding along walls (esp. while sprinting).
                if int(inter.w) <= int(skin) and int(inter.h) <= int(skin):
                    continue
                # For horizontal movement, only keep hits that are "mostly side walls"
                # (penetration in X smaller than in Y, plus a small skin). Otherwise,
                # treat the hit as a top/bottom scrape and resolve via a small
                # orthogonal depenetration. This also avoids getting stuck on
                # outside corners where inter.w ~= inter.h.
                if axis == "x":
                    if int(inter.w) <= int(inter.h) + int(skin):
                        kept.append(h)
                else:
                    if int(inter.h) <= int(inter.w) + int(skin):
                        kept.append(h)
            return kept

        # If we ever end up slightly inside a wall (rounding edge-case), push out
        # in the shortest direction. This prevents large "snap" corrections later.
        cur = rect_at(float(p.x), float(p.y))
        if self._collide_rect_world(cur):
            pref = None
            try:
                if abs(float(vel.x)) >= abs(float(vel.y)) and abs(float(vel.x)) > 1e-6:
                    pref = "y"
                elif abs(float(vel.y)) > 1e-6:
                    pref = "x"
            except Exception:
                pref = None
            if pref in ("x", "y"):
                cur2 = depenetrate_axis(cur, axis=str(pref))
                cur = cur2 if not self._collide_rect_world(cur2) else depenetrate(cur, prefer_axis=pref)
            else:
                cur = depenetrate(cur, prefer_axis=pref)
            p.update(float(cur.centerx), float(cur.centery))

        # Prevent tunneling through thin walls/doorways on hitches by moving
        # in small sub-steps (still using a crisp int rect for collisions).
        max_step = max(1.0, float(self.TILE_SIZE) / 2.0)
        steps = int(max(1, math.ceil(max(abs(dx_total), abs(dy_total)) / max_step)))
        dx = float(dx_total) / float(steps)
        dy = float(dy_total) / float(steps)
        nudge_max = int(clamp(int(self.TILE_SIZE) // 2, 1, 4))

        for _ in range(int(steps)):
            step_prev = pygame.Vector2(p)
            if dx != 0.0:
                prev = rect_at(float(p.x), float(p.y))
                p.x += float(dx)
                rect = rect_at(float(p.x), float(p.y))
                hits = self._collide_rect_world(rect)
                if hits:
                    hits_block = filter_hits_axis(hits, rect, axis="x")
                    if not hits_block:
                        rect2 = depenetrate_axis(rect, axis="y")
                        if not self._collide_rect_world(rect2):
                            rect = rect2
                            p.y = float(rect.centery)
                        p.x = float(rect.centerx)
                        continue
                    hits = hits_block
                    # Corner correction: when moving purely horizontally, a tiny Y nudge
                    # makes 1-tile corridors/doorways feel smooth instead of "pixel perfect".
                    corrected = False
                    depen_fixed = False
                    if abs(float(vel.y)) < 1e-6:
                        prefer = 0
                        try:
                            avg = sum(int(hh.centery) for hh in hits) / float(max(1, len(hits)))
                            if float(avg) < float(rect.centery):
                                prefer = 1  # obstacles above -> move down first
                            elif float(avg) > float(rect.centery):
                                prefer = -1  # obstacles below -> move up first
                        except Exception:
                            prefer = 0

                        base = pygame.Rect(rect)
                        for n in range(1, int(nudge_max) + 1):
                            if prefer > 0:
                                cands = (n, -n)
                            elif prefer < 0:
                                cands = (-n, n)
                            else:
                                cands = (-n, n)
                            for sy in cands:
                                test = pygame.Rect(base)
                                test.y += int(sy)
                                if not self._collide_rect_world(test):
                                    rect = test
                                    corrected = True
                                    break
                            if corrected:
                                break
                    if not corrected and abs(float(vel.y)) < 1e-6:
                        # If this collision can be fixed by a tiny vertical push (common when
                        # sliding along the top/bottom walls), prefer that so horizontal motion
                        # doesn't get cancelled at 1px corner overlaps.
                        rect2 = depenetrate_axis(rect, axis="y")
                        if abs(int(rect2.y) - int(rect.y)) <= int(nudge_max) and not self._collide_rect_world(rect2):
                            rect = rect2
                            corrected = True
                            depen_fixed = True
                    if corrected:
                        # Accept the corrected position and skip the blocking clamp for X.
                        p.x = float(rect.centerx)
                        p.y = float(rect.centery)
                    else:
                        if dx > 0.0:
                            blocks = [int(r.left) for r in hits if int(prev.right) <= int(r.left)]
                            if blocks:
                                rect.right = int(min(blocks))
                            else:
                                # If we can't find a proper blocking face, do NOT depenetrate in X
                                # (that can push several pixels and trigger the teleport-guard,
                                # which feels like getting stuck). Prefer a tiny Y depenetration;
                                # if that can't fix it, cancel this X step.
                                rect2 = depenetrate_axis(rect, axis="y")
                                if (
                                    abs(float(vel.y)) < 1e-6
                                    and abs(int(rect2.y) - int(rect.y)) <= int(nudge_max)
                                    and rect2.topleft != rect.topleft
                                    and not self._collide_rect_world(rect2)
                                ):
                                    rect = rect2
                                    depen_fixed = True
                                else:
                                    rect = pygame.Rect(prev)
                        else:
                            blocks = [int(r.right) for r in hits if int(prev.left) >= int(r.right)]
                            if blocks:
                                rect.left = int(max(blocks))
                            else:
                                rect2 = depenetrate_axis(rect, axis="y")
                                if (
                                    abs(float(vel.y)) < 1e-6
                                    and abs(int(rect2.y) - int(rect.y)) <= int(nudge_max)
                                    and rect2.topleft != rect.topleft
                                    and not self._collide_rect_world(rect2)
                                ):
                                    rect = rect2
                                    depen_fixed = True
                                else:
                                    rect = pygame.Rect(prev)
                        if self._collide_rect_world(rect):
                            rect2 = depenetrate_axis(rect, axis="y")
                            if abs(int(rect2.y) - int(rect.y)) <= int(nudge_max) and rect2.topleft != rect.topleft:
                                rect = rect2
                                depen_fixed = True
                        # Keep wall sliding stable: avoid large cross-axis corrections here.
                        # We only apply tiny axis depenetration when we're still overlapping.
                        p.x = float(rect.centerx)
                        if depen_fixed:
                            p.y = float(rect.centery)

            if dy != 0.0:
                prev = rect_at(float(p.x), float(p.y))
                p.y += float(dy)
                rect = rect_at(float(p.x), float(p.y))
                hits = self._collide_rect_world(rect)
                if hits:
                    hits_block = filter_hits_axis(hits, rect, axis="y")
                    if not hits_block:
                        rect2 = depenetrate_axis(rect, axis="x")
                        if not self._collide_rect_world(rect2):
                            rect = rect2
                            p.x = float(rect.centerx)
                        p.y = float(rect.centery)
                        continue
                    hits = hits_block
                    corrected = False
                    depen_fixed = False
                    if abs(float(vel.x)) < 1e-6:
                        prefer = 0
                        try:
                            avg = sum(int(hh.centerx) for hh in hits) / float(max(1, len(hits)))
                            if float(avg) < float(rect.centerx):
                                prefer = 1  # obstacles left -> move right first
                            elif float(avg) > float(rect.centerx):
                                prefer = -1  # obstacles right -> move left first
                        except Exception:
                            prefer = 0

                        base = pygame.Rect(rect)
                        for n in range(1, int(nudge_max) + 1):
                            if prefer > 0:
                                cands = (n, -n)
                            elif prefer < 0:
                                cands = (-n, n)
                            else:
                                cands = (-n, n)
                            for sx in cands:
                                test = pygame.Rect(base)
                                test.x += int(sx)
                                if not self._collide_rect_world(test):
                                    rect = test
                                    corrected = True
                                    break
                            if corrected:
                                break
                    if corrected:
                        p.x = float(rect.centerx)
                        p.y = float(rect.centery)
                        continue
                    if not corrected and abs(float(vel.x)) < 1e-6:
                        # Mirror of the horizontal case: if we can clear the collision by
                        # nudging in X, do so to avoid 1px corner lockups.
                        rect2 = depenetrate_axis(rect, axis="x")
                        if abs(int(rect2.x) - int(rect.x)) <= int(nudge_max) and not self._collide_rect_world(rect2):
                            rect = rect2
                            corrected = True
                            depen_fixed = True
                            p.x = float(rect.centerx)
                            p.y = float(rect.centery)
                            continue
                    if dy > 0.0:
                        blocks = [int(r.top) for r in hits if int(prev.bottom) <= int(r.top)]
                        if blocks:
                            rect.bottom = int(min(blocks))
                        else:
                            rect2 = depenetrate_axis(rect, axis="x")
                            if (
                                abs(float(vel.x)) < 1e-6
                                and abs(int(rect2.x) - int(rect.x)) <= int(nudge_max)
                                and rect2.topleft != rect.topleft
                                and not self._collide_rect_world(rect2)
                            ):
                                rect = rect2
                                depen_fixed = True
                            else:
                                rect = pygame.Rect(prev)
                    else:
                        blocks = [int(r.bottom) for r in hits if int(prev.top) >= int(r.bottom)]
                        if blocks:
                            rect.top = int(max(blocks))
                        else:
                            rect2 = depenetrate_axis(rect, axis="x")
                            if (
                                abs(float(vel.x)) < 1e-6
                                and abs(int(rect2.x) - int(rect.x)) <= int(nudge_max)
                                and rect2.topleft != rect.topleft
                                and not self._collide_rect_world(rect2)
                            ):
                                rect = rect2
                                depen_fixed = True
                            else:
                                rect = pygame.Rect(prev)
                    if self._collide_rect_world(rect):
                        rect2 = depenetrate_axis(rect, axis="x")
                        if abs(int(rect2.x) - int(rect.x)) <= int(nudge_max) and rect2.topleft != rect.topleft:
                            rect = rect2
                            depen_fixed = True
                    # Same idea as X: only clamp along Y to preserve wall sliding.
                    p.y = float(rect.centery)
                    if depen_fixed:
                        p.x = float(rect.centerx)

            # Final safety: never return a penetrated position (prevents "贴墙卡住").
            final = rect_at(float(p.x), float(p.y))
            if self._collide_rect_world(final):
                # Avoid large depenetration "snaps" at outside corners: only allow
                # tiny corrective pushes. Otherwise, revert this sub-step.
                max_fix = int(max(1, int(nudge_max)))
                fixed: pygame.Rect | None = None

                if abs(float(vel.y)) < 1e-6 and abs(float(vel.x)) > 1e-6:
                    cand = depenetrate_axis(final, axis="y")
                    if abs(int(cand.y) - int(final.y)) <= max_fix and not self._collide_rect_world(cand):
                        fixed = cand
                elif abs(float(vel.x)) < 1e-6 and abs(float(vel.y)) > 1e-6:
                    cand = depenetrate_axis(final, axis="x")
                    if abs(int(cand.x) - int(final.x)) <= max_fix and not self._collide_rect_world(cand):
                        fixed = cand
                else:
                    cand = depenetrate_axis(final, axis="x")
                    if abs(int(cand.x) - int(final.x)) <= max_fix and not self._collide_rect_world(cand):
                        fixed = cand
                    else:
                        cand = depenetrate_axis(final, axis="y")
                        if abs(int(cand.y) - int(final.y)) <= max_fix and not self._collide_rect_world(cand):
                            fixed = cand

                if fixed is not None:
                    p.update(float(fixed.centerx), float(fixed.centery))
                else:
                    p.update(float(step_prev.x), float(step_prev.y))

        return p

    def _move_box_vehicle(
        self,
        pos: pygame.Vector2,
        vel: pygame.Vector2,
        dt: float,
        *,
        w: int,
        h: int,
        max_dist: float | None = None,
    ) -> pygame.Vector2:
        # Sub-stepped movement to avoid tunneling through 1-tile walls when dt spikes.
        w = int(w)
        h = int(h)
        dt = float(dt)
        if dt > 0.25:
            dt = 0.25

        p = pygame.Vector2(pos)
        rect = pygame.Rect(
            iround(float(p.x) - float(w) / 2.0),
            iround(float(p.y) - float(h) / 2.0),
            int(w),
            int(h),
        )

        def _rect_at_center(center: pygame.Vector2) -> pygame.Rect:
            return pygame.Rect(
                iround(float(center.x) - float(w) / 2.0),
                iround(float(center.y) - float(h) / 2.0),
                int(w),
                int(h),
            )

        def _resolve_vehicle_overlap(r: pygame.Rect, *, iters: int = 14) -> pygame.Rect:
            r = pygame.Rect(r)
            for _ in range(int(iters)):
                try:
                    hits2 = self._collide_rect_world_vehicle(r)
                except Exception:
                    hits2 = []
                if not hits2:
                    break
                best: tuple[float, str, pygame.Rect] | None = None
                for hit in hits2:
                    if not r.colliderect(hit):
                        continue
                    dl = float(r.right - hit.left)
                    dr = float(hit.right - r.left)
                    du = float(r.bottom - hit.top)
                    dd = float(hit.bottom - r.top)
                    for d, axis in ((dl, "L"), (dr, "R"), (du, "U"), (dd, "D")):
                        if d <= 0.0:
                            continue
                        if best is None or float(d) < float(best[0]):
                            best = (float(d), str(axis), hit)
                if best is None:
                    break
                _d, axis, hit = best
                if axis == "L":
                    r.right = int(hit.left)
                elif axis == "R":
                    r.left = int(hit.right)
                elif axis == "U":
                    r.bottom = int(hit.top)
                else:
                    r.top = int(hit.bottom)
            return r

        # If the vehicle starts overlapped (e.g., after a collision snap), depenetrate
        # so it doesn't become permanently stuck with zero velocity.
        try:
            init_hits = self._collide_rect_world_vehicle(rect)
        except Exception:
            init_hits = []
        if init_hits:
            # Prefer snapping back to a known-safe position if we have one.
            last_safe_global = None
            if self.mount == "rv":
                last_safe_global = getattr(self, "_rv_last_safe_pos", None)
            elif self.mount == "bike":
                last_safe_global = getattr(self, "_bike_last_safe_pos", None)
            if isinstance(last_safe_global, pygame.Vector2):
                cand = _rect_at_center(pygame.Vector2(last_safe_global))
                try:
                    if not self._collide_rect_world_vehicle(cand):
                        rect = cand
                        p.update(float(rect.centerx), float(rect.centery))
                        init_hits = []
                except Exception:
                    pass

            if init_hits:
                rect = _resolve_vehicle_overlap(rect, iters=18)
                p.update(float(rect.centerx), float(rect.centery))
                try:
                    init_hits = self._collide_rect_world_vehicle(rect)
                except Exception:
                    init_hits = []

            if init_hits:
                # Final fallback: small radial search for any nearby free spot.
                step = int(max(1, int(self.TILE_SIZE) // 2))
                max_r = int(self.TILE_SIZE) * 4
                found = False
                for r in range(int(step), int(max_r) + 1, int(step)):
                    for ox, oy in (
                        (r, 0),
                        (-r, 0),
                        (0, r),
                        (0, -r),
                        (r, r),
                        (r, -r),
                        (-r, r),
                        (-r, -r),
                    ):
                        cand_pos = pygame.Vector2(float(p.x) + float(ox), float(p.y) + float(oy))
                        cand_rect = _rect_at_center(cand_pos)
                        try:
                            if not self._collide_rect_world_vehicle(cand_rect):
                                rect = cand_rect
                                p.update(float(rect.centerx), float(rect.centery))
                                found = True
                                break
                        except Exception:
                            continue
                    if found:
                        break

        dx_total = float(vel.x) * dt
        dy_total = float(vel.y) * dt
        # If the vehicle is running out of fuel mid-frame, cap the travel distance so it
        # stops exactly when fuel reaches 0 (instead of gliding for the rest of the frame).
        if max_dist is not None:
            try:
                md = float(max_dist)
            except Exception:
                md = None
            if md is not None:
                if md <= 0.0:
                    dx_total = 0.0
                    dy_total = 0.0
                else:
                    dlen = float(math.hypot(float(dx_total), float(dy_total)))
                    if dlen > md and dlen > 1e-9:
                        s = float(md) / float(dlen)
                        dx_total *= float(s)
                        dy_total *= float(s)
        if abs(dx_total) < 1e-6 and abs(dy_total) < 1e-6:
            # Persist a safe position for un-sticking.
            try:
                if not self._collide_rect_world_vehicle(rect):
                    if self.mount == "rv":
                        self._rv_last_safe_pos = pygame.Vector2(float(rect.centerx), float(rect.centery))
                    elif self.mount == "bike":
                        self._bike_last_safe_pos = pygame.Vector2(float(rect.centerx), float(rect.centery))
            except Exception:
                pass
            return pygame.Vector2(p)

        # Keep per-step movement small (px) so collisions can't be skipped.
        max_step = 2.0
        steps = int(max(1, math.ceil(max(abs(dx_total), abs(dy_total)) / max_step)))
        steps = int(clamp(int(steps), 1, 80))
        step_dx = float(dx_total) / float(steps)
        step_dy = float(dy_total) / float(steps)

        last_safe: pygame.Vector2 | None = None
        try:
            if not self._collide_rect_world_vehicle(rect):
                last_safe = pygame.Vector2(p)
        except Exception:
            last_safe = pygame.Vector2(p)

        skin = int(clamp(int(self.TILE_SIZE) // 6, 1, 2))
        max_jump = max(float(self.TILE_SIZE) * 2.0, float(max_step) * 8.0)

        for _ in range(int(steps)):
            step_prev = pygame.Vector2(p)
            prev_rect = pygame.Rect(rect)
            had_hit = False

            if abs(step_dx) > 1e-9:
                prev_x = pygame.Rect(rect)
                p.x += float(step_dx)
                rect.x = iround(float(p.x) - float(w) / 2.0)
                hits = self._collide_rect_world_vehicle(rect)
                if hits:
                    had_hit = True
                    # First clamp along X as usual.
                    if step_dx > 0.0:
                        blocks = [int(hit.left) for hit in hits if int(prev_x.right) <= int(hit.left) + int(skin)]
                        limit = int(min(blocks)) if blocks else int(min(int(hit.left) for hit in hits))
                        rect.right = int(limit)
                    else:
                        blocks = [int(hit.right) for hit in hits if int(prev_x.left) >= int(hit.right) - int(skin)]
                        limit = int(max(blocks)) if blocks else int(max(int(hit.right) for hit in hits))
                        rect.left = int(limit)

                # Preserve sub-pixel remainder so shallow headings don't "snap" to axis movement.
                try:
                    fx = float(clamp(float(p.x) - float(rect.centerx), -0.49, 0.49))
                except Exception:
                    fx = 0.0
                p.x = float(rect.centerx) + float(fx)

            if abs(step_dy) > 1e-9:
                prev_y = pygame.Rect(rect)
                p.y += float(step_dy)
                rect.y = iround(float(p.y) - float(h) / 2.0)
                hits = self._collide_rect_world_vehicle(rect)
                if hits:
                    had_hit = True
                    # First clamp along Y as usual.
                    if step_dy > 0.0:
                        blocks = [int(hit.top) for hit in hits if int(prev_y.bottom) <= int(hit.top) + int(skin)]
                        limit = int(min(blocks)) if blocks else int(min(int(hit.top) for hit in hits))
                        rect.bottom = int(limit)
                    else:
                        blocks = [int(hit.bottom) for hit in hits if int(prev_y.top) >= int(hit.bottom) - int(skin)]
                        limit = int(max(blocks)) if blocks else int(max(int(hit.bottom) for hit in hits))
                        rect.top = int(limit)

                try:
                    fy = float(clamp(float(p.y) - float(rect.centery), -0.49, 0.49))
                except Exception:
                    fy = 0.0
                p.y = float(rect.centery) + float(fy)

            # If we still overlap after resolution (e.g., due to large colliders like
            # whole-building rects), depenetrate a bit; otherwise revert to the last
            # known safe position to prevent visible "teleport" snaps.
            if had_hit:
                try:
                    post_hits = self._collide_rect_world_vehicle(rect)
                except Exception:
                    post_hits = []
                if post_hits:
                    r = pygame.Rect(rect)
                    for _j in range(10):
                        try:
                            hits2 = self._collide_rect_world_vehicle(r)
                        except Exception:
                            hits2 = []
                        if not hits2:
                            break
                        best: tuple[float, str, pygame.Rect] | None = None
                        for hit in hits2:
                            if not r.colliderect(hit):
                                continue
                            dl = float(r.right - hit.left)
                            dr = float(hit.right - r.left)
                            du = float(r.bottom - hit.top)
                            dd = float(hit.bottom - r.top)
                            for d, axis in ((dl, "L"), (dr, "R"), (du, "U"), (dd, "D")):
                                if d <= 0.0:
                                    continue
                                if best is None or d < best[0]:
                                    best = (float(d), str(axis), hit)
                        if best is None:
                            break
                        _d, axis, hit = best
                        if axis == "L":
                            r.right = int(hit.left)
                        elif axis == "R":
                            r.left = int(hit.right)
                        elif axis == "U":
                            r.bottom = int(hit.top)
                        else:
                            r.top = int(hit.bottom)
                    rect = r
                    p.update(float(rect.centerx), float(rect.centery))

                    try:
                        post_hits = self._collide_rect_world_vehicle(rect)
                    except Exception:
                        post_hits = []
                    if post_hits:
                        if last_safe is not None:
                            rect.x = iround(float(last_safe.x) - float(w) / 2.0)
                            rect.y = iround(float(last_safe.y) - float(h) / 2.0)
                            p.update(float(last_safe.x), float(last_safe.y))
                        else:
                            rect = prev_rect
                            p.update(float(step_prev.x), float(step_prev.y))
                        break

            # Anti-teleport guard: collision resolution should never move a vehicle
            # multiple tiles in a single sub-step. If it does, snap back.
            try:
                step_jump = float((pygame.Vector2(float(rect.centerx), float(rect.centery)) - step_prev).length())
            except Exception:
                step_jump = 0.0
            allowed_jump = float(max_jump) if last_safe is not None else float(max(float(self.TILE_SIZE) * 6.0, float(max_jump)))
            if float(step_jump) > float(allowed_jump):
                if last_safe is not None:
                    rect.x = iround(float(last_safe.x) - float(w) / 2.0)
                    rect.y = iround(float(last_safe.y) - float(h) / 2.0)
                    p.update(float(last_safe.x), float(last_safe.y))
                else:
                    rect = prev_rect
                    p.update(float(step_prev.x), float(step_prev.y))
                break

            # Record a "safe" (non-overlapping) position for fallback.
            if not had_hit:
                last_safe = pygame.Vector2(p)
            else:
                try:
                    if not self._collide_rect_world_vehicle(rect):
                        last_safe = pygame.Vector2(p)
                except Exception:
                    last_safe = pygame.Vector2(p)

        # Persist a safe position for un-sticking.
        if last_safe is not None:
            if self.mount == "rv":
                self._rv_last_safe_pos = pygame.Vector2(last_safe)
            elif self.mount == "bike":
                self._bike_last_safe_pos = pygame.Vector2(last_safe)

        return pygame.Vector2(p)

    def _update_world_door_open_anim(self, dt: float) -> None:
        # Visual-only door open/close animation for world-map doors.
        if bool(getattr(self, "hr_interior", False)) or bool(getattr(self, "house_interior", False)) or bool(getattr(self, "sch_interior", False)):
            return
        anim = getattr(self, "_door_open_anim", None)
        if not isinstance(anim, dict):
            anim = {}
            self._door_open_anim = anim
        tx, ty = self._player_tile()
        openable = {int(self.T_DOOR), int(self.T_DOOR_HOME), int(self.T_DOOR_BROKEN)}
        want: set[tuple[int, int]] = set()
        for yy in range(int(ty) - 2, int(ty) + 3):
            for xx in range(int(tx) - 2, int(tx) + 3):
                tid = int(self.world.peek_tile(int(xx), int(yy), default=int(self.T_GRASS)))
                if int(tid) not in openable:
                    continue
                if abs(int(xx) - int(tx)) <= 1 and abs(int(yy) - int(ty)) <= 1:
                    want.add((int(xx), int(yy)))

        open_speed = 10.0
        close_speed = 8.0
        for pos in set(anim.keys()) | want:
            cur = float(anim.get(pos, 0.0))
            if pos in want:
                cur = min(1.0, cur + float(dt) * float(open_speed))
            else:
                cur = max(0.0, cur - float(dt) * float(close_speed))
            if cur <= 0.001 and pos not in want:
                anim.pop(pos, None)
            else:
                anim[pos] = float(cur)

    def update(self, dt: float) -> None:
        if self.hint_left > 0.0:
            self.hint_left = max(0.0, float(self.hint_left) - dt)
            if self.hint_left <= 0.0:
                self.hint_text = ""

        self._dialog_update(float(dt))
        if float(getattr(self, "speech_left", 0.0)) > 0.0:
            self.speech_left = max(0.0, float(getattr(self, "speech_left", 0.0)) - dt)
            if float(self.speech_left) <= 0.0:
                self.speech_text = ""

        if float(getattr(self, "world_ctx_cooldown_left", 0.0)) > 0.0:
            self.world_ctx_cooldown_left = max(0.0, float(getattr(self, "world_ctx_cooldown_left", 0.0)) - dt)

        if bool(getattr(self, "pause_open", False)):
            return

        # Auto-dismiss the in-world context bubble if it stays up without clicks.
        try:
            if bool(getattr(self, "world_ctx_open", False)) and isinstance(getattr(self, "world_ctx_target", None), tuple):
                tgt = tuple(getattr(self, "world_ctx_target"))
                if tgt == getattr(self, "world_ctx_idle_target", None):
                    self.world_ctx_idle_s = float(getattr(self, "world_ctx_idle_s", 0.0)) + float(dt)
                else:
                    self.world_ctx_idle_target = tgt
                    self.world_ctx_idle_s = 0.0
            else:
                self.world_ctx_idle_target = None
                self.world_ctx_idle_s = 0.0

            if float(getattr(self, "world_ctx_idle_s", 0.0)) >= 4.0:
                ptx, pty = self._player_tile()
                self.world_ctx_suppressed = {"target": tuple(getattr(self, "world_ctx_target", ())), "player_tile": (int(ptx), int(pty))}
                self.world_ctx_idle_s = 0.0
                self.world_ctx_idle_target = None
                self.world_ctx_open = False
                self.world_ctx_target = None
                self.world_ctx_rects = []
                self.world_ctx_cooldown_left = max(float(getattr(self, "world_ctx_cooldown_left", 0.0)), 0.8)
        except Exception:
            pass

        if getattr(self, "rv_ui_status_left", 0.0) > 0.0:
            self.rv_ui_status_left = max(0.0, float(self.rv_ui_status_left) - dt)
            if self.rv_ui_status_left <= 0.0:
                self.rv_ui_status = ""

        if getattr(self, "home_ui_status_left", 0.0) > 0.0:
            self.home_ui_status_left = max(0.0, float(self.home_ui_status_left) - dt)
            if self.home_ui_status_left <= 0.0:
                self.home_ui_status = ""

        if getattr(self, "muzzle_flash_left", 0.0) > 0.0:
            self.muzzle_flash_left = max(0.0, float(self.muzzle_flash_left) - dt)

        if self.player.hp <= 0:
            if self.dead_left <= 0.0:
                self.dead_left = 2.0
                self._set_hint("你死了… 2秒后回主菜单", seconds=2.0)
            else:
                self.dead_left = max(0.0, float(self.dead_left) - dt)
                if self.dead_left <= 0.0:
                    self.app.set_state(MainMenuState(self.app))
            return

        if self.inv_open or getattr(self, "rv_ui_open", False) or getattr(self, "home_ui_open", False) or getattr(self, "hr_elevator_ui_open", False) or getattr(self, "world_elevator_ui_open", False) or getattr(self, "sch_elevator_ui_open", False) or getattr(self, "_gallery_open", False) or getattr(self, "world_map_open", False):
            self.player.vel.update(0, 0)
            self.player.walk_phase *= 0.85
            self.rv.vel.update(0, 0)
            self.bike.vel.update(0, 0)
            return

        dt_time = float(dt)
        if str(getattr(self, "player_pose", "")) == "sleep" and str(getattr(self, "player_pose_space", "")) == "world":
            # Sleep at night fast-forwards time; the fuller you are, the faster it goes.
            tday = (float(self.world_time_s) % float(self.DAY_LENGTH_S)) / float(self.DAY_LENGTH_S)
            if tday >= (20.0 / 24.0) or tday <= (6.0 / 24.0):
                full = float(clamp(float(self.player.hunger) / 100.0, 0.0, 1.0))
                dt_time = float(dt) * float(8.0 + 16.0 * full)
        dt_time = float(clamp(float(dt_time), 0.0, 0.45))

        self.world_time_s += dt_time
        self._update_weather(dt_time)

        if getattr(self, "noise_left", 0.0) > 0.0:
            self.noise_left = max(0.0, float(self.noise_left) - dt_time)
            if self.noise_left <= 0.0:
                self.noise_radius = 0.0

        # Survival stats (prototype tuning).
        self.player.hunger = float(clamp(self.player.hunger - dt_time * 0.10, 0.0, 100.0))
        self.player.thirst = float(clamp(self.player.thirst - dt_time * 0.16, 0.0, 100.0))

        focus = pygame.Vector2(self.player.pos)
        nearest = 99999.0
        for z in self.zombies:
            nearest = min(nearest, float((z.pos - focus).length()))

        stress = 0.0
        if self.player.hunger < 25.0:
            stress += (25.0 - self.player.hunger) / 25.0
        if self.player.thirst < 25.0:
            stress += 1.2 * (25.0 - self.player.thirst) / 25.0
        if self.player.hp < 40:
            stress += (40.0 - float(self.player.hp)) / 40.0
        if nearest < 90.0:
            stress += (90.0 - nearest) / 90.0 * 1.4

        morale_decay = 0.010 + 0.035 * stress
        self.player.morale = float(clamp(self.player.morale - dt_time * morale_decay * 20.0, 0.0, 100.0))

        cond_down = 0.0
        if self.player.hunger <= 0.0:
            cond_down += 0.10
        if self.player.thirst <= 0.0:
            cond_down += 0.14
        if self.player.hp < 60:
            cond_down += 0.06
        cond_up = 0.0
        if self.mount == "rv" and self.rv.vel.length_squared() <= 0.1 and nearest > 140.0:
            cond_up += 0.08
            if self.player.hunger > 50.0 and self.player.thirst > 50.0:
                cond_up += 0.05
        self.player.condition = float(clamp(self.player.condition + dt_time * (cond_up - cond_down) * 10.0, 0.0, 100.0))

        # Starvation / dehydration damage.
        dmg_rate = 0.0
        if self.player.hunger <= 0.0:
            dmg_rate += 0.55
        if self.player.thirst <= 0.0:
            dmg_rate += 0.85
        if dmg_rate > 0.0:
            self.starve_accum += dmg_rate * dt_time
            while self.starve_accum >= 1.0:
                self.starve_accum -= 1.0
                self.player.hp = max(0, int(self.player.hp) - 1)        

        # Bleeding damage (from zombie scratches/bites).
        self._apply_bleed(dt_time)

        keys = pygame.key.get_pressed()
        move = pygame.Vector2(0, 0)
        if keys[pygame.K_w] or keys[pygame.K_UP]:
            move.y -= 1
        if keys[pygame.K_s] or keys[pygame.K_DOWN]:
            move.y += 1
        if keys[pygame.K_a] or keys[pygame.K_LEFT]:
            move.x -= 1
        if keys[pygame.K_d] or keys[pygame.K_RIGHT]:
            move.x += 1

        # In-world furniture moving mode freezes the player; the cursor is moved via key events.
        if bool(getattr(self, "home_move_mode", False)):
            move = pygame.Vector2(0, 0)

        # Sit/Sleep pose locks movement inside interiors.
        pose = getattr(self, "player_pose", None)
        if pose:
            cur_space = "world"
            if getattr(self, "house_interior", False):
                cur_space = "house"
            elif getattr(self, "sch_interior", False):
                cur_space = "sch"
            elif getattr(self, "hr_interior", False):
                cur_space = "hr"
            if str(getattr(self, "player_pose_space", "")) != cur_space:
                self._clear_player_pose()
            else:
                self.player_pose_phase = float(getattr(self, "player_pose_phase", 0.0)) + dt
                left = float(getattr(self, "player_pose_left", 0.0))
                if left > 0.0:
                    self.player_pose_left = max(0.0, left - dt)
                    if self.player_pose_left <= 0.0:
                        self._clear_player_pose()
                if getattr(self, "player_pose", None) is not None:
                    if move.length_squared() > 0.001:
                        self._clear_player_pose()
                    else:
                        move = pygame.Vector2(0, 0)

        # Timed world actions (e.g. toilet) that rely on the sit pose.
        self._update_toilet_task(float(dt))

        move_raw = pygame.Vector2(move)
        if move.length_squared() > 0.001:
            move = move.normalize()
            if self.mount != "rv":
                self.player.facing = pygame.Vector2(move.x, move.y)

        if getattr(self, "sch_interior", False):
            base_speed = 60.0
            self.sch_int_vel = move * base_speed
            self.player_sprinting = False
            if self.sch_int_vel.length_squared() > 0.1:
                self.sch_int_facing = pygame.Vector2(self.sch_int_vel).normalize()
                self.sch_int_walk_phase += dt * 10.0 * (self.sch_int_vel.length() / base_speed)
            else:
                self.sch_int_walk_phase *= 0.90
            self.sch_int_pos = self._sch_int_move_box(
                self.sch_int_pos,
                self.sch_int_vel,
                dt,
                w=int(getattr(self, "int_player_w", 10)),
                h=int(getattr(self, "int_player_h", 14)),
            )
            self.player.vel.update(0, 0)
            self.rv.vel.update(0, 0)
            self.bike.vel.update(0, 0)
            self._update_gun_timers(dt, allow_fire=False)
            return

        if getattr(self, "house_interior", False):
            base_speed = 60.0
            self.house_int_vel = move * base_speed
            self.player_sprinting = False
            if self.house_int_vel.length_squared() > 0.1:
                self.house_int_facing = pygame.Vector2(self.house_int_vel).normalize()
                self.house_int_walk_phase += dt * 10.0 * (self.house_int_vel.length() / base_speed)
            else:
                self.house_int_walk_phase *= 0.90
            self.house_int_pos = self._house_int_move_box(
                self.house_int_pos,
                self.house_int_vel,
                dt,
                w=int(getattr(self, "int_player_w", 10)),
                h=int(getattr(self, "int_player_h", 14)),
            )
            self.player.vel.update(0, 0)
            self.rv.vel.update(0, 0)
            self.bike.vel.update(0, 0)
            self._update_gun_timers(dt, allow_fire=False)
            return

        if getattr(self, "hr_interior", False):
            base_speed = 60.0
            if bool(getattr(self, "hr_travel_active", False)):
                self.player_sprinting = False
                self.hr_int_vel = pygame.Vector2(0, 0)
                self.hr_int_walk_phase *= 0.90
                self._hr_travel_update(dt)
                self.player.vel.update(0, 0)
                self.rv.vel.update(0, 0)
                self.bike.vel.update(0, 0)
                self._update_gun_timers(dt, allow_fire=False)
                return

            # "Walk into the lobby then to the elevator" feel on entry.
            if bool(getattr(self, "hr_auto_walk_to_elevator", False)):  
                # Allow player input to cancel the auto-walk.
                if move.length_squared() > 0.001:
                    self.hr_auto_walk_to_elevator = False
                else:
                    delay = float(getattr(self, "hr_auto_walk_delay", 0.0))
                    if delay > 0.0:
                        self.hr_auto_walk_delay = max(0.0, delay - dt)
                        move = pygame.Vector2(0, 0)
                    elif str(getattr(self, "hr_mode", "lobby")) == "lobby":
                        elev = self._hr_int_find("E")
                        if elev is None:
                            self.hr_auto_walk_to_elevator = False
                        else:
                            ex, ey = elev
                            tile = int(self._HR_INT_TILE_SIZE)
                            target = pygame.Vector2((ex + 0.5) * tile, (ey + 0.5) * tile)
                            diff = target - pygame.Vector2(self.hr_int_pos)
                            d2 = float(diff.length_squared())
                            if d2 <= 3.0 * 3.0:
                                self.hr_auto_walk_to_elevator = False
                                move = pygame.Vector2(0, 0)
                                if not bool(getattr(self, "hr_elevator_ui_open", False)):
                                    self._hr_elevator_open()
                            else:
                                if diff.length_squared() > 0.001:
                                    move = diff.normalize()
                                    base_speed = 56.0

            self.hr_int_vel = move * base_speed
            self.player_sprinting = False
            if self.hr_int_vel.length_squared() > 0.1:
                self.hr_int_facing = pygame.Vector2(self.hr_int_vel).normalize()
                self.hr_int_walk_phase += dt * 10.0 * (self.hr_int_vel.length() / base_speed)
            else:
                self.hr_int_walk_phase *= 0.90
            self.hr_int_pos = self._hr_int_move_box(
                self.hr_int_pos,
                self.hr_int_vel,
                dt,
                w=int(getattr(self, "int_player_w", 10)),
                h=int(getattr(self, "int_player_h", 14)),
            )
            self.player.vel.update(0, 0)
            self.rv.vel.update(0, 0)
            self.bike.vel.update(0, 0)
            self._update_gun_timers(dt, allow_fire=False)
            return

        if self.mount == "rv":
            mid = getattr(self.rv, "model_id", "rv")
            model = self._CAR_MODELS.get(str(mid))
            if model is None:
                model = self._CAR_MODELS.get("rv") or next(iter(self._CAR_MODELS.values()))

            want_fwd = bool(keys[pygame.K_w] or keys[pygame.K_UP])
            want_rev = bool(keys[pygame.K_s] or keys[pygame.K_DOWN])
            throttle = (1.0 if want_fwd else 0.0) + (-1.0 if want_rev else 0.0)
            steer_in = 0.0
            if keys[pygame.K_a] or keys[pygame.K_LEFT]:
                steer_in -= 1.0
            if keys[pygame.K_d] or keys[pygame.K_RIGHT]:
                steer_in += 1.0

            tx = int(math.floor(self.rv.pos.x / self.TILE_SIZE))        
            ty = int(math.floor(self.rv.pos.y / self.TILE_SIZE))        
            tile_under = self.world.get_tile(tx, ty)
            traction = float(self._tile_slow(tile_under))

            fuel = float(getattr(self.rv, "fuel", 0.0))
            fuel_empty = fuel <= 0.01
            boost = 1.15 if (keys[pygame.K_LSHIFT] or keys[pygame.K_RSHIFT]) else 1.0
            if fuel_empty:
                boost = 1.0
                if abs(float(throttle)) > 0.1 and not bool(getattr(self, "_rv_no_fuel_warned", False)):
                    self._set_hint("房车没油了", seconds=1.0)
                    self._rv_no_fuel_warned = True
            else:
                self._rv_no_fuel_warned = False

            # Out of fuel: engine stops (no acceleration), but the vehicle can still coast
            # due to inertia and slow down via drag/braking (hardcore simulation feel).
            accel_mult = 0.0 if fuel_empty else boost

            max_fwd = float(model.max_fwd) * traction * float(boost)
            max_rev = float(model.max_rev) * traction
            accel = float(model.accel) * traction * float(accel_mult)
            brake = float(model.brake) * traction
            drag = 1.8 + (1.0 - traction) * 2.2

            max_steer = float(getattr(model, "steer_max", 0.62))  # radians
            # Faster return-to-center reduces "drift" when releasing A/D.
            steer_resp = 16.0
            target_steer = float(clamp(steer_in, -1.0, 1.0)) * max_steer        
            self.rv.steer = float(self.rv.steer + (target_steer - float(self.rv.steer)) * clamp(dt * steer_resp, 0.0, 1.0))
            # Snap small residual steer to zero so straight driving stays straight.
            if abs(float(steer_in)) < 1e-6 and abs(float(self.rv.steer)) < 0.0035:
                self.rv.steer = 0.0

            speed = float(self.rv.speed)
            if fuel_empty:
                # Engine off: W does nothing; S is braking. Otherwise coast with drag.
                if throttle < 0.0:
                    if speed > 0.5:
                        speed = max(0.0, speed - brake * dt)
                    elif speed < -0.5:
                        speed = min(0.0, speed + brake * dt)
                    else:
                        speed = 0.0
                else:
                    speed *= max(0.0, 1.0 - drag * dt)
                self._rv_reverse_hold = 0.0
            else:
                # W = accelerate forward, S = brake (and reverse only after stopping).
                if throttle > 0.0:
                    if speed < -0.5:
                        # Braking while reversing.
                        speed = min(0.0, speed + brake * dt)
                    else:
                        speed += accel * dt
                    self._rv_reverse_hold = 0.0
                elif throttle < 0.0:
                    if speed > 0.5:
                        # Braking while moving forward.
                        speed = max(0.0, speed - brake * dt)
                        self._rv_reverse_hold = 0.0
                    else:
                        # Reverse is gated: hold S briefly after stopping.
                        hold = float(getattr(self, "_rv_reverse_hold", 0.0)) + float(dt)
                        self._rv_reverse_hold = float(hold)
                        if float(hold) >= 0.25:
                            speed -= (accel * 0.75) * dt
                        else:
                            speed = 0.0
                else:
                    speed *= max(0.0, 1.0 - drag * dt)
                    self._rv_reverse_hold = 0.0

            speed = float(clamp(speed, -max_rev, max_fwd))
            self.rv.speed = speed

            wheelbase = float(max(8.0, getattr(model, "wheelbase", 20.0)))
            heading0 = float(getattr(self.rv, "heading", 0.0))
            forward0 = pygame.Vector2(math.cos(heading0), math.sin(heading0))
            if forward0.length_squared() <= 0.001:
                forward0 = pygame.Vector2(1, 0)
            else:
                forward0 = forward0.normalize()

            turn = 0.0
            if abs(speed) > 0.5 and abs(float(self.rv.steer)) > 1e-6:
                turn = (speed / wheelbase) * math.tan(float(self.rv.steer))
            heading1 = float((heading0 + turn * dt) % math.tau)
            self.rv.heading = float(heading1)

            forward1 = pygame.Vector2(math.cos(float(heading1)), math.sin(float(heading1)))
            if forward1.length_squared() <= 0.001:
                forward1 = pygame.Vector2(1, 0)
            else:
                forward1 = forward1.normalize()

            # Move the vehicle as if steering is applied at the front axle (rear-axle anchored),
            # so it doesn't feel like turning around its center.
            length_px = float(max(int(getattr(self.rv, "w", 0)), int(getattr(self.rv, "h", 0))))
            half_len = float(length_px * 0.5) if length_px > 0.0 else float(wheelbase * 0.5)
            rear_ref = float(max(6.0, float(wheelbase * 0.5)))
            if half_len > 0.0:
                rear_ref = float(max(rear_ref, half_len - 6.0))
                rear_ref = float(min(rear_ref, max(6.0, half_len - 2.0)))

            rear0 = pygame.Vector2(self.rv.pos) - forward0 * float(rear_ref)
            # Midpoint integration so the RV doesn't "slide" sideways while turning.
            heading_mid = float(heading0 + turn * dt * 0.5)
            forward_mid = pygame.Vector2(math.cos(float(heading_mid)), math.sin(float(heading_mid)))
            if forward_mid.length_squared() <= 0.001:
                forward_mid = forward0
            else:
                forward_mid = forward_mid.normalize()
            rear1 = rear0 + forward_mid * speed * dt
            center1 = rear1 + forward1 * float(rear_ref)
            if dt > 0.0:
                self.rv.vel = (center1 - pygame.Vector2(self.rv.pos)) / float(dt)
            else:
                self.rv.vel = pygame.Vector2(0, 0)

            if abs(speed) > 4.0:
                self.rv_anim += dt * (2.0 + abs(speed) * 0.06)
            else:
                self.rv_anim *= 0.85

            before = pygame.Vector2(self.rv.pos)
            desired_vel = pygame.Vector2(self.rv.vel)
            try:
                desired_step = float((pygame.Vector2(desired_vel) * float(dt)).length())
            except Exception:
                desired_step = 0.0
            # Driving collision: use a stable axis-aligned collider (swap on near-vertical)
            # instead of the rotated AABB, which becomes overly conservative at ~45° and
            # makes vehicles feel like they hit buildings too early.
            try:
                cw = int(max(2, int(getattr(self.rv, "w", 0))))
                ch = int(max(2, int(getattr(self.rv, "h", 0))))
                # Allow per-model driving collider (e.g. RV uses a smaller box to avoid
                # feeling blocked by dense city building facades while keeping a big footprint
                # for its interior stamping).
                try:
                    dc = getattr(model, "drive_collider", None)
                    if isinstance(dc, tuple) and len(dc) == 2:
                        dcw, dch = int(dc[0]), int(dc[1])
                        if dcw > 0 and dch > 0:
                            cw = int(max(2, min(int(cw), int(dcw))))
                            ch = int(max(2, min(int(ch), int(dch))))
                except Exception:
                    pass
                heading = float(getattr(self.rv, "heading", 0.0))
                c = abs(float(math.cos(float(heading))))
                s = abs(float(math.sin(float(heading))))
                ratio = float(s / max(1e-6, c))
                axis = int(getattr(self, "_rv_drive_axis", 0))  # 0=horiz, 1=vert
                if axis == 0:
                    if ratio > 1.18:
                        axis = 1
                else:
                    if ratio < 0.85:
                        axis = 0
                self._rv_drive_axis = int(axis)
                if axis == 1:
                    vw, vh = int(ch), int(cw)
                else:
                    vw, vh = int(cw), int(ch)
            except Exception:
                vw = int(max(2, int(getattr(self.rv, "w", 0))))
                vh = int(max(2, int(getattr(self.rv, "h", 0))))
            self.rv.pos = self._move_box_vehicle(self.rv.pos, self.rv.vel, dt, w=vw, h=vh)
            moved = pygame.Vector2(self.rv.pos) - before
            dist = float(moved.length())
            if dt > 0.0:
                self.rv.vel = moved / float(dt)
                # If we hit something, the kinematic model will keep "pushing" unless we
                # sync the signed speed to the *actual* movement. This prevents the
                # spin-in-place exploit that can creep vehicles through walls/buildings.
                # BUT: vehicle movement is quantized to pixels for crisp rendering. If we always
                # sync speed to the quantized movement, braking/accel will feel "steppy" and
                # can even get stuck at exactly 60px/s (1px per frame). Only sync when we were
                # meaningfully blocked (i.e., forward progress is much less than intended).
                try:
                    desired_fwd_step = float(abs(float(speed)) * float(dt))
                    actual_fwd_step = float(abs(float(moved.dot(forward1))))
                except Exception:
                    desired_fwd_step = float(desired_step)
                    actual_fwd_step = float(dist)
                if float(desired_fwd_step) >= 0.51 and (float(actual_fwd_step) + 0.15) < float(desired_fwd_step):
                    try:
                        self.rv.speed = float(clamp(float(self.rv.vel.dot(forward1)), -max_rev, max_fwd))
                    except Exception:
                        pass
            if dist > 0.001:
                self.rv.fuel = max(0.0, float(self.rv.fuel) - dist * float(getattr(model, "fuel_per_px", 0.0125)))
            self.player.pos.update(self.rv.pos)
            self.player.vel.update(self.rv.vel)
            self.player.walk_phase *= 0.85
            self.player_sprinting = False

            # If the player is clearly trying to move but the RV doesn't translate for a while,
            # auto-unstuck to a nearby road-like tile so the vehicle never feels permanently dead.
            try:
                stuck_t = float(getattr(self, "_rv_stuck_t", 0.0))
                trying = abs(float(throttle)) > 0.10
                # Consider it "stuck" when the player intends meaningful movement this frame,
                # but the quantized movement stays near-zero.
                want_move = bool(trying and float(desired_step) >= 0.35)
                if want_move and float(dist) <= 0.05:
                    stuck_t += float(dt)
                else:
                    stuck_t = max(0.0, float(stuck_t) - float(dt) * 2.5)
                if stuck_t >= 0.85:
                    if self._rv_try_unstuck_nearby():
                        self._set_hint("房车已脱困", seconds=0.9)
                    stuck_t = 0.0
                self._rv_stuck_t = float(stuck_t)
            except Exception:
                pass
        elif self.mount == "bike":
            base_speed = float(self._bike_base_speed())
            tx = int(math.floor(self.bike.pos.x / self.TILE_SIZE))       
            ty = int(math.floor(self.bike.pos.y / self.TILE_SIZE))        
            tile_under = self.world.get_tile(tx, ty)
            speed = base_speed * self._tile_slow(tile_under)
            speed *= self._weather_move_mult()

            mid = str(getattr(self.bike, "model_id", "bike"))
            uses_fuel = bool(mid.startswith("moto"))
            fuel = float(getattr(self.bike, "fuel", 0.0))
            if uses_fuel and fuel > 0.05:
                self._bike_no_fuel_warned = False

            want_sprint = bool(keys[pygame.K_LSHIFT] or keys[pygame.K_RSHIFT])
            moving_now = move.length_squared() > 0.001
            fuel_empty = bool(uses_fuel and fuel <= 0.01)
            if fuel_empty:
                if moving_now and not bool(getattr(self, "_bike_no_fuel_warned", False)):
                    self._set_hint("摩托车没油了", seconds=1.0)
                    self._bike_no_fuel_warned = True
                # Engine off: keep coasting with friction; no input thrust.
                try:
                    drag = 5.0
                    self.bike.vel *= max(0.0, 1.0 - float(drag) * float(dt))
                    if self.bike.vel.length_squared() < 0.15:
                        self.bike.vel.update(0, 0)
                except Exception:
                    self.bike.vel.update(0, 0)
                want_sprint = False
            elif self._bike_uses_stamina():
                stamina = float(self.player.stamina)
                can_sprint = bool(want_sprint and moving_now and stamina > 10.0)
                if can_sprint:
                    speed *= 1.25
                    self.player.stamina = float(clamp(stamina - dt * 18.0, 0.0, 100.0))
                else:
                    self.player.stamina = float(clamp(stamina + dt * 10.0, 0.0, 100.0))
            else:
                # Motorized two-wheelers: shift is throttle, stamina should recover.
                if want_sprint and moving_now:
                    speed *= 1.35
                self.player.stamina = float(clamp(float(self.player.stamina) + dt * 14.0, 0.0, 100.0))

            if not fuel_empty:
                self.bike.vel = move * speed
            if self.bike.vel.length_squared() > 0.1:
                if abs(self.bike.vel.y) >= abs(self.bike.vel.x):
                    self.bike_dir = "down" if self.bike.vel.y >= 0 else "up"
                else:
                    self.bike_dir = "right" if self.bike.vel.x >= 0 else "left"
                self.bike_anim += dt * 10.0
            else:
                self.bike_anim *= 0.85

            before = pygame.Vector2(self.bike.pos)
            self.bike.pos = self._move_box_vehicle(self.bike.pos, self.bike.vel, dt, w=self.bike.w, h=self.bike.h)
            dist = float((self.bike.pos - before).length())
            if uses_fuel and dist > 0.001:
                fuel_per_px = {
                    "moto": 0.0024,
                    "moto_lux": 0.0022,
                    "moto_long": 0.0026,
                }.get(mid, 0.0024)
                before_fuel = float(getattr(self.bike, "fuel", 0.0))
                self.bike.fuel = float(clamp(before_fuel - dist * float(fuel_per_px), 0.0, 100.0))
                if before_fuel > 0.01 and float(self.bike.fuel) <= 0.01:
                    self._set_hint("摩托车没油了", seconds=1.0)
                    self._bike_no_fuel_warned = True
            self.player.pos.update(self.bike.pos)
            self.player.vel.update(self.bike.vel)
            self.player.walk_phase *= 0.85
            self.player_sprinting = False
        else:
            base_speed = 60.0
            tx = int(math.floor(self.player.pos.x / self.TILE_SIZE))
            ty = int(math.floor(self.player.pos.y / self.TILE_SIZE))
            tile_under = self.world.get_tile(tx, ty)
            speed = base_speed * self._tile_slow(tile_under)
            speed *= 0.80 + 0.20 * (float(self.player.condition) / 100.0)
            speed *= self._weather_move_mult()

            carrying_furniture = bool(self._world_furniture_carry_active())
            if carrying_furniture:
                speed *= 0.62
            want_sprint = bool(keys[pygame.K_LSHIFT] or keys[pygame.K_RSHIFT]) and not bool(carrying_furniture)
            moving_now = move_raw.length_squared() > 0.001
            sprint_intent = bool(want_sprint and moving_now)
            stamina = float(self.player.stamina)

            # Sprint gating with hysteresis: once stamina is depleted, the
            # player must recover some stamina before sprinting again. This
            # prevents tiny "bursts" of sprint when stamina hovers near zero.
            sprint_start_need = 25.0
            sprint_stop_need = 8.0
            was_sprinting = bool(getattr(self, "player_sprinting", False))
            if sprint_intent:
                can_sprint = stamina > (sprint_stop_need if was_sprinting else sprint_start_need)
            else:
                can_sprint = False

            if can_sprint: 
                # Sprint speed multiplier (diagonal sprint is normalized below). 
                speed *= 1.45 
                self.player.stamina = float(clamp(stamina - dt * 28.0, 0.0, 100.0)) 
            else: 
                regen_mod = 0.50 + 0.50 * (min(self.player.hunger, self.player.thirst) / 100.0) 
                regen_mod *= 0.55 + 0.45 * (self.player.morale / 100.0) 
                self.player.stamina = float(clamp(stamina + dt * 16.0 * regen_mod, 0.0, 100.0)) 
            self.player_sprinting = bool(can_sprint) 
            # Keep raw 8-way input (no normalization) so cardinal walking stays 
            # pixel-perfect, but normalize diagonal movement so斜向不会更快。 
            move_vel = pygame.Vector2(move_raw) 
            if abs(float(move_raw.x)) > 1e-6 and abs(float(move_raw.y)) > 1e-6: 
                move_vel = pygame.Vector2(move) 
            self.player.vel = move_vel * speed 

            if self.player.vel.length_squared() > 0.1:
                self.player.walk_phase += dt * 10.0 * (self.player.vel.length() / base_speed)
            else:
                self.player.walk_phase *= 0.92

            # Walk-into-door: special buildings (highrise/school) are portals.
            if self._try_walk_into_special_door(move, dt):
                return

            prev_pos = pygame.Vector2(self.player.pos)
            new_pos = self._move_box(
                self.player.pos,
                self.player.vel,
                dt,
                w=self.player.w,
                h=int(getattr(self.player, "collider_h", self.player.h)),
            )
            # Anti-jitter: if we started from a non-penetrating position, never let
            # collision resolution move the player *opposite* their intended axis
            # direction (this can look like camera shake when pushing on walls).
            try:
                if not self._collide_rect_world(self.player.rect_at(prev_pos)):
                    dx = float(new_pos.x) - float(prev_pos.x)
                    dy = float(new_pos.y) - float(prev_pos.y)
                    vx = float(getattr(self.player.vel, "x", 0.0))
                    vy = float(getattr(self.player.vel, "y", 0.0))
                    if vx > 1e-6 and dx < -1e-6:
                        new_pos.x = float(prev_pos.x)
                    elif vx < -1e-6 and dx > 1e-6:
                        new_pos.x = float(prev_pos.x)
                    if vy > 1e-6 and dy < -1e-6:
                        new_pos.y = float(prev_pos.y)
                    elif vy < -1e-6 and dy > 1e-6:
                        new_pos.y = float(prev_pos.y)
            except Exception:
                pass
            # Safety net: if collision resolution ever produces a multi-tile jump,
            # keep the old position (prevents visible "闪现").
            max_ok = max(float(self.player.vel.length()) * float(dt) + 2.0, float(self.TILE_SIZE) * 0.95)
            if float((new_pos - prev_pos).length_squared()) > float(max_ok * max_ok):
                try:
                    with open("__teleport.log", "a", encoding="utf-8") as f:
                        f.write(
                            f"world_tp_guard pos=({prev_pos.x:.2f},{prev_pos.y:.2f}) new=({float(new_pos.x):.2f},{float(new_pos.y):.2f}) "
                            f"vel=({float(self.player.vel.x):.2f},{float(self.player.vel.y):.2f}) dt={float(dt):.4f} "
                            f"hr_interior={int(bool(getattr(self,'hr_interior',False)))} house_interior={int(bool(getattr(self,'house_interior',False)))}\\n"
                        )
                except Exception:
                    pass
                self.player.pos.update(prev_pos)
            else:
                self.player.pos.update(new_pos)

        self._update_world_door_open_anim(float(dt))
        self._maybe_show_home_highrise_dialog()

        focus = pygame.Vector2(self.player.pos)
        target_cam_x = float(focus.x - INTERNAL_W / 2)
        target_cam_y = float(focus.y - INTERNAL_H / 2)

        # Camera: direct follow (no smoothing). Keep float + int versions.
        self.cam_fx = float(target_cam_x)
        self.cam_fy = float(target_cam_y)
        # Pixel-perfect camera: snap to int pixels. Use iround() (instead of
        # floor) to avoid diagonal "flicker" from asymmetric rounding.
        self.cam_x = int(iround(float(self.cam_fx)))
        self.cam_y = int(iround(float(self.cam_fy)))

        self._stream_world_chunks()

        if self.gun is not None and float(self.gun.reload_left) > 0.0 and getattr(self, "_reload_lock_dir", None) is not None:
            lock = pygame.Vector2(self._reload_lock_dir)
            if lock.length_squared() > 0.001:
                self.aim_dir = lock.normalize()
            else:
                self.aim_dir = pygame.Vector2(1, 0)
        else:
            self.aim_dir = self._compute_aim_dir()

        block_fire = bool(getattr(self, "world_ctx_open", False)) or bool(getattr(self, "home_move_mode", False)) or self._world_furniture_carry_active()
        self._update_gun_timers(dt, allow_fire=not bool(block_fire))

        self._update_punch(dt)
        self._update_zombies(dt)
        self._update_bullets(dt)
        self._update_thrown_furniture(dt)
        self._update_hit_fx(dt)

    def _set_hint(self, text: str, *, seconds: float = 1.2) -> None:    
        self.hint_text = str(text)
        self.hint_left = float(seconds)

    def _pause_open_menu(self) -> None:
        self.pause_open = True
        self.pause_rects = []
        self.inv_open = False
        self.world_map_open = False
        self.rv_ui_open = False
        self.home_ui_open = False
        self.world_elevator_ui_open = False
        self.hr_elevator_ui_open = False
        self.sch_elevator_ui_open = False
        self._gallery_open = False
        self.lamp_cfg_open = False
        self.lamp_cfg_target = None
        self.lamp_cfg_rects = []
        # Close any world context bubble so it doesn't overlap the menu.
        self.world_ctx_open = False
        self.world_ctx_target = None
        self.world_ctx_rects = []

    def _pause_close_menu(self) -> None:
        self.pause_open = False
        self.pause_rects = []

    def _pause_activate(self, action: str) -> None:
        action = str(action)
        if action == "resume":
            self._pause_close_menu()
            return
        if action == "menu":
            self._pause_close_menu()
            self.app.set_state(MainMenuState(self.app))
            return
        if action == "quit":
            self._pause_close_menu()
            try:
                pygame.event.post(pygame.event.Event(pygame.QUIT))
            except Exception:
                pass
            return

    def _handle_pause_menu_mouse(self, event: pygame.event.Event) -> bool:
        if not bool(getattr(self, "pause_open", False)):
            return False
        if not hasattr(event, "pos"):
            return False
        mp = self.app.screen_to_internal(event.pos)
        if mp is None:
            return False
        mx, my = int(mp[0]), int(mp[1])
        for r, act in list(getattr(self, "pause_rects", []) or []):
            if isinstance(r, pygame.Rect) and r.collidepoint(mx, my):
                self._pause_activate(str(act))
                return True
        return True

    def _draw_pause_menu(self, surface: pygame.Surface) -> None:
        if not bool(getattr(self, "pause_open", False)):
            return

        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 170))
        surface.blit(overlay, (0, 0))

        panel_w = 240
        panel_h = 140
        panel = pygame.Rect(0, 0, panel_w, panel_h)
        panel.center = (INTERNAL_W // 2, INTERNAL_H // 2)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=10)
        pygame.draw.rect(surface, (90, 90, 110), panel, 2, border_radius=10)

        draw_text(surface, self.app.font_m, "暂停", (panel.centerx, panel.top + 18), pygame.Color(240, 240, 240), anchor="center")

        buttons = [("继续", "resume"), ("回到主菜单", "menu"), ("退出游戏", "quit")]
        btn_w = panel.w - 40
        btn_h = 22
        gap = 8
        x0 = panel.x + 20
        y0 = panel.y + 38

        rects: list[tuple[pygame.Rect, str]] = []
        for i, (label, act) in enumerate(buttons):
            br = pygame.Rect(int(x0), int(y0 + i * (btn_h + gap)), int(btn_w), int(btn_h))
            pygame.draw.rect(surface, (28, 28, 34), br, border_radius=8)
            pygame.draw.rect(surface, (160, 160, 180), br, 1, border_radius=8)
            draw_text(surface, self.app.font_s, label, (br.centerx, br.centery - 1), pygame.Color(230, 230, 240), anchor="center")
            rects.append((br, str(act)))
        self.pause_rects = rects

    def _lamp_cfg_close(self) -> None:
        self.lamp_cfg_open = False
        self.lamp_cfg_target = None
        self.lamp_cfg_rects = []

    def _lamp_cfg_activate(self, action: str) -> None:
        action = str(action)
        if action == "close":
            self._lamp_cfg_close()
            return
        cfg = getattr(self.app, "config", None)
        if not isinstance(cfg, GameConfig):
            return

        if action in ("r-", "r+"):
            delta = -1 if action == "r-" else 1
            cur = int(getattr(cfg, "lamp_world_radius_tiles", 3))
            cur = int(clamp(int(cur) + int(delta), 2, 18))
            cfg.lamp_world_radius_tiles = int(cur)
            cfg.save()
            self._set_hint(f"灯范围: {cur}", seconds=0.8)
            return
        if action in ("i-", "i+"):
            delta = -0.1 if action == "i-" else 0.1
            cur = float(getattr(cfg, "lamp_world_intensity", 1.0))
            cur = float(clamp(float(cur) + float(delta), 0.0, 3.0))
            cur = float(round(cur, 2))
            cfg.lamp_world_intensity = float(cur)
            cfg.save()
            self._set_hint(f"灯亮度: {cur:.2f}", seconds=0.8)
            return
        if action in ("h-", "h+"):
            delta = -0.05 if action == "h-" else 0.05
            cur = float(getattr(cfg, "lamp_world_halo", 0.35))
            cur = float(clamp(float(cur) + float(delta), 0.0, 1.5))
            cur = float(round(cur, 2))
            cfg.lamp_world_halo = float(cur)
            cfg.save()
            self._set_hint(f"光晕: {cur:.2f}", seconds=0.8)
            return

    def _handle_lamp_cfg_mouse(self, event: pygame.event.Event) -> bool:
        if not bool(getattr(self, "lamp_cfg_open", False)):
            return False
        if not hasattr(event, "pos"):
            return False
        mp = self.app.screen_to_internal(event.pos)
        if mp is None:
            return False
        mx, my = int(mp[0]), int(mp[1])
        rects = list(getattr(self, "lamp_cfg_rects", []) or [])
        for r, act in rects:
            if isinstance(r, pygame.Rect) and r.collidepoint(mx, my):
                self._lamp_cfg_activate(str(act))
                return True
        # Click outside closes it.
        self._lamp_cfg_close()
        return True

    def _draw_lamp_cfg_ui(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        if not bool(getattr(self, "lamp_cfg_open", False)):
            return
        if bool(getattr(self, "pause_open", False)):
            return
        tgt = getattr(self, "lamp_cfg_target", None)
        if not (isinstance(tgt, tuple) and len(tgt) == 2):
            return
        cfg = getattr(self.app, "config", None)
        if not isinstance(cfg, GameConfig):
            return

        tx, ty = int(tgt[0]), int(tgt[1])
        tile_rect = self._world_tile_screen_rect(int(tx), int(ty), int(cam_x), int(cam_y))

        panel_w = 220
        panel_h = 96
        px = int(tile_rect.centerx - panel_w // 2)
        py = int(tile_rect.top - panel_h - 8)
        if py < 4:
            py = int(tile_rect.bottom + 8)
        px = int(clamp(int(px), 4, int(INTERNAL_W - 4 - panel_w)))
        py = int(clamp(int(py), 4, int(INTERNAL_H - 4 - panel_h)))
        panel = pygame.Rect(px, py, panel_w, panel_h)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=10)
        pygame.draw.rect(surface, (90, 90, 110), panel, 1, border_radius=10)

        draw_text(surface, self.app.font_s, "灯设置", (panel.centerx, panel.y + 10), pygame.Color(230, 230, 240), anchor="center")

        rows = [
            ("范围", int(getattr(cfg, "lamp_world_radius_tiles", 3)), "r-", "r+"),
            ("亮度", float(getattr(cfg, "lamp_world_intensity", 1.0)), "i-", "i+"),
            ("光晕", float(getattr(cfg, "lamp_world_halo", 0.35)), "h-", "h+"),
        ]
        rects: list[tuple[pygame.Rect, str]] = []
        y = panel.y + 24
        for name, val, a_dec, a_inc in rows:
            draw_text(surface, self.app.font_s, f"{name}: {val}", (panel.x + 10, y + 8), pygame.Color(200, 200, 210), anchor="midleft")
            bw = 26
            bh = 18
            dec = pygame.Rect(panel.right - 10 - bw * 2 - 6, y, bw, bh)
            inc = pygame.Rect(panel.right - 10 - bw, y, bw, bh)
            for br, lbl, act in ((dec, "-", a_dec), (inc, "+", a_inc)):
                pygame.draw.rect(surface, (28, 28, 34), br, border_radius=6)
                pygame.draw.rect(surface, (160, 160, 180), br, 1, border_radius=6)
                draw_text(surface, self.app.font_s, lbl, (br.centerx, br.centery - 1), pygame.Color(230, 230, 240), anchor="center")
                rects.append((br, str(act)))
            y += 24

        close = pygame.Rect(panel.right - 28, panel.y + 6, 20, 16)
        pygame.draw.rect(surface, (28, 28, 34), close, border_radius=6)
        pygame.draw.rect(surface, (160, 160, 180), close, 1, border_radius=6)
        draw_text(surface, self.app.font_s, "x", (close.centerx, close.centery - 1), pygame.Color(230, 230, 240), anchor="center")
        rects.append((close, "close"))

        self.lamp_cfg_rects = rects

    def _adjust_lamp_settings_key(self, key: int) -> bool:
        cfg = getattr(self.app, "config", None)
        if not isinstance(cfg, GameConfig):
            return False

        key = int(key)
        in_hr = bool(getattr(self, "hr_interior", False))
        if in_hr:
            radius_name = "lamp_hr_radius_tiles"
            inten_name = "lamp_hr_intensity"
            halo_name = "lamp_hr_halo"
        else:
            radius_name = "lamp_world_radius_tiles"
            inten_name = "lamp_world_intensity"
            halo_name = "lamp_world_halo"

        # New lighting controls (override legacy hint strings).
        if key in (pygame.K_F7, pygame.K_F8):
            delta = -1 if key == pygame.K_F7 else 1
            cur = int(getattr(cfg, radius_name, 5))
            cur = int(clamp(int(cur) + int(delta), 2, 18))
            setattr(cfg, radius_name, int(cur))
            cfg.save()
            self._set_hint(f"灯范围 {cur}", seconds=0.9)
            return True

        if key in (pygame.K_F9, pygame.K_F10):
            delta = -0.1 if key == pygame.K_F9 else 0.1
            cur = float(getattr(cfg, inten_name, 1.0))
            cur = float(clamp(float(cur) + float(delta), 0.0, 3.0))
            cur = float(round(cur, 2))
            setattr(cfg, inten_name, float(cur))
            cfg.save()
            self._set_hint(f"灯亮度 {cur:.2f}", seconds=0.9)
            return True

        if key in (pygame.K_F11, pygame.K_F12, pygame.K_LEFTBRACKET, pygame.K_RIGHTBRACKET):
            delta = -0.1 if key in (pygame.K_F11, pygame.K_LEFTBRACKET) else 0.1
            cur = float(getattr(cfg, halo_name, 0.35))
            cur = float(clamp(float(cur) + float(delta), 0.0, 1.5))
            cur = float(round(cur, 2))
            setattr(cfg, halo_name, float(cur))
            cfg.save()
            self._set_hint(f"灯光晕 {cur:.2f}", seconds=0.9)
            return True

        if key in (pygame.K_F7, pygame.K_F8):
            delta = -1 if key == pygame.K_F7 else 1
            cur = int(getattr(cfg, radius_name, 5))
            cur = int(clamp(int(cur) + int(delta), 2, 18))
            setattr(cfg, radius_name, int(cur))
            cfg.save()
            self._set_hint(f"灯范围 {cur}", seconds=0.9)
            return True

        if key in (pygame.K_F9, pygame.K_F10):
            delta = -0.1 if key == pygame.K_F9 else 0.1
            cur = float(getattr(cfg, inten_name, 1.0))
            cur = float(clamp(float(cur) + float(delta), 0.0, 3.0))
            cur = float(round(cur, 2))
            setattr(cfg, inten_name, float(cur))
            cfg.save()
            self._set_hint(f"灯强度 {cur:.2f}", seconds=0.9)
            return True

        if key in (pygame.K_F11, pygame.K_F12):
            delta = -0.1 if key == pygame.K_F11 else 0.1
            cur = float(getattr(cfg, inten_name, 1.0))
            cur = float(clamp(float(cur) + float(delta), 0.0, 3.0))
            cur = float(round(cur, 2))
            setattr(cfg, inten_name, float(cur))
            cfg.save()
            self._set_hint(f"灯亮度 {cur:.2f}", seconds=0.9)
            return True

        if key in (pygame.K_LEFTBRACKET, pygame.K_RIGHTBRACKET):
            delta = -0.1 if key == pygame.K_LEFTBRACKET else 0.1
            cur = float(getattr(cfg, halo_name, 0.35))
            cur = float(clamp(float(cur) + float(delta), 0.0, 1.5))
            cur = float(round(cur, 2))
            setattr(cfg, halo_name, float(cur))
            cfg.save()
            self._set_hint(f"灯光晕 {cur:.2f}", seconds=0.9)
            return True

        return False

    def _dialog_start(self, title: str, lines: list[str], *, speed: float = 42.0) -> None:
        title = str(title).strip()
        if not title:
            title = "提示"
        self.dialog_open = True
        self.dialog_title = title
        self.dialog_text_full = "\n".join(str(s) for s in (lines or [])).strip()
        self.dialog_reveal = 0.0
        self.dialog_speed = float(clamp(float(speed), 10.0, 120.0))
        self.dialog_blink = 0.0

    def _dialog_close(self) -> None:
        self.dialog_open = False
        self.dialog_title = ""
        self.dialog_text_full = ""
        self.dialog_reveal = 0.0
        self.dialog_blink = 0.0

    def _dialog_finished(self) -> bool:
        full = str(getattr(self, "dialog_text_full", ""))
        return int(max(0.0, float(getattr(self, "dialog_reveal", 0.0)))) >= len(full)

    def _dialog_finish(self) -> None:
        full = str(getattr(self, "dialog_text_full", ""))
        self.dialog_reveal = float(len(full))

    def _dialog_update(self, dt: float) -> None:
        if not bool(getattr(self, "dialog_open", False)):
            return
        full = str(getattr(self, "dialog_text_full", ""))
        if not full:
            self.dialog_reveal = 0.0
            return
        self.dialog_blink = float(getattr(self, "dialog_blink", 0.0)) + float(dt)
        if self._dialog_finished():
            return
        speed = float(getattr(self, "dialog_speed", 42.0))
        self.dialog_reveal = float(min(float(len(full)), float(getattr(self, "dialog_reveal", 0.0)) + speed * float(dt)))

    def _speech_say(self, text: str, *, seconds: float = 1.2) -> None:
        self.speech_text = str(text)
        self.speech_left = float(max(0.0, float(seconds)))

    def _draw_speech_bubble(self, surface: pygame.Surface) -> None:
        if float(getattr(self, "speech_left", 0.0)) <= 0.0:
            return
        text = str(getattr(self, "speech_text", "")).strip()
        if not text:
            return
        try:
            font = self.app.font_s
            max_w = int(min(180, INTERNAL_W - 16))

            lines: list[str] = []
            cur = ""
            for ch in text:
                test = cur + ch
                if cur and font.size(test)[0] > max_w:
                    lines.append(cur)
                    cur = ch
                else:
                    cur = test
            if cur:
                lines.append(cur)
            drawn = lines[:2] if lines else [""]

            pad_x = 10
            pad_y = 8
            line_gap = 2
            tail_h = 8
            tail_w = 12
            bubble_bg = (0, 0, 0, 180)
            bubble_border = (220, 220, 235, 140)
            bubble_hi = (240, 220, 140, 20)

            content_w = max(1, max(int(font.size(str(ln))[0]) for ln in drawn))
            bubble_w = int(clamp(int(content_w + pad_x * 2), 64, INTERNAL_W - 12))
            bubble_h = int(clamp(int(len(drawn) * (font.get_height() + line_gap) + pad_y * 2), 30, 90))

            anchor = getattr(self, "_last_player_screen_rect", None)
            if not isinstance(anchor, pygame.Rect):
                anchor = pygame.Rect(INTERNAL_W // 2 - 6, INTERNAL_H // 2 - 10, 12, 20)
            mouth_x = int(anchor.centerx)
            mouth_y = int(anchor.top + max(2, int(anchor.h) // 4))

            # Tail tip position (screen).
            tip_x = int(mouth_x)
            tip_y = int(mouth_y - 2)

            bubble_surf = pygame.Surface((bubble_w, bubble_h + tail_h), pygame.SRCALPHA)
            panel = pygame.Surface((bubble_w, bubble_h), pygame.SRCALPHA)
            panel.fill(bubble_bg)
            pygame.draw.rect(panel, bubble_hi, panel.get_rect(), border_radius=10)
            pygame.draw.rect(panel, bubble_border, panel.get_rect(), 2, border_radius=10)
            bubble_surf.blit(panel, (0, 0))

            out = bubble_surf.get_rect(centerx=tip_x, bottom=tip_y + 1)
            out.left = int(clamp(int(out.left), 6, INTERNAL_W - out.w - 6))
            out.top = int(clamp(int(out.top), 6, INTERNAL_H - out.h - 6))

            tip_x_local = int(clamp(int(tip_x - out.left), 10, bubble_w - 11))
            base_y = int(bubble_h - 1)
            tip_y_local = int(bubble_h + tail_h - 1)
            tail = [(tip_x_local - tail_w // 2, base_y), (tip_x_local + tail_w // 2, base_y), (tip_x_local, tip_y_local)]
            pygame.draw.polygon(bubble_surf, bubble_bg, tail)
            pygame.draw.polygon(bubble_surf, bubble_border, tail, 2)

            tx = pad_x
            ty = pad_y
            for ln in drawn:
                bubble_surf.blit(font.render(str(ln), False, pygame.Color(230, 230, 240)), (tx, ty))
                ty += int(font.get_height() + line_gap)

            surface.blit(bubble_surf, out.topleft)
        except Exception:
            return

    def _draw_toilet_task_ui(self, surface: pygame.Surface) -> None:
        task = getattr(self, "toilet_task", None)
        if not isinstance(task, dict):
            return
        if getattr(self, "mount", None) is not None:
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return
        if str(getattr(self, "player_pose", "")) != "sit" or str(getattr(self, "player_pose_space", "")) != "world":
            return

        total = float(task.get("total", 1.0))
        left = float(task.get("left", 0.0))
        if total <= 1e-4:
            return
        p = float(clamp((total - left) / total, 0.0, 1.0))
        kind = str(task.get("kind", "pee"))

        label = "大便中..." if kind == "poop" else "小便中..."
        pct_text = f"{int(round(p * 100.0)):d}%"
        lines = [label, pct_text]

        try:
            font = self.app.font_s
            pad_x = 8
            pad_y = 6
            line_gap = 2
            tail_h = 6
            tail_w = 10
            bubble_bg = (0, 0, 0, 160)
            bubble_border = (220, 220, 235, 110)
            bubble_hi = (240, 220, 140, 18)

            font_h = int(font.get_height())
            content_w = max(1, max(int(font.size(str(ln))[0]) for ln in lines))
            bar_h = 6
            bar_gap = 4
            bubble_w = int(clamp(int(max(content_w + pad_x * 2, 84)), 84, INTERNAL_W - 12))
            bubble_h = int(clamp(int(pad_y * 2 + font_h + bar_gap + bar_h + bar_gap + font_h), 34, 78))

            anchor = getattr(self, "_last_player_screen_rect", None)
            if not isinstance(anchor, pygame.Rect):
                anchor = pygame.Rect(INTERNAL_W // 2 - 6, INTERNAL_H // 2 - 10, 12, 20)
            mouth_x = int(anchor.centerx)
            mouth_y = int(anchor.top + max(2, int(anchor.h) // 4))

            tip_x = int(mouth_x)
            tip_y = int(mouth_y - 12)

            bubble_surf = pygame.Surface((bubble_w, bubble_h + tail_h), pygame.SRCALPHA)
            panel = pygame.Surface((bubble_w, bubble_h), pygame.SRCALPHA)
            panel.fill(bubble_bg)
            pygame.draw.rect(panel, bubble_hi, panel.get_rect(), border_radius=10)
            pygame.draw.rect(panel, bubble_border, panel.get_rect(), 2, border_radius=10)
            bubble_surf.blit(panel, (0, 0))

            out = bubble_surf.get_rect(centerx=tip_x, bottom=tip_y + 1)
            out.left = int(clamp(int(out.left), 6, INTERNAL_W - out.w - 6))
            out.top = int(clamp(int(out.top), 6, INTERNAL_H - out.h - 6))

            tip_x_local = int(clamp(int(tip_x - out.left), 10, bubble_w - 11))
            base_y = int(bubble_h - 1)
            tip_y_local = int(bubble_h + tail_h - 1)
            tail = [(tip_x_local - tail_w // 2, base_y), (tip_x_local + tail_w // 2, base_y), (tip_x_local, tip_y_local)]
            pygame.draw.polygon(bubble_surf, bubble_bg, tail)
            pygame.draw.polygon(bubble_surf, bubble_border, tail, 2)

            text_col = pygame.Color(230, 230, 240)
            bubble_surf.blit(font.render(str(label), False, text_col), (pad_x, pad_y))

            bar_x = int(pad_x)
            bar_y = int(pad_y + font_h + bar_gap)
            bar_w = int(bubble_w - pad_x * 2)
            bar_rect = pygame.Rect(bar_x, bar_y, bar_w, bar_h)
            pygame.draw.rect(bubble_surf, (0, 0, 0, 130), bar_rect, border_radius=3)
            pygame.draw.rect(bubble_surf, (220, 220, 235, 120), bar_rect, 1, border_radius=3)
            inner = bar_rect.inflate(-2, -2)
            if inner.w > 0 and inner.h > 0:
                fill_w = int(clamp(int(round(float(inner.w) * p)), 0, inner.w))
                if fill_w > 0:
                    fill_col = (210, 180, 120, 210) if kind == "poop" else (120, 190, 230, 210)
                    bubble_surf.fill(fill_col, pygame.Rect(inner.x, inner.y, fill_w, inner.h))
                for i in range(1, 10):
                    x = int(inner.x + (inner.w * i) / 10.0)
                    if inner.x < x < inner.right:
                        bubble_surf.fill((0, 0, 0, 60), pygame.Rect(x, inner.y, 1, inner.h))

            pct_spr = font.render(str(pct_text), False, text_col)
            pct_y = int(bar_rect.bottom + bar_gap - 1)
            bubble_surf.blit(pct_spr, (int(bubble_w - pad_x - pct_spr.get_width()), pct_y))

            surface.blit(bubble_surf, out.topleft)
        except Exception:
            return

    def _maybe_show_home_highrise_dialog(self) -> None:
        # Show a small home guidance dialog when the player walks up to their
        # home high-rise entrance on the world map.
        if bool(getattr(self, "dialog_open", False)):
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return
        home = getattr(self, "home_highrise_door", None)
        if home is None or not isinstance(home, tuple) or len(home) != 2:
            return
        try:
            hx, hy = int(home[0]), int(home[1])
        except Exception:
            return
        center = pygame.Vector2((float(hx) + 0.5) * float(self.TILE_SIZE), (float(hy) + 0.5) * float(self.TILE_SIZE))
        d2 = float((pygame.Vector2(self.player.pos) - center).length_squared())
        near = float(self.TILE_SIZE) * 3.2
        far = float(self.TILE_SIZE) * 4.8
        armed = bool(getattr(self, "home_highrise_dialog_armed", True))
        if armed and d2 <= near * near:
            self._speech_say("我的家在6楼2户", seconds=1.7)
            self.home_highrise_dialog_armed = False
            return
            home_floor = int(getattr(self, "home_highrise_floor", 0))
            home_room = str(getattr(self, "home_highrise_room", "")).strip()
            if home_floor > 0 and home_room:
                line1 = f"你的家：{home_room}（{home_floor}F）"
            elif home_floor > 0:
                line1 = f"你的家在 {home_floor}F"
            else:
                line1 = "这是你的家"
            line2 = f"进楼后坐电梯到 {home_floor}F，找绿色门进入。" if home_floor > 0 else "进楼后找绿色门进入。"
            self._dialog_start("家", [line1, line2], speed=44.0)
            self.home_highrise_dialog_armed = False
            return
        if (not armed) and d2 >= far * far:
            self.home_highrise_dialog_armed = True

    def _draw_dialog(self, surface: pygame.Surface) -> None:
        if not bool(getattr(self, "dialog_open", False)):
            return
        title = str(getattr(self, "dialog_title", "")).strip() or "提示"
        full = str(getattr(self, "dialog_text_full", ""))
        shown = full[: int(max(0.0, float(getattr(self, "dialog_reveal", 0.0))))]

        # Speech bubble near the player (feels like it's "spoken" by the character).
        try:
            font = self.app.font_s
            max_w = int(min(220, INTERNAL_W - 16))

            lines: list[str] = []
            for para in str(shown).split("\n"):
                cur = ""
                for ch in para:
                    test = cur + ch
                    if cur and font.size(test)[0] > max_w:
                        lines.append(cur)
                        cur = ch
                    else:
                        cur = test
                lines.append(cur)
            while len(lines) > 1 and not str(lines[-1]).strip():
                lines.pop()

            drawn = lines[:3]
            if not drawn:
                drawn = [""]

            pad_x = 10
            pad_y = 8
            line_gap = 2
            tail_h = 8
            tail_w = 12
            bubble_bg = (0, 0, 0, 180)
            bubble_border = (220, 220, 235, 140)
            bubble_hi = (240, 220, 140, 20)

            content_w = max(1, max(int(font.size(str(ln))[0]) for ln in drawn))
            bubble_w = int(clamp(int(content_w + pad_x * 2), 80, INTERNAL_W - 12))
            bubble_h = int(clamp(int(len(drawn) * (font.get_height() + line_gap) + pad_y * 2), 36, 120))

            anchor = getattr(self, "_last_player_screen_rect", None)
            if not isinstance(anchor, pygame.Rect):
                anchor = pygame.Rect(INTERNAL_W // 2 - 6, INTERNAL_H // 2 - 10, 12, 20)
            mouth_x = int(anchor.centerx)
            mouth_y = int(anchor.top + max(2, int(anchor.h) // 4))

            # Tail tip position (screen).
            tip_x = int(mouth_x)
            tip_y = int(mouth_y - 2)

            bubble_surf = pygame.Surface((bubble_w, bubble_h + tail_h), pygame.SRCALPHA)
            panel = pygame.Surface((bubble_w, bubble_h), pygame.SRCALPHA)
            panel.fill(bubble_bg)
            pygame.draw.rect(panel, bubble_hi, panel.get_rect(), border_radius=10)
            pygame.draw.rect(panel, bubble_border, panel.get_rect(), 2, border_radius=10)
            bubble_surf.blit(panel, (0, 0))

            out = bubble_surf.get_rect(centerx=tip_x, bottom=tip_y + 1)
            if out.left < 4:
                out.left = 4
            if out.right > INTERNAL_W - 4:
                out.right = INTERNAL_W - 4
            if out.top < 4:
                out.top = 4
            if out.bottom > INTERNAL_H - 4:
                out.bottom = INTERNAL_H - 4

            tip_x_local = int(clamp(int(tip_x - out.left), 10, bubble_w - 11))
            base_y = int(bubble_h - 1)
            tip_y_local = int(bubble_h + tail_h - 1)
            tail = [(tip_x_local - tail_w // 2, base_y), (tip_x_local + tail_w // 2, base_y), (tip_x_local, tip_y_local)]
            pygame.draw.polygon(bubble_surf, bubble_bg, tail)
            pygame.draw.polygon(bubble_surf, bubble_border, tail, 2)

            tx = pad_x
            ty = pad_y
            for ln in drawn:
                bubble_surf.blit(font.render(str(ln), False, pygame.Color(230, 230, 240)), (tx, ty))
                ty += int(font.get_height() + line_gap)

            if not self._dialog_finished() and (int(float(getattr(self, "dialog_blink", 0.0)) * 3.0) % 2 == 0):
                last_ln = str(drawn[-1]) if drawn else ""
                cx = tx + max(0, int(font.size(last_ln)[0]))
                cy = ty - int(font.get_height() + line_gap)
                bubble_surf.blit(font.render("|", False, pygame.Color(240, 220, 140)), (cx, cy))

            if self._dialog_finished():
                tip = "空格/Enter"
                bubble_surf.blit(
                    font.render(tip, False, pygame.Color(170, 170, 180)),
                    (bubble_w - 6 - font.size(tip)[0], bubble_h - 6 - font.get_height()),
                )

            # Optional tiny title tag.
            if title and title != "提示":
                tag = font.render(str(title), False, pygame.Color(240, 220, 140))
                bubble_surf.blit(tag, (pad_x, 2))

            surface.blit(bubble_surf, out.topleft)
            return
        except Exception:
            pass

        panel_h = 74
        pad_x = 12
        pad_y = 10
        panel = pygame.Rect(pad_x, INTERNAL_H - panel_h - pad_y, INTERNAL_W - pad_x * 2, panel_h)
        if panel.y < 6:
            panel.y = 6
        bg = pygame.Surface((panel.w, panel.h), pygame.SRCALPHA)
        bg.fill((0, 0, 0, 180))
        pygame.draw.rect(bg, (240, 220, 140, 26), bg.get_rect(), border_radius=10)
        pygame.draw.rect(bg, (220, 220, 235, 140), bg.get_rect(), 2, border_radius=10)
        surface.blit(bg, panel.topleft)

        font_t = self.app.font_m
        font = self.app.font_s
        surface.blit(font_t.render(title, False, pygame.Color(240, 240, 240)), (panel.x + 10, panel.y + 8))

        max_w = int(panel.w - 20)
        lines: list[str] = []
        for para in str(shown).split("\n"):
            cur = ""
            for ch in para:
                test = cur + ch
                if cur and font.size(test)[0] > max_w:
                    lines.append(cur)
                    cur = ch
                else:
                    cur = test
            lines.append(cur)
        # Trim trailing empty lines (but keep at least one line).
        while len(lines) > 1 and not str(lines[-1]).strip():
            lines.pop()

        tx = panel.x + 10
        ty = panel.y + 32
        drawn = lines[:3]
        for ln in drawn:
            surface.blit(font.render(str(ln), False, pygame.Color(230, 230, 240)), (tx, ty))
            ty += int(font.get_height() + 2)

        if not self._dialog_finished() and (int(float(getattr(self, "dialog_blink", 0.0)) * 3.0) % 2 == 0):
            last_ln = str(drawn[-1]) if drawn else ""
            cx = tx + max(0, int(font.size(last_ln)[0]))
            cy = ty - int(font.get_height() + 2)
            surface.blit(font.render("|", False, pygame.Color(240, 220, 140)), (cx, cy))
        if self._dialog_finished():
            tip = "空格/Enter 关闭"
            surface.blit(font.render(tip, False, pygame.Color(170, 170, 180)), (panel.right - 10 - font.size(tip)[0], panel.bottom - 16))

    def _bleed_total_rate(self) -> float:
        wounds = getattr(self, "bleed_wounds", None)
        if not isinstance(wounds, dict) or not wounds:
            return 0.0
        total = 0.0
        for v in wounds.values():
            try:
                total += max(0.0, float(v))
            except Exception:
                continue
        return float(total)

    def _apply_bleed(self, dt: float) -> None:
        rate = float(self._bleed_total_rate())
        if rate <= 0.0:
            self.bleed_accum = 0.0
            return
        self.bleed_accum = float(getattr(self, "bleed_accum", 0.0)) + float(rate) * float(dt)
        while float(self.bleed_accum) >= 1.0:
            self.bleed_accum = float(self.bleed_accum) - 1.0
            self.player.hp = max(0, int(self.player.hp) - 1)

    def _inflict_wound(self, part: str, *, rate: float) -> None:
        part = str(part)
        rate = float(rate)
        if rate <= 0.0 or self.player.hp <= 0:
            return
        wounds = getattr(self, "bleed_wounds", None)
        if not isinstance(wounds, dict):
            wounds = {}
            self.bleed_wounds = wounds
        # Cap wound count; keep the heaviest wounds and merge the rest.
        if len(wounds) >= 3 and part not in wounds:
            # Add to the weakest wound instead of creating a new slot.
            try:
                part = min(wounds.items(), key=lambda kv: float(kv[1]))[0]
            except Exception:
                pass
        prev = float(wounds.get(part, 0.0))
        wounds[part] = float(min(2.5, prev + rate))
        if prev <= 0.0:
            name = self._BODY_PART_NAMES.get(part, part)
            self._set_hint(f"被抓伤：{name}流血！用绷带止血", seconds=1.6)

    def _bandage_one_wound(self) -> str | None:
        wounds = getattr(self, "bleed_wounds", None)
        if not isinstance(wounds, dict) or not wounds:
            return None
        try:
            part = max(wounds.items(), key=lambda kv: float(kv[1]))[0]
        except Exception:
            part = next(iter(wounds.keys()))
        try:
            del wounds[part]
        except Exception:
            pass
        return str(part)

    def _clear_all_wounds(self) -> int:
        wounds = getattr(self, "bleed_wounds", None)
        if not isinstance(wounds, dict) or not wounds:
            return 0
        n = len(wounds)
        try:
            wounds.clear()
        except Exception:
            self.bleed_wounds = {}
        return int(n)

    def _player_tile(self) -> tuple[int, int]:
        tx = int(math.floor(self.player.pos.x / self.TILE_SIZE))        
        ty = int(math.floor(self.player.pos.y / self.TILE_SIZE))        
        return tx, ty

    def _player_chunk(self) -> tuple[int, int]:
        tx, ty = self._player_tile()
        return tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE

    def _stream_world_chunks(self) -> None:
        # Stream/generate chunks ahead of the camera to avoid hitches when
        # walking diagonally across chunk corners. Render code only "peeks"
        # tiles/chunks and never generates them.
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "sch_interior", False))
            or bool(getattr(self, "house_interior", False))
        ):
            return

        tx, ty = self._player_tile()
        pcx = int(tx) // int(self.CHUNK_SIZE)
        pcy = int(ty) // int(self.CHUNK_SIZE)

        # Always ensure the current chunk exists (physics/collisions rely on it).
        self.world.get_chunk(int(pcx), int(pcy))

        # Collision safety near chunk edges: ensure neighbor chunks that the
        # player's collider might touch soon.
        lx = int(tx - pcx * int(self.CHUNK_SIZE))
        ly = int(ty - pcy * int(self.CHUNK_SIZE))
        margin = 3  # tiles
        need_x = [0]
        if lx <= int(margin):
            need_x.append(-1)
        elif lx >= int(self.CHUNK_SIZE) - 1 - int(margin):
            need_x.append(1)
        need_y = [0]
        if ly <= int(margin):
            need_y.append(-1)
        elif ly >= int(self.CHUNK_SIZE) - 1 - int(margin):
            need_y.append(1)
        for oy in need_y:
            for ox in need_x:
                if int(ox) == 0 and int(oy) == 0:
                    continue
                self.world.get_chunk(int(pcx + ox), int(pcy + oy))

        # Request chunks in/around the camera view for smooth scrolling.
        cam_x = int(getattr(self, "cam_x", 0))
        cam_y = int(getattr(self, "cam_y", 0))
        # Match (and slightly exceed) the draw margins so tall facades don't "vanish"
        # when walking quickly into a not-yet-generated chunk.
        margin_tiles = 4
        start_tx = int(math.floor(float(cam_x) / float(self.TILE_SIZE))) - int(margin_tiles)
        start_ty = int(math.floor(float(cam_y) / float(self.TILE_SIZE))) - int(margin_tiles)
        end_tx = int(math.floor(float(cam_x + INTERNAL_W) / float(self.TILE_SIZE))) + int(margin_tiles)
        end_ty = int(math.floor(float(cam_y + INTERNAL_H) / float(self.TILE_SIZE))) + int(margin_tiles)

        chunk_pad = 1
        start_cx = start_tx // int(self.CHUNK_SIZE) - int(chunk_pad)
        end_cx = end_tx // int(self.CHUNK_SIZE) + int(chunk_pad)
        start_cy = start_ty // int(self.CHUNK_SIZE) - int(chunk_pad)
        end_cy = end_ty // int(self.CHUNK_SIZE) + int(chunk_pad)
        for cy in range(int(start_cy), int(end_cy) + 1):
            for cx in range(int(start_cx), int(end_cx) + 1):
                self.world.request_chunk(int(cx), int(cy))

        tick = int(getattr(self, "_stream_tick", 0)) + 1
        self._stream_tick = int(tick)

        mount = getattr(self, "mount", None)
        moving = False
        if mount == "rv" and getattr(self, "rv", None) is not None:
            moving = self.rv.vel.length_squared() > 0.1
        elif mount == "bike" and getattr(self, "bike", None) is not None:
            moving = self.bike.vel.length_squared() > 0.1
        else:
            moving = self.player.vel.length_squared() > 0.1

        # Budgeted generation: keep the world streaming ahead so buildings
        # (including facades) don't "vanish" while walking into new chunks.
        try:
            pending = int(len(getattr(self.world, "_gen_queue", [])) - int(getattr(self.world, "_gen_queue_i", 0)))
        except Exception:
            pending = 0

        budget = 0
        if moving:
            # Always generate a little while moving; ramp up if we're behind.
            if pending > 0:
                budget = 1
            if pending > 18:
                budget = 2
        else:
            # Standing still: catch up faster.
            budget = 2 if pending > 0 else 0
            if pending > 18:
                budget = 3
        if budget > 0:
            self.world.pump_generation(max_chunks=int(budget))

    def _find_nearest_item(self, *, radius_px: float) -> tuple["_Chunk | None", "_WorldItem | None"]:
        cx, cy = self._player_chunk()
        best_d2 = float(radius_px * radius_px)
        best_item: HardcoreSurvivalState._WorldItem | None = None
        best_chunk: HardcoreSurvivalState._Chunk | None = None

        for oy in (-1, 0, 1):
            for ox in (-1, 0, 1):
                chunk = self.world.get_chunk(cx + ox, cy + oy)
                for it in chunk.items:
                    d2 = float((it.pos - self.player.pos).length_squared())
                    if d2 < best_d2:
                        best_d2 = d2
                        best_item = it
                        best_chunk = chunk

        return best_chunk, best_item

    def _find_nearest_parked_bike(
        self, *, radius_px: float
    ) -> tuple["_Chunk | None", "_ParkedBike | None", float]:
        cx, cy = self._player_chunk()
        best_d2 = float(radius_px * radius_px)
        best_bike: HardcoreSurvivalState._ParkedBike | None = None
        best_chunk: HardcoreSurvivalState._Chunk | None = None

        for oy in (-1, 0, 1):
            for ox in (-1, 0, 1):
                chunk = self.world.get_chunk(cx + ox, cy + oy)
                for b in getattr(chunk, "bikes", []):
                    pos = getattr(b, "pos", None)
                    if pos is None:
                        continue
                    d2 = float((pygame.Vector2(pos) - self.player.pos).length_squared())
                    if d2 < best_d2:
                        best_d2 = d2
                        best_bike = b
                        best_chunk = chunk

        return best_chunk, best_bike, best_d2

    def _find_nearest_parked_car(
        self, *, radius_px: float
    ) -> tuple["_Chunk | None", "_ParkedCar | None", float]:
        cx, cy = self._player_chunk()
        best_d2 = float(radius_px * radius_px)
        best_car: HardcoreSurvivalState._ParkedCar | None = None
        best_chunk: HardcoreSurvivalState._Chunk | None = None

        for oy in (-1, 0, 1):
            for ox in (-1, 0, 1):
                chunk = self.world.get_chunk(cx + ox, cy + oy)
                for car in getattr(chunk, "cars", []):
                    pos = getattr(car, "pos", None)
                    if pos is None:
                        continue
                    d2 = float((pygame.Vector2(pos) - self.player.pos).length_squared())
                    if d2 < best_d2:
                        best_d2 = d2
                        best_car = car
                        best_chunk = chunk

        return best_chunk, best_car, best_d2

    def _stash_personal_bike_as_parked(self) -> None:
        if not hasattr(self, "bike") or self.bike is None:
            return
        mid = str(getattr(self.bike, "model_id", "bike"))
        d = str(getattr(self, "bike_dir", "right"))
        pos = pygame.Vector2(self.bike.pos)
        w, h = self._two_wheel_collider_px(mid)

        def rect_at(p: pygame.Vector2) -> pygame.Rect:
            return pygame.Rect(
                int(iround(float(p.x) - float(w) / 2.0)),
                int(iround(float(p.y) - float(h) / 2.0)),
                int(w),
                int(h),
            )

        def inside_any_building(tx: int, ty: int) -> bool:
            ch = self.world.get_chunk(int(tx) // self.CHUNK_SIZE, int(ty) // self.CHUNK_SIZE)
            for bx0, by0, bw, bh, _roof_kind, _floors in getattr(ch, "buildings", []):
                if int(bx0) <= int(tx) < int(bx0) + int(bw) and int(by0) <= int(ty) < int(by0) + int(bh):
                    return True
            return False

        # Don't leave a parked bike "on top of" building roofs/facades.
        tx0 = int(math.floor(pos.x / self.TILE_SIZE))
        ty0 = int(math.floor(pos.y / self.TILE_SIZE))
        if inside_any_building(tx0, ty0) or self._collide_rect_world_vehicle(rect_at(pos)):
            found: pygame.Vector2 | None = None
            # Spiral search around the current tile.
            search_r = 6
            for r in range(int(search_r) + 1):
                for dy in range(-int(r), int(r) + 1):
                    for dx in range(-int(r), int(r) + 1):
                        if max(abs(int(dx)), abs(int(dy))) != int(r):
                            continue
                        tx = int(tx0 + int(dx))
                        ty = int(ty0 + int(dy))
                        if inside_any_building(tx, ty):
                            continue
                        p = pygame.Vector2(
                            (float(tx) + 0.5) * float(self.TILE_SIZE),
                            (float(ty) + 0.5) * float(self.TILE_SIZE),
                        )
                        if self._collide_rect_world_vehicle(rect_at(p)):
                            continue
                        found = p
                        break
                    if found is not None:
                        break
                if found is not None:
                    break
            if found is None:
                return
            pos = found

        tx = int(math.floor(pos.x / self.TILE_SIZE))
        ty = int(math.floor(pos.y / self.TILE_SIZE))
        chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
        for pb in getattr(chunk, "bikes", []):
            if (pygame.Vector2(getattr(pb, "pos", pos)) - pos).length_squared() <= (6.0 * 6.0):
                return
        chunk.bikes.append(
            HardcoreSurvivalState._ParkedBike(
                pos=pos,
                model_id=mid,
                dir=d,
                frame=0,
                fuel=float(getattr(self.bike, "fuel", 0.0)),
            )
        )

    def _stash_personal_car_as_parked(self) -> None:
        if not hasattr(self, "rv") or self.rv is None:
            return
        mid = str(getattr(self.rv, "model_id", "rv"))
        pos = pygame.Vector2(self.rv.pos)
        heading = float(getattr(self.rv, "heading", 0.0))
        fuel = float(getattr(self.rv, "fuel", 0.0))

        def rect_at(p: pygame.Vector2) -> pygame.Rect:
            return self._rv_collider_rect_at(p)

        def inside_any_building(tx: int, ty: int) -> bool:
            ch = self.world.get_chunk(int(tx) // self.CHUNK_SIZE, int(ty) // self.CHUNK_SIZE)
            for bx0, by0, bw, bh, _roof_kind, _floors in getattr(ch, "buildings", []):
                if int(bx0) <= int(tx) < int(bx0) + int(bw) and int(by0) <= int(ty) < int(by0) + int(bh):
                    return True
            return False

        tx0 = int(math.floor(pos.x / self.TILE_SIZE))
        ty0 = int(math.floor(pos.y / self.TILE_SIZE))

        saved_mount = getattr(self, "mount", None)
        try:
            # Ignore self-car collision when checking for a safe parked spot.
            self.mount = "rv"
            if inside_any_building(tx0, ty0) or self._collide_rect_world_vehicle(rect_at(pos)):
                found: pygame.Vector2 | None = None
                search_r = 10
                for r in range(int(search_r) + 1):
                    for dy in range(-int(r), int(r) + 1):
                        for dx in range(-int(r), int(r) + 1):
                            if max(abs(int(dx)), abs(int(dy))) != int(r):
                                continue
                            tx = int(tx0 + int(dx))
                            ty = int(ty0 + int(dy))
                            if inside_any_building(tx, ty):
                                continue
                            p = pygame.Vector2(
                                (float(tx) + 0.5) * float(self.TILE_SIZE),
                                (float(ty) + 0.5) * float(self.TILE_SIZE),
                            )
                            if self._collide_rect_world_vehicle(rect_at(p)):
                                continue
                            found = p
                            break
                        if found is not None:
                            break
                    if found is not None:
                        break
                if found is None:
                    return
                pos = found
        finally:
            self.mount = saved_mount

        tx = int(math.floor(pos.x / self.TILE_SIZE))
        ty = int(math.floor(pos.y / self.TILE_SIZE))
        chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
        for pc in getattr(chunk, "cars", []):
            if (pygame.Vector2(getattr(pc, "pos", pos)) - pos).length_squared() <= (8.0 * 8.0):
                return
        chunk.cars.append(
            HardcoreSurvivalState._ParkedCar(
                pos=pos,
                model_id=mid,
                heading=float(heading),
                steer_state=0,
                frame=0,
                fuel=float(fuel),
            )
        )

    def _special_building_for_door_tile(
        self, tx: int, ty: int
    ) -> HardcoreSurvivalState._SpecialBuilding | None:
        door = (int(tx), int(ty))
        cx = int(door[0]) // self.CHUNK_SIZE
        cy = int(door[1]) // self.CHUNK_SIZE
        for oy in (-1, 0, 1):
            for ox in (-1, 0, 1):
                chunk = self.world.get_chunk(int(cx + ox), int(cy + oy))
                for sb in getattr(chunk, "special_buildings", []):
                    if door in getattr(sb, "door_tiles", ()):
                        return sb
        return None

    def _try_walk_into_special_door(self, move: pygame.Vector2, dt: float) -> bool:
        if self.mount is not None:
            return False
        if move.length_squared() <= 0.001:
            return False

        rect = self.player.rect_at(self.player.pos)
        dx_f = float(self.player.vel.x) * float(dt)
        dy_f = float(self.player.vel.y) * float(dt)
        dx = int(round(dx_f))
        dy = int(round(dy_f))
        if dx == 0 and abs(dx_f) > 0.001:
            dx = 1 if dx_f > 0 else -1
        if dy == 0 and abs(dy_f) > 0.001:
            dy = 1 if dy_f > 0 else -1
        if dx == 0 and dy == 0:
            return False

        next_rect = rect.move(int(dx), int(dy))
        tx, ty = self._player_tile()
        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        for cx, cy in candidates:
            cx = int(cx)
            cy = int(cy)
            if int(self.world.get_tile(cx, cy)) != int(self.T_DOOR):
                continue
            door_rect = pygame.Rect(
                int(cx * self.TILE_SIZE),
                int(cy * self.TILE_SIZE),
                int(self.TILE_SIZE),
                int(self.TILE_SIZE),
            )
            if not next_rect.colliderect(door_rect):
                continue

            # Only enter if you're actually walking *towards* the door.
            door_center = pygame.Vector2(
                (float(cx) + 0.5) * float(self.TILE_SIZE),
                (float(cy) + 0.5) * float(self.TILE_SIZE),
            )
            to_door = door_center - pygame.Vector2(self.player.pos)
            if to_door.length_squared() > 0.001:
                to_door = to_door.normalize()
                if float(move.dot(to_door)) < 0.25:
                    continue

            sb = self._special_building_for_door_tile(cx, cy)
            if sb is None:
                continue
            kind = str(getattr(sb, "kind", ""))
            if kind == "house":
                self._house_interior_enter(sb)
                return True
            if kind == "school":
                self._sch_interior_enter(sb)
                return True
        return False

    def _try_open_home_storage_world(self) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        home = getattr(self, "home_highrise_door", None)
        if home is None or not isinstance(home, tuple) or len(home) != 2:
            return False
        try:
            hx, hy = int(home[0]), int(home[1])
        except Exception:
            return False

        tx, ty = self._player_tile()
        found = self._multi_house_at(int(tx), int(ty))
        if found is None:
            return False
        _chunk, mh = found
        mh_tx0 = int(getattr(mh, "tx0", 0))
        mh_ty0 = int(getattr(mh, "ty0", 0))
        mh_w = int(getattr(mh, "w", 0))
        mh_h = int(getattr(mh, "h", 0))
        if not (mh_tx0 <= int(hx) < mh_tx0 + mh_w and mh_ty0 <= int(hy) < mh_ty0 + mh_h):
            return False

        home_floor = int(getattr(self, "home_highrise_floor", 0))
        cur_floor = int(getattr(mh, "cur_floor", 1))
        if home_floor <= 0 or int(cur_floor) != int(home_floor):
            return False

        # Ensure the home door + furniture exist (runs once).
        self._setup_home_highrise_world()

        candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
        for cx, cy in candidates:
            tid = int(self.world.get_tile(int(cx), int(cy)))
            if tid == int(self.T_FRIDGE):
                self._home_ui_open(storage_kind="fridge")
                return True
            if tid in (int(self.T_SHELF), int(self.T_CABINET)):
                self._home_ui_open(storage_kind="cabinet")
                return True
        return False

    def _try_rest_world_bed(self) -> bool:
        if getattr(self, "mount", None) is not None:
            return False

        # Pressing E again while sleeping gets you up.
        if str(getattr(self, "player_pose", "")) == "sleep" and str(getattr(self, "player_pose_space", "")) == "world":
            self._clear_player_pose()
            self._set_hint("醒来", seconds=0.8)
            return True

        tx, ty = self._player_tile()
        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        bed_tile: tuple[int, int] | None = None
        for cx, cy in candidates:
            if int(self.world.get_tile(int(cx), int(cy))) == int(self.T_BED):
                bed_tile = (int(cx), int(cy))
                break
        if bed_tile is None:
            return False

        # Find the whole bed block (usually 2 tiles) so the anchor is centered.
        bx, by = bed_tile
        seen: set[tuple[int, int]] = set()
        stack = [(int(bx), int(by))]
        cells: list[tuple[int, int]] = []
        while stack and len(cells) < 24:
            cx, cy = stack.pop()
            cx = int(cx)
            cy = int(cy)
            if (cx, cy) in seen:
                continue
            seen.add((cx, cy))
            if int(self.world.get_tile(int(cx), int(cy))) != int(self.T_BED):
                continue
            cells.append((cx, cy))
            stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])

        if not cells:
            return False
        min_x = min(int(p[0]) for p in cells)
        max_x = max(int(p[0]) for p in cells)
        min_y = min(int(p[1]) for p in cells)
        max_y = max(int(p[1]) for p in cells)

        ax = (float(min_x + max_x + 1) * float(self.TILE_SIZE)) * 0.5
        ay = (float(min_y + max_y + 1) * float(self.TILE_SIZE)) * 0.5

        self.player.stamina = 100.0
        self.player.morale = float(clamp(self.player.morale + 10.0, 0.0, 100.0))
        self._set_player_pose("sleep", space="world", anchor=(ax, ay), seconds=0.0)
        self._set_hint("躺床休息", seconds=1.1)
        return True

    def _try_use_pc_world(self) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        tx, ty = self._player_tile()
        sitting = str(getattr(self, "player_pose", "")) == "sit" and str(getattr(self, "player_pose_space", "")) == "world"
        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        hit: tuple[int, int] | None = None
        for cx, cy in candidates:
            if int(self.world.get_tile(int(cx), int(cy))) == int(self.T_PC):
                hit = (int(cx), int(cy))
                break
        if hit is None and sitting:
            best = None
            for dy2 in range(-2, 3):
                for dx2 in range(-2, 3):
                    if max(abs(int(dx2)), abs(int(dy2))) > 2:
                        continue
                    cx = int(tx + dx2)
                    cy = int(ty + dy2)
                    if int(self.world.get_tile(int(cx), int(cy))) != int(self.T_PC):
                        continue
                    key = (max(abs(int(dx2)), abs(int(dy2))), abs(int(dx2)) + abs(int(dy2)))
                    if best is None or key < best[0]:
                        best = (key, int(cx), int(cy))
            if best is not None:
                _key, cx, cy = best
                hit = (int(cx), int(cy))
        if hit is None:
            return False

        if not sitting:
            self._set_hint("坐下再用电脑", seconds=1.0)
            return True

        dx = int(hit[0]) - int(tx)
        dy = int(hit[1]) - int(ty)
        if abs(int(dx)) >= abs(int(dy)):
            if int(dx) > 0:
                self.player.dir = "right"
            elif int(dx) < 0:
                self.player.dir = "left"
        else:
            if int(dy) > 0:
                self.player.dir = "down"
            elif int(dy) < 0:
                self.player.dir = "up"

        self._toggle_world_map(open=True)
        self._set_hint("电脑：地图", seconds=1.0)
        return True

    def _try_watch_tv_world(self) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        tx, ty = self._player_tile()
        candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
        hit: tuple[int, int] | None = None
        for cx, cy in candidates:
            if int(self.world.get_tile(int(cx), int(cy))) == int(self.T_TV):
                hit = (int(cx), int(cy))
                break
        if hit is None:
            return False

        states = getattr(self, "world_tv_states", None)
        if not isinstance(states, dict):
            states = {}
            self.world_tv_states = states
        key = (int(hit[0]), int(hit[1]))
        states[key] = not bool(states.get(key, False))
        tv_now = bool(states.get(key, False))
        if tv_now:
            self.player.morale = float(clamp(float(self.player.morale) + 2.0, 0.0, 100.0))
        self._gallery_open = False
        self._set_hint("电视：开" if tv_now else "电视：关", seconds=1.0)
        return True

    def _try_sit_world(self) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False
        if str(getattr(self, "player_pose", "")) == "sleep" and str(getattr(self, "player_pose_space", "")) == "world":
            return False

        tx, ty = self._player_tile()
        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        chosen: tuple[int, int, int] | None = None
        for cx, cy in candidates:
            tid = int(self.world.get_tile(int(cx), int(cy)))
            if tid in (int(self.T_CHAIR), int(self.T_SOFA)):
                chosen = (int(cx), int(cy), int(tid))
                break
        if chosen is None:
            return False

        cx, cy, tid = chosen
        seen: set[tuple[int, int]] = set()
        stack = [(int(cx), int(cy))]
        cells: list[tuple[int, int]] = []
        while stack and len(cells) < 24:
            sx, sy = stack.pop()
            sx = int(sx)
            sy = int(sy)
            if (sx, sy) in seen:
                continue
            seen.add((sx, sy))
            if int(self.world.get_tile(int(sx), int(sy))) != int(tid):
                continue
            cells.append((sx, sy))
            stack.extend([(sx + 1, sy), (sx - 1, sy), (sx, sy + 1), (sx, sy - 1)])
        if not cells:
            cells = [(int(cx), int(cy))]

        min_x = min(int(p[0]) for p in cells)
        max_x = max(int(p[0]) for p in cells)
        min_y = min(int(p[1]) for p in cells)
        max_y = max(int(p[1]) for p in cells)
        ax = (float(min_x + max_x + 1) * float(self.TILE_SIZE)) * 0.5
        ay = (float(min_y + max_y + 1) * float(self.TILE_SIZE)) * 0.5

        # Prefer an adjacent walkable tile so sitting never snaps into walls/outside.
        prefer = pygame.Vector2(self.player.pos)
        seat_building = self._peek_building_at_tile(int(cx), int(cy))
        need_home = bool(self._tile_in_home_world(int(cx), int(cy)))
        cand: list[tuple[float, int, int]] = []
        for sx, sy in cells:
            for dx2, dy2 in (
                (1, 0),
                (-1, 0),
                (0, 1),
                (0, -1),
                (1, 1),
                (1, -1),
                (-1, 1),
                (-1, -1),
            ):
                nx = int(sx) + int(dx2)
                ny = int(sy) + int(dy2)
                if need_home and not self._tile_in_home_world(int(nx), int(ny)):
                    continue
                if seat_building is not None:
                    nb = self._peek_building_at_tile(int(nx), int(ny))
                    if nb is None or tuple(nb[:4]) != tuple(seat_building[:4]):
                        continue
                tid2 = int(self.world.get_tile(int(nx), int(ny)))
                if bool(self._tile_solid(int(tid2))):
                    continue
                cxp = (float(nx) + 0.5) * float(self.TILE_SIZE)
                cyp = (float(ny) + 0.5) * float(self.TILE_SIZE)
                d2 = float((cxp - prefer.x) ** 2 + (cyp - prefer.y) ** 2)
                cand.append((d2, int(nx), int(ny)))
        if cand:
            cand.sort(key=lambda v: v[0])
            nx, ny = int(cand[0][1]), int(cand[0][2])
            ax = (float(nx) + 0.5) * float(self.TILE_SIZE)
            ay = (float(ny) + 0.5) * float(self.TILE_SIZE)

        dx = int(cx) - int(tx)
        dy = int(cy) - int(ty)
        if abs(int(dx)) >= abs(int(dy)):
            if int(dx) > 0:
                self.player.dir = "right"
            elif int(dx) < 0:
                self.player.dir = "left"
        else:
            if int(dy) > 0:
                self.player.dir = "down"
            elif int(dy) < 0:
                self.player.dir = "up"

        self._set_player_pose("sit", space="world", anchor=(ax, ay), seconds=0.0)
        self._set_hint("坐下", seconds=0.9)
        return True

    def _try_unlock_near_door_world(self) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        tx, ty = self._player_tile()
        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        for cx, cy in candidates:
            t = int(self.world.get_tile(int(cx), int(cy)))
            if t not in (int(self.T_DOOR_LOCKED), int(self.T_DOOR_HOME_LOCKED)):
                continue

            # Door rules:
            # - The green home door: key_house only.
            # - Other locked doors: can't be unlocked here (unless they're broken).
            if int(t) == int(self.T_DOOR_LOCKED):
                self._set_hint("别人的门锁住了", seconds=1.2)
                return True
            if int(self.inventory.count("key_house")) <= 0:
                self._set_hint("需要我家的钥匙", seconds=1.1)
                return True
            has_key = int(self.inventory.count("key_house")) > 0
            has_crowbar = int(self.inventory.count("crowbar")) > 0
            if not (has_key or has_crowbar):
                self._set_hint("需要钥匙/撬棍", seconds=1.1)
                return True

            want = int(t)
            seen: set[tuple[int, int]] = set()
            stack = [(int(cx), int(cy))]
            cells: list[tuple[int, int]] = []
            while stack and len(cells) < 12:
                sx, sy = stack.pop()
                sx = int(sx)
                sy = int(sy)
                if (sx, sy) in seen:
                    continue
                seen.add((sx, sy))
                if int(self.world.get_tile(int(sx), int(sy))) != int(want):
                    continue
                cells.append((sx, sy))
                stack.extend([(sx + 1, sy), (sx - 1, sy), (sx, sy + 1), (sx, sy - 1)])
            if not cells:
                cells = [(int(cx), int(cy))]

            new_tid = int(self.T_DOOR) if int(want) == int(self.T_DOOR_LOCKED) else int(self.T_DOOR_HOME)
            for sx, sy in cells:
                self._world_set_tile(int(sx), int(sy), int(new_tid))
            self._set_hint("已解锁" if has_key else "撬开了", seconds=0.9)
            return True
        return False

    def _try_toggle_home_light_world(self) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        home_key = getattr(self, "home_highrise_world_key", None)
        if not (isinstance(home_key, tuple) and len(home_key) == 4):
            return False

        tx, ty = self._player_tile()
        hit = self._peek_building_at_tile(int(tx), int(ty))
        if hit is None:
            return False
        btx0, bty0, bw, bh = hit[:4]
        if (int(btx0), int(bty0), int(bw), int(bh)) != tuple(int(v) for v in home_key):
            return False
        home_floor = int(getattr(self, "home_highrise_world_floor", 0) or 0)
        if home_floor > 0:
            found = self._multi_house_at(int(tx), int(ty))
            if found is not None:
                _ch, mh = found
                if int(getattr(mh, "cur_floor", 1)) != int(home_floor):
                    return False

        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        for cx, cy in candidates:
            tid = int(self.world.get_tile(int(cx), int(cy)))
            if tid not in (int(self.T_LAMP), int(self.T_SWITCH)):
                continue
            self.home_light_on = not bool(getattr(self, "home_light_on", True))
            self._set_hint("开灯" if bool(self.home_light_on) else "关灯", seconds=0.8)
            return True
        return False

    def _try_refuel_at_gas_pump_world(self) -> bool:
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        tx, ty = self._player_tile()
        pump: tuple[int, int] | None = None
        for dy in (-1, 0, 1):
            for dx in (-1, 0, 1):
                cx = int(tx + dx)
                cy = int(ty + dy)
                if int(self.world.peek_tile(int(cx), int(cy))) == int(self.T_GAS_PUMP):
                    pump = (int(cx), int(cy))
                    break
            if pump is not None:
                break
        if pump is None:
            return False

        px, py = pump
        pump_pos = pygame.Vector2((float(px) + 0.5) * float(self.TILE_SIZE), (float(py) + 0.5) * float(self.TILE_SIZE))

        # Prefer the currently mounted vehicle; otherwise refuel a nearby personal vehicle.
        candidates: list[tuple[str, object]] = []
        if getattr(self, "mount", None) == "rv":
            candidates.append(("rv", self.rv))
        elif getattr(self, "mount", None) == "bike":
            mid = str(getattr(self.bike, "model_id", "bike"))
            if mid.startswith("moto"):
                candidates.append(("bike", self.bike))
        else:
            candidates.append(("rv", self.rv))
            mid = str(getattr(self.bike, "model_id", "bike"))
            if mid.startswith("moto"):
                candidates.append(("bike", self.bike))

        best: tuple[str, object] | None = None
        best_d2 = float(70.0 * 70.0)
        for kind, obj in candidates:
            pos = pygame.Vector2(getattr(obj, "pos", pygame.Vector2(0, 0)))
            d2 = float((pos - pump_pos).length_squared())
            if d2 <= best_d2:
                best = (str(kind), obj)
                best_d2 = d2

        if best is None:
            self._set_hint("把车开到加油机旁边", seconds=1.1)
            return True

        kind, target = best
        before = float(getattr(target, "fuel", 0.0))
        if before >= 99.9:
            self._set_hint("油已满", seconds=0.9)
            return True

        try:
            setattr(target, "fuel", 100.0)
        except Exception:
            return False

        if kind == "rv":
            self._rv_no_fuel_warned = False
        else:
            self._bike_no_fuel_warned = False
        self._set_hint("加油完成", seconds=0.9)
        return True

    def _interact_primary(self) -> None:
        # Primary interact key on the world map: stairs/pickup (doors are walk-into).
        if str(getattr(self, "player_pose", "")) == "sleep" and str(getattr(self, "player_pose_space", "")) == "world":
            self._clear_player_pose()
            self._set_hint("醒来", seconds=0.8)
            return
        if str(getattr(self, "player_pose", "")) == "sit" and str(getattr(self, "player_pose_space", "")) == "world":
            if self._try_use_pc_world():
                return
            if self._try_watch_tv_world():
                return
            self._clear_player_pose()
            self._set_hint("起身", seconds=0.8)
            return
        if self._try_exit_rv_world_interior():
            return
        if self._try_refuel_at_gas_pump_world():
            return
        if self._try_use_highrise_elevator():
            return
        if self._try_use_multi_house_stairs():
            return
        if self._try_unlock_near_door_world():
            return
        if self._try_toggle_home_light_world():
            return
        if self._try_open_home_storage_world():
            return
        if self._try_pickup(quiet=True):
            return
        if self._try_sit_world():
            return
        if self._try_rest_world_bed():
            return
        if self._try_use_pc_world():
            return
        if self._try_watch_tv_world():
            return
        self._try_pickup(quiet=False)

    def _player_in_home_world_building(self) -> bool:
        home_key = getattr(self, "home_highrise_world_key", None)
        if not (isinstance(home_key, tuple) and len(home_key) == 4):
            return False
        tx, ty = self._player_tile()
        hit = self._peek_building_at_tile(int(tx), int(ty))
        if hit is None:
            return False
        btx0, bty0, bw, bh = hit[:4]
        if (int(btx0), int(bty0), int(bw), int(bh)) != tuple(int(v) for v in home_key):
            return False
        home_floor = int(getattr(self, "home_highrise_world_floor", 0) or 0)
        if home_floor > 0:
            found = self._multi_house_at(int(tx), int(ty))
            if found is not None:
                _ch, mh = found
                if int(getattr(mh, "cur_floor", 1)) != int(home_floor):
                    return False
        return True

    def _toggle_home_move_mode(self) -> None:
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return
        if bool(getattr(self, "home_move_mode", False)):
            # Exit: restore any carried furniture.
            try:
                self._home_move_cancel()
            except Exception:
                pass
            self.home_move_mode = False
            self._set_hint("退出搬家具模式", seconds=0.8)
            return

        if getattr(self, "mount", None) is not None:
            self._set_hint("下车后才能搬家具", seconds=1.0)
            return
        if not self._player_in_home_world_building():
            self._set_hint("在自己家里才能搬家具", seconds=1.1)
            return

        # Clear poses so movement/interaction state is clean.
        if getattr(self, "player_pose", None) is not None and str(getattr(self, "player_pose_space", "")) == "world":
            self._clear_player_pose()

        tx, ty = self._player_tile()
        self.home_move_mode = True
        self.home_move_cursor = (int(tx), int(ty))
        self.home_move_carry = None
        self._set_hint("搬家具模式：方向键移动光标，E拾起/放下，Q取消，G退出", seconds=2.0)

    def _home_move_cursor_move(self, dx: int, dy: int) -> None:
        if not bool(getattr(self, "home_move_mode", False)):
            return
        cx, cy = getattr(self, "home_move_cursor", (0, 0))
        cx = int(cx)
        cy = int(cy)
        nx = int(cx + int(dx))
        ny = int(cy + int(dy))

        home_key = getattr(self, "home_highrise_world_key", None)
        if isinstance(home_key, tuple) and len(home_key) == 4:
            hit = self._peek_building_at_tile(int(nx), int(ny))
            if hit is None:
                return
            btx0, bty0, bw, bh = hit[:4]
            if (int(btx0), int(bty0), int(bw), int(bh)) != tuple(int(v) for v in home_key):
                return
        self.home_move_cursor = (int(nx), int(ny))

    def _home_move_cancel(self) -> None:
        carry = getattr(self, "home_move_carry", None)
        if not isinstance(carry, dict):
            self.home_move_carry = None
            return
        tid = int(carry.get("tid", 0))
        origin = carry.get("origin_cells", [])
        if isinstance(origin, list):
            for tx, ty in origin:
                try:
                    self._world_set_tile(int(tx), int(ty), int(tid))
                except Exception:
                    pass
            hp = carry.get("hp")
            if hp is not None and origin:
                try:
                    anchor = min((int(v[0]), int(v[1])) for v in origin if isinstance(v, tuple) and len(v) == 2)
                    self.world_furniture_hp[self._world_furniture_hp_key(int(anchor[0]), int(anchor[1]))] = int(hp)
                except Exception:
                    pass
        self.home_move_carry = None

    def _home_move_interact(self) -> None:
        if not bool(getattr(self, "home_move_mode", False)):
            return
        cur = getattr(self, "home_move_cursor", (0, 0))
        cx, cy = int(cur[0]), int(cur[1])

        movable = {
            int(self.T_TABLE),
            int(self.T_SHELF),
            int(self.T_CABINET),
            int(self.T_BED),
            int(self.T_SOFA),
            int(self.T_FRIDGE),
            int(self.T_TV),
            int(self.T_CHAIR),
            int(self.T_PC),
            int(self.T_LAMP),
            int(self.T_SWITCH),
            int(self.T_TOILET),
            int(self.T_SINK),
        }

        carry = getattr(self, "home_move_carry", None)
        if not isinstance(carry, dict):
            tid = int(self.world.get_tile(int(cx), int(cy)))
            if tid not in movable:
                self._set_hint("这里没有可搬动的家具", seconds=0.9)
                return

            # Pick up a connected cluster (supports 2-tile beds/sofas/PC desks).
            seen: set[tuple[int, int]] = set()
            stack = [(int(cx), int(cy))]
            cells: list[tuple[int, int]] = []
            while stack and len(cells) < 12:
                x, y = stack.pop()
                x = int(x)
                y = int(y)
                if (x, y) in seen:
                    continue
                seen.add((x, y))
                if int(self.world.get_tile(int(x), int(y))) != int(tid):
                    continue
                cells.append((int(x), int(y)))
                stack.extend([(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)])

            if not cells:
                self._set_hint("这里没有可搬动的家具", seconds=0.9)
                return

            offsets = [(int(x - cx), int(y - cy)) for x, y in cells]
            hp = None
            try:
                anchor = min(cells)
                hp_key = self._world_furniture_hp_key(int(anchor[0]), int(anchor[1]))
                hp = self.world_furniture_hp.pop(hp_key, None)
                for x, y in cells:
                    self.world_furniture_hp.pop(self._world_furniture_hp_key(int(x), int(y)), None)
            except Exception:
                hp = None
            carry: dict[str, object] = {"tid": int(tid), "offsets": offsets, "origin_cells": list(cells), "space": "home"}
            if hp is not None:
                carry["hp"] = int(hp)
            self.home_move_carry = carry
            for x, y in cells:
                self._world_set_tile(int(x), int(y), int(self.T_FLOOR))
            self._set_hint("已拾起（E放下 / Q取消）", seconds=1.1)
            return

        # Place.
        tid = int(carry.get("tid", 0))
        offsets = carry.get("offsets", [])
        if not isinstance(offsets, list) or tid not in movable:
            self._home_move_cancel()
            return

        target_cells: list[tuple[int, int]] = [(int(cx + int(dx)), int(cy + int(dy))) for dx, dy in offsets]
        home_key = getattr(self, "home_highrise_world_key", None)
        if not (isinstance(home_key, tuple) and len(home_key) == 4):
            self._home_move_cancel()
            return

        for tx, ty in target_cells:
            hit = self._peek_building_at_tile(int(tx), int(ty))
            if hit is None:
                self._set_hint("放不下", seconds=0.8)
                return
            btx0, bty0, bw, bh = hit[:4]
            if (int(btx0), int(bty0), int(bw), int(bh)) != tuple(int(v) for v in home_key):
                self._set_hint("放不下", seconds=0.8)
                return
            if int(self.world.get_tile(int(tx), int(ty))) != int(self.T_FLOOR):
                self._set_hint("放不下", seconds=0.8)
                return

        for tx, ty in target_cells:
            self._world_set_tile(int(tx), int(ty), int(tid))
        hp = carry.get("hp")
        if hp is not None:
            try:
                anchor = min(target_cells) if target_cells else (int(cx), int(cy))
                self.world_furniture_hp[self._world_furniture_hp_key(int(anchor[0]), int(anchor[1]))] = int(hp)
            except Exception:
                pass
        self.home_move_carry = None
        self._set_hint("已放下", seconds=0.8)

    def _handle_home_move_mode_key(self, key: int) -> None:
        if not bool(getattr(self, "home_move_mode", False)):
            return
        key = int(key)
        if key in (pygame.K_ESCAPE, pygame.K_g):
            self._toggle_home_move_mode()
            return
        if key in (pygame.K_q,):
            self._home_move_cancel()
            self._set_hint("已取消", seconds=0.8)
            return
        if key in (pygame.K_e, pygame.K_RETURN, pygame.K_SPACE):
            self._home_move_interact()
            return
        if key in (pygame.K_LEFT, pygame.K_a):
            self._home_move_cursor_move(-1, 0)
            return
        if key in (pygame.K_RIGHT, pygame.K_d):
            self._home_move_cursor_move(1, 0)
            return
        if key in (pygame.K_UP, pygame.K_w):
            self._home_move_cursor_move(0, -1)
            return
        if key in (pygame.K_DOWN, pygame.K_s):
            self._home_move_cursor_move(0, 1)
            return

    def _world_furniture_carry_active(self) -> bool:
        return isinstance(getattr(self, "home_move_carry", None), dict) and not bool(getattr(self, "home_move_mode", False))

    def _world_furniture_hp_key(self, tx: int, ty: int) -> tuple[object, ...]:
        tx = int(tx)
        ty = int(ty)
        if bool(self._tile_in_rv_world(int(tx), int(ty))):
            key = getattr(self, "_rv_world_int_active_key", None)
            if isinstance(key, tuple) and len(key) == 4:
                try:
                    rx0, ry0, rw, rh = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
                except Exception:
                    rx0, ry0, rw, rh = (0, 0, 0, 0)
                return ("rv", rx0, ry0, rw, rh, tx, ty)
            return ("rv", tx, ty)

        found = self._multi_house_at(int(tx), int(ty))
        if found is not None:
            _ch, mh = found
            try:
                bkey = (
                    int(getattr(mh, "tx0", 0)),
                    int(getattr(mh, "ty0", 0)),
                    int(getattr(mh, "w", 0)),
                    int(getattr(mh, "h", 0)),
                    int(getattr(mh, "cur_floor", 1)),
                )
            except Exception:
                bkey = (0, 0, 0, 0, 1)
            return ("mh",) + tuple(bkey) + (tx, ty)

        return ("world", tx, ty)

    def _world_furniture_connected_cells(self, tx: int, ty: int, tid: int, *, limit: int = 24) -> list[tuple[int, int]]:
        tx = int(tx)
        ty = int(ty)
        tid = int(tid)
        limit = int(limit)
        seen: set[tuple[int, int]] = set()
        stack = [(int(tx), int(ty))]
        cells: list[tuple[int, int]] = []
        while stack and len(cells) < int(limit):
            cx, cy = stack.pop()
            cx = int(cx)
            cy = int(cy)
            if (cx, cy) in seen:
                continue
            seen.add((cx, cy))
            if int(self.world.get_tile(int(cx), int(cy))) != int(tid):
                continue
            cells.append((int(cx), int(cy)))
            stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])
        if not cells:
            cells = [(int(tx), int(ty))]
        return cells

    def _world_guess_base_tile_under_furniture(self, tx: int, ty: int) -> int:
        tx = int(tx)
        ty = int(ty)
        if bool(self._tile_in_rv_world(int(tx), int(ty))):
            base = getattr(self, "_rv_world_floor_base", None)
            if isinstance(base, dict):
                bt = base.get((int(tx), int(ty)))
                if bt is not None:
                    return int(bt)
            return int(self.T_FLOOR)

        counts: dict[int, int] = {}
        ignore = set(int(t) for t in self._WORLD_FURNITURE_HP_DEFAULTS.keys())
        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)):
            tid = int(self.world.get_tile(int(tx + dx), int(ty + dy)))
            if int(tid) in ignore:
                continue
            if bool(self._tile_solid(int(tid))):
                continue
            counts[int(tid)] = int(counts.get(int(tid), 0)) + 1
        if not counts:
            return int(self.T_FLOOR)
        best_tid = int(self.T_FLOOR)
        best_n = -1
        for tid, n in counts.items():
            if int(n) > int(best_n):
                best_tid = int(tid)
                best_n = int(n)
        return int(best_tid)

    def _world_furniture_damage_at(self, tx: int, ty: int, *, dmg: int, impact_dir: pygame.Vector2) -> bool:
        tx = int(tx)
        ty = int(ty)
        dmg = int(dmg)
        if dmg <= 0:
            return False
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        tid = int(self.world.get_tile(int(tx), int(ty)))
        if int(tid) not in self._WORLD_FURNITURE_HP_DEFAULTS:
            return False

        # HP is tracked per connected block (beds/sofas/PC desks may be 2 tiles).
        cells = self._world_furniture_connected_cells(int(tx), int(ty), int(tid), limit=24)
        anchor = min(cells) if cells else (int(tx), int(ty))
        key = self._world_furniture_hp_key(int(anchor[0]), int(anchor[1]))
        cur = int(self.world_furniture_hp.get(key, int(self._WORLD_FURNITURE_HP_DEFAULTS.get(int(tid), 20))))
        cur = int(cur) - int(dmg)
        if cur > 0:
            self.world_furniture_hp[key] = int(cur)
            self._spawn_hit_fx(pygame.Vector2((tx + 0.5) * self.TILE_SIZE, (ty + 0.5) * self.TILE_SIZE), dir=pygame.Vector2(impact_dir))
            self.app.play_sfx("hit")
            return True

        # Break: clear the whole connected block so 2-tile furniture doesn't split.
        center = pygame.Vector2((tx + 0.5) * self.TILE_SIZE, (ty + 0.5) * self.TILE_SIZE)
        try:
            self.world_furniture_hp.pop(key, None)
        except Exception:
            pass
        for cx, cy in cells:
            base_tid = int(self._world_guess_base_tile_under_furniture(int(cx), int(cy)))
            try:
                self._world_set_tile(int(cx), int(cy), int(base_tid))
            except Exception:
                pass
            # Defensive: clear any stale per-cell keys too.
            try:
                self.world_furniture_hp.pop(self._world_furniture_hp_key(int(cx), int(cy)), None)
            except Exception:
                pass

        # Drops: simple materials.
        try:
            extra = max(0, int(len(cells)) - 1)
            if int(tid) in self._WORLD_FURNITURE_WOOD_TILES:
                self._drop_world_item(center, "wood", int(clamp(random.randint(1, 2) + extra, 1, 6)))
            elif int(tid) in self._WORLD_FURNITURE_METAL_TILES:
                self._drop_world_item(center, "scrap", int(clamp(random.randint(1, 2) + extra, 1, 6)))
        except Exception:
            pass

        self._spawn_hit_fx(center, dir=pygame.Vector2(impact_dir))
        self.app.play_sfx("hit")
        self._set_hint("家具被砸坏了", seconds=0.7)
        return True

    def _world_context_action(self, action: str) -> None:
        action = str(action)
        target = getattr(self, "world_ctx_target", None)
        if not (isinstance(target, tuple) and len(target) == 3):
            return
        tx, ty, _tid = int(target[0]), int(target[1]), int(target[2])

        if action == "sit":
            self._try_sit_world()
            return
        if action == "sleep":
            self._try_rest_world_bed()
            return
        if action == "open":
            self._try_open_home_storage_world()
            return
        if action == "light":
            self._try_toggle_home_light_world()
            return
        if action == "lamp_cfg":
            self.lamp_cfg_open = True
            self.lamp_cfg_target = (int(tx), int(ty))
            self.lamp_cfg_rects = []
            # Close the context menu so it doesn't overlap.
            self.world_ctx_open = False
            self.world_ctx_target = None
            self.world_ctx_rects = []
            return
        if action == "tv":
            self._try_watch_tv_world()
            return
        if action == "drive":
            self._rv_world_try_drive_from_anywhere()
            return
        if action == "water":
            if not self._fill_sink_water_world_at(int(tx), int(ty)):
                self._set_hint("靠近水龙头", seconds=0.9)
            return
        if action == "pc":
            if not (str(getattr(self, "player_pose", "")) == "sit" and str(getattr(self, "player_pose_space", "")) == "world"):
                self._try_sit_world()
            self._try_use_pc_world()
            return
        if action == "pee":
            if not self._use_toilet_world_at(int(tx), int(ty), kind="pee"):
                self._set_hint("靠近马桶", seconds=0.9)
            return
        if action == "poop":
            if not self._use_toilet_world_at(int(tx), int(ty), kind="poop"):
                self._set_hint("靠近马桶", seconds=0.9)
            return
        if action == "move":
            if self._home_furniture_pickup_at(int(tx), int(ty)):
                # Close the context menu immediately so clicks place furniture.
                self.world_ctx_open = False
                self.world_ctx_target = None
                self.world_ctx_rects = []
            else:
                self._set_hint("不能搬", seconds=0.9)
            return

    def _use_toilet_world_at(self, tx: int, ty: int, *, kind: str) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        tx = int(tx)
        ty = int(ty)
        ptx, pty = self._player_tile()
        if abs(int(tx) - int(ptx)) > 1 or abs(int(ty) - int(pty)) > 1:
            return False
        in_home = bool(self._tile_in_home_world(int(tx), int(ty)))
        in_rv = bool(self._tile_in_rv_world(int(tx), int(ty)))
        if not (in_home or in_rv):
            return False
        if int(self.world.get_tile(int(tx), int(ty))) != int(self.T_TOILET):
            return False

        kind = str(kind)
        if kind not in ("pee", "poop"):
            kind = "pee"

        # Already busy.
        if isinstance(getattr(self, "toilet_task", None), dict):
            return True

        # Find a nearby walkable tile to sit (never snap outside the building).
        toilet_building = self._peek_building_at_tile(int(tx), int(ty))
        prefer = pygame.Vector2(self.player.pos)
        best: tuple[float, int, int] | None = None
        for dx2, dy2 in (
            (0, 1),
            (0, -1),
            (1, 0),
            (-1, 0),
            (1, 1),
            (1, -1),
            (-1, 1),
            (-1, -1),
        ):
            nx = int(tx + dx2)
            ny = int(ty + dy2)
            if not self._tile_in_home_world(int(nx), int(ny)):
                continue
            if toilet_building is not None:
                nb = self._peek_building_at_tile(int(nx), int(ny))
                if nb is None or tuple(nb[:4]) != tuple(toilet_building[:4]):
                    continue
            tid2 = int(self.world.get_tile(int(nx), int(ny)))
            if bool(self._tile_solid(int(tid2))):
                continue
            cxp = (float(nx) + 0.5) * float(self.TILE_SIZE)
            cyp = (float(ny) + 0.5) * float(self.TILE_SIZE)
            d2 = float((cxp - prefer.x) ** 2 + (cyp - prefer.y) ** 2)
            if best is None or d2 < float(best[0]):
                best = (d2, int(nx), int(ny))
        if best is None:
            return False

        _d2, sx, sy = best
        ax = (float(sx) + 0.5) * float(self.TILE_SIZE)
        ay = (float(sy) + 0.5) * float(self.TILE_SIZE)

        # Face the toilet.
        fdx = int(tx) - int(sx)
        fdy = int(ty) - int(sy)
        if abs(int(fdx)) >= abs(int(fdy)):
            if int(fdx) > 0:
                self.player.dir = "right"
            elif int(fdx) < 0:
                self.player.dir = "left"
        else:
            if int(fdy) > 0:
                self.player.dir = "down"
            elif int(fdy) < 0:
                self.player.dir = "up"

        self.player.vel.update(0, 0)
        self._set_player_pose("sit", space="world", anchor=(ax, ay), seconds=0.0)

        total = 4.0 if kind == "poop" else 2.4
        self.toilet_task = {"kind": kind, "total": float(total), "left": float(total)}
        return True

    def _fill_sink_water_world_at(self, tx: int, ty: int) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False

        tx = int(tx)
        ty = int(ty)
        ptx, pty = self._player_tile()
        if abs(int(tx) - int(ptx)) > 1 or abs(int(ty) - int(pty)) > 1:
            return False
        if not self._tile_in_home_world(int(tx), int(ty)):
            return False
        if int(self.world.get_tile(int(tx), int(ty))) != int(self.T_SINK):
            return False

        held = getattr(self, "held_item", None)
        if isinstance(held, HardcoreSurvivalState._ItemStack) and str(getattr(held, "item_id", "")) == "cup":
            held.item_id = "cup_water"
            held.qty = 1
            self._speech_say("接了一杯水", seconds=1.1)
            return True

        inv = getattr(self, "inventory", None)
        if not isinstance(inv, HardcoreSurvivalState._Inventory):
            return False

        if int(inv.count("cup")) <= 0:
            self._set_hint("需要杯子（柜子里有）", seconds=1.2)
            return True

        removed = int(inv.remove("cup", 1))
        if removed <= 0:
            self._set_hint("需要杯子（柜子里有）", seconds=1.2)
            return True
        left = int(inv.add("cup_water", 1, self._ITEMS))
        if left > 0:
            inv.add("cup", 1, self._ITEMS)
            self._set_hint("背包满了", seconds=1.0)
            return True

        self._speech_say("接了一杯水", seconds=1.1)
        return True

    def _update_toilet_task(self, dt: float) -> None:
        task = getattr(self, "toilet_task", None)
        if not isinstance(task, dict):
            return
        if getattr(self, "mount", None) is not None:
            self.toilet_task = None
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            self.toilet_task = None
            return

        if str(getattr(self, "player_pose", "")) != "sit" or str(getattr(self, "player_pose_space", "")) != "world":
            # Cancelled (player moved / left pose).
            self.toilet_task = None
            return

        left = float(task.get("left", 0.0))
        left = max(0.0, left - float(dt))
        task["left"] = float(left)
        if left > 0.0:
            return

        kind = str(task.get("kind", "pee"))
        self.toilet_task = None
        self._clear_player_pose()

        if kind == "poop":
            self.player.morale = float(clamp(float(self.player.morale) + 1.0, 0.0, 100.0))
            self._speech_say("拉屎完成", seconds=1.2)
        else:
            self.player.morale = float(clamp(float(self.player.morale) + 0.5, 0.0, 100.0))
            self._speech_say("小便完成", seconds=1.2)

    def _handle_rv_mode_buttons_mouse(self, event: pygame.event.Event) -> bool:
        rects = getattr(self, "_rv_mode_btn_rects", None)
        if not isinstance(rects, dict) or not rects:
            return False
        if not hasattr(event, "pos"):
            return False
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return False
        mx, my = int(internal[0]), int(internal[1])
        btn = int(getattr(event, "button", 0))
        if btn != 1:
            return False

        for key, r in rects.items():
            if not isinstance(r, pygame.Rect):
                continue
            if not r.collidepoint(mx, my):
                continue
            key = str(key)

            if key == "life":
                if str(getattr(self.rv, "model_id", "rv")) != "rv":
                    self._set_hint("只有房车能进内部", seconds=1.0)
                    return True
                if bool(getattr(self, "rv_world_interior", False)):
                    return True
                if getattr(self, "mount", None) == "rv":
                    if abs(float(getattr(self.rv, "speed", 0.0))) > 1.0:
                        self._set_hint("先停车", seconds=0.9)
                        return True
                if not self._can_access_rv():
                    self._set_hint("靠近房车", seconds=0.9)
                    return True
                self._rv_world_interior_enter()
                return True

            if key == "drive":
                if getattr(self, "mount", None) == "rv":
                    return True
                if bool(getattr(self, "rv_world_interior", False)):
                    self._rv_world_try_drive_from_anywhere()
                    return True
                if not self._can_access_rv():
                    self._set_hint("靠近房车", seconds=0.9)
                    return True
                if int(self.inventory.count("key_rv")) <= 0:
                    self._set_hint("需要车钥匙", seconds=1.1)
                    return True
                self.mount = "rv"
                self.rv.vel.update(0, 0)
                self.rv.speed = 0.0
                self.player.pos.update(self.rv.pos)
                self.player.vel.update(0, 0)
                self._set_hint("开始驾驶", seconds=0.9)
                return True

            return True

        return False

    def _handle_world_context_menu_mouse(self, event: pygame.event.Event) -> bool:
        if bool(getattr(self, "home_move_mode", False)):
            return False
        if self._world_furniture_carry_active():
            return False
        if not bool(getattr(self, "world_ctx_open", False)):
            return False
        rects = getattr(self, "world_ctx_rects", None)
        if not isinstance(rects, list) or not rects:
            return False
        if not hasattr(event, "pos"):
            return False
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return False
        mx, my = int(internal[0]), int(internal[1])
        btn = int(getattr(event, "button", 0))
        if btn == 3:
            self.world_ctx_open = False
            self.world_ctx_target = None
            self.world_ctx_rects = []
            return True
        if btn != 1:
            return True
        for r, action in rects:
            if isinstance(r, pygame.Rect) and r.collidepoint(mx, my):
                self._world_context_action(str(action))
                self.world_ctx_open = False
                self.world_ctx_target = None
                self.world_ctx_rects = []
                return True
        # Click outside closes the menu (and consumes the click so it doesn't fire).
        self.world_ctx_open = False
        self.world_ctx_target = None
        self.world_ctx_rects = []
        return True

    def _handle_world_furniture_carry_mouse(self, event: pygame.event.Event) -> bool:
        if not self._world_furniture_carry_active():
            return False
        if not hasattr(event, "pos"):
            return False
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return False
        mx, my = int(internal[0]), int(internal[1])
        btn = int(getattr(event, "button", 0))
        if btn == 3:
            self._home_move_cancel()
            self._set_hint("已取消", seconds=0.8)
            return True
        if btn != 1:
            return True

        cam_x, cam_y = getattr(self, "_last_cam_draw", (int(getattr(self, "cam_x", 0)), int(getattr(self, "cam_y", 0))))
        tx, ty = self._screen_to_world_tile(int(mx), int(my), int(cam_x), int(cam_y))
        mods = int(pygame.key.get_mods())
        if (mods & pygame.KMOD_SHIFT) != 0:
            if self._world_furniture_throw_to(int(tx), int(ty)):
                return True
        if self._home_furniture_place_at(int(tx), int(ty)):
            return True
        self._set_hint("放不下", seconds=0.8)
        return True

    def _world_set_tile(self, tx: int, ty: int, tile_id: int) -> None:
        tx = int(tx)
        ty = int(ty)
        tile_id = int(tile_id)
        chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
        base_tx = int(chunk.cx) * int(self.CHUNK_SIZE)
        base_ty = int(chunk.cy) * int(self.CHUNK_SIZE)
        lx = int(tx - base_tx)
        ly = int(ty - base_ty)
        if not (0 <= lx < int(self.CHUNK_SIZE) and 0 <= ly < int(self.CHUNK_SIZE)):
            return
        chunk.tiles[int(ly) * int(self.CHUNK_SIZE) + int(lx)] = int(tile_id)

        # Keep multi-floor snapshots in sync so the change survives floor switches.
        found = self._multi_house_at(int(tx), int(ty))
        if found is None:
            return
        _ch, mh = found
        cur_floor = int(getattr(mh, "cur_floor", 1))
        tiles = mh.floor_tiles.get(int(cur_floor))
        if not isinstance(tiles, list):
            return
        w = int(getattr(mh, "w", 0))
        h = int(getattr(mh, "h", 0))
        if w <= 0 or h <= 0 or len(tiles) != int(w) * int(h):
            return
        mx = int(tx - int(getattr(mh, "tx0", 0)))
        my = int(ty - int(getattr(mh, "ty0", 0)))
        if not (0 <= mx < w and 0 <= my < h):
            return
        tiles[int(my) * int(w) + int(mx)] = int(tile_id)

    def _toggle_door_lock(self) -> None:
        if getattr(self, "mount", None) is not None:
            self._set_hint("下车再锁门", seconds=1.1)
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return

        if int(self.inventory.count("key_house")) <= 0:
            self._set_hint("需要钥匙", seconds=1.1)
            return

        tx, ty = self._player_tile()
        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        chosen: tuple[int, int, int] | None = None
        for cx, cy in candidates:
            t = int(self.world.get_tile(int(cx), int(cy)))
            if t in (int(self.T_DOOR_HOME), int(self.T_DOOR_HOME_LOCKED)):
                chosen = (int(cx), int(cy), int(t))
                break
        if chosen is None:
            self._set_hint("附近没有我家的门", seconds=1.0)
            return
        cx, cy, t = chosen

        home_tiles = getattr(self, "home_highrise_world_home_door_tiles", None)
        if isinstance(home_tiles, list) and home_tiles:
            home_set = {(int(p[0]), int(p[1])) for p in home_tiles if isinstance(p, tuple) and len(p) == 2}
            if home_set and (int(cx), int(cy)) not in home_set:
                self._set_hint("不是我家的门", seconds=1.0)
                return
        group = (int(self.T_DOOR_HOME), int(self.T_DOOR_HOME_LOCKED))
        lock_tid = int(self.T_DOOR_HOME_LOCKED)
        unlock_tid = int(self.T_DOOR_HOME)
        is_locked = int(t) == int(self.T_DOOR_HOME_LOCKED)

        seen: set[tuple[int, int]] = set()
        stack = [(int(cx), int(cy))]
        cells: list[tuple[int, int]] = []
        while stack and len(cells) < 12:
            sx, sy = stack.pop()
            sx = int(sx)
            sy = int(sy)
            if (sx, sy) in seen:
                continue
            seen.add((sx, sy))
            if int(self.world.get_tile(int(sx), int(sy))) not in group:
                continue
            cells.append((sx, sy))
            stack.extend([(sx + 1, sy), (sx - 1, sy), (sx, sy + 1), (sx, sy - 1)])
        if not cells:
            cells = [(int(cx), int(cy))]

        if not is_locked:
            # Don't lock the doorway if the player is standing on it.
            prect = self.player.rect_at(self.player.pos)
            ts = int(self.TILE_SIZE)
            for sx, sy in cells:
                door_rect = pygame.Rect(int(sx) * ts, int(sy) * ts, ts, ts)
                if prect.colliderect(door_rect):
                    self._set_hint("离开门口", seconds=1.0)
                    return
            for sx, sy in cells:
                self._world_set_tile(int(sx), int(sy), int(lock_tid))
            self._set_hint("已上锁", seconds=0.9)
            return

        for sx, sy in cells:
            self._world_set_tile(int(sx), int(sy), int(unlock_tid))
        self._set_hint("已解锁", seconds=0.9)

    def _toggle_barricade(self) -> None:
        if getattr(self, "mount", None) is not None:
            self._set_hint("下车后再封门", seconds=1.1)
            return
        tx, ty = self._player_tile()
        candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
        chosen: tuple[int, int, int] | None = None
        for cx, cy in candidates:
            t = int(self.world.get_tile(int(cx), int(cy)))
            if t in (
                int(self.T_DOOR),
                int(self.T_DOOR_HOME),
                int(self.T_DOOR_LOCKED),
                int(self.T_DOOR_HOME_LOCKED),
                int(self.T_BARRICADE),
            ):
                chosen = (int(cx), int(cy), int(t))
                break
        if chosen is None:
            self._set_hint("附近没有门", seconds=1.0)
            return
        cx, cy, t = chosen

        if t in (int(self.T_DOOR), int(self.T_DOOR_HOME), int(self.T_DOOR_LOCKED), int(self.T_DOOR_HOME_LOCKED)):
            need_plank = 1
            need_nails = 4
            if int(self.inventory.count("plank")) < int(need_plank) or int(self.inventory.count("nails")) < int(need_nails):
                self._set_hint("需要木板+钉子", seconds=1.2)
                return
            self.inventory.remove("plank", int(need_plank))
            self.inventory.remove("nails", int(need_nails))
            self._world_set_tile(int(cx), int(cy), int(self.T_BARRICADE))
            self._set_hint("封门", seconds=0.9)
            return

        # Remove barricade.
        if int(self.inventory.count("crowbar")) <= 0 and int(self.inventory.count("hammer")) <= 0:
            self._set_hint("需要撬棍/锤子", seconds=1.2)
            return
        self._world_set_tile(int(cx), int(cy), int(self.T_DOOR))
        # Recover a little material.
        self.inventory.add("nails", 2, self._ITEMS)
        self.inventory.add("plank", 1, self._ITEMS)
        self._set_hint("拆除封门", seconds=0.9)

    def _try_use_highrise_elevator(self) -> bool:
        if getattr(self, "world_elevator_ui_open", False):
            return True
        if getattr(self, "mount", None) is not None:
            return False

        tx, ty = self._player_tile()
        candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
        chosen: tuple[int, int] | None = None
        for cx, cy in candidates:
            if int(self.world.get_tile(int(cx), int(cy))) == int(self.T_ELEVATOR):
                chosen = (int(cx), int(cy))
                break
        if chosen is None:
            return False
        cx, cy = chosen

        found = self._multi_house_at(int(cx), int(cy))
        if found is None:
            return False
        chunk, mh = found

        # Only high-rises use elevators on the world map.
        style = 0
        tx0 = int(getattr(mh, "tx0", 0))
        ty0 = int(getattr(mh, "ty0", 0))
        bw = int(getattr(mh, "w", 0))
        bh = int(getattr(mh, "h", 0))
        for b in getattr(chunk, "buildings", []):
            if int(b[0]) == int(tx0) and int(b[1]) == int(ty0) and int(b[2]) == int(bw) and int(b[3]) == int(bh):
                roof_kind = int(b[4]) if len(b) > 4 else 0
                style, _var = self._building_roof_style_var(int(roof_kind))
                break
        if int(style) != 6:
            return False

        floors = int(max(1, int(getattr(mh, "floors", 1))))
        if floors <= 1:
            self._set_hint("只有一层", seconds=1.0)
            return True

        self._world_elevator_open(chunk, mh, elev_tile=(int(cx), int(cy)))
        return True

    def _multi_house_at(self, tx: int, ty: int) -> tuple["_Chunk", "_MultiHouse"] | None:
        tx = int(tx)
        ty = int(ty)
        chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
        for mh in getattr(chunk, "multi_houses", []):
            if int(mh.tx0) <= tx < int(mh.tx0) + int(mh.w) and int(mh.ty0) <= ty < int(mh.ty0) + int(mh.h):
                return chunk, mh
        return None

    def _multi_house_apply_floor(self, chunk: "_Chunk", mh: "_MultiHouse") -> None:
        tiles = mh.floor_tiles.get(int(getattr(mh, "cur_floor", 1)))
        if not tiles:
            return
        base_tx = int(chunk.cx) * int(self.CHUNK_SIZE)
        base_ty = int(chunk.cy) * int(self.CHUNK_SIZE)
        ox = int(getattr(mh, "tx0", 0)) - int(base_tx)
        oy = int(getattr(mh, "ty0", 0)) - int(base_ty)
        if not (0 <= ox < int(self.CHUNK_SIZE) and 0 <= oy < int(self.CHUNK_SIZE)):
            return
        w = int(getattr(mh, "w", 0))
        h = int(getattr(mh, "h", 0))
        cs = int(self.CHUNK_SIZE)
        if w <= 0 or h <= 0:
            return
        if ox + w > cs or oy + h > cs:
            return
        for yy in range(int(h)):
            row_off = int((oy + yy) * cs + ox)
            src_off = int(yy * w)
            for xx in range(int(w)):
                chunk.tiles[int(row_off + xx)] = int(tiles[int(src_off + xx)])

    def _setup_home_highrise_world(self) -> None:
        # One-time furnishing for the player's high-rise home on the world map.
        # If an existing save predates features (e.g. toilet), we patch in the
        # missing pieces without re-randomizing the whole layout.
        already = bool(getattr(self, "_home_highrise_world_setup_done", False))
        home = getattr(self, "home_highrise_door", None)
        if not isinstance(home, tuple) or len(home) != 2:
            return
        try:
            hx, hy = int(home[0]), int(home[1])
        except Exception:
            return

        found = self._multi_house_at(int(hx), int(hy))
        if found is None:
            return
        chunk, mh = found

        tx0 = int(getattr(mh, "tx0", 0))
        ty0 = int(getattr(mh, "ty0", 0))
        bw = int(getattr(mh, "w", 0))
        bh = int(getattr(mh, "h", 0))
        if bw <= 0 or bh <= 0:
            return

        # Confirm this multi-house is a high-rise building footprint.
        style = 0
        for b in getattr(chunk, "buildings", []):
            if int(b[0]) == int(tx0) and int(b[1]) == int(ty0) and int(b[2]) == int(bw) and int(b[3]) == int(bh):
                roof_kind = int(b[4]) if len(b) > 4 else 0
                style, _var = self._building_roof_style_var(int(roof_kind))
                break
        if int(style) != 6:
            return

        floors = int(max(1, int(getattr(mh, "floors", 1))))
        floors = int(min(int(floors), int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
        if floors <= 1:
            return

        home_floor = int(getattr(self, "home_highrise_floor", 0))
        if home_floor <= 0:
            return
        home_floor = int(clamp(int(home_floor), 1, int(floors)))

        base_tiles = mh.floor_tiles.get(int(home_floor))
        if not isinstance(base_tiles, list):
            return
        w = int(bw)
        h = int(bh)
        if len(base_tiles) != int(w) * int(h):
            return

        # IMPORTANT: upper floors may share the same list instance; copy so only the home floor is furnished.
        tiles = list(int(t) for t in base_tiles)
        mh.floor_tiles[int(home_floor)] = tiles

        def get(x: int, y: int) -> int:
            return int(tiles[int(y) * int(w) + int(x)])

        def set_t(x: int, y: int, tid: int) -> None:
            tiles[int(y) * int(w) + int(x)] = int(tid)

        def has_toilet() -> bool:
            return any(int(t) == int(self.T_TOILET) for t in tiles)

        # Identify unit-entry doors by looking at the public lobby/corridor region.
        # This stays stable even after we add interior room doors for the home layout.
        door_like = {
            int(self.T_DOOR),
            int(self.T_DOOR_HOME),
            int(self.T_DOOR_LOCKED),
            int(self.T_DOOR_HOME_LOCKED),
            int(self.T_DOOR_BROKEN),
        }

        # Public region seed: elevator tile (always in the lobby).
        elev: tuple[int, int] | None = None
        for yy in range(1, int(h) - 1):
            row_off = int(yy) * int(w)
            for xx in range(1, int(w) - 1):
                if int(tiles[int(row_off + xx)]) == int(self.T_ELEVATOR):
                    elev = (int(xx), int(yy))
                    break
            if elev is not None:
                break
        if elev is None:
            return

        def public_passable(x: int, y: int) -> bool:
            if not (0 <= int(x) < int(w) and 0 <= int(y) < int(h)):
                return False
            tid = int(get(int(x), int(y)))
            if int(tid) in door_like:
                return False
            tdef = self._TILES.get(int(tid))
            return bool(tdef is not None and not bool(getattr(tdef, "solid", False)))

        public: set[tuple[int, int]] = set()
        stack = [elev]
        while stack:
            x, y = stack.pop()
            x = int(x)
            y = int(y)
            if (x, y) in public:
                continue
            if not public_passable(int(x), int(y)):
                continue
            public.add((int(x), int(y)))
            stack.extend(((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)))

        # Candidate unit-entry door tiles are those that border the public region.
        unit_doors: list[tuple[int, int]] = []
        for yy in range(1, int(h) - 1):
            row_off = int(yy) * int(w)
            for xx in range(1, int(w) - 1):
                tid = int(tiles[int(row_off + xx)])
                if int(tid) not in door_like:
                    continue
                near_public = False
                near_private = False
                for ox, oy in ((0, -1), (-1, 0), (1, 0), (0, 1)):
                    nx, ny = int(xx + ox), int(yy + oy)
                    if not (0 <= int(nx) < int(w) and 0 <= int(ny) < int(h)):
                        continue
                    if (int(nx), int(ny)) in public:
                        near_public = True
                    else:
                        nt = int(get(int(nx), int(ny)))
                        if int(nt) != int(self.T_WALL):
                            near_private = True
                if near_public and near_private:
                    unit_doors.append((int(xx), int(yy)))

        if not unit_doors:
            return
        unit_doors.sort(key=lambda p: (int(p[0]), int(p[1])))

        # Doorways can be 1-2 tiles wide; group contiguous door tiles so we
        # pick a whole doorway as a "unit door".
        unit_door_set = {(int(x), int(y)) for (x, y) in unit_doors}
        seen_doors: set[tuple[int, int]] = set()
        door_clusters: list[list[tuple[int, int]]] = []
        for px, py in unit_doors:
            px = int(px)
            py = int(py)
            if (px, py) in seen_doors:
                continue
            stack = [(int(px), int(py))]
            comp: list[tuple[int, int]] = []
            while stack:
                sx, sy = stack.pop()
                sx = int(sx)
                sy = int(sy)
                if (sx, sy) in seen_doors:
                    continue
                if (sx, sy) not in unit_door_set:
                    continue
                seen_doors.add((sx, sy))
                comp.append((sx, sy))
                stack.extend(((sx + 1, sy), (sx - 1, sy), (sx, sy + 1), (sx, sy - 1)))
            if comp:
                comp.sort(key=lambda q: (int(q[0]), int(q[1])))
                door_clusters.append(comp)
        if not door_clusters:
            return
        door_clusters.sort(
            key=lambda comp: (
                min(int(q[0]) for q in comp),
                min(int(q[1]) for q in comp),
                int(len(comp)),
            )
        )

        unit = int(getattr(self, "home_highrise_unit", 1))
        unit = int(clamp(int(unit), 1, int(len(door_clusters))))
        home_cluster = door_clusters[int(unit - 1)]
        dx, dy = home_cluster[0]

        # Mark the home door as green. Default to *locked* so only the
        # matching key can open it.
        if not already:
            for hx2, hy2 in home_cluster:
                set_t(int(hx2), int(hy2), int(self.T_DOOR_HOME_LOCKED))
        else:
            # Don't re-lock existing saves; just ensure the tile is a home door.
            for hx2, hy2 in home_cluster:
                cur_home_door = int(get(int(hx2), int(hy2)))
                if cur_home_door == int(self.T_DOOR):
                    set_t(int(hx2), int(hy2), int(self.T_DOOR_HOME))
                elif cur_home_door == int(self.T_DOOR_LOCKED):
                    set_t(int(hx2), int(hy2), int(self.T_DOOR_HOME_LOCKED))
        self.home_highrise_world_key = (int(tx0), int(ty0), int(w), int(h))
        self.home_highrise_world_floor = int(home_floor)
        self.home_highrise_world_home_door = (int(tx0 + dx), int(ty0 + dy))
        self.home_highrise_world_home_door_tiles = [(int(tx0 + x), int(ty0 + y)) for (x, y) in home_cluster]

        # Lock other unit-entry doors; a few are randomly broken (enterable).
        # IMPORTANT: these are the doors from the *base building plan* (unit doors),
        # not the interior bedroom/bath doors we add later.
        try:
            seed_base = int(self.seed) ^ 0x6B8B4567
            for comp in door_clusters:
                if comp is home_cluster:
                    continue
                # Only patch untouched unit doors; preserve any player changes.
                if any(int(get(int(ux), int(uy))) != int(self.T_DOOR) for (ux, uy) in comp):
                    continue
                ax0, ay0 = comp[0]
                hh = int(self._hash2_u32(int(tx0 + ax0), int(ty0 + ay0), int(seed_base)))
                # ~18% broken doors.
                tid = int(self.T_DOOR_BROKEN) if int(hh % 100) < 18 else int(self.T_DOOR_LOCKED)
                for ux, uy in comp:
                    set_t(int(ux), int(uy), int(tid))
        except Exception:
            pass

        # Migration: if any non-entry interior doors were accidentally locked by
        # older logic, unlock them (keep unit-entry doors as-is).
        unit_door_set_all: set[tuple[int, int]] = set()
        for comp in door_clusters:
            for x, y in comp:
                unit_door_set_all.add((int(x), int(y)))

        for yy in range(1, int(h) - 1):
            row_off = int(yy) * int(w)
            for xx in range(1, int(w) - 1):
                if (int(xx), int(yy)) in unit_door_set_all:
                    continue
                tid = int(tiles[int(row_off + xx)])
                if tid in (int(self.T_DOOR_LOCKED), int(self.T_DOOR_HOME_LOCKED), int(self.T_DOOR_HOME)):
                    tiles[int(row_off + xx)] = int(self.T_DOOR)

        # Flood-fill the apartment region above the door (skip the elevator lobby below).
        start: tuple[int, int] | None = (int(dx), int(dy - 1))

        def is_floor(x: int, y: int) -> bool:
            if not (0 <= int(x) < int(w) and 0 <= int(y) < int(h)):
                return False
            # For initial carve (fresh layout), the apartment interior is all floor so
            # this behaves like a floor-only flood-fill. For older saves, internal
            # room doors already exist; treat them as passable so the region covers
            # the whole apartment (but never cross the green home door to the hall).
            tid = int(get(int(x), int(y)))
            if int(tid) == int(self.T_FLOOR):
                return True
            if int(tid) == int(self.T_DOOR):
                return True
            return False

        if start is None or not is_floor(int(start[0]), int(start[1])):
            start = None
            for sx, sy in ((dx, dy - 1), (dx - 1, dy), (dx + 1, dy), (dx, dy + 1)):
                if is_floor(int(sx), int(sy)):
                    start = (int(sx), int(sy))
                    break
        if start is None:
            return

        region: set[tuple[int, int]] = set()
        stack = [start]
        while stack:
            x, y = stack.pop()
            x = int(x)
            y = int(y)
            if (x, y) in region:
                continue
            if not is_floor(int(x), int(y)):
                continue
            region.add((int(x), int(y)))
            stack.extend(((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)))
        if not region:
            return

        # Patch pass: if this home was already set up previously, avoid changing
        # walls/furniture; only ensure critical fixtures exist.
        if already:
            # Always enforce "toilet is in the bathroom" for older saves.
            # We don't re-carve the whole layout; we relocate the toilet into the
            # smallest south-side room (rooms are split by doors/walls).
            def passable_tid(tid: int) -> bool:
                tdef = self._TILES.get(int(tid))
                return bool(tdef is not None and not bool(getattr(tdef, "solid", False)))

            min_x = min(int(p[0]) for p in region)
            max_x = max(int(p[0]) for p in region)
            min_y = min(int(p[1]) for p in region)
            max_y = max(int(p[1]) for p in region)
            south_y = int((min_y + max_y) // 2)

            # Build floor-room components (doors split rooms).
            floor_cells = {(int(x), int(y)) for (x, y) in region if int(get(int(x), int(y))) == int(self.T_FLOOR)}
            comps: list[set[tuple[int, int]]] = []
            seen_fc: set[tuple[int, int]] = set()
            for cell in list(floor_cells):
                if cell in seen_fc:
                    continue
                stack2 = [cell]
                comp: set[tuple[int, int]] = set()
                while stack2:
                    cx2, cy2 = stack2.pop()
                    if (int(cx2), int(cy2)) in seen_fc:
                        continue
                    if (int(cx2), int(cy2)) not in floor_cells:
                        continue
                    seen_fc.add((int(cx2), int(cy2)))
                    comp.add((int(cx2), int(cy2)))
                    stack2.extend(
                        (
                            (int(cx2) + 1, int(cy2)),
                            (int(cx2) - 1, int(cy2)),
                            (int(cx2), int(cy2) + 1),
                            (int(cx2), int(cy2) - 1),
                        )
                    )
                if comp:
                    comps.append(comp)

            start_xy = (int(start[0]), int(start[1])) if isinstance(start, tuple) else None
            main_comp: set[tuple[int, int]] | None = None
            if start_xy is not None and start_xy in floor_cells:
                for c in comps:
                    if start_xy in c:
                        main_comp = c
                        break
            if main_comp is None and comps:
                main_comp = max(comps, key=lambda c: len(c))

            bath_comp: set[tuple[int, int]] | None = None
            bath_key: tuple[int, int, int] | None = None  # (size, -max_y, -max_x)
            for c in comps:
                if main_comp is not None and c is main_comp:
                    continue
                if not c:
                    continue
                c_max_y = max(int(p[1]) for p in c)
                if c_max_y <= int(south_y):
                    continue
                c_max_x = max(int(p[0]) for p in c)
                key = (int(len(c)), -int(c_max_y), -int(c_max_x))
                if bath_key is None or key < bath_key:
                    bath_key = key
                    bath_comp = c

            toilet_cells = {
                (int(i) % int(w), int(i) // int(w))
                for i, t in enumerate(tiles)
                if int(t) == int(self.T_TOILET)
            }
            need_relocate = False
            if not toilet_cells:
                need_relocate = True
            elif bath_comp is not None:
                # If we can identify a bathroom room-component, keep the toilet there.
                def toilet_in_bathroom(pos: tuple[int, int]) -> bool:
                    x, y = pos
                    if (int(x), int(y)) in bath_comp:
                        return True
                    for ox, oy in ((0, -1), (-1, 0), (1, 0), (0, 1)):
                        if (int(x + ox), int(y + oy)) in bath_comp:
                            return True
                    return False

                need_relocate = not any(toilet_in_bathroom(c) for c in toilet_cells)
            else:
                # No clear bathroom component: keep any existing toilet in the south half.
                need_relocate = not any(int(y) > int(south_y) for (_x, y) in toilet_cells)

            if not need_relocate:
                self._home_highrise_world_setup_done = True
                try:
                    if int(getattr(mh, "cur_floor", 1)) == int(home_floor):
                        self._multi_house_apply_floor(chunk, mh)
                except Exception:
                    pass
                return

            target_room = bath_comp if bath_comp is not None else None
            candidates = list(target_room) if target_room is not None else [(int(x), int(y)) for (x, y) in floor_cells]
            candidates.sort(key=lambda p: (int(p[1]), int(p[0])), reverse=True)

            def adj_has_door(x: int, y: int) -> bool:
                for ox, oy in ((0, -1), (-1, 0), (1, 0), (0, 1)):
                    nx, ny = int(x + ox), int(y + oy)
                    if not (0 <= int(nx) < int(w) and 0 <= int(ny) < int(h)):
                        continue
                    if int(get(int(nx), int(ny))) == int(self.T_DOOR):
                        return True
                return False

            best: tuple[int, int] | None = None
            for x, y in candidates:
                x = int(x)
                y = int(y)
                if y <= int(south_y):
                    continue
                if int(get(int(x), int(y))) != int(self.T_FLOOR):
                    continue
                if adj_has_door(int(x), int(y)):
                    continue
                ok_adj = False
                for ox, oy in ((0, -1), (-1, 0), (1, 0), (0, 1)):
                    nx, ny = int(x + ox), int(y + oy)
                    if not (0 <= int(nx) < int(w) and 0 <= int(ny) < int(h)):
                        continue
                    if passable_tid(int(get(int(nx), int(ny)))):
                        ok_adj = True
                        break
                if not ok_adj:
                    continue
                best = (int(x), int(y))
                break

            # If the room is tiny, allow placing next to the door.
            if best is None:
                for x, y in candidates:
                    x = int(x)
                    y = int(y)
                    if y <= int(south_y):
                        continue
                    if int(get(int(x), int(y))) != int(self.T_FLOOR):
                        continue
                    ok_adj = False
                    for ox, oy in ((0, -1), (-1, 0), (1, 0), (0, 1)):
                        nx, ny = int(x + ox), int(y + oy)
                        if not (0 <= int(nx) < int(w) and 0 <= int(ny) < int(h)):
                            continue
                        if passable_tid(int(get(int(nx), int(ny)))):
                            ok_adj = True
                            break
                    if not ok_adj:
                        continue
                    best = (int(x), int(y))
                    break

            if best is not None:
                # Clear existing toilets first (so we don't leave a random one in the living room).
                for i, t in enumerate(list(tiles)):
                    if int(t) == int(self.T_TOILET):
                        tiles[int(i)] = int(self.T_FLOOR)
                bx, by = best
                set_t(int(bx), int(by), int(self.T_TOILET))
                try:
                    self._multi_house_apply_floor(chunk, mh)
                except Exception:
                    pass
            self._home_highrise_world_setup_done = True
            try:
                if int(getattr(mh, "cur_floor", 1)) == int(home_floor):
                    self._multi_house_apply_floor(chunk, mh)
            except Exception:
                pass
            return

        min_x = min(int(p[0]) for p in region)
        max_x = max(int(p[0]) for p in region)
        min_y = min(int(p[1]) for p in region)
        max_y = max(int(p[1]) for p in region)

        # Keep the entry area clear so the player never gets stuck at the door.
        reserved: set[tuple[int, int]] = set()
        ex, ey = start
        for oy in (-1, 0, 1):
            for ox in (-1, 0, 1):
                reserved.add((int(ex + ox), int(ey + oy)))
        layout_guard: set[tuple[int, int]] = set(reserved)

        def can_place(cells: list[tuple[int, int]]) -> bool:
            for x, y in cells:
                x = int(x)
                y = int(y)
                if (x, y) in reserved:
                    return False
                if (x, y) not in region:
                    return False
                if int(get(x, y)) != int(self.T_FLOOR):
                    return False
            return True

        def place(tid: int, cells: list[tuple[int, int]]) -> bool:
            if not can_place(cells):
                return False
            for x, y in cells:
                set_t(int(x), int(y), int(tid))
            return True

        # Home floorplan (world-map, NOT full-screen): 1 living + 2 bedrooms + 1 bath + 1 kitchen.
        rect_w = int(max_x - min_x + 1)
        rect_h = int(max_y - min_y + 1)
        # Debug: helps validate that the home is actually >= 100 floor tiles.
        self._home_highrise_world_debug = {"region": int(len(region)), "rect_w": int(rect_w), "rect_h": int(rect_h)}

        def set_if_clear(x: int, y: int, tid: int) -> bool:
            x = int(x)
            y = int(y)
            if (x, y) in reserved:
                return False
            if (x, y) not in region:
                return False
            if int(get(x, y)) != int(self.T_FLOOR):
                return False
            set_t(int(x), int(y), int(tid))
            return True

        def set_if_floor(x: int, y: int, tid: int) -> bool:
            x = int(x)
            y = int(y)
            if (x, y) not in region:
                return False
            if int(get(int(x), int(y))) != int(self.T_FLOOR):
                return False
            set_t(int(x), int(y), int(tid))
            return True

        def wall_at(x: int, y: int) -> None:
            x = int(x)
            y = int(y)
            if (x, y) in layout_guard:
                return
            if (x, y) not in region:
                return
            if int(get(x, y)) != int(self.T_FLOOR):
                return
            set_t(int(x), int(y), int(self.T_WALL))

        def door_at(x: int, y: int) -> None:
            x = int(x)
            y = int(y)
            if (x, y) in layout_guard:
                return
            if (x, y) not in region:
                return
            set_t(int(x), int(y), int(self.T_DOOR))

        def reserve_near(x: int, y: int) -> None:
            # Reserve a tiny cross-shaped passage so doors/corridors stay usable,
            # without wasting too much space in smaller apartments.
            x = int(x)
            y = int(y)
            for ox, oy in ((0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)):
                reserved.add((int(x + ox), int(y + oy)))

        door_clear: list[tuple[int, int, list[tuple[int, int]]]] = []

        did_layout = False
        layout_kind = "none"  # home_v2 | classic | classic_small | none
        bed_wall_y = None
        bed_div_x = None
        service_wall_x = None
        bath_box: tuple[int, int, int, int] | None = None  # (x0,y0,x1,y1) interior floor rect
        kitchen_box: tuple[int, int, int, int] | None = None  # (x0,y0,x1,y1) interior floor rect
        bed1_box: tuple[int, int, int, int] | None = None
        bed2_box: tuple[int, int, int, int] | None = None
        living_box: tuple[int, int, int, int] | None = None

        # Prefer a "real home" plan for narrow but tall apartments.
        min_home_tiles = 100
        if int(rect_w) >= 7 and int(rect_h) >= 12 and len(region) >= int(min_home_tiles) and int(rect_w) <= 8:
            layout_kind = "home_v2"
            did_layout = True

            # Allocate a living band at the bottom while guaranteeing space for
            # 2 bedrooms + separator walls.
            # Narrow apartments need a bit more living depth so the kitchen isn't
            # a 2-row strip (we need room for fridge + counters).
            min_living_h = 7
            min_bed_total = 8  # 2 bedrooms (>=3 each) + 1 sep wall + 1 boundary wall
            max_living_h = max(int(min_living_h), int(rect_h) - int(min_bed_total))
            living_h = int(clamp(int(round(float(rect_h) * 0.42)), int(min_living_h), int(max_living_h)))
            living_top_y = int(max_y - int(living_h) + 1)
            bed_zone_wall_y = int(living_top_y - 1)  # wall row between bedrooms and living

            # Corridor at x=min_x; bedrooms start after a wall at x=min_x+1.
            corridor_wall_x = int(min_x + 1)
            room_x0 = int(corridor_wall_x + 1)

            bed_zone_h = int(bed_zone_wall_y - min_y)  # rows above the boundary wall
            min_bed_h = 3

            # Basic sanity: need at least a 3-tile wide bedroom side and enough height.
            ok_home_v2 = not (
                int(room_x0) >= int(max_x - 1)
                or int(bed_zone_wall_y) <= int(min_y + 5)
                or int(bed_zone_h) < int(min_bed_h * 2 + 1)
            )
            if not ok_home_v2:
                did_layout = False
                layout_kind = "none"
            else:
                bed1_h_max = int(bed_zone_h - (int(min_bed_h) + 1))
                bed1_h = int(clamp(int(round(float(bed_zone_h) * 0.52)), int(min_bed_h), int(bed1_h_max)))
                bed_sep_y = int(min_y + int(bed1_h))  # wall row between bedrooms
                bed1_y0 = int(min_y)
                bed1_y1 = int(bed_sep_y - 1)
                bed2_y0 = int(bed_sep_y + 1)
                bed2_y1 = int(bed_zone_wall_y - 1)
                if int(bed2_y1 - bed2_y0 + 1) < int(min_bed_h):
                    did_layout = False
                    layout_kind = "none"
                else:
                    # Compute the living-side kitchen/bath strip.
                    living_band_h = int(max_y - living_top_y + 1)
                    service_w = 2 if int(rect_w) <= 7 else 3
                    service_w = int(clamp(int(service_w), 2, max(2, int(rect_w) - 4)))
                    service_x0 = int(max_x - int(service_w) + 1)
                    service_wall = int(service_x0 - 1)

                    # Keep at least a 4-tile living width.
                    if int(service_wall - min_x) < 5:
                        service_w = 2
                        service_x0 = int(max_x - 1)
                        service_wall = int(service_x0 - 1)

                    kitchen_min_h = 3
                    bath_target_h = 3
                    max_bath_h = int(living_band_h) - int(kitchen_min_h) - 1  # leave 1 wall row
                    max_bath_h = int(max(2, int(max_bath_h)))
                    bath_h = int(clamp(int(bath_target_h), 2, int(max_bath_h)))
                    bath_y0 = int(max_y - int(bath_h) + 1)
                    bath_sep_y = int(bath_y0 - 1)
                    kitchen_y0 = int(living_top_y)
                    kitchen_y1 = int(bath_sep_y - 1)

                    # Require a usable kitchen band.
                    if int(kitchen_y1) < int(kitchen_y0) + int(kitchen_min_h - 1):
                        did_layout = False
                        layout_kind = "none"
                    else:
                        # Corridor wall (separates corridor from bedrooms).
                        for yy in range(int(min_y), int(bed_zone_wall_y) + 1):
                            wall_at(int(corridor_wall_x), int(yy))

                        # Bedroom separator + boundary wall (bedroom side only; keep corridor open).
                        for xx in range(int(room_x0), int(max_x) + 1):
                            wall_at(int(xx), int(bed_sep_y))
                            wall_at(int(xx), int(bed_zone_wall_y))

                        def pick_door_y(y0: int, y1: int) -> int:
                            y0 = int(y0)
                            y1 = int(y1)
                            if y1 - y0 < 3:
                                return int(clamp(int(y0 + 1), int(y0), int(y1)))
                            return int(clamp(int((y0 + y1) // 2), int(y0 + 1), int(y1 - 1)))

                        for dy2 in (pick_door_y(int(bed1_y0), int(bed1_y1)), pick_door_y(int(bed2_y0), int(bed2_y1))):
                            door_at(int(corridor_wall_x), int(dy2))
                            door_clear.append(
                                (
                                    int(corridor_wall_x),
                                    int(dy2),
                                    [(int(corridor_wall_x - 1), int(dy2)), (int(corridor_wall_x + 1), int(dy2))],
                                )
                            )
                            reserve_near(int(corridor_wall_x - 1), int(dy2))
                            reserve_near(int(corridor_wall_x + 1), int(dy2))

                        # Vertical wall between living and the service strip.
                        for yy in range(int(living_top_y), int(max_y) + 1):
                            wall_at(int(service_wall), int(yy))

                        # Horizontal wall between kitchen and bathroom (service strip only).
                        for xx in range(int(service_x0), int(max_x) + 1):
                            wall_at(int(xx), int(bath_sep_y))

                        # Doors into kitchen and bath (on the service wall).
                        kitchen_door_y = int((int(kitchen_y0) + int(kitchen_y1)) // 2)
                        bath_door_y = int((int(bath_y0) + int(max_y)) // 2)
                        for dy2 in (int(kitchen_door_y), int(bath_door_y)):
                            door_at(int(service_wall), int(dy2))
                            door_clear.append(
                                (
                                    int(service_wall),
                                    int(dy2),
                                    [(int(service_wall - 1), int(dy2)), (int(service_wall + 1), int(dy2))],
                                )
                            )
                            reserve_near(int(service_wall - 1), int(dy2))
                            reserve_near(int(service_wall + 1), int(dy2))

                        # Boxes for furnishing (interior floor rects).
                        bed1_box = (int(room_x0), int(bed1_y0), int(max_x), int(bed1_y1))
                        bed2_box = (int(room_x0), int(bed2_y0), int(max_x), int(bed2_y1))
                        living_box = (int(min_x), int(living_top_y), int(service_wall - 1), int(max_y))
                        kitchen_box = (int(service_x0), int(kitchen_y0), int(max_x), int(kitchen_y1))
                        bath_box = (int(service_x0), int(bath_y0), int(max_x), int(max_y))
                        # Keep the 1-tile corridor strip clear so bedrooms never get blocked by furniture.
                        for yy in range(int(min_y), int(max_y) + 1):
                            reserved.add((int(min_x), int(yy)))

        # Only attempt the room carve when there's enough space to walk.
        if (not did_layout) and int(rect_w) >= 7 and int(rect_h) >= 6:
            did_layout = True
            layout_kind = "classic"
            # Bedrooms (north) vs living/kitchen/bath (south).
            max_bed = int(rect_h) - 4 if int(rect_h) >= 6 else int(rect_h) - 3
            max_bed = int(max(2, int(max_bed)))
            bed_depth = int(clamp(int(round(float(rect_h) * 0.45)), 2, int(max_bed)))
            bed_wall_y = int(clamp(int(min_y + bed_depth), int(min_y + 2), int(max_y - 2)))

            # Two bedrooms split left/right.
            bed_div_x = int(clamp(int(min_x + (int(rect_w) // 2)), int(min_x + 3), int(max_x - 3)))

            # Horizontal wall between bedrooms and living area.
            for xx in range(int(min_x), int(max_x) + 1):
                wall_at(int(xx), int(bed_wall_y))
            # Vertical wall between the two bedrooms.
            for yy in range(int(min_y), int(bed_wall_y)):
                wall_at(int(bed_div_x), int(yy))

            # Bedroom doors on the bedroom/living separator.
            left_door_x = int(
                clamp(
                    int((int(min_x) + int(bed_div_x)) // 2),
                    int(min_x + 1),
                    int(bed_div_x - 1),
                )
            )
            right_door_x = int(
                clamp(int((int(bed_div_x + 1) + int(max_x)) // 2), int(bed_div_x + 1), int(max_x - 1))
            )
            door_at(int(left_door_x), int(bed_wall_y))
            door_at(int(right_door_x), int(bed_wall_y))
            door_clear.append((int(left_door_x), int(bed_wall_y), [(int(left_door_x), int(bed_wall_y - 1)), (int(left_door_x), int(bed_wall_y + 1))]))
            door_clear.append((int(right_door_x), int(bed_wall_y), [(int(right_door_x), int(bed_wall_y - 1)), (int(right_door_x), int(bed_wall_y + 1))]))
            reserve_near(int(left_door_x), int(bed_wall_y + 1))
            reserve_near(int(right_door_x), int(bed_wall_y + 1))
            reserve_near(int(left_door_x), int(bed_wall_y - 1))
            reserve_near(int(right_door_x), int(bed_wall_y - 1))
            reserve_near(int(left_door_x), int(bed_wall_y - 1))
            reserve_near(int(right_door_x), int(bed_wall_y - 1))

            south_top_y = int(bed_wall_y + 1)
            south_h = int(max_y - south_top_y + 1)

            # Kitchen/bath service strip on the right (keeps living room larger).
            service_w = 0
            if int(rect_w) >= 14:
                service_w = 4
            elif int(rect_w) >= 10:
                service_w = 3
            elif int(rect_w) >= 7:
                service_w = 2
            if int(service_w) > 0 and int(south_h) >= 3:
                service_wall_x = int(max_x - int(service_w))
                for yy in range(int(south_top_y), int(max_y) + 1):
                    wall_at(int(service_wall_x), int(yy))

                # Door into the kitchen/service area.
                kitchen_door_y = int(south_top_y)
                door_at(int(service_wall_x), int(kitchen_door_y))
                door_clear.append(
                    (
                        int(service_wall_x),
                        int(kitchen_door_y),
                        [(int(service_wall_x - 1), int(kitchen_door_y)), (int(service_wall_x + 1), int(kitchen_door_y))],
                    )
                )
                reserve_near(int(service_wall_x - 1), int(kitchen_door_y))
                reserve_near(int(service_wall_x + 1), int(kitchen_door_y))

                # Bathroom: take the bottom slice of the service area (not just 1 row).
                min_kitchen_h = 2
                min_bath_h = 2
                max_bath_h = int(south_h) - int(min_kitchen_h) - 1  # leave 1 wall row too
                if int(max_bath_h) < int(min_bath_h):
                    bath_h = 1
                else:
                    bath_h = int(clamp(int(round(float(south_h) * 0.45)), int(min_bath_h), int(max_bath_h)))
                bath_sep_y = int(max_y - int(bath_h))
                bath_sep_y = int(clamp(int(bath_sep_y), int(south_top_y + 1), int(max_y - 1)))
                for xx in range(int(service_wall_x + 1), int(max_x) + 1):
                    wall_at(int(xx), int(bath_sep_y))
                bath_door_x = int(service_wall_x + 1)
                door_at(int(bath_door_x), int(bath_sep_y))
                door_clear.append(
                    (
                        int(bath_door_x),
                        int(bath_sep_y),
                        [(int(bath_door_x), int(bath_sep_y - 1)), (int(bath_door_x), int(bath_sep_y + 1))],
                    )
                )
                reserve_near(int(bath_door_x), int(bath_sep_y + 1))
                reserve_near(int(bath_door_x), int(bath_sep_y - 1))
                bath_box = (int(service_wall_x + 1), int(bath_sep_y + 1), int(max_x), int(max_y))
        elif (not did_layout) and int(rect_w) >= 5 and int(rect_h) >= 6:
            # Small-unit fallback: still carve the same concept (1厅2室1卫1厨) in a compact way.
            did_layout = True
            layout_kind = "classic_small"
            bed_wall_y = int(clamp(int(min_y + 2), int(min_y + 2), int(max_y - 2)))
            bed_div_x = int(clamp(int(min_x + (int(rect_w) // 2)), int(min_x + 2), int(max_x - 2)))

            # Bedrooms vs living separator.
            for xx in range(int(min_x), int(max_x) + 1):
                wall_at(int(xx), int(bed_wall_y))
            for yy in range(int(min_y), int(bed_wall_y)):
                wall_at(int(bed_div_x), int(yy))

            # Bedroom doors.
            left_door_x = int(clamp(int(min_x + 1), int(min_x + 1), int(bed_div_x - 1)))
            right_door_x = int(clamp(int(bed_div_x + 1), int(bed_div_x + 1), int(max_x - 1)))
            door_at(int(left_door_x), int(bed_wall_y))
            door_at(int(right_door_x), int(bed_wall_y))
            door_clear.append((int(left_door_x), int(bed_wall_y), [(int(left_door_x), int(bed_wall_y - 1)), (int(left_door_x), int(bed_wall_y + 1))]))
            door_clear.append((int(right_door_x), int(bed_wall_y), [(int(right_door_x), int(bed_wall_y - 1)), (int(right_door_x), int(bed_wall_y + 1))]))
            reserve_near(int(left_door_x), int(bed_wall_y + 1))
            reserve_near(int(right_door_x), int(bed_wall_y + 1))

            # Living (left) + service (right) split on the same divider.
            service_wall_x = int(bed_div_x)
            south_top_y = int(bed_wall_y + 1)
            for yy in range(int(south_top_y), int(max_y) + 1):
                wall_at(int(service_wall_x), int(yy))
            service_door_y = int(clamp(int(south_top_y), int(south_top_y), int(max_y - 1)))
            door_at(int(service_wall_x), int(service_door_y))
            door_clear.append(
                (
                    int(service_wall_x),
                    int(service_door_y),
                    [(int(service_wall_x - 1), int(service_door_y)), (int(service_wall_x + 1), int(service_door_y))],
                )
            )
            reserve_near(int(service_wall_x - 1), int(service_door_y))
            reserve_near(int(service_wall_x + 1), int(service_door_y))

            # Bathroom: bottom slice of the service area.
            bath_h = 2 if int(max_y - south_top_y + 1) >= 4 else 1
            bath_sep_y = int(max_y - int(bath_h))
            bath_sep_y = int(clamp(int(bath_sep_y), int(south_top_y + 1), int(max_y - 1)))
            for xx in range(int(service_wall_x + 1), int(max_x) + 1):
                wall_at(int(xx), int(bath_sep_y))
            bath_door_x = int(service_wall_x + 1)
            door_at(int(bath_door_x), int(bath_sep_y))
            door_clear.append(
                (
                    int(bath_door_x),
                    int(bath_sep_y),
                    [(int(bath_door_x), int(bath_sep_y - 1)), (int(bath_door_x), int(bath_sep_y + 1))],
                )
            )
            reserve_near(int(bath_door_x), int(bath_sep_y + 1))
            reserve_near(int(bath_door_x), int(bath_sep_y - 1))
            bath_box = (int(service_wall_x + 1), int(bath_sep_y + 1), int(max_x), int(max_y))

        def place_in_rect(tid: int, shape: list[tuple[int, int]], *, x0: int, y0: int, x1: int, y1: int) -> bool:
            x0 = int(x0)
            y0 = int(y0)
            x1 = int(x1)
            y1 = int(y1)
            if x1 < x0 or y1 < y0:
                return False
            for yy in range(int(y0), int(y1) + 1):
                for xx in range(int(x0), int(x1) + 1):
                    cells = [(int(xx + dx2), int(yy + dy2)) for dx2, dy2 in shape]
                    if place(int(tid), cells):
                        return True
            return False

        if (
            did_layout
            and str(layout_kind) == "home_v2"
            and bed1_box is not None
            and bed2_box is not None
            and living_box is not None
            and kitchen_box is not None
            and bath_box is not None
        ):
            b1x0, b1y0, b1x1, b1y1 = (int(v) for v in bed1_box)
            b2x0, b2y0, b2x1, b2y1 = (int(v) for v in bed2_box)
            lvx0, lvy0, lvx1, lvy1 = (int(v) for v in living_box)
            kx0, ky0, kx1, ky1 = (int(v) for v in kitchen_box)
            bax0, bay0, bax1, bay1 = (int(v) for v in bath_box)

            # Beds (2-tile connected).
            bed_shape_h = [(0, 0), (1, 0)]
            place_in_rect(int(self.T_BED), bed_shape_h, x0=int(b1x0), y0=int(b1y0 + 1), x1=int(b1x1 - 1), y1=int(b1y1))
            place_in_rect(int(self.T_BED), bed_shape_h, x0=int(b2x0), y0=int(b2y0 + 1), x1=int(b2x1 - 1), y1=int(b2y1))

            # Bedroom storage (wardrobe/bookshelf).
            if not place_in_rect(int(self.T_SHELF), [(0, 0)], x0=int(b1x1), y0=int(b1y0 + 1), x1=int(b1x1), y1=int(b1y1)):
                place_in_rect(int(self.T_SHELF), [(0, 0)], x0=int(b1x0), y0=int(b1y0), x1=int(b1x1), y1=int(b1y1))

            # Study: PC desk near the top-right of bedroom 2.
            pc_shape = [(0, 0), (1, 0)]
            pc_anchor: tuple[int, int] | None = None
            for yy in range(int(b2y0 + 1), int(b2y1) + 1):
                for xx in range(int(b2x1 - 1), int(b2x0) - 1, -1):
                    if place(int(self.T_PC), [(int(xx), int(yy)), (int(xx + 1), int(yy))]):
                        pc_anchor = (int(xx), int(yy))
                        break
                if pc_anchor is not None:
                    break
            if pc_anchor is None:
                # Fallback: any fit in the study bedroom.
                for yy in range(int(b2y0), int(b2y1) + 1):
                    for xx in range(int(b2x0), int(b2x1)):
                        if place(int(self.T_PC), [(int(xx), int(yy)), (int(xx + 1), int(yy))]):
                            pc_anchor = (int(xx), int(yy))
                            break
                    if pc_anchor is not None:
                        break

            # Chair in front of the desk (try a few cells).
            if pc_anchor is not None:
                dx, dy = pc_anchor
                for sx, sy in (
                    (dx, dy + 1),
                    (dx + 1, dy + 1),
                    (dx, dy + 2),
                    (dx + 1, dy + 2),
                    (dx - 1, dy + 1),
                    (dx + 2, dy + 1),
                ):
                    if set_if_clear(int(sx), int(sy), int(self.T_CHAIR)):
                        break

            # Living room: sofa + TV + small table.
            sofa_y = int(max(int(lvy0), int(lvy1 - 2)))
            # Try to keep the far-right tile free for the TV by shortening the sofa run.
            sofa_x1 = int(max(int(lvx0 + 1), int(lvx1 - 2)))
            if not place_in_rect(int(self.T_SOFA), [(0, 0), (1, 0)], x0=int(lvx0 + 1), y0=int(sofa_y), x1=int(sofa_x1), y1=int(sofa_y)):
                place_in_rect(int(self.T_SOFA), [(0, 0), (1, 0)], x0=int(lvx0 + 1), y0=int(sofa_y), x1=int(lvx1 - 1), y1=int(sofa_y))

            tv_pos: tuple[int, int] | None = None
            for ty3 in (int(sofa_y), int(sofa_y - 1), int(sofa_y + 1), int(lvy0 + 1), int(lvy1 - 1)):
                if set_if_clear(int(lvx1), int(ty3), int(self.T_TV)):
                    tv_pos = (int(lvx1), int(ty3))
                    break

            # Table near center with one chair (some houses are intentionally unfurnished).
            if random.random() < 0.75:
                cx2 = int((int(lvx0) + int(lvx1)) // 2)
                cy2 = int((int(lvy0) + int(lvy1)) // 2)
                table_pos: tuple[int, int] | None = None
                for r in range(0, 6):
                    for dy2 in range(-int(r), int(r) + 1):
                        for dx2 in range(-int(r), int(r) + 1):
                            tx2 = int(cx2 + dx2)
                            ty2 = int(cy2 + dy2)
                            if (tx2, ty2) in reserved:
                                continue
                            if (tx2, ty2) not in region:
                                continue
                            if int(get(int(tx2), int(ty2))) != int(self.T_FLOOR):
                                continue
                            if place(int(self.T_TABLE), [(int(tx2), int(ty2))]):
                                table_pos = (int(tx2), int(ty2))
                                break
                        if table_pos is not None:
                            break
                    if table_pos is not None:
                        break
                if table_pos is not None:
                    tx2, ty2 = table_pos
                    for (sx, sy) in ((tx2, ty2 + 1), (tx2 + 1, ty2), (tx2 - 1, ty2), (tx2, ty2 - 1)):
                        if set_if_clear(int(sx), int(sy), int(self.T_CHAIR)):
                            break

            # Kitchen: fridge + cabinets.
            fridge_ok = False
            for fx, fy in (
                (int(kx1), int(ky0)),
                (int(kx1), int(ky1)),
                (int(kx0), int(ky0)),
                (int(kx0), int(ky1)),
                (int(kx1), int(ky0 + 1)),
                (int(kx0), int(ky0 + 1)),
            ):
                if set_if_clear(int(fx), int(fy), int(self.T_FRIDGE)):
                    fridge_ok = True
                    break
            if not fridge_ok:
                place_in_rect(int(self.T_FRIDGE), [(0, 0)], x0=int(kx0), y0=int(ky0), x1=int(kx1), y1=int(ky1))

            cab_count = 0
            for sx, sy in (
                (int(kx0), int(ky0)),
                (int(kx0), int(ky1)),
                (int(kx1), int(ky0)),
                (int(kx1), int(ky1)),
                (int(kx0), int(ky0 + 1)),
                (int(kx1), int(ky0 + 1)),
            ):
                if set_if_clear(int(sx), int(sy), int(self.T_CABINET)):
                    cab_count += 1
                if cab_count >= 2:
                    break
            if cab_count == 0:
                place_in_rect(int(self.T_CABINET), [(0, 0)], x0=int(kx0), y0=int(ky0), x1=int(kx1), y1=int(ky1))

            # Bathroom: toilet + sink (faucet).
            placed_toilet = False
            for ty3 in range(int(bay1), int(bay0) - 1, -1):
                for tx3 in range(int(bax1), int(bax0) - 1, -1):
                    # Avoid the door-adjacent tile.
                    if int(tx3) == int(bax0) and int(ty3) == int(bay0):
                        continue
                    if set_if_floor(int(tx3), int(ty3), int(self.T_TOILET)):
                        placed_toilet = True
                        break
                if placed_toilet:
                    break
            if not placed_toilet:
                place_in_rect(int(self.T_TOILET), [(0, 0)], x0=int(bax0), y0=int(bay0), x1=int(bax1), y1=int(bay1))

            if not set_if_clear(int(bax0), int(bay0), int(self.T_SINK)):
                place_in_rect(int(self.T_SINK), [(0, 0)], x0=int(bax0), y0=int(bay0), x1=int(bax1), y1=int(bay1))

        elif did_layout and bed_wall_y is not None and bed_div_x is not None:
            south_top_y = int(bed_wall_y + 1)

            # Bedrooms: beds + a small study.
            bed_shape_h = [(0, 0), (1, 0)]
            if not place_in_rect(
                int(self.T_BED),
                bed_shape_h,
                x0=int(min_x + 1),
                y0=int(min_y + 1),
                x1=int(bed_div_x - 2),
                y1=int(bed_wall_y - 2),
            ):
                place_in_rect(
                    int(self.T_BED),
                    bed_shape_h,
                    x0=int(min_x),
                    y0=int(min_y),
                    x1=int(bed_div_x - 1),
                    y1=int(bed_wall_y - 1),
                )
            if not place_in_rect(
                int(self.T_BED),
                bed_shape_h,
                x0=int(bed_div_x + 1),
                y0=int(min_y + 1),
                x1=int(max_x - 2),
                y1=int(bed_wall_y - 2),
            ):
                place_in_rect(
                    int(self.T_BED),
                    bed_shape_h,
                    x0=int(bed_div_x + 1),
                    y0=int(min_y),
                    x1=int(max_x),
                    y1=int(bed_wall_y - 1),
                )
            place_in_rect(
                int(self.T_PC),
                [(0, 0), (1, 0)],
                x0=int(bed_div_x + 1),
                y0=int(bed_wall_y - 2),
                x1=int(max_x - 2),
                y1=int(bed_wall_y - 2),
            )
            place_in_rect(
                int(self.T_SHELF),
                [(0, 0)],
                x0=int(min_x + 1),
                y0=int(min_y + 1),
                x1=int(min_x + 2),
                y1=int(bed_wall_y - 2),
            )

            # Living room: sofa + TV + table.
            living_x1 = int(max_x if service_wall_x is None else service_wall_x - 1)
            for sy in (int(max_y - 2), int(max_y - 3), int(max_y - 1), int(south_top_y)):
                if int(sy) < int(south_top_y) or int(sy) > int(max_y - 1):
                    continue
                if place_in_rect(
                    int(self.T_SOFA),
                    [(0, 0), (1, 0)],
                    x0=int(min_x + 1),
                    y0=int(sy),
                    x1=int(max(int(min_x + 2), int(living_x1 - 2))),
                    y1=int(sy),
                ):
                    break
            for ty3 in (int(max_y - 2), int(max_y - 3), int(max_y - 1), int(south_top_y)):
                if int(ty3) < int(south_top_y) or int(ty3) > int(max_y - 1):
                    continue
                if place_in_rect(
                    int(self.T_TV),
                    [(0, 0)],
                    x0=int(max(int(min_x + 1), int(living_x1 - 2))),
                    y0=int(ty3),
                    x1=int(living_x1 - 1),
                    y1=int(ty3),
                ):
                    break
            if random.random() < 0.75:
                table_pos: tuple[int, int] | None = None
                cx2 = int((min_x + living_x1) // 2)
                cy2 = int((south_top_y + max_y) // 2)
                for r in range(0, max(2, max(living_x1 - min_x, max_y - south_top_y) + 1)):
                    for dy2 in range(-int(r), int(r) + 1):
                        for dx2 in range(-int(r), int(r) + 1):
                            tx2 = int(cx2 + dx2)
                            ty2 = int(cy2 + dy2)
                            if (tx2, ty2) in reserved:
                                continue
                            if (tx2, ty2) not in region:
                                continue
                            if int(get(tx2, ty2)) != int(self.T_FLOOR):
                                continue
                            if place(int(self.T_TABLE), [(int(tx2), int(ty2))]):
                                table_pos = (int(tx2), int(ty2))
                                break
                        if table_pos is not None:
                            break
                    if table_pos is not None:
                        break
                if table_pos is not None:
                    tx2, ty2 = table_pos
                    for cells in ([(tx2, ty2 + 1)], [(tx2 + 1, ty2)], [(tx2 - 1, ty2)], [(tx2, ty2 - 1)]):
                        if place(int(self.T_CHAIR), [(int(c[0]), int(c[1])) for c in cells]):
                            break

            # Kitchen: fridge + shelf (if service area exists, prefer it; otherwise tuck into living corner).
            if service_wall_x is not None:
                place_in_rect(
                    int(self.T_FRIDGE),
                    [(0, 0)],
                    x0=int(service_wall_x + 1),
                    y0=int(south_top_y),
                    x1=int(max_x - 1),
                    y1=int(max_y - 1),
                )
                place_in_rect(
                    int(self.T_CABINET),
                    [(0, 0)],
                    x0=int(service_wall_x + 1),
                    y0=int(south_top_y),
                    x1=int(max_x - 1),
                    y1=int(max_y - 1),
                )
            else:
                if not place_in_rect(
                    int(self.T_FRIDGE),
                    [(0, 0)],
                    x0=int(max(int(min_x + 1), int(max_x - 2))),
                    y0=int(south_top_y),
                    x1=int(max_x - 1),
                    y1=int(max_y - 2),
                ):
                    place_in_rect(
                        int(self.T_FRIDGE),
                        [(0, 0)],
                        x0=int(min_x + 1),
                        y0=int(south_top_y),
                        x1=int(max_x - 1),
                        y1=int(max_y - 2),
                    )

            # Bathroom: toilet + sink (faucet).
            if bath_box is not None:
                bx0, by0, bx1, by1 = bath_box
                # Place toilet first (priority) — avoid blocking the bathroom door
                # (the tile right behind the door is bx0/by0).
                placed_toilet = False
                for ty3 in range(int(by1), int(by0) - 1, -1):
                    for tx3 in range(int(bx1), int(bx0) - 1, -1):
                        if int(tx3) == int(bx0) and int(ty3) == int(by0):
                            continue
                        # Ignore "reserved" for the toilet so small bathrooms still get one.
                        if set_if_floor(int(tx3), int(ty3), int(self.T_TOILET)):
                            placed_toilet = True
                            break
                    if placed_toilet:
                        break
                if not placed_toilet:
                    place_in_rect(
                        int(self.T_TOILET),
                        [(0, 0)],
                        x0=int(bx0),
                        y0=int(by0),
                        x1=int(bx1),
                        y1=int(by1),
                )
                # Then place sink.
                place_in_rect(
                    int(self.T_SINK),
                    [(0, 0)],
                    x0=int(bx0),
                    y0=int(by0),
                    x1=int(bx1 - 2),
                    y1=int(by1),
                )
            elif service_wall_x is not None:
                # Small layout: put toilet + sink into the bathroom corner.
                bx = int(max_x)
                by = int(max_y)
                # Try to place toilet
                for ox, oy in ((0, 0), (-1, 0), (0, -1)):
                    if set_if_clear(int(bx + ox), int(by + oy), int(self.T_TOILET)):
                        break
                # Then place sink nearby
                for ox, oy in ((-1, 0), (0, -1), (-1, -1)):
                    if set_if_clear(int(bx + ox), int(by + oy), int(self.T_SINK)):
                        break
        else:
            # Fallback: minimal furnishing if the apartment is too small to carve.
            for cells in (
                [(min_x + 1, min_y + 1), (min_x + 2, min_y + 1)],
                [(max_x - 2, min_y + 1), (max_x - 1, min_y + 1)],
            ):
                if place(int(self.T_BED), [(int(c[0]), int(c[1])) for c in cells]):
                    break
            place(int(self.T_FRIDGE), [(int(max_x - 1), int(min_y + 1))])
            place(int(self.T_CABINET), [(int(max_x - 2), int(min_y + 1))])
            place(int(self.T_SOFA), [(int(min_x + 1), int(max_y - 2)), (int(min_x + 2), int(max_y - 2))])
            place(int(self.T_TV), [(int(max_x - 1), int(max_y - 2))])

        # Lighting: a lamp in the living area (toggle on the lamp itself).
        def place_decor(tid: int, candidates: list[tuple[int, int]]) -> bool:
            for x, y in candidates:
                x = int(x)
                y = int(y)
                if (x, y) not in region:
                    continue
                if int(get(x, y)) != int(self.T_FLOOR):
                    continue
                set_t(int(x), int(y), int(tid))
                return True
            return False

        lamp_y0 = int(min_y if bed_wall_y is None else (bed_wall_y + 1))
        lamp_x1 = int(max_x if service_wall_x is None else (service_wall_x - 1))
        lamp_cx = int((min_x + lamp_x1) // 2)
        lamp_cy = int(clamp(int((lamp_y0 + max_y) // 2), int(lamp_y0), int(max_y - 1)))
        place_decor(
            int(self.T_LAMP),
            [
                (lamp_cx, lamp_cy),
                (lamp_cx + 1, lamp_cy),
                (lamp_cx - 1, lamp_cy),
                (lamp_cx, lamp_cy + 1),
                (lamp_cx, lamp_cy - 1),
            ],
        )

        # Ensure the home always has a toilet (older layouts or tight shapes can miss it).
        if not has_toilet():
            # Prefer putting it inside the bathroom box if we carved one.
            if bath_box is not None:
                bx0, by0, bx1, by1 = bath_box
                for ty3 in range(int(by1), int(by0) - 1, -1):
                    for tx3 in range(int(bx1), int(bx0) - 1, -1):
                        if int(tx3) == int(bx0) and int(ty3) == int(by0):
                            continue
                        if int(get(int(tx3), int(ty3))) != int(self.T_FLOOR):
                            continue
                        set_t(int(tx3), int(ty3), int(self.T_TOILET))
                        break
                    if has_toilet():
                        break

            if not has_toilet():
                avoid: set[tuple[int, int]] = set()
                for _dx2, _dy2, adj2 in list(door_clear):
                    for ax2, ay2 in adj2:
                        avoid.add((int(ax2), int(ay2)))

                def passable_tid(tid: int) -> bool:
                    tdef = self._TILES.get(int(tid))
                    return bool(tdef is not None and not bool(getattr(tdef, "solid", False)))

                placed = False
                for px, py in sorted(region, key=lambda p: (int(p[1]), int(p[0])), reverse=True):
                    if (int(px), int(py)) in avoid or (int(px), int(py)) in reserved:
                        continue
                    if int(get(int(px), int(py))) != int(self.T_FLOOR):
                        continue
                    ok_adj = False
                    for ox, oy in ((0, -1), (-1, 0), (1, 0), (0, 1)):
                        nx, ny = int(px + ox), int(py + oy)
                        if not (0 <= int(nx) < int(w) and 0 <= int(ny) < int(h)):
                            continue
                        if passable_tid(int(get(int(nx), int(ny)))):
                            ok_adj = True
                            break
                    if not ok_adj:
                        continue
                    set_t(int(px), int(py), int(self.T_TOILET))
                    placed = True
                    break

                # Last resort: drop it anywhere walkable in the apartment.
                if not placed:
                    for px, py in sorted(region, key=lambda p: (int(p[1]), int(p[0])), reverse=True):
                        if (int(px), int(py)) in avoid or (int(px), int(py)) in reserved:
                            continue
                        if int(get(int(px), int(py))) != int(self.T_FLOOR):
                            continue
                        set_t(int(px), int(py), int(self.T_TOILET))
                        break

        # Guarantee doors are usable: clear solid tiles right next to each interior door we placed.
        def clear_passage_cell(x: int, y: int) -> None:
            x = int(x)
            y = int(y)
            if (x, y) not in region:
                return
            tid = int(get(x, y))
            if tid in (
                int(self.T_FLOOR),
                int(self.T_DOOR),
                int(self.T_DOOR_HOME),
                int(self.T_DOOR_LOCKED),
                int(self.T_DOOR_HOME_LOCKED),
                int(self.T_ELEVATOR),
                int(self.T_STAIRS_UP),
                int(self.T_STAIRS_DOWN),
            ):
                return
            set_t(int(x), int(y), int(self.T_FLOOR))

        for _dx, _dy, adj in list(door_clear):
            for ax, ay in adj:
                clear_passage_cell(int(ax), int(ay))

        self._home_highrise_world_setup_done = True
        try:
            if int(getattr(mh, "cur_floor", 1)) == int(home_floor):
                self._multi_house_apply_floor(chunk, mh)
        except Exception:
            pass

    def _debug_enter_home_world(self) -> bool:
        # Debug helper: teleport to the home apartment (world-map view), no full-screen mode.
        if bool(getattr(self, "hr_interior", False)) or bool(getattr(self, "house_interior", False)) or bool(getattr(self, "sch_interior", False)):
            return False
        home = getattr(self, "home_highrise_door", None)
        if not isinstance(home, tuple) or len(home) != 2:
            return False
        try:
            hx, hy = int(home[0]), int(home[1])
        except Exception:
            return False

        found = self._multi_house_at(int(hx), int(hy))
        if found is None:
            return False
        chunk, mh = found

        floors = int(max(1, int(getattr(mh, "floors", 1))))
        floors = int(min(int(floors), int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
        home_floor = int(getattr(self, "home_highrise_floor", 1) or 1)
        home_floor = int(clamp(int(home_floor), 1, int(floors)))
        mh.cur_floor = int(home_floor)

        # Ensure green door + home layout exist.
        self._setup_home_highrise_world()
        self._multi_house_apply_floor(chunk, mh)

        door = getattr(self, "home_highrise_world_home_door", None)
        if not isinstance(door, tuple) or len(door) != 2:
            door = (int(hx), int(hy))
        gx, gy = int(door[0]), int(door[1])

        def passable(tx: int, ty: int) -> bool:
            try:
                tid = int(self.world.get_tile(int(tx), int(ty)))
            except Exception:
                return False
            tdef = self._TILES.get(int(tid))
            return bool(tdef is not None and not bool(getattr(tdef, "solid", False)))

        spawn: tuple[int, int] | None = None
        for tx, ty in (
            (gx, gy - 1),
            (gx, gy),
            (gx - 1, gy - 1),
            (gx + 1, gy - 1),
            (gx - 1, gy),
            (gx + 1, gy),
            (gx, gy + 1),
        ):
            if passable(int(tx), int(ty)):
                spawn = (int(tx), int(ty))
                break
        if spawn is None:
            spawn = (int(gx), int(gy))

        sx, sy = spawn
        self.player.vel.update(0, 0)
        self.player.pos.update((float(sx) + 0.5) * float(self.TILE_SIZE), (float(sy) + 0.5) * float(self.TILE_SIZE))
        self._set_hint("传送到家(K)", seconds=1.0)
        return True

    def _teleport_to_bathroom(self) -> bool:
        """Teleport to bathroom (toilet) in home on world map."""
        if bool(getattr(self, "hr_interior", False)) or bool(getattr(self, "house_interior", False)) or bool(getattr(self, "sch_interior", False)):
            return False
        home = getattr(self, "home_highrise_door", None)
        if not isinstance(home, tuple) or len(home) != 2:
            self._set_hint("未找到家", seconds=1.0)
            return False
        try:
            hx, hy = int(home[0]), int(home[1])
        except Exception:
            return False

        found = self._multi_house_at(int(hx), int(hy))
        if found is None:
            return False
        chunk, mh = found

        floors = int(max(1, int(getattr(mh, "floors", 1))))
        floors = int(min(int(floors), int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
        home_floor = int(getattr(self, "home_highrise_floor", 1) or 1)
        home_floor = int(clamp(int(home_floor), 1, int(floors)))
        mh.cur_floor = int(home_floor)

        self._setup_home_highrise_world()
        self._multi_house_apply_floor(chunk, mh)

        # Find toilet position
        tx0 = int(getattr(mh, "tx0", 0))
        ty0 = int(getattr(mh, "ty0", 0))
        bw = int(getattr(mh, "w", 0))
        bh = int(getattr(mh, "h", 0))

        base_tiles = mh.floor_tiles.get(int(home_floor))
        toilet_pos: tuple[int, int] | None = None
        if isinstance(base_tiles, list) and len(base_tiles) == bw * bh:
            for yy in range(bh):
                for xx in range(bw):
                    if int(base_tiles[yy * bw + xx]) == int(self.T_TOILET):
                        toilet_pos = (tx0 + xx, ty0 + yy)
                        break
                if toilet_pos:
                    break

        if toilet_pos is None:
            self._set_hint("未找到卫生间", seconds=1.0)
            return False

        # Find passable tile near toilet
        tx, ty = toilet_pos
        def passable(px: int, py: int) -> bool:
            try:
                tid = int(self.world.get_tile(int(px), int(py)))
            except Exception:
                return False
            tdef = self._TILES.get(int(tid))
            return bool(tdef is not None and not bool(getattr(tdef, "solid", False)))

        spawn: tuple[int, int] | None = None
        for dx, dy in ((0, -1), (-1, 0), (1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1), (1, 1)):
            if passable(tx + dx, ty + dy):
                spawn = (tx + dx, ty + dy)
                break
        if spawn is None:
            spawn = (tx, ty)

        sx, sy = spawn
        self.player.vel.update(0, 0)
        self.player.pos.update((float(sx) + 0.5) * float(self.TILE_SIZE), (float(sy) + 0.5) * float(self.TILE_SIZE))
        self._set_hint("卫生间", seconds=1.0)
        return True

    def _try_use_multi_house_stairs(self) -> bool:
        tx, ty = self._player_tile()
        candidates = [(tx, ty), (tx + 1, ty), (tx - 1, ty), (tx, ty + 1), (tx, ty - 1)]
        chosen: tuple[int, int, int] | None = None
        for cx, cy in candidates:
            t = int(self.world.get_tile(int(cx), int(cy)))
            if t in (int(self.T_STAIRS_UP), int(self.T_STAIRS_DOWN)):
                chosen = (int(cx), int(cy), int(t))
                break
        if chosen is None:
            return False
        cx, cy, t = chosen
        found = self._multi_house_at(int(cx), int(cy))
        if found is None:
            return False
        chunk, mh = found
        floors = int(max(1, int(getattr(mh, "floors", 1))))
        floors = int(min(int(floors), int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
        cur = int(max(1, int(getattr(mh, "cur_floor", 1))))

        if t == int(self.T_STAIRS_UP):
            if cur >= floors:
                self._set_hint("已经是顶层", seconds=1.0)
                return True
            mh.cur_floor = int(cur + 1)
        else:
            if cur <= 1:
                self._set_hint("已经是一层", seconds=1.0)
                return True
            mh.cur_floor = int(cur - 1)

        self._multi_house_apply_floor(chunk, mh)
        self.player.vel.update(0, 0)
        self.player.pos.update((float(cx) + 0.5) * float(self.TILE_SIZE), (float(cy) + 0.5) * float(self.TILE_SIZE))
        self._set_hint(f"{int(getattr(mh, 'cur_floor', 1))}F", seconds=0.8)
        return True

    def _try_enter_highrise(self) -> bool:
        if getattr(self, "hr_interior", False):
            return False
        tx, ty = self._player_tile()
        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        for cx, cy in candidates:
            if self.world.get_tile(int(cx), int(cy)) != int(self.T_DOOR):
                continue
            chunk = self.world.get_chunk(int(cx) // self.CHUNK_SIZE, int(cy) // self.CHUNK_SIZE)
            for sb in getattr(chunk, "special_buildings", []):
                if getattr(sb, "kind", "") != "highrise":
                    continue
                if (int(cx), int(cy)) not in set(getattr(sb, "door_tiles", ())):
                    continue
                if self.mount is not None:
                    self._set_hint("下车后再进入高层住宅", seconds=1.2)
                    return True
                self._hr_interior_enter(sb)
                return True
        return False

    def _try_enter_school(self) -> bool:
        if getattr(self, "sch_interior", False):
            return False
        tx, ty = self._player_tile()
        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        for cx, cy in candidates:
            if self.world.get_tile(int(cx), int(cy)) != int(self.T_DOOR):
                continue
            chunk = self.world.get_chunk(int(cx) // self.CHUNK_SIZE, int(cy) // self.CHUNK_SIZE)
            for sb in getattr(chunk, "special_buildings", []):
                if getattr(sb, "kind", "") != "school":
                    continue
                if (int(cx), int(cy)) not in set(getattr(sb, "door_tiles", ())):
                    continue
                if self.mount is not None:
                    self._set_hint("下车后再进入学校", seconds=1.2)
                    return True
                self._sch_interior_enter(sb)
                return True
        return False

    def _try_pickup(self, *, quiet: bool = False) -> bool:
        chunk, it = self._find_nearest_item(radius_px=18.0)
        if it is None or chunk is None:
            if not bool(quiet):
                self._set_hint("附近没有可拾取物")
            return False
        idef = self._ITEMS.get(it.item_id)
        if idef is None:
            self._set_hint("未知物品")
            return True

        # If it's a small tool (like a cup) and the hand is empty, carry it in-hand.
        held = getattr(self, "held_item", None)
        if held is None and str(getattr(idef, "kind", "")) == "tool":
            take = int(clamp(int(getattr(it, "qty", 1)), 0, 1))
            if take > 0:
                self.held_item = HardcoreSurvivalState._ItemStack(item_id=str(it.item_id), qty=int(take))
                left2 = int(getattr(it, "qty", 1)) - int(take)
                if left2 <= 0:
                    try:
                        chunk.items.remove(it)
                    except ValueError:
                        pass
                else:
                    it.qty = int(left2)
                self._set_hint(f"拿在手上 {idef.name}")
                return True
        left = self.inventory.add(it.item_id, int(it.qty), self._ITEMS)
        taken = int(it.qty) - int(left)
        if taken <= 0:
            self._set_hint("背包满了")
            return True
        if left <= 0:
            try:
                chunk.items.remove(it)
            except ValueError:
                pass
        else:
            it.qty = int(left)
        self._set_hint(f"拾取 {idef.name} x{taken}")
        return True

    def _drop_selected(self) -> None:
        stack = self.inventory.drop_slot(int(self.inv_index))
        if stack is None:
            self._set_hint("空槽位")
            return
        idef = self._ITEMS.get(stack.item_id)
        name = idef.name if idef is not None else stack.item_id
        tx, ty = self._player_tile()
        chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
        offset = pygame.Vector2(random.randint(-6, 6), random.randint(-6, 6))
        chunk.items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(self.player.pos) + offset, item_id=stack.item_id, qty=int(stack.qty)))
        self._set_hint(f"丢弃 {name} x{stack.qty}")

    def _use_consumable(self, item_id: str) -> bool:
        item_id = str(item_id)
        if item_id == "cola":
            self.player.thirst = clamp(self.player.thirst + 42.0, 0.0, 100.0)
            self.player.morale = clamp(self.player.morale + 5.0, 0.0, 100.0)
            self.player.stamina = clamp(self.player.stamina + 6.0, 0.0, 100.0)
            self._set_hint("喝了可乐：口渴++ 心态+")
            return True
        if item_id == "food_can":
            self.player.hunger = clamp(self.player.hunger + 38.0, 0.0, 100.0)
            self.player.morale = clamp(self.player.morale + 4.0, 0.0, 100.0)
            self.player.condition = clamp(self.player.condition + 2.0, 0.0, 100.0)
            self._set_hint("吃了罐头：饥饿+ 心态+")
            return True
        if item_id == "water":
            self.player.thirst = clamp(self.player.thirst + 50.0, 0.0, 100.0)
            self.player.morale = clamp(self.player.morale + 2.0, 0.0, 100.0)
            self._set_hint("喝了水：口渴+")
            return True
        if item_id == "cup_water":
            self.player.thirst = clamp(self.player.thirst + 35.0, 0.0, 100.0)
            self.player.morale = clamp(self.player.morale + 1.0, 0.0, 100.0)
            self._set_hint("喝了一杯水", seconds=1.0)
            return True
        if item_id == "bandage":
            stopped = self._bandage_one_wound()
            self.player.hp = int(clamp(self.player.hp + 18, 0, 100))    
            self.player.condition = clamp(self.player.condition + 3.0, 0.0, 100.0)
            if stopped:
                name = self._BODY_PART_NAMES.get(str(stopped), str(stopped))
                self._set_hint(f"绷带止血：{name}", seconds=1.2)
            else:
                self._set_hint("使用绷带：生命+")
            return True
        if item_id == "medkit":
            cleared = self._clear_all_wounds()
            self.player.hp = int(clamp(self.player.hp + 55, 0, 100))     
            self.player.condition = clamp(self.player.condition + 10.0, 0.0, 100.0)
            self.player.morale = clamp(self.player.morale + 3.0, 0.0, 100.0)
            if cleared > 0:
                self._set_hint("急救包：止血 + 生命++")
            else:
                self._set_hint("使用急救包：生命++")
            return True

        if item_id == "gas_can":
            add = float(getattr(self, "GAS_CAN_REFUEL", 45.0))
            add = float(clamp(add, 5.0, 100.0))

            kind: str | None = None
            target: object | None = None

            if self.mount == "rv":
                kind = "rv"
                target = self.rv
            elif self.mount == "bike":
                mid = str(getattr(self.bike, "model_id", "bike"))
                if mid.startswith("moto"):
                    kind = "bike"
                    target = self.bike
                else:
                    self._set_hint("自行车不需要汽油", seconds=1.0)
                    return False
            else:
                best_kind: str | None = None
                best_target: object | None = None
                best_d2 = float(28.0 * 28.0)

                rv_d2 = float((self.player.pos - self.rv.pos).length_squared())
                if rv_d2 <= best_d2:
                    best_kind = "rv"
                    best_target = self.rv
                    best_d2 = rv_d2

                mid = str(getattr(self.bike, "model_id", "bike"))
                if mid.startswith("moto"):
                    bike_d2 = float((self.player.pos - self.bike.pos).length_squared())
                    if bike_d2 <= best_d2:
                        best_kind = "bike"
                        best_target = self.bike
                        best_d2 = bike_d2

                # Also allow refueling parked motorcycles.
                parked_chunk, parked_bike, parked_d2 = self._find_nearest_parked_bike(radius_px=28.0)
                if parked_bike is not None and parked_chunk is not None:
                    pb_mid = str(getattr(parked_bike, "model_id", "bike"))
                    if pb_mid.startswith("moto") and float(parked_d2) <= float(best_d2):
                        best_kind = "parked"
                        best_target = parked_bike
                        best_d2 = float(parked_d2)

                kind = best_kind
                target = best_target

            if kind is None or target is None:
                self._set_hint("靠近载具再加油", seconds=1.1)
                return False

            before = float(getattr(target, "fuel", 0.0))
            if before >= 99.9:
                self._set_hint("油箱已满", seconds=1.0)
                return False

            after = float(clamp(before + add, 0.0, 100.0))
            try:
                setattr(target, "fuel", after)
            except Exception:
                return False

            if kind == "rv":
                self._rv_no_fuel_warned = False
                self._set_hint("房车加油", seconds=0.9)
            elif kind in ("bike", "parked"):
                self._bike_no_fuel_warned = False
                self._set_hint("摩托加油", seconds=0.9)
            else:
                self._set_hint("加油", seconds=0.9)
            return True

        # Generic consumables (so the bulk item library is actually usable).
        idef = self._ITEMS.get(item_id)
        if idef is None:
            return False
        kind = str(getattr(idef, "kind", ""))
        if kind not in ("food", "drink", "med"):
            return False

        seed = 0
        for ch in str(item_id):
            seed = (seed * 131 + ord(ch)) & 0xFFFFFFFF

        if kind == "drink":
            thirst = 20.0 + float(seed % 30)  # 20..49
            morale = 1.0 + float((seed >> 3) % 4)  # 1..4
            self.player.thirst = clamp(self.player.thirst + thirst, 0.0, 100.0)
            self.player.morale = clamp(self.player.morale + morale, 0.0, 100.0)
            self._set_hint(f"喝了{idef.name}：口渴+")
            return True

        if kind == "food":
            hunger = 18.0 + float(seed % 25)  # 18..42
            morale = 1.0 + float((seed >> 2) % 4)  # 1..4
            cond = float((seed >> 8) % 3)  # 0..2
            self.player.hunger = clamp(self.player.hunger + hunger, 0.0, 100.0)
            self.player.morale = clamp(self.player.morale + morale, 0.0, 100.0)
            self.player.condition = clamp(self.player.condition + cond, 0.0, 100.0)
            self._set_hint(f"吃了{idef.name}：饥饿+")
            return True

        # kind == "med"
        heal = 10.0 + float(seed % 18)  # 10..27
        cond = 2.0 + float((seed >> 5) % 5)  # 2..6
        morale = 0.0 + float((seed >> 9) % 3)  # 0..2
        stopped = None
        if any(k in str(item_id) for k in ("bandage", "suture", "splint", "iodine", "antiseptic", "ointment", "disinfect")):
            stopped = self._bandage_one_wound()
        self.player.hp = int(clamp(float(self.player.hp) + heal, 0.0, 100.0))
        self.player.condition = clamp(self.player.condition + cond, 0.0, 100.0)
        self.player.morale = clamp(self.player.morale + morale, 0.0, 100.0)
        if stopped:
            name = self._BODY_PART_NAMES.get(str(stopped), str(stopped))
            self._set_hint(f"{idef.name}：止血({name})")
        else:
            self._set_hint(f"使用{idef.name}：恢复+")
        return True
        return False

    def _gun_effective_def(self, gun: "HardcoreSurvivalState._Gun | None" = None) -> "HardcoreSurvivalState._GunDef | None":
        gun = self.gun if gun is None else gun
        if gun is None:
            return None
        base = self._GUNS.get(str(getattr(gun, "gun_id", "")))
        if base is None:
            return None

        mag_add = 0
        fire_rate_mult = 1.0
        reload_mult = 1.0
        damage_mult = 1.0
        damage_add = 0
        bullet_speed_mult = 1.0
        spread_mult = 1.0
        noise_mult = 1.0

        mods = getattr(gun, "mods", None)
        if isinstance(mods, dict):
            for _slot, mod_id in list(mods.items()):
                mdef = self._GUN_MODS.get(str(mod_id))
                if mdef is None:
                    continue
                if str(getattr(gun, "gun_id", "")) not in tuple(getattr(mdef, "compat", ())):
                    continue
                mag_add += int(getattr(mdef, "mag_add", 0))
                fire_rate_mult *= float(getattr(mdef, "fire_rate_mult", 1.0))
                reload_mult *= float(getattr(mdef, "reload_mult", 1.0))
                damage_mult *= float(getattr(mdef, "damage_mult", 1.0))
                damage_add += int(getattr(mdef, "damage_add", 0))
                bullet_speed_mult *= float(getattr(mdef, "bullet_speed_mult", 1.0))
                spread_mult *= float(getattr(mdef, "spread_mult", 1.0))
                noise_mult *= float(getattr(mdef, "noise_mult", 1.0))

        mag_size = max(1, int(round(float(base.mag_size) + float(mag_add))))
        fire_rate = max(0.1, float(base.fire_rate) * float(fire_rate_mult))
        reload_s = max(0.20, float(base.reload_s) * float(reload_mult))
        damage = int(max(1.0, float(base.damage) * float(damage_mult) + float(damage_add)))
        bullet_speed = max(40.0, float(base.bullet_speed) * float(bullet_speed_mult))
        spread_deg = max(0.25, float(base.spread_deg) * float(spread_mult))
        noise_radius = max(60.0, float(base.noise_radius) * float(noise_mult))

        return HardcoreSurvivalState._GunDef(
            id=str(base.id),
            name=str(base.name),
            ammo_item=str(base.ammo_item),
            mag_size=int(mag_size),
            fire_rate=float(fire_rate),
            reload_s=float(reload_s),
            damage=int(damage),
            bullet_speed=float(bullet_speed),
            spread_deg=float(spread_deg),
            noise_radius=float(noise_radius),
            muzzle_flash_s=float(getattr(base, "muzzle_flash_s", 0.06)),
            bullet_ttl=float(getattr(base, "bullet_ttl", 1.35)),
            bullet_kind=str(getattr(base, "bullet_kind", "bullet")),
            aoe_radius=float(getattr(base, "aoe_radius", 0.0)),
            aoe_damage=int(getattr(base, "aoe_damage", 0)),
        )

    def _gun_mod_label(self, gun: "HardcoreSurvivalState._Gun | None" = None) -> str:
        gun = self.gun if gun is None else gun
        if gun is None:
            return ""
        mods = getattr(gun, "mods", None)
        if not isinstance(mods, dict) or not mods:
            return ""
        names: list[str] = []
        for _slot, mid in mods.items():
            mdef = self._GUN_MODS.get(str(mid))
            if mdef is None:
                continue
            if str(getattr(gun, "gun_id", "")) not in tuple(getattr(mdef, "compat", ())):
                continue
            n = str(getattr(mdef, "name", "")).strip()
            if n:
                names.append(n)
        if not names:
            return ""
        return " +".join(names[:3])

    def _equip_selected(self) -> None:
        if not (0 <= int(self.inv_index) < len(self.inventory.slots)):
            return
        stack = self.inventory.slots[int(self.inv_index)]
        if stack is None:
            self._set_hint("空槽位")
            return
        idef = self._ITEMS.get(stack.item_id)
        if idef is None:
            self._set_hint("未知物品")
            return

        if idef.kind == "gun_mod":
            if self.gun is None:
                self._set_hint("先装枪再装配件", seconds=1.0)
                return
            mdef = self._GUN_MODS.get(str(stack.item_id))
            if mdef is None:
                self._set_hint("未知枪械配件", seconds=1.0)
                return
            if str(getattr(self.gun, "gun_id", "")) not in tuple(getattr(mdef, "compat", ())):
                self._set_hint("这个配件不适配当前枪", seconds=1.0)
                return

            slot_key = str(getattr(mdef, "slot", ""))
            if not slot_key:
                self._set_hint("配件缺少安装位", seconds=1.0)
                return

            old = None
            try:
                old = (self.gun.mods or {}).get(slot_key)
            except Exception:
                old = None

            if str(old or "") == str(getattr(mdef, "id", "")):
                self._set_hint("已经装着了", seconds=0.8)
                return

            if old:
                left = int(self.inventory.add(str(old), 1, self._ITEMS))
                if left > 0:
                    self._set_hint("背包满了，拆不下来", seconds=1.0)
                    return

            if stack.qty > 1:
                stack.qty -= 1
            else:
                self.inventory.slots[int(self.inv_index)] = None

            try:
                self.gun.mods[slot_key] = str(getattr(mdef, "id", ""))
            except Exception:
                self.gun.mods = {slot_key: str(getattr(mdef, "id", ""))}

            # Installing parts changes timings/capacity: cancel reload and clamp mag.
            try:
                self.gun.reload_left = 0.0
                self.gun.reload_total = 0.0
            except Exception:
                pass
            self._reload_lock_dir = None

            gdef2 = self._gun_effective_def(self.gun)
            if gdef2 is not None:
                try:
                    self.gun.mag = int(clamp(int(self.gun.mag), 0, int(gdef2.mag_size)))
                except Exception:
                    pass

            self._set_hint(f"已安装 {getattr(mdef, 'name', '')}")
            return

        if idef.kind != "gun": 
            if idef.kind == "melee": 
                def clone_obj(o: object) -> object: 
                    if isinstance(o, dict): 
                        return {str(k): clone_obj(v) for k, v in o.items()} 
                    if isinstance(o, list): 
                        return [clone_obj(v) for v in o] 
                    if isinstance(o, tuple): 
                        return tuple(clone_obj(v) for v in o) 
                    return o 
 
                before_slots: list[HardcoreSurvivalState._ItemStack | None] = [] 
                for s in self.inventory.slots: 
                    if s is None: 
                        before_slots.append(None) 
                        continue 
                    before_slots.append( 
                        HardcoreSurvivalState._ItemStack( 
                            item_id=str(getattr(s, "item_id", "")), 
                            qty=int(getattr(s, "qty", 0)), 
                            meta=(clone_obj(getattr(s, "meta", {})) if isinstance(getattr(s, "meta", None), dict) else {}), 
                        ) 
                    ) 
 
                before_gun: HardcoreSurvivalState._Gun | None = None 
                if self.gun is not None: 
                    before_gun = HardcoreSurvivalState._Gun( 
                        gun_id=str(getattr(self.gun, "gun_id", "")), 
                        mag=int(getattr(self.gun, "mag", 0)), 
                        mods=dict(getattr(self.gun, "mods", {}) or {}), 
                        cooldown_left=float(getattr(self.gun, "cooldown_left", 0.0)), 
                        reload_left=float(getattr(self.gun, "reload_left", 0.0)), 
                        reload_total=float(getattr(self.gun, "reload_total", 0.0)), 
                    ) 
                before_melee = str(getattr(self, "melee_weapon_id", "") or "") 
                before_reload_lock = pygame.Vector2(getattr(self, "_reload_lock_dir", pygame.Vector2(0, 0))) if getattr(self, "_reload_lock_dir", None) is not None else None 
 
                try: 
                    new_melee_id = str(stack.item_id) 
                    if stack.qty > 1: 
                        stack.qty -= 1 
                    else: 
                        self.inventory.slots[int(self.inv_index)] = None 
 
                    if before_melee: 
                        left = int(self.inventory.add(before_melee, 1, self._ITEMS)) 
                        if left > 0: 
                            raise RuntimeError("inv_full_old_melee") 
 
                    if before_gun is not None and str(getattr(before_gun, "gun_id", "")): 
                        old_meta = {"mag": int(getattr(before_gun, "mag", 0)), "mods": dict(getattr(before_gun, "mods", {}) or {})} 
                        left = int(self.inventory.add(str(before_gun.gun_id), 1, self._ITEMS, meta=old_meta)) 
                        if left > 0: 
                            raise RuntimeError("inv_full_old_gun") 
 
                    self.gun = None 
                    self._reload_lock_dir = None 
                    self.melee_weapon_id = new_melee_id 
                except Exception: 
                    self.inventory.slots[:] = before_slots 
                    self.gun = before_gun 
                    self.melee_weapon_id = before_melee 
                    self._reload_lock_dir = before_reload_lock 
                    self._set_hint("背包满了，无法换近战", seconds=1.0) 
                    return 
 
                self._set_hint(f"装备近战 {idef.name}") 
                return 
 
            if idef.kind == "clothes": 
                new_outfit = self._CLOTHES_OUTFIT_INDEX.get(str(stack.item_id)) 
                if new_outfit is None: 
                    self._set_hint("未知衣服", seconds=1.0)
                    return
                if str(getattr(self, "clothes_id", "") or "") == str(stack.item_id):
                    self._set_hint("已经穿着了", seconds=0.8)
                    return

                old = str(getattr(self, "clothes_id", "") or "")
                if stack.qty > 1:
                    stack.qty -= 1
                else:
                    self.inventory.slots[int(self.inv_index)] = None

                if old:
                    left = int(self.inventory.add(old, 1, self._ITEMS))
                    if left > 0:
                        self.inventory.add(str(stack.item_id), 1, self._ITEMS)
                        self._set_hint("背包满了，无法换装", seconds=1.0)
                        return

                try:
                    self.avatar.outfit = int(new_outfit)
                    self.avatar.clamp_all()
                except Exception:
                    pass
                self.player_frames = HardcoreSurvivalState.build_avatar_player_frames(self.avatar, run=False)
                self.player_frames_run = HardcoreSurvivalState.build_avatar_player_frames(self.avatar, run=True)
                self.cyclist_frames = HardcoreSurvivalState.build_avatar_cyclist_frames(self.avatar)

                self.clothes_id = str(stack.item_id)
                self._set_hint(f"换装：{idef.name}")
                return

            if idef.kind in ("food", "drink", "med", "fuel"):
                ok = self._use_consumable(stack.item_id)
                if not ok:
                    if not str(getattr(self, "hint_text", "")).strip():
                        self._set_hint("暂时不能使用", seconds=1.0)
                    return
                if str(stack.item_id) == "cup_water":
                    # Drinking a cup leaves the empty cup behind (so you can refill it).
                    self.inventory.slots[int(self.inv_index)] = HardcoreSurvivalState._ItemStack(item_id="cup", qty=1)
                    return
                stack.qty -= 1
                if stack.qty <= 0:
                    self.inventory.slots[int(self.inv_index)] = None     
                return

            if str(getattr(idef, "kind", "")) == "tool":
                # Toggle "held in hand" for small tools (e.g. cup).
                held = getattr(self, "held_item", None)
                if isinstance(held, HardcoreSurvivalState._ItemStack):
                    left = int(self.inventory.add(str(held.item_id), int(held.qty), self._ITEMS))
                    if left > 0:
                        self._set_hint("背包满了")
                        return
                    self.held_item = None

                take = int(min(int(getattr(stack, "qty", 1)), 1))
                if take <= 0:
                    return
                stack.qty -= int(take)
                if int(stack.qty) <= 0:
                    self.inventory.slots[int(self.inv_index)] = None
                self.held_item = HardcoreSurvivalState._ItemStack(item_id=str(stack.item_id), qty=int(take))
                self._set_hint(f"拿在手上 {idef.name}")
                return
            self._set_hint("不能使用/装备")
            return

        gun_def = self._GUNS.get(stack.item_id)
        if gun_def is None:
            self._set_hint("未知枪械")
            return

        saved_meta: dict[str, object] = {}
        try: 
            if isinstance(getattr(stack, "meta", None), dict): 
                saved_meta = dict(getattr(stack, "meta", {})) 
        except Exception: 
            saved_meta = {} 

        def clone_obj(o: object) -> object: 
            if isinstance(o, dict): 
                return {str(k): clone_obj(v) for k, v in o.items()} 
            if isinstance(o, list): 
                return [clone_obj(v) for v in o] 
            if isinstance(o, tuple): 
                return tuple(clone_obj(v) for v in o) 
            return o 

        before_slots: list[HardcoreSurvivalState._ItemStack | None] = [] 
        for s in self.inventory.slots: 
            if s is None: 
                before_slots.append(None) 
                continue 
            before_slots.append( 
                HardcoreSurvivalState._ItemStack( 
                    item_id=str(getattr(s, "item_id", "")), 
                    qty=int(getattr(s, "qty", 0)), 
                    meta=(clone_obj(getattr(s, "meta", {})) if isinstance(getattr(s, "meta", None), dict) else {}), 
                ) 
            ) 

        before_gun: HardcoreSurvivalState._Gun | None = None 
        if self.gun is not None: 
            before_gun = HardcoreSurvivalState._Gun( 
                gun_id=str(getattr(self.gun, "gun_id", "")), 
                mag=int(getattr(self.gun, "mag", 0)), 
                mods=dict(getattr(self.gun, "mods", {}) or {}), 
                cooldown_left=float(getattr(self.gun, "cooldown_left", 0.0)), 
                reload_left=float(getattr(self.gun, "reload_left", 0.0)), 
                reload_total=float(getattr(self.gun, "reload_total", 0.0)), 
            ) 
        before_melee = str(getattr(self, "melee_weapon_id", "") or "") 
        before_reload_lock = pygame.Vector2(getattr(self, "_reload_lock_dir", pygame.Vector2(0, 0))) if getattr(self, "_reload_lock_dir", None) is not None else None 

        if stack.qty > 1: 
            stack.qty -= 1 
        else: 
            self.inventory.slots[int(self.inv_index)] = None 

        try: 
            if before_gun is not None: 
                old_meta = {"mag": int(getattr(before_gun, "mag", 0)), "mods": dict(getattr(before_gun, "mods", {}) or {})} 
                left = int(self.inventory.add(str(before_gun.gun_id), 1, self._ITEMS, meta=old_meta)) 
                if left > 0: 
                    raise RuntimeError("inv_full_old_gun") 

            if before_melee: 
                left = int(self.inventory.add(before_melee, 1, self._ITEMS)) 
                if left > 0: 
                    raise RuntimeError("inv_full_old_melee") 
        except Exception: 
            self.inventory.slots[:] = before_slots 
            self.gun = before_gun 
            self.melee_weapon_id = before_melee 
            self._reload_lock_dir = before_reload_lock 
            self._set_hint("背包满了，无法换枪", seconds=1.0) 
            return 
 
        mag = int(gun_def.mag_size)  
        mods: dict[str, str] = {}  
        try:  
            if isinstance(saved_meta, dict):
                if isinstance(saved_meta.get("mag"), (int, float)):
                    mag = int(saved_meta["mag"])
                if isinstance(saved_meta.get("mods"), dict):
                    mods = {str(k): str(v) for k, v in saved_meta["mods"].items()}
        except Exception:
            mag = int(gun_def.mag_size)
            mods = {}

        self.gun = HardcoreSurvivalState._Gun(gun_id=gun_def.id, mag=int(mag), mods=mods) 
        gdef2 = self._gun_effective_def(self.gun) 
        if gdef2 is not None: 
            self.gun.mag = int(clamp(int(self.gun.mag), 0, int(gdef2.mag_size))) 
        self._reload_lock_dir = None
        self.melee_weapon_id = "" 
        self._set_hint(f"装备 {gun_def.name}") 

    def _start_reload(self) -> None:
        if self.gun is None:
            self._set_hint("没有装备枪")
            return
        gun_def = self._gun_effective_def(self.gun)
        if gun_def is None:
            self._set_hint("未知枪械")
            return
        if self.gun.reload_left > 0.0:
            return
        need = int(gun_def.mag_size) - int(self.gun.mag)
        if need <= 0:
            self._set_hint("弹匣已满")
            return
        if self.inventory.count(gun_def.ammo_item) <= 0:
            self._set_hint("没有弹药")
            return
        lock = pygame.Vector2(self.aim_dir)
        if lock.length_squared() <= 0.001:
            lock = pygame.Vector2(self.player.facing)
        self._reload_lock_dir = lock.normalize() if lock.length_squared() > 0.001 else pygame.Vector2(1, 0)
        self.gun.reload_total = float(gun_def.reload_s)
        self.gun.reload_left = float(gun_def.reload_s)
        self._set_hint("换弹中…", seconds=0.8)

    def _start_punch(self) -> None: 
        # J: melee swing / punch (only when not holding a gun). 
        if self.player.hp <= 0: 
            return 
        if getattr(self, "mount", None) is not None: 
            self._set_hint("下车后才能出拳", seconds=0.9) 
            return 
        if self.gun is not None: 
            self._set_hint("手上拿着枪，不能近战；去背包装备木棍/钢管", seconds=1.0) 
            return 
        if ( 
            bool(getattr(self, "hr_interior", False)) 
            or bool(getattr(self, "sch_interior", False)) 
            or bool(getattr(self, "house_interior", False)) 
        ):
            return
        if float(getattr(self, "punch_cooldown_left", 0.0)) > 0.0:
            return

        # Punch direction follows movement/facing (NOT mouse aim), so left
        # punch always extends to the left when facing left.
        keys = pygame.key.get_pressed()
        move = pygame.Vector2(0, 0)
        if keys[pygame.K_w] or keys[pygame.K_UP]:
            move.y -= 1
        if keys[pygame.K_s] or keys[pygame.K_DOWN]:
            move.y += 1
        if keys[pygame.K_a] or keys[pygame.K_LEFT]:
            move.x -= 1
        if keys[pygame.K_d] or keys[pygame.K_RIGHT]:
            move.x += 1

        dname: str | None = None
        if move.length_squared() > 0.001:
            if abs(float(move.x)) >= abs(float(move.y)):
                dname = "right" if float(move.x) >= 0.0 else "left"
            else:
                dname = "down" if float(move.y) >= 0.0 else "up"
        else:
            dname = str(getattr(self.player, "dir", "down"))
            if dname not in ("left", "right", "up", "down"):
                dname = None

        if dname is None:
            f = pygame.Vector2(self.player.facing)
            if f.length_squared() <= 0.001:
                f = pygame.Vector2(1, 0)
            if abs(float(f.x)) >= abs(float(f.y)):
                dname = "right" if float(f.x) >= 0.0 else "left"
            else:
                dname = "down" if float(f.y) >= 0.0 else "up"

        dir_map = {
            "right": pygame.Vector2(1, 0),
            "left": pygame.Vector2(-1, 0),
            "down": pygame.Vector2(0, 1),
            "up": pygame.Vector2(0, -1),
        }
        self.punch_dir = pygame.Vector2(dir_map.get(dname, pygame.Vector2(1, 0)))
        self.punch_hand = 1 - int(getattr(self, "punch_hand", 0))
        mdef = self._MELEE_DEFS.get(str(getattr(self, "melee_weapon_id", "")) or "") or self._MELEE_DEFS.get("fist")
        if mdef is None:
            return
        self._melee_swing_id = str(getattr(mdef, "id", "fist"))
        self.punch_left = float(getattr(mdef, "total_s", self._PUNCH_TOTAL_S))
        self.punch_hit_done = False
        self.punch_cooldown_left = float(getattr(mdef, "cooldown_s", self._PUNCH_COOLDOWN_S))

        # Small stamina cost (no hard gate).
        try:
            cost = float(getattr(mdef, "stamina_cost", 5.0))
            self.player.stamina = float(clamp(float(self.player.stamina) - float(cost), 0.0, 100.0))
        except Exception:
            pass

        self.app.play_sfx("swing")

    def _update_punch(self, dt: float) -> None:
        self.punch_cooldown_left = max(0.0, float(getattr(self, "punch_cooldown_left", 0.0)) - dt)

        left = float(getattr(self, "punch_left", 0.0))
        if left <= 0.0:
            self.punch_left = 0.0
            return

        left = max(0.0, left - dt)
        self.punch_left = float(left)

        if bool(getattr(self, "punch_hit_done", False)):
            return

        mdef = self._MELEE_DEFS.get(str(getattr(self, "_melee_swing_id", "")) or "") or self._MELEE_DEFS.get("fist")
        total = float(getattr(mdef, "total_s", self._PUNCH_TOTAL_S)) if mdef is not None else float(self._PUNCH_TOTAL_S)
        t = 1.0 - float(left) / max(1e-6, total)
        base_hit_t = float(getattr(mdef, "hit_t", self._PUNCH_HIT_T)) if mdef is not None else float(self._PUNCH_HIT_T)
        windup_s = float(getattr(mdef, "windup_s", self._PUNCH_WINDUP_S)) if mdef is not None else float(self._PUNCH_WINDUP_S)
        hit_t = max(float(base_hit_t), float(windup_s) / max(1e-6, total))
        if t < hit_t:
            return

        self.punch_hit_done = True
        self._punch_apply_hit()

    def _punch_apply_hit(self) -> None:
        pdir = pygame.Vector2(getattr(self, "punch_dir", pygame.Vector2(0, 0)))
        if pdir.length_squared() <= 0.001:
            pdir = pygame.Vector2(self.player.facing)
        if pdir.length_squared() <= 0.001:
            pdir = pygame.Vector2(1, 0)
        pdir = pdir.normalize()

        mdef = self._MELEE_DEFS.get(str(getattr(self, "_melee_swing_id", "")) or "") or self._MELEE_DEFS.get("fist")

        origin = pygame.Vector2(self.player.pos)
        max_r = float(getattr(mdef, "range_px", getattr(self, "_PUNCH_RANGE_PX", 18.0))) if mdef is not None else float(getattr(self, "_PUNCH_RANGE_PX", 18.0))
        max_r2 = float(max_r * max_r)
        arc_dot = float(getattr(mdef, "arc_dot", getattr(self, "_PUNCH_ARC_DOT", 0.28))) if mdef is not None else float(getattr(self, "_PUNCH_ARC_DOT", 0.28))

        best: HardcoreSurvivalState._Zombie | None = None
        best_d2 = 1e18
        for z in self.zombies:
            if int(getattr(z, "hp", 0)) <= 0:
                continue
            to = pygame.Vector2(z.pos) - origin
            d2 = float(to.length_squared())
            if d2 > max_r2:
                continue
            if d2 > 0.001:
                dot = float(to.normalize().dot(pdir))
                if dot < arc_dot:
                    continue
            if d2 < best_d2:
                best = z
                best_d2 = d2

        dmg = int(getattr(mdef, "damage", self._PUNCH_DAMAGE)) if mdef is not None else int(self._PUNCH_DAMAGE)

        if best is not None:
            best.hp = int(best.hp) - int(dmg)
            if int(best.hp) > 0:
                stag_s = float(getattr(mdef, "stagger_s", self._PUNCH_STAGGER_S)) if mdef is not None else float(self._PUNCH_STAGGER_S)
                stag_spd = float(getattr(mdef, "stagger_speed", self._PUNCH_STAGGER_SPEED)) if mdef is not None else float(self._PUNCH_STAGGER_SPEED)
                best.stagger_left = max(float(getattr(best, "stagger_left", 0.0)), float(stag_s))
                best.stagger_vel = pygame.Vector2(pdir) * float(stag_spd)
            else:
                self._kill_zombie(best, impact_dir=pdir)

            self._spawn_hit_fx(pygame.Vector2(best.pos), dir=pdir)
            self.app.play_sfx("hit")
            nrad = float(getattr(mdef, "noise_radius", 120.0)) if mdef is not None else 120.0
            loud = 0.22 if str(getattr(mdef, "id", "fist")) == "fist" else 0.30
            self.noise_left = max(float(getattr(self, "noise_left", 0.0)), float(loud))
            self.noise_radius = max(float(getattr(self, "noise_radius", 0.0)), float(nrad))
            # Zombies become corpses (decay later) instead of being removed immediately.
            return

        # No zombie hit: allow melee to damage/break furniture (tables/chairs/etc).
        swing_id = str(getattr(mdef, "id", "fist")) if mdef is not None else "fist"
        struct_dmg = int(max(1, int(round(float(dmg) * 0.80))))
        if swing_id == "fist":
            struct_dmg = 1
        elif swing_id == "melee_pipe":
            struct_dmg = int(max(struct_dmg, 10))

        # Sample a few points along the swing reach to find a furniture tile.
        step_len = max(6.0, float(self.TILE_SIZE) * 0.45)
        steps = int(clamp(int(math.ceil(max_r / step_len)), 1, 10))
        for i in range(1, int(steps) + 1): 
            p = origin + pdir * (float(i) / float(steps)) * float(max_r) 
            tx = int(math.floor(float(p.x) / float(self.TILE_SIZE))) 
            ty = int(math.floor(float(p.y) / float(self.TILE_SIZE))) 
            if self._world_furniture_damage_at(int(tx), int(ty), dmg=int(struct_dmg), impact_dir=pygame.Vector2(pdir)): 
                nrad = float(getattr(mdef, "noise_radius", 120.0)) if mdef is not None else 120.0 
                loud = 0.18 if swing_id == "fist" else 0.26 
                self.noise_left = max(float(getattr(self, "noise_left", 0.0)), float(loud)) 
                self.noise_radius = max(float(getattr(self, "noise_radius", 0.0)), float(nrad)) 
                return 
        return 

    def _spawn_hit_fx(self, pos: pygame.Vector2, *, dir: pygame.Vector2) -> None:
        pos = pygame.Vector2(pos)
        d = pygame.Vector2(dir)
        if d.length_squared() <= 0.001:
            d = pygame.Vector2(1, 0)
        d = d.normalize()

        rnd = getattr(self, "fx_rng", None)
        if not isinstance(rnd, random.Random):
            rnd = random.Random(1234)

        base_ang = float(math.atan2(float(d.y), float(d.x)))
        count = 7
        for _ in range(count):
            ang = base_ang + float(rnd.uniform(-1.15, 1.15))
            spd = float(rnd.uniform(35.0, 130.0))
            vel = pygame.Vector2(math.cos(ang), math.sin(ang)) * spd
            ttl = float(rnd.uniform(0.10, 0.22))
            self.hit_fx.append(HardcoreSurvivalState._HitFX(pos=pygame.Vector2(pos), vel=vel, ttl=ttl))

        # A brighter "spark" reads better than pure blood at 1x.
        self.hit_fx.append(
            HardcoreSurvivalState._HitFX(
                pos=pygame.Vector2(pos) + d * 2.0,
                vel=pygame.Vector2(d) * 10.0,
                ttl=0.08,
                color=(255, 220, 160),
            )
        )

        if len(self.hit_fx) > 240:
            self.hit_fx = self.hit_fx[-240:]

    def _update_hit_fx(self, dt: float) -> None:
        if not getattr(self, "hit_fx", None):
            return
        alive: list[HardcoreSurvivalState._HitFX] = []
        for fx in self.hit_fx:
            fx.pos += fx.vel * dt
            fx.vel *= 0.82
            fx.ttl -= dt
            if float(fx.ttl) > 0.0:
                alive.append(fx)
        self.hit_fx = alive

    def _draw_hit_fx(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        if not getattr(self, "hit_fx", None):
            return
        for fx in self.hit_fx:
            p = pygame.Vector2(fx.pos) - pygame.Vector2(cam_x, cam_y)
            x = iround(float(p.x))
            y = iround(float(p.y))
            if not (0 <= x < INTERNAL_W and 0 <= y < INTERNAL_H):
                continue
            # Big at first, then fade to single pixels.
            if float(fx.ttl) > 0.14:
                surface.fill(fx.color, pygame.Rect(int(x), int(y), 2, 1))
            else:
                surface.fill(fx.color, pygame.Rect(int(x), int(y), 1, 1))

    def _toggle_vehicle(self) -> None:
        if self.mount is not None:
            mount_kind = str(self.mount)
            if self.mount == "rv":
                vehicle_pos = pygame.Vector2(self.rv.pos)
                vw, vh = float(self.rv.w), float(self.rv.h)
                self.rv.vel.update(0, 0)
                self.rv.speed = 0.0
                self.rv.steer = 0.0
            else:
                vehicle_pos = pygame.Vector2(self.bike.pos)
                vw, vh = float(self.bike.w), float(self.bike.h)
                self.bike.vel.update(0, 0)

            # Dismount: choose a nearby free spot. RV uses heading-relative exits so the
            # player doesn't overlap the rotated sprite.
            ph = float(max(int(self.player.w), int(getattr(self.player, "collider_h", self.player.h)))) / 2.0
            if self.mount == "rv":
                heading = float(getattr(self.rv, "heading", 0.0))
                fwd = pygame.Vector2(math.cos(float(heading)), math.sin(float(heading)))
                if fwd.length_squared() < 0.001:
                    fwd = pygame.Vector2(1, 0)
                fwd = fwd.normalize()
                right = pygame.Vector2(-float(fwd.y), float(fwd.x))
                side_margin = float(vh) / 2.0 + float(ph) + 8.0
                fwd_margin = float(vw) / 2.0 + float(ph) + 8.0
                exits = [
                    right * float(side_margin),
                    -right * float(side_margin),
                    fwd * float(fwd_margin),
                    -fwd * float(fwd_margin),
                ]
            else:
                exits = [
                    pygame.Vector2(vw / 2 + float(ph) + 4, 0),
                    pygame.Vector2(-(vw / 2 + float(ph) + 4), 0),
                    pygame.Vector2(0, vh / 2 + float(ph) + 4),
                    pygame.Vector2(0, -(vh / 2 + float(ph) + 4)),
                ]

            # Treat the vehicle as solid (as it will be after dismount) while searching.
            self.mount = None
            placed = False
            # Prevent dismount/teleporting through walls: require the path from the
            # vehicle center to the exit point to be unobstructed (except for the vehicle itself).
            ignore_rect: pygame.Rect | None = None
            try:
                if str(mount_kind) == "rv":
                    ignore_rect = self._rv_collider_rect_at(vehicle_pos)
                elif str(mount_kind) == "bike":
                    ignore_rect = pygame.Rect(
                        iround(float(vehicle_pos.x) - float(vw) / 2.0),
                        iround(float(vehicle_pos.y) - float(vh) / 2.0),
                        int(vw),
                        int(vh),
                    )
            except Exception:
                ignore_rect = None

            def path_clear(dst: pygame.Vector2) -> bool:
                try:
                    a = pygame.Vector2(vehicle_pos)
                    b = pygame.Vector2(dst)
                    d = b - a
                    dist = float(d.length())
                    if dist <= 0.5:
                        return True
                    step_len = max(1.0, float(self.TILE_SIZE) / 4.0)
                    steps = int(clamp(int(math.ceil(dist / step_len)), 1, 80))
                    for i in range(1, int(steps) + 1):
                        t = float(i) / float(steps)
                        p2 = a + d * t
                        hits = self._collide_rect_world(self.player.rect_at(p2))
                        if not hits:
                            continue
                        for hh in hits:
                            if ignore_rect is not None and hh == ignore_rect:
                                continue
                            return False
                    return True
                except Exception:
                    return False

            for off in exits:
                p = vehicle_pos + off
                if not self._collide_rect_world(self.player.rect_at(p)) and path_clear(p):
                    self.player.pos.update(p)
                    placed = True
                    break
            if not placed:
                self.mount = mount_kind
                self.player.pos.update(vehicle_pos)
                self._set_hint("下车位置被挡住", seconds=1.0)
                return

            self.mount = None
            self._set_hint("下车")
            return

        rv_d2 = float((self.player.pos - self.rv.pos).length_squared())
        bike_d2 = float((self.player.pos - self.bike.pos).length_squared())
        parked_chunk, parked_bike, parked_d2 = self._find_nearest_parked_bike(radius_px=18.0)
        # Cars are large; use a bigger pickup radius than bikes so you can interact near the doors.
        parked_car_chunk, parked_car, parked_car_d2 = self._find_nearest_parked_car(radius_px=70.0)
        try:
            pad = 22
            can_rv = bool(
                self._rv_collider_rect_at()
                .inflate(int(pad * 2), int(pad * 2))
                .collidepoint(int(round(float(self.player.pos.x))), int(round(float(self.player.pos.y))))
            )
        except Exception:
            can_rv = rv_d2 <= (22.0 * 22.0)
        can_bike = bike_d2 <= (18.0 * 18.0)
        can_parked_bike = parked_bike is not None and parked_chunk is not None
        can_parked_car = parked_car is not None and parked_car_chunk is not None
        if not can_rv and not can_bike and not can_parked_bike and not can_parked_car:
            self._set_hint("离载具太远")
            return

        # Choose the nearest available vehicle (parked beats personal when closer).
        choice: tuple[str, float] | None = None
        for kind, ok, d2 in (
            ("parked_car", bool(can_parked_car), float(parked_car_d2)),
            ("parked_bike", bool(can_parked_bike), float(parked_d2)),
            ("bike", bool(can_bike), float(bike_d2)),
            ("car", bool(can_rv), float(rv_d2)),
        ):
            if not ok:
                continue
            if choice is None or float(d2) < float(choice[1]):
                choice = (str(kind), float(d2))
        if choice is None:
            self._set_hint("离载具太远")
            return
        pick = str(choice[0])

        if pick == "parked_car":
            pc = parked_car
            if pc is None or parked_car_chunk is None:
                self._set_hint("离载具太远")
                return
            # Need to be actually close to the car, not just within the scan radius.
            try:
                pad = 22
                wpos = pygame.Vector2(getattr(pc, "pos", self.player.pos))
                mid = str(getattr(pc, "model_id", "rv"))
                cmodel = self._CAR_MODELS.get(str(mid)) or self._CAR_MODELS.get("rv")
                cw, ch = (cmodel.collider if cmodel is not None else (22, 14))
                chead = float(getattr(pc, "heading", 0.0))
                c = abs(math.cos(float(chead)))
                s = abs(math.sin(float(chead)))
                ww = float(cw) * c + float(ch) * s
                hh = float(cw) * s + float(ch) * c
                aabb = pygame.Rect(
                    iround(float(wpos.x) - float(ww) / 2.0),
                    iround(float(wpos.y) - float(hh) / 2.0),
                    int(max(2, int(round(float(ww))))),
                    int(max(2, int(round(float(hh))))),
                )
                near = bool(
                    aabb.inflate(int(pad * 2), int(pad * 2)).collidepoint(
                        int(round(float(self.player.pos.x))), int(round(float(self.player.pos.y)))
                    )
                )
            except Exception:
                near = (self.player.pos - pygame.Vector2(getattr(pc, "pos", self.player.pos))).length_squared() <= (22.0 * 22.0)
            if not near:
                self._set_hint("靠近后: F 开车", seconds=1.0)
                return
            if int(self.inventory.count("key_rv")) <= 0:
                self._set_hint("需要车钥匙", seconds=1.1)
                return
            try:
                self._stash_personal_car_as_parked()
            except Exception:
                pass
            self.rv.pos.update(pygame.Vector2(getattr(pc, "pos", self.player.pos)))
            self.rv.vel.update(0, 0)
            self.rv.model_id = str(getattr(pc, "model_id", "rv"))
            self.rv.fuel = float(getattr(pc, "fuel", 0.0))
            self.rv.heading = float(getattr(pc, "heading", 0.0))
            self.rv.speed = 0.0
            self.rv.steer = 0.0
            self._apply_rv_model()
            try:
                parked_car_chunk.cars.remove(pc)
            except Exception:
                pass
            self.mount = "rv"
            self.player.pos.update(self.rv.pos)
            self.player.vel.update(0, 0)
            model = self._CAR_MODELS.get(str(self.rv.model_id))
            name = model.name if model is not None else str(self.rv.model_id)
            self._set_hint(f"上车：{name}", seconds=1.0)
            return

        if pick == "parked_bike":
            # Take a parked two-wheeler (including motorcycles) and mount it.
            pb = parked_bike
            pb_mid = str(getattr(pb, "model_id", "bike")) if pb is not None else "bike"
            if pb_mid.startswith("moto") and int(self.inventory.count("key_moto")) <= 0:
                self._set_hint("需要摩托钥匙", seconds=1.1)
                return
            try:
                self._stash_personal_bike_as_parked()
            except Exception:
                pass
            self.bike.pos.update(pygame.Vector2(getattr(pb, "pos", self.player.pos)))
            self.bike.vel.update(0, 0)
            self.bike.model_id = str(getattr(pb, "model_id", "bike"))
            self.bike.fuel = float(getattr(pb, "fuel", 0.0))
            self.bike_dir = str(getattr(pb, "dir", "right"))
            self.bike_anim = 0.0
            self._apply_bike_model()
            try:
                parked_chunk.bikes.remove(pb)
            except Exception:
                pass
            self.mount = "bike"
            self.player.pos.update(self.bike.pos)
            self._set_hint(f"骑上 {self._two_wheel_name(self.bike.model_id)}")
            return

        if pick == "bike":
            mid = str(getattr(self.bike, "model_id", "bike"))
            if mid.startswith("moto") and int(self.inventory.count("key_moto")) <= 0:
                self._set_hint("需要摩托钥匙", seconds=1.1)
                return
            self.mount = "bike"
            self.player.pos.update(self.bike.pos)
            self._set_hint(f"骑上 {self._two_wheel_name(getattr(self.bike, 'model_id', 'bike'))}")
            return

        # Car (personal): F is always mount/drive. Use H to enter the RV interior.

        if int(self.inventory.count("key_rv")) <= 0:
            self._set_hint("需要车钥匙", seconds=1.1)
            return
        self.mount = "rv"
        self.player.pos.update(self.rv.pos)
        model = self._CAR_MODELS.get(str(getattr(self.rv, "model_id", "rv")))
        name = model.name if model is not None else str(getattr(self.rv, "model_id", "rv"))
        self._set_hint(f"上车：{name}", seconds=1.0)

    def _compute_aim_dir(self) -> pygame.Vector2:
        m = self.app.screen_to_internal(pygame.mouse.get_pos())
        if m is None:
            d = pygame.Vector2(self.player.facing)
            return d.normalize() if d.length_squared() > 0.001 else pygame.Vector2(1, 0)
        mw = pygame.Vector2(m) + pygame.Vector2(float(self.cam_x), float(self.cam_y))
        v = mw - self.player.pos
        if v.length_squared() <= 0.001:
            d = pygame.Vector2(self.player.facing)
            return d.normalize() if d.length_squared() > 0.001 else pygame.Vector2(1, 0)
        return v.normalize()

    def _fire(self) -> None:
        if self.gun is None:
            return
        gun_def = self._gun_effective_def(self.gun)
        if gun_def is None:
            return
        if self.gun.reload_left > 0.0 or self.gun.cooldown_left > 0.0:
            return
        if int(self.gun.mag) <= 0:
            self._set_hint("没子弹：按R换弹", seconds=0.8)
            return

        aim = pygame.Vector2(self.aim_dir)
        if aim.length_squared() <= 0.001:
            aim = pygame.Vector2(self.player.facing)
        if aim.length_squared() <= 0.001:
            aim = pygame.Vector2(1, 0)
        aim = aim.normalize()
        base_ang = math.atan2(aim.y, aim.x)
        spread = math.radians(float(gun_def.spread_deg))
        ang = base_ang + random.uniform(-spread, spread)
        d = pygame.Vector2(math.cos(ang), math.sin(ang))

        # Spawn from muzzle (hand-bone) so visuals match bullets.
        height_delta = 0
        av = getattr(self, "avatar", None)
        if av is not None:
            hidx = int(getattr(av, "height", 1))
            height_delta = 1 if hidx == 0 else -1 if hidx == 2 else 0

        face = pygame.Vector2(aim)
        if abs(face.y) >= abs(face.x):
            spr_dir = "down" if face.y >= 0 else "up"
        else:
            spr_dir = "right" if face.x >= 0 else "left"

        pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
        pf_run = getattr(self, "player_frames_run", None)
        is_run = bool(getattr(self, "player_sprinting", False))
        pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
        frames = pf.get(spr_dir, pf["down"])
        moving = self.player.vel.length_squared() > 1.0
        bob = 0
        step_idx = 0
        idle_anim = True
        if moving and len(frames) > 1:
            idle_anim = False
            walk = frames[1:]
            phase = (float(self.player.walk_phase) % math.tau) / math.tau
            step_idx = int(phase * len(walk)) % len(walk)
            if is_run and step_idx in (1, 4):
                bob = 1
            spr = walk[step_idx]
        else:
            spr = frames[0]

        rect = spr.get_rect()
        rect.midbottom = (
            iround(float(self.player.pos.x)),
            iround(float(self.player.pos.y) + float(self.player.h) / 2.0),
        )
        rect.y += int(bob)
        sk = self._survivor_skeleton_nodes(
            spr_dir,
            int(step_idx),
            idle=bool(idle_anim),
            height_delta=int(height_delta),
            run=bool(is_run),
        )
        hand_node = sk.get("r_hand")
        if hand_node is not None:
            hx, hy = hand_node
            base_hand = pygame.Vector2(int(rect.left + hx), int(rect.top + hy))
        else:
            base_hand = pygame.Vector2(rect.centerx, rect.centery + 3)
        muzzle = base_hand + aim * 17.0
        spawn = pygame.Vector2(muzzle)
        bkind = str(getattr(gun_def, "bullet_kind", "bullet"))
        self.bullets.append(
            HardcoreSurvivalState._Bullet(
                pos=spawn,
                vel=d * float(gun_def.bullet_speed),
                ttl=float(getattr(gun_def, "bullet_ttl", 1.35)),
                dmg=int(gun_def.damage),
                kind=bkind,
                aoe_radius=float(getattr(gun_def, "aoe_radius", 0.0)),
                aoe_damage=int(getattr(gun_def, "aoe_damage", 0)),
            )
        )
        self.gun.mag = int(self.gun.mag) - 1
        self.gun.cooldown_left = 1.0 / max(0.1, float(gun_def.fire_rate))
        self.app.play_sfx("shot")
        self.muzzle_flash_left = float(getattr(gun_def, "muzzle_flash_s", 0.06))
        self.noise_left = max(float(getattr(self, "noise_left", 0.0)), 0.95 if bkind == "rocket" else 0.55)
        self.noise_radius = max(float(getattr(self, "noise_radius", 0.0)), float(getattr(gun_def, "noise_radius", 220.0)))

    def _update_bullets(self, dt: float) -> None:
        if not self.bullets:
            return
        alive: list[HardcoreSurvivalState._Bullet] = []

        def explode(
            center: pygame.Vector2,
            *,
            radius: float,
            splash: int,
            direct: HardcoreSurvivalState._Zombie | None = None,
            direct_damage: int = 0,
        ) -> None:
            center = pygame.Vector2(center)
            radius = float(radius)
            splash = int(splash)
            direct_damage = int(direct_damage)

            # Direct hit (rockets).
            if direct is not None and int(getattr(direct, "hp", 0)) > 0 and direct_damage > 0:
                try:
                    direct.hp = int(direct.hp) - int(direct_damage)
                except Exception:
                    pass
                if int(getattr(direct, "hp", 0)) <= 0:
                    self._kill_zombie(direct, impact_dir=pygame.Vector2(direct.pos) - center)
                else:
                    to = pygame.Vector2(direct.pos) - center
                    if to.length_squared() > 0.001:
                        direct.stagger_left = max(float(getattr(direct, "stagger_left", 0.0)), 0.18)
                        direct.stagger_vel = to.normalize() * 120.0

            if radius <= 1.0 or splash <= 0:
                return

            r2 = float(radius * radius)
            for z in self.zombies:
                if direct is not None and z is direct:
                    continue
                if int(getattr(z, "hp", 0)) <= 0:
                    continue
                to = pygame.Vector2(z.pos) - center
                d2 = float(to.length_squared())
                if d2 > r2:
                    continue
                t = 1.0 - math.sqrt(d2) / max(1e-6, float(radius))
                dmg = int(max(1, int(round(float(splash) * (0.35 + 0.65 * float(t))))))
                z.hp = int(z.hp) - int(dmg)
                if int(z.hp) > 0:
                    z.stagger_left = max(float(getattr(z, "stagger_left", 0.0)), 0.18)
                    if to.length_squared() > 0.001:
                        z.stagger_vel = to.normalize() * (85.0 + 60.0 * float(t))
                else:
                    self._kill_zombie(z, impact_dir=to)

            # FX + noise.
            try:
                base_dir = pygame.Vector2(1, 0)
                if direct is not None:
                    base_dir = pygame.Vector2(direct.pos) - center
                self._spawn_hit_fx(center, dir=base_dir)
                for _ in range(10):
                    ang = random.random() * math.tau
                    spd = random.uniform(80.0, 220.0)
                    vel = pygame.Vector2(math.cos(ang), math.sin(ang)) * spd
                    self.hit_fx.append(
                        HardcoreSurvivalState._HitFX(pos=pygame.Vector2(center), vel=vel, ttl=0.18, color=(255, 190, 120))
                    )
            except Exception:
                pass
            self.noise_left = max(float(getattr(self, "noise_left", 0.0)), 1.0)
            self.noise_radius = max(float(getattr(self, "noise_radius", 0.0)), 420.0)

        for b in self.bullets:
            b.pos += b.vel * dt
            b.ttl -= dt
            bkind = str(getattr(b, "kind", "bullet"))

            if b.ttl <= 0.0:
                if bkind == "rocket":
                    explode(
                        pygame.Vector2(b.pos),
                        radius=float(getattr(b, "aoe_radius", 0.0)),
                        splash=int(getattr(b, "aoe_damage", 0)),
                    )
                continue

            tx = int(math.floor(b.pos.x / self.TILE_SIZE))
            ty = int(math.floor(b.pos.y / self.TILE_SIZE))
            tile = self.world.get_tile(tx, ty)
            if self._tile_solid(tile):
                if bkind == "rocket":
                    explode(
                        pygame.Vector2(b.pos),
                        radius=float(getattr(b, "aoe_radius", 0.0)),
                        splash=int(getattr(b, "aoe_damage", 0)),
                    )
                continue

            hit = False
            for z in self.zombies:
                if int(getattr(z, "hp", 0)) <= 0:
                    continue
                if z.rect().collidepoint(int(round(b.pos.x)), int(round(b.pos.y))):
                    if bkind == "rocket":
                        explode(
                            pygame.Vector2(b.pos),
                            radius=float(getattr(b, "aoe_radius", 0.0)),
                            splash=int(getattr(b, "aoe_damage", 0)),
                            direct=z,
                            direct_damage=int(getattr(b, "dmg", 0)),
                        )
                    else:
                        z.hp = int(z.hp) - int(b.dmg)
                        if int(z.hp) > 0:
                            z.stagger_left = max(float(getattr(z, "stagger_left", 0.0)), 0.12)
                            if b.vel.length_squared() > 0.1:
                                z.stagger_vel = pygame.Vector2(b.vel).normalize() * 85.0
                        else:
                            self._kill_zombie(z, impact_dir=pygame.Vector2(b.vel))
                    hit = True
                    break
            if hit:
                continue
            alive.append(b)

        self.bullets = alive
        # Zombies become corpses (decay later) instead of being removed immediately.

    def _thrown_furniture_try_place_at(self, tf: "HardcoreSurvivalState._ThrownFurniture", anchor_tx: int, anchor_ty: int) -> bool:
        try:
            tid = int(getattr(tf, "tid", 0))
            offsets = getattr(tf, "offsets", [])
        except Exception:
            return False
        if tid <= 0 or not isinstance(offsets, list) or not offsets:
            return False

        space = str(getattr(tf, "space", "world"))
        if space not in ("home", "rv", "world"):
            space = "world"

        anchor_tx = int(anchor_tx)
        anchor_ty = int(anchor_ty)
        cells: list[tuple[int, int]] = []
        for off in offsets:
            if not (isinstance(off, tuple) and len(off) == 2):
                continue
            dx, dy = int(off[0]), int(off[1])
            cells.append((int(anchor_tx + dx), int(anchor_ty + dy)))
        if not cells:
            return False

        for tx, ty in cells:
            if space == "rv":
                if not self._tile_in_rv_world(int(tx), int(ty)):
                    return False
                base = getattr(self, "_rv_world_floor_base", None)
                if not isinstance(base, dict):
                    return False
                want = base.get((int(tx), int(ty)))
                if want is None:
                    return False
                if int(self.world.peek_tile(int(tx), int(ty))) != int(want):
                    return False
            elif space == "home":
                if not self._tile_in_home_world(int(tx), int(ty)):
                    return False
                if int(self.world.peek_tile(int(tx), int(ty))) != int(self.T_FLOOR):
                    return False
            else:
                base_tid = int(self.world.peek_tile(int(tx), int(ty)))
                if int(base_tid) in self._WORLD_FURNITURE_HP_DEFAULTS:
                    return False
                if int(base_tid) in (
                    int(self.T_DOOR),
                    int(self.T_DOOR_HOME),
                    int(self.T_DOOR_BROKEN),
                    int(self.T_STAIRS_UP),
                    int(self.T_STAIRS_DOWN),
                    int(self.T_ELEVATOR),
                ):
                    return False
                if bool(self._tile_solid(int(base_tid))):
                    return False

        for tx, ty in cells:
            self._world_set_tile(int(tx), int(ty), int(tid))

        hp = getattr(tf, "hp", None)
        if hp is not None:
            try:
                anchor = min(cells)
                self.world_furniture_hp[self._world_furniture_hp_key(int(anchor[0]), int(anchor[1]))] = int(hp)
            except Exception:
                pass
        return True

    def _thrown_furniture_break_drop(self, *, tid: int, cells_n: int, pos: pygame.Vector2, impact_dir: pygame.Vector2) -> None:
        tid = int(tid)
        cells_n = int(max(1, int(cells_n)))
        pos = pygame.Vector2(pos)
        d = pygame.Vector2(impact_dir)
        if d.length_squared() <= 0.001:
            d = pygame.Vector2(1, 0)
        self._spawn_hit_fx(pos, dir=d)
        self.app.play_sfx("hit")
        try:
            extra = max(0, int(cells_n) - 1)
            if int(tid) in self._WORLD_FURNITURE_WOOD_TILES:
                self._drop_world_item(pos, "wood", int(clamp(random.randint(1, 2) + extra, 1, 6)))
            elif int(tid) in self._WORLD_FURNITURE_METAL_TILES:
                self._drop_world_item(pos, "scrap", int(clamp(random.randint(1, 2) + extra, 1, 6)))
        except Exception:
            pass
        self.noise_left = max(float(getattr(self, "noise_left", 0.0)), 0.28)
        self.noise_radius = max(float(getattr(self, "noise_radius", 0.0)), 190.0)

    def _update_thrown_furniture(self, dt: float) -> None:
        thrown = getattr(self, "thrown_furniture", None)
        if not isinstance(thrown, list) or not thrown:
            return
        alive: list[HardcoreSurvivalState._ThrownFurniture] = []
        ts = float(max(1, int(self.TILE_SIZE)))

        for tf in thrown:
            if not isinstance(tf, HardcoreSurvivalState._ThrownFurniture):
                continue

            tf.ttl = float(getattr(tf, "ttl", 0.0)) - float(dt)
            # Simple drag so throws feel weighty.
            try:
                tf.vel *= max(0.0, 1.0 - float(dt) * 1.8)
            except Exception:
                pass

            next_pos = pygame.Vector2(getattr(tf, "pos", pygame.Vector2(0, 0))) + pygame.Vector2(getattr(tf, "vel", pygame.Vector2(0, 0))) * float(dt)
            cells_n = int(max(1, len(getattr(tf, "offsets", []))))
            hit_rad = 6 + 2 * int(min(4, max(0, cells_n - 1)))

            # Zombie hit first (treat as a weapon impact; it breaks on hit).
            hit_z: HardcoreSurvivalState._Zombie | None = None
            for z in self.zombies:
                if int(getattr(z, "hp", 0)) <= 0:
                    continue
                try:
                    if z.rect().inflate(int(hit_rad), int(hit_rad)).collidepoint(int(round(next_pos.x)), int(round(next_pos.y))):
                        hit_z = z
                        break
                except Exception:
                    continue
            if hit_z is not None:
                dmg = int(10 + 3 * int(min(4, max(0, cells_n - 1))))
                try:
                    hit_z.hp = int(hit_z.hp) - int(dmg)
                except Exception:
                    pass
                if int(getattr(hit_z, "hp", 0)) > 0:
                    try:
                        hit_z.stagger_left = max(float(getattr(hit_z, "stagger_left", 0.0)), 0.22)
                        v = pygame.Vector2(getattr(tf, "vel", pygame.Vector2(1, 0)))
                        if v.length_squared() > 0.001:
                            hit_z.stagger_vel = v.normalize() * 140.0
                    except Exception:
                        pass
                else:
                    self._kill_zombie(hit_z, impact_dir=pygame.Vector2(getattr(tf, "vel", pygame.Vector2(1, 0))))
                self._thrown_furniture_break_drop(tid=int(getattr(tf, "tid", 0)), cells_n=int(cells_n), pos=pygame.Vector2(hit_z.pos), impact_dir=pygame.Vector2(getattr(tf, "vel", pygame.Vector2(1, 0))))
                continue

            # Tile collision / landing.
            tx = int(math.floor(float(next_pos.x) / ts))
            ty = int(math.floor(float(next_pos.y) / ts))
            if float(getattr(tf, "ttl", 0.0)) <= 0.0 or bool(self._tile_solid(int(self.world.get_tile(int(tx), int(ty))))):
                placed = False
                # Try a few nearby tiles so it "lands" naturally instead of always breaking.
                for ox, oy in (
                    (0, 0),
                    (1, 0),
                    (-1, 0),
                    (0, 1),
                    (0, -1),
                    (1, 1),
                    (1, -1),
                    (-1, 1),
                    (-1, -1),
                ):
                    if self._thrown_furniture_try_place_at(tf, int(tx + ox), int(ty + oy)):
                        placed = True
                        break
                if not placed:
                    self._thrown_furniture_break_drop(tid=int(getattr(tf, "tid", 0)), cells_n=int(cells_n), pos=pygame.Vector2(getattr(tf, "pos", next_pos)), impact_dir=pygame.Vector2(getattr(tf, "vel", pygame.Vector2(1, 0))))
                continue

            tf.pos = pygame.Vector2(next_pos)
            alive.append(tf)

        self.thrown_furniture = alive

    def _kill_zombie(self, z: "HardcoreSurvivalState._Zombie", *, impact_dir: pygame.Vector2 | None = None) -> None:
        # Convert a zombie into a corpse that slowly decays away.
        try:
            if int(getattr(z, "hp", 0)) <= 0 and float(getattr(z, "corpse_left", 0.0)) > 0.0:
                return
        except Exception:
            pass

        try:
            z.hp = 0
        except Exception:
            return

        try:
            z.vel.update(0, 0)
        except Exception:
            z.vel = pygame.Vector2(0, 0)
        try:
            z.stagger_left = 0.0
            z.stagger_vel.update(0, 0)
        except Exception:
            pass

        try:
            z.death_t = 0.0
            total = float(getattr(self, "_ZOMBIE_CORPSE_TOTAL_S", 14.0))
            z.corpse_total = float(total)
            z.corpse_left = float(total)
        except Exception:
            pass

        # Orient the corpse based on the impact direction (purely visual).
        try:
            if isinstance(impact_dir, pygame.Vector2) and impact_dir.length_squared() > 0.001:
                v = pygame.Vector2(impact_dir)
                if abs(float(v.x)) >= abs(float(v.y)):
                    z.dir = "right" if float(v.x) >= 0 else "left"
                else:
                    z.dir = "down" if float(v.y) >= 0 else "up"
        except Exception:
            pass

        self._on_zombie_killed(z)

    def _push_corpse_off_vehicle(
        self,
        z: "HardcoreSurvivalState._Zombie",
        *,
        vehicle_rect: pygame.Rect,
        dir_vec: pygame.Vector2,
    ) -> None:
        """Prevent vehicle-killed corpses from sitting on top of the vehicle."""
        try:
            if int(getattr(z, "hp", 0)) > 0:
                return
            if float(getattr(z, "corpse_left", 0.0)) <= 0.0:
                return
        except Exception:
            return

        try:
            if not z.rect().colliderect(vehicle_rect):
                return
        except Exception:
            return

        base = pygame.Vector2(getattr(z, "pos", pygame.Vector2(0, 0)))
        try:
            d = pygame.Vector2(dir_vec)
            if d.length_squared() <= 0.001:
                d = pygame.Vector2(1, 0)
            else:
                d = d.normalize()
        except Exception:
            d = pygame.Vector2(1, 0)
        right = pygame.Vector2(-float(d.y), float(d.x))

        # Prefer pushing forward far enough to clear the vehicle AABB.
        try:
            push = float(max(int(vehicle_rect.w), int(vehicle_rect.h))) * 0.55 + 10.0
        except Exception:
            push = 58.0
        push = float(clamp(push, 24.0, 140.0))

        offsets = [
            d * push,
            d * push + right * 14.0,
            d * push - right * 14.0,
            d * (push * 1.25),
            right * (push * 0.55),
            -right * (push * 0.55),
        ]

        for off in offsets:
            try:
                cand = pygame.Vector2(base) + pygame.Vector2(off)
                tx = int(math.floor(float(cand.x) / float(self.TILE_SIZE)))
                ty = int(math.floor(float(cand.y) / float(self.TILE_SIZE)))
                tid = int(self.world.get_tile(int(tx), int(ty)))
                if bool(self._tile_solid(int(tid))):
                    continue
                z.pos.update(cand)
                if not z.rect().colliderect(vehicle_rect):
                    return
            except Exception:
                continue

        # Last resort: march forward until clear.
        try:
            for i in range(1, 30):
                cand = pygame.Vector2(base) + d * float(push + i * 6.0)
                tx = int(math.floor(float(cand.x) / float(self.TILE_SIZE)))
                ty = int(math.floor(float(cand.y) / float(self.TILE_SIZE)))
                tid = int(self.world.get_tile(int(tx), int(ty)))
                if bool(self._tile_solid(int(tid))):
                    continue
                z.pos.update(cand)
                if not z.rect().colliderect(vehicle_rect):
                    return
        except Exception:
            pass

        # Restore if we couldn't find a better spot.
        try:
            z.pos.update(base)
        except Exception:
            pass

    def _drop_world_item(self, pos: pygame.Vector2, item_id: str, qty: int) -> None:
        item_id = str(item_id)
        qty = int(qty)
        if qty <= 0:
            return
        tx = int(math.floor(float(pos.x) / self.TILE_SIZE))
        ty = int(math.floor(float(pos.y) / self.TILE_SIZE))
        chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
        chunk.items.append(HardcoreSurvivalState._WorldItem(pos=pygame.Vector2(pos), item_id=item_id, qty=qty))

    def _on_zombie_killed(self, z: "HardcoreSurvivalState._Zombie") -> None:
        kind = str(getattr(z, "kind", "walker"))
        pos = pygame.Vector2(z.pos)

        # Lightweight loot loop: enough to reinforce survival, not enough to break it.
        if random.random() < 0.22:
            self._drop_world_item(pos, "scrap", random.randint(1, 2))
        if random.random() < (0.12 if kind == "runner" else 0.06):
            self._drop_world_item(pos, "ammo_9mm", random.randint(3, 7))
        if random.random() < (0.06 if kind == "runner" else 0.02):
            self._drop_world_item(pos, random.choice(["ammo_556", "ammo_762"]), random.randint(2, 6))
        if random.random() < 0.008:
            self._drop_world_item(pos, "ammo_rocket", 1)
        if kind == "screamer" and random.random() < 0.045:
            self._drop_world_item(
                pos,
                random.choice(
                    [
                        "mod_optic_reddot",
                        "mod_optic_4x",
                        "mod_optic_holo",
                        "mod_muzzle_suppressor_9mm",
                        "mod_muzzle_suppressor_rifle",
                        "mod_muzzle_flash_hider_rifle",
                        "mod_undergrip_stab",
                        "mod_undergrip_bipod",
                        "mod_stock_tactical",
                        "mod_trigger_light",
                    ]
                ),
                1,
            )
        if random.random() < 0.07:
            self._drop_world_item(pos, "bandage", 1)
        if random.random() < 0.05:
            self._drop_world_item(pos, random.choice(["cola", "food_can", "water"]), 1)

    def _pick_zombie_kind(self, *, in_town: bool) -> str:
        season = int(self._season_index())
        tday = (float(self.world_time_s) % float(self.DAY_LENGTH_S)) / max(1e-6, float(self.DAY_LENGTH_S))
        night = bool(tday < 0.25 or tday > 0.75)

        weights: dict[str, float] = {"walker": 0.72, "runner": 0.22, "screamer": 0.06}
        if in_town:
            weights = {"walker": 0.55, "runner": 0.25, "screamer": 0.20}

        if night:
            weights["runner"] += 0.10
            weights["screamer"] += 0.06
            weights["walker"] -= 0.16

        # Season flavor (lightweight).
        if season == 1:  # summer
            weights["screamer"] += 0.05
            weights["walker"] -= 0.05
        elif season == 2:  # autumn
            weights["walker"] += 0.08
            weights["runner"] -= 0.04
        elif season == 3:  # winter
            weights["walker"] += 0.10
            weights["runner"] -= 0.06
            weights["screamer"] -= 0.04

        total = 0.0
        for v in weights.values():
            total += max(0.0, float(v))
        if total <= 0.0001:
            return "walker"
        r = random.random() * total
        acc = 0.0
        for k in ("walker", "runner", "screamer"):
            acc += max(0.0, float(weights.get(k, 0.0)))
            if r <= acc:
                return k
        return "walker"

    def _spawn_one_zombie(self, target_pos: pygame.Vector2, *, in_town: bool) -> None:
        kind = self._pick_zombie_kind(in_town=in_town)
        mdef = self._MONSTER_DEFS.get(kind, self._MONSTER_DEFS["walker"])
        # Spawn outside the current camera view so zombies "walk in" instead of popping in.
        view_r = float(math.hypot(float(INTERNAL_W) * 0.5, float(INTERNAL_H) * 0.5))
        min_dist = view_r + (70.0 if in_town else 110.0)
        max_dist = min_dist + (160.0 if in_town else 260.0)
        for _ in range(24):
            ang = random.random() * math.tau
            dist = random.uniform(float(min_dist), float(max_dist))
            pos = pygame.Vector2(target_pos) + pygame.Vector2(math.cos(ang), math.sin(ang)) * float(dist)
            tx = int(math.floor(pos.x / self.TILE_SIZE))
            ty = int(math.floor(pos.y / self.TILE_SIZE))
            tile = int(self.world.get_tile(tx, ty))
            if self._tile_solid(tile):
                continue
            # Don't spawn zombies inside buildings or on interior tiles.
            if tile in (int(self.T_FLOOR), int(self.T_DOOR)):
                continue
            chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
            in_building = False
            for bx0, by0, bw, bh, _roof_kind, _floors in getattr(chunk, "buildings", []):
                if int(bx0) <= int(tx) < int(bx0) + int(bw) and int(by0) <= int(ty) < int(by0) + int(bh):
                    in_building = True
                    break
            if in_building:
                continue
            hp = int(mdef.hp) + (6 if in_town else 0)
            speed = float(mdef.speed)
            z = HardcoreSurvivalState._Zombie(
                pos=pos,
                vel=pygame.Vector2(0, 0),
                hp=hp,
                speed=speed,
                kind=str(kind),
                dir="down",
                anim=random.random() * 2.0,
                attack_left=random.random() * float(mdef.attack_cd),
                scream_left=(random.random() * float(mdef.scream_cd) if float(mdef.scream_cd) > 0.0 else 0.0),
                wander_dir=pygame.Vector2(0, 0),
                wander_left=0.0,
                stagger_left=0.0,
                stagger_vel=pygame.Vector2(0, 0),
            )
            self.zombies.append(z)
            return

    def _update_zombies(self, dt: float) -> None:
        target = pygame.Vector2(self.player.pos)
        suppress_gather = False
        try:
            tx = int(math.floor(float(target.x) / float(self.TILE_SIZE)))
            ty = int(math.floor(float(target.y) / float(self.TILE_SIZE)))
            p_tile = int(self.world.get_tile(int(tx), int(ty)))
            if p_tile in (
                int(self.T_FLOOR),
                int(self.T_DOOR),
                int(self.T_ELEVATOR),
                int(self.T_STAIRS_UP),
                int(self.T_STAIRS_DOWN),
            ):
                found = self._multi_house_at(int(tx), int(ty))
                if found is not None:
                    chunk, mh = found
                    style = 0
                    tx0 = int(getattr(mh, "tx0", 0))
                    ty0 = int(getattr(mh, "ty0", 0))
                    bw = int(getattr(mh, "w", 0))
                    bh = int(getattr(mh, "h", 0))
                    for b in getattr(chunk, "buildings", []):
                        if int(b[0]) == int(tx0) and int(b[1]) == int(ty0) and int(b[2]) == int(bw) and int(b[3]) == int(bh):
                            roof_kind = int(b[4]) if len(b) > 4 else 0
                            style, _var = self._building_roof_style_var(int(roof_kind))
                            break
                    if int(style) == 6:
                        cur_floor = int(max(1, int(getattr(mh, "cur_floor", 1))))
                        if int(cur_floor) > 4:
                            suppress_gather = True
        except Exception:
            suppress_gather = False

        # Update corpse decay + vehicle-hit cooldown, and drop fully decayed corpses.
        if self.zombies:
            kept: list[HardcoreSurvivalState._Zombie] = []
            for z in self.zombies:
                try:
                    z.vehicle_hit_left = max(0.0, float(getattr(z, "vehicle_hit_left", 0.0)) - dt)
                except Exception:
                    pass

                if int(getattr(z, "hp", 0)) > 0:
                    kept.append(z)
                    continue

                corpse_left = float(getattr(z, "corpse_left", 0.0))
                if corpse_left <= 0.0:
                    continue
                try:
                    z.corpse_left = max(0.0, float(corpse_left) - dt)
                    z.death_t = float(getattr(z, "death_t", 0.0)) + dt
                except Exception:
                    pass
                if float(getattr(z, "corpse_left", 0.0)) > 0.0:
                    kept.append(z)
            self.zombies = kept

        # Vehicle collision: drive into zombies to damage/kill them (they become corpses).
        try:
            if self.mount == "rv" and self.zombies:
                v = pygame.Vector2(getattr(self.rv, "vel", pygame.Vector2(0, 0)))
                spd = float(v.length())
                if spd >= 12.0:
                    vrect = self._rv_collider_rect_at()
                    hitrect = vrect.inflate(-max(0, int(vrect.w // 4)), -max(0, int(vrect.h // 4)))
                    if hitrect.w <= 0 or hitrect.h <= 0:
                        hitrect = vrect
                    dir_vec = v.normalize() if v.length_squared() > 0.001 else pygame.Vector2(1, 0)
                    hit_cd = float(getattr(self, "_ZOMBIE_VEHICLE_HIT_CD_S", 0.18))
                    for z in self.zombies:
                        if int(getattr(z, "hp", 0)) <= 0:
                            continue
                        if float(getattr(z, "vehicle_hit_left", 0.0)) > 0.0:
                            continue
                        if hitrect.colliderect(z.rect()):
                            z.vehicle_hit_left = float(hit_cd)
                            dmg = int(clamp(spd * 0.45, 10.0, 120.0))
                            z.hp = int(z.hp) - int(dmg)
                            if int(z.hp) <= 0:
                                self._kill_zombie(z, impact_dir=v)
                                try:
                                    self._push_corpse_off_vehicle(z, vehicle_rect=vrect, dir_vec=dir_vec)
                                except Exception:
                                    pass
                            else:
                                z.stagger_left = max(float(getattr(z, "stagger_left", 0.0)), 0.22)
                                z.stagger_vel = pygame.Vector2(dir_vec) * min(260.0, spd * 1.35)
                                self._spawn_hit_fx(pygame.Vector2(z.pos), dir=dir_vec)
        except Exception:
            pass

        cap = max(0, int(getattr(self, "zombie_cap", 8)))
        if cap <= 0:
            return

        alive_n = 0
        for z in self.zombies:
            if int(getattr(z, "hp", 0)) > 0:
                alive_n += 1

        self.spawn_left -= dt
        if suppress_gather:
            # High floors shouldn't endlessly pull/spawn hordes at the building base.
            self.spawn_left = max(float(self.spawn_left), 3.0)
        elif self.spawn_left <= 0.0 and int(alive_n) < int(cap):
            tx = int(math.floor(target.x / self.TILE_SIZE))
            ty = int(math.floor(target.y / self.TILE_SIZE))
            chunk = self.world.get_chunk(tx // self.CHUNK_SIZE, ty // self.CHUNK_SIZE)
            in_town = chunk.town_kind is not None
            self.spawn_left = 6.5 if in_town else 10.0
            spawn_n = 1
            for _ in range(spawn_n):
                self._spawn_one_zombie(target, in_town=in_town)
                # Re-count alive zombies so corpses don't block spawns.
                alive_n = 0
                for zz in self.zombies:
                    if int(getattr(zz, "hp", 0)) > 0:
                        alive_n += 1

        if getattr(self, "zombie_frozen", False):
            for z in self.zombies:
                z.vel.update(0, 0)
            return

        for z in self.zombies:
            if int(getattr(z, "hp", 0)) <= 0:
                continue
            kind = str(getattr(z, "kind", "walker"))
            mdef = self._MONSTER_DEFS.get(kind, self._MONSTER_DEFS["walker"])

            z.attack_left = max(0.0, float(getattr(z, "attack_left", 0.0)) - dt)
            z.scream_left = max(0.0, float(getattr(z, "scream_left", 0.0)) - dt)
            z.wander_left = max(0.0, float(getattr(z, "wander_left", 0.0)) - dt)
            z.stagger_left = max(0.0, float(getattr(z, "stagger_left", 0.0)) - dt)

            if float(z.stagger_left) > 0.0:
                z.pos = self._move_box(z.pos, z.stagger_vel, dt, w=z.w, h=z.h)
                z.stagger_vel *= 0.86
                z.anim = float(z.anim) + dt * 10.0
                continue

            to_p = target - z.pos
            d2 = float(to_p.length_squared())

            sense = float(mdef.sense)
            # Vehicles are loud: pull monsters from farther away (even if RV is "safe").
            if (not suppress_gather) and self.mount == "rv":
                sense += 80.0 + min(120.0, abs(float(getattr(self.rv, "speed", 0.0))) * 1.1)
            if (not suppress_gather) and getattr(self, "noise_left", 0.0) > 0.0:
                sense = max(sense, float(getattr(self, "noise_radius", 0.0)))

            alerted = (not suppress_gather) and d2 <= (sense * sense)
            if alerted:
                if kind == "screamer" and float(z.scream_left) <= 0.0 and d2 <= float(mdef.scream_radius) ** 2:
                    z.scream_left = float(mdef.scream_cd)
                    if int(alive_n) < int(cap):
                        for _ in range(int(mdef.scream_spawn)):
                            if int(alive_n) >= int(cap):
                                break
                            self._spawn_one_zombie(target, in_town=True)
                            before = int(alive_n)
                            alive_n = 0
                            for zz in self.zombies:
                                if int(getattr(zz, "hp", 0)) > 0:
                                    alive_n += 1
                            if int(alive_n) <= int(before):
                                break
                    self._set_hint("尖叫声……更多怪物来了！", seconds=1.3)

                if d2 > 1.0:
                    dir_vec = to_p.normalize()
                    want = dir_vec * float(z.speed)
                    accel = 5.5 if kind == "runner" else 3.6 if kind == "screamer" else 2.8
                    a = float(clamp(1.0 - math.exp(-dt * float(accel)), 0.0, 1.0))
                    z.vel = z.vel.lerp(want, a)
                else:
                    z.vel.update(0, 0)
            else:
                if float(z.wander_left) <= 0.0 or z.wander_dir.length_squared() <= 0.001:
                    ang = random.random() * math.tau
                    z.wander_dir = pygame.Vector2(math.cos(ang), math.sin(ang))
                    z.wander_left = random.uniform(0.6, 1.8)
                want = pygame.Vector2(z.wander_dir) * float(mdef.roam_speed)
                accel = 3.0 if kind == "runner" else 2.2 if kind == "screamer" else 1.8
                a = float(clamp(1.0 - math.exp(-dt * float(accel)), 0.0, 1.0))
                z.vel = z.vel.lerp(want, a)

            if z.vel.length_squared() > 0.1:
                ztx = int(math.floor(z.pos.x / self.TILE_SIZE))
                zty = int(math.floor(z.pos.y / self.TILE_SIZE))
                z_under = self.world.get_tile(ztx, zty)
                z.vel *= self._tile_slow(z_under) * self._weather_move_mult()
                if abs(float(z.vel.y)) >= abs(float(z.vel.x)):
                    z.dir = "down" if float(z.vel.y) >= 0 else "up"
                else:
                    z.dir = "right" if float(z.vel.x) >= 0 else "left"
                anim_base = 1.8 if kind == "walker" else 2.4 if kind == "screamer" else 3.4
                z.anim = float(z.anim) + dt * float(anim_base) * (z.vel.length() / max(1.0, float(z.speed)))
            else:
                z.anim = float(z.anim) * 0.88

            z.pos = self._move_box(z.pos, z.vel, dt, w=z.w, h=z.h)       

            # Player/zombie collision volume (prevent overlap).
            if self.mount != "rv":
                try:
                    prect = self.player.rect_at()
                    zrect = z.rect()
                    if zrect.colliderect(prect):
                        dx = float(zrect.centerx - prect.centerx)
                        dy = float(zrect.centery - prect.centery)
                        overlap_x = (float(zrect.w) + float(prect.w)) / 2.0 - abs(dx)
                        overlap_y = (float(zrect.h) + float(prect.h)) / 2.0 - abs(dy)
                        if overlap_x > 0.0 and overlap_y > 0.0:
                            sign_x = 1.0 if dx >= 0.0 else -1.0
                            sign_y = 1.0 if dy >= 0.0 else -1.0
                            if dx == 0.0:
                                sign_x = 1.0 if ((int(zrect.centerx) + int(zrect.centery)) & 1) else -1.0
                            if dy == 0.0:
                                sign_y = 1.0 if ((int(zrect.centerx) - int(zrect.centery)) & 1) else -1.0
                            move_x = int(sign_x * math.ceil(overlap_x))
                            move_y = int(sign_y * math.ceil(overlap_y))
                            # Prefer the smaller axis push, but don't shove into walls.
                            candidates: list[tuple[int, int]] = []
                            if float(overlap_x) <= float(overlap_y):
                                candidates = [(int(move_x), 0), (0, int(move_y))]
                            else:
                                candidates = [(0, int(move_y)), (int(move_x), 0)]
                            moved = False
                            for mx, my in candidates:
                                if mx == 0 and my == 0:
                                    continue
                                test = zrect.move(int(mx), int(my))
                                if not self._collide_rect_world(test):
                                    zrect = test
                                    moved = True
                                    break
                            if not moved and candidates:
                                zrect = zrect.move(int(candidates[0][0]), int(candidates[0][1]))
                            z.pos.update(float(zrect.centerx), float(zrect.centery))
                except Exception:
                    pass

            if self.mount != "rv" and float(z.attack_left) <= 0.0 and (z.pos - self.player.pos).length_squared() <= float(mdef.attack_range) ** 2:       
                z.attack_left = float(mdef.attack_cd)
                self.player.hp = max(0, int(self.player.hp) - int(mdef.dmg))
                self.player.morale = float(clamp(self.player.morale - (2.0 + float(mdef.dmg) * 0.35), 0.0, 100.0))

                # Chance to inflict a bleeding wound (scratch/bite).
                try:
                    chance = float(clamp(0.12 + 0.02 * float(mdef.dmg), 0.08, 0.55))
                    if random.random() < chance:
                        dx = float(self.player.pos.x - z.pos.x)
                        dy = float(self.player.pos.y - z.pos.y)
                        side_left = dx > 0.0
                        part = "torso"
                        if abs(dy) > abs(dx) and dy > 0.0 and random.random() < 0.18:
                            part = "head"
                        elif random.random() < 0.38:
                            part = "torso"
                        else:
                            if abs(dx) >= abs(dy):
                                part = "left_arm" if side_left else "right_arm"
                                if random.random() < 0.35:
                                    part = "left_leg" if side_left else "right_leg"
                            else:
                                part = "left_leg" if side_left else "right_leg"
                                if random.random() < 0.35:
                                    part = "left_arm" if side_left else "right_arm"
                        rate = float(clamp(0.18 + 0.01 * float(mdef.dmg), 0.12, 0.60))
                        self._inflict_wound(part, rate=rate)
                except Exception:
                    pass

    def _season_index(self) -> int:
        day = int(self.world_time_s / max(1e-6, self.DAY_LENGTH_S)) + 1
        return ((day - 1) // max(1, int(self.SEASON_LENGTH_DAYS))) % len(self.SEASONS)

    def _tint(self, c: tuple[int, int, int], *, add: tuple[int, int, int] = (0, 0, 0)) -> tuple[int, int, int]:
        r = int(clamp(c[0] + add[0], 0, 255))
        g = int(clamp(c[1] + add[1], 0, 255))
        b = int(clamp(c[2] + add[2], 0, 255))
        return r, g, b

    @staticmethod
    def _pixel_outline_rect(
        surface: pygame.Surface,
        rect: pygame.Rect,
        fill_color: tuple[int, int, int] | tuple[int, int, int, int],
        outline_color: tuple[int, int, int] = (10, 10, 12),
    ) -> None:
        """Draw a filled rectangle with 1-pixel outline (no border_radius, pure pixel style)."""
        # Draw outline first (1 pixel larger on each side).
        outline_rect = rect.inflate(2, 2)
        pygame.draw.rect(surface, outline_color, outline_rect)
        # Draw fill on top.
        pygame.draw.rect(surface, fill_color, rect)

    @staticmethod
    def _smoothstep(edge0: float, edge1: float, x: float) -> float:
        if edge0 == edge1:
            return 0.0
        t = float(clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0))
        return t * t * (3.0 - 2.0 * t)

    def _time_of_day(self) -> float:
        return (float(self.world_time_s) % float(self.DAY_LENGTH_S)) / max(
            1e-6,
            float(self.DAY_LENGTH_S),
        )

    def _daylight_amount(self) -> tuple[float, float]:
        tday = float(self._time_of_day())
        dawn_start, dawn_end = 0.22, 0.28
        dusk_start, dusk_end = 0.72, 0.78
        # Keep nights readable (roughly like ~20:00) so the world doesn't become
        # pitch-black without lamps. Lamps/streetlights still matter for detail.
        night_ambient = 0.28

        if tday < dawn_start or tday >= dusk_end:
            return float(night_ambient), tday
        if tday < dawn_end:
            t = float(self._smoothstep(dawn_start, dawn_end, tday))
            return float(float(night_ambient) + (1.0 - float(night_ambient)) * t), tday
        if tday < dusk_start:
            return 1.0, tday
        t = float(self._smoothstep(dusk_start, dusk_end, tday))
        return float(1.0 - (1.0 - float(night_ambient)) * t), tday

    def _make_day_night_overlay_surface(self, *, in_rv: bool) -> pygame.Surface | None:
        daylight, tday = self._daylight_amount()
        # Night should be dark, but not total blackout (so it's playable without
        # staring only at light halos). Interiors get a lighter overlay.
        max_alpha = 230 if not in_rv else 80
        a = int(round(float(max_alpha) * (1.0 - float(daylight))))
        if a <= 0:
            return None

        # With a night ambient floor, daylight is never 0.0, so pick colors by time.
        if 0.22 <= tday < 0.28:
            col = (36, 26, 64)  # dawn
        elif 0.72 <= tday < 0.78:
            col = (64, 34, 26)  # dusk
        else:
            col = (8, 10, 18) if float(daylight) < 0.95 else (12, 14, 30)  # night / (unused) day

        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((int(col[0]), int(col[1]), int(col[2]), int(a)))
        return overlay

    def _draw_day_night_overlay(self, surface: pygame.Surface, *, in_rv: bool) -> None:
        overlay = self._make_day_night_overlay_surface(in_rv=in_rv)
        if overlay is None:
            return
        surface.blit(overlay, (0, 0))

    def _blit_screen(self, surface: pygame.Surface, src: pygame.Surface, *, pos: tuple[int, int], alpha: int = 255) -> None:
        alpha = int(clamp(int(alpha), 0, 255))
        if alpha <= 0:
            return

        src_rect = src.get_rect(topleft=(int(pos[0]), int(pos[1])))
        clip = src_rect.clip(surface.get_clip())
        if clip.w <= 0 or clip.h <= 0:
            return
        dx = int(clip.x - src_rect.x)
        dy = int(clip.y - src_rect.y)
        src_sub = src.subsurface(pygame.Rect(int(dx), int(dy), int(clip.w), int(clip.h)))
        dst_sub = surface.subsurface(clip)

        cache = getattr(self, "_screen_white_cache", {})
        white = cache.get((int(clip.w), int(clip.h)))
        if white is None:
            white = pygame.Surface((int(clip.w), int(clip.h))).convert()
            white.fill((255, 255, 255))
            cache[(int(clip.w), int(clip.h))] = white
            self._screen_white_cache = cache

        inv_dst = white.copy()
        inv_dst.blit(dst_sub, (0, 0), special_flags=pygame.BLEND_RGB_SUB)
        inv_src = white.copy()
        inv_src.blit(src_sub, (0, 0), special_flags=pygame.BLEND_RGB_SUB)
        inv_dst.blit(inv_src, (0, 0), special_flags=pygame.BLEND_RGB_MULT)

        out = white.copy()
        out.blit(inv_dst, (0, 0), special_flags=pygame.BLEND_RGB_SUB)
        if alpha < 255:
            out.set_alpha(int(alpha))
        surface.blit(out, clip.topleft)

    def _radial_gray_gradient(self, radius_px: int) -> pygame.Surface:
        radius_px = int(radius_px)
        radius_px = max(1, radius_px)
        cache: dict[int, pygame.Surface] = getattr(self, "_radial_gray_grad_cache", {})
        cached = cache.get(int(radius_px))
        if isinstance(cached, pygame.Surface):
            return cached

        size = int(radius_px) * 2 + 1
        g = pygame.Surface((int(size), int(size))).convert()
        g.fill((0, 0, 0))
        rings = int(clamp(int(round(float(radius_px) * 0.65)), 24, 120))
        for i in range(int(rings)):
            t = float(i) / float(max(1, int(rings) - 1))
            r = int(round(float(radius_px) * (1.0 - t)))
            if r <= 0:
                continue
            v = int(round(255.0 * ((1.0 - t) ** 2)))
            v = int(clamp(int(v), 0, 255))
            if v <= 0:
                continue
            pygame.draw.circle(g, (int(v), int(v), int(v)), (int(radius_px), int(radius_px)), int(r))

        cache[int(radius_px)] = g
        self._radial_gray_grad_cache = cache
        return g

    def _carve_world_lamps_from_night_overlay(
        self,
        overlay: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
    ) -> None:
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return

        try:
            night_a = int(overlay.get_at((0, 0))[3])
        except Exception:
            night_a = int(overlay.get_alpha() or 0)
        if int(night_a) <= 0:
            return

        ts = int(self.TILE_SIZE)
        if ts <= 0:
            return

        home_on = bool(getattr(self, "home_light_on", True))

        # World lamps: home lamps (toggleable) + streetlamps (always on).
        lamps: list[tuple[int, int, bool]] = []  # (tx, ty, restrict_to_home)
        seen_lamps: set[tuple[int, int]] = set()
        for ty in range(int(start_ty), int(end_ty) + 1):
            for tx in range(int(start_tx), int(end_tx) + 1):
                if int(self.world.peek_tile(int(tx), int(ty))) != int(self.T_LAMP):
                    continue
                restrict_home = bool(self._tile_in_home_world(int(tx), int(ty)))
                if restrict_home and not home_on:
                    continue
                key = (int(tx), int(ty))
                if key in seen_lamps:
                    continue
                seen_lamps.add(key)
                lamps.append((int(tx), int(ty), bool(restrict_home)))

        # Streetlamps are props, not tiles (so sidewalks remain sidewalks).
        rv_hide: tuple[int, int, int, int] | None = None
        if bool(getattr(self, "rv_world_interior", False)):
            key = getattr(self, "_rv_world_int_active_key", None)
            if isinstance(key, tuple) and len(key) == 4:
                try:
                    rv_hide = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
                except Exception:
                    rv_hide = None

        start_cx = int(start_tx) // int(self.CHUNK_SIZE)
        end_cx = int(end_tx) // int(self.CHUNK_SIZE)
        start_cy = int(start_ty) // int(self.CHUNK_SIZE)
        end_cy = int(end_ty) // int(self.CHUNK_SIZE)
        for cy in range(int(start_cy), int(end_cy) + 1):
            for cx in range(int(start_cx), int(end_cx) + 1):
                chunk = self.world.peek_chunk(int(cx), int(cy))
                if chunk is None:
                    continue
                for pr in getattr(chunk, "props", []):
                    if str(getattr(pr, "prop_id", "")) != "streetlamp":
                        continue
                    px = float(getattr(getattr(pr, "pos", pygame.Vector2(0, 0)), "x", 0.0))
                    py = float(getattr(getattr(pr, "pos", pygame.Vector2(0, 0)), "y", 0.0))
                    tx = int(math.floor(px / float(ts)))
                    ty = int(math.floor(py / float(ts)))
                    if rv_hide is not None:
                        rx0, ry0, rw, rh = rv_hide
                        if int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh):
                            continue
                    if tx < int(start_tx) or tx > int(end_tx) or ty < int(start_ty) or ty > int(end_ty):
                        continue
                    key = (int(tx), int(ty))
                    if key in seen_lamps:
                        continue
                    seen_lamps.add(key)
                    lamps.append((int(tx), int(ty), False))
        if not lamps:
            return

        cfg = getattr(self.app, "config", None)
        radius_tiles = int(getattr(cfg, "lamp_world_radius_tiles", 3)) if cfg is not None else 3
        radius_tiles = int(clamp(int(radius_tiles), 2, 18))
        intensity = float(getattr(cfg, "lamp_world_intensity", 1.0)) if cfg is not None else 1.0
        intensity = float(clamp(float(intensity), 0.0, 3.0))
        # Opacity controls halo only; brightness of the lit area is intensity-based.
        if intensity <= 0.01:
            return

        radius_px = int(max(int(ts) * 2, int(ts) * int(radius_tiles)))
        max_sub_alpha = int(clamp(int(round(float(night_a) * 1.0 * float(intensity))), 0, int(night_a)))
        if max_sub_alpha <= 0:
            return

        hole_key = (int(ts), int(radius_px), int(max_sub_alpha))
        hole = getattr(self, "_lamp_hole_cache", {}).get(hole_key) if hasattr(self, "_lamp_hole_cache") else None
        if hole is None:
            g = pygame.Surface((radius_px * 2 + 1, radius_px * 2 + 1), pygame.SRCALPHA)
            rings = 18
            for i in range(rings):
                t = float(i) / float(max(1, rings - 1))
                r = int(round(float(radius_px) * (1.0 - t)))
                if r <= 0:
                    continue
                a = int(round(float(max_sub_alpha) * ((1.0 - t) ** 2)))
                a = int(clamp(int(a), 0, 255))
                if a <= 0:
                    continue
                pygame.draw.circle(g, (0, 0, 0, int(a)), (radius_px, radius_px), int(r))
            cache = getattr(self, "_lamp_hole_cache", {})
            cache[hole_key] = g
            self._lamp_hole_cache = cache
            hole = g

        door_blocks = {
            int(self.T_DOOR),
            int(self.T_DOOR_HOME),
            int(self.T_DOOR_LOCKED),
            int(self.T_DOOR_HOME_LOCKED),
        }

        for lx, ly, restrict_home in lamps:
            base_rect = self._world_tile_screen_rect(int(lx), int(ly), int(cam_x), int(cam_y))
            cx, cy = int(base_rect.centerx), int(base_rect.centery)
            ox = int(cx - radius_px)
            oy = int(cy - radius_px)

            # Streetlamps (restrict_home=False) use simple circle without wall occlusion for performance.
            if not bool(restrict_home):
                overlay.blit(hole, (int(ox), int(oy)), special_flags=pygame.BLEND_RGBA_SUB)
                continue

            # Home lamps use BFS for wall occlusion.
            seen: set[tuple[int, int]] = set()
            lit: list[tuple[int, int]] = []
            stack = [(int(lx), int(ly))]
            r2 = int(radius_tiles) * int(radius_tiles)
            while stack and len(lit) < 1600:
                x, y = stack.pop()
                x = int(x)
                y = int(y)
                if (x, y) in seen:
                    continue
                seen.add((x, y))
                dx = int(x - int(lx))
                dy = int(y - int(ly))
                if int(dx * dx + dy * dy) > int(r2):
                    continue
                if not self._tile_in_home_world(int(x), int(y)):
                    continue
                tid = int(self.world.peek_tile(int(x), int(y)))
                if int(tid) in door_blocks:
                    continue
                if bool(self._tile_solid(int(tid))):
                    continue
                lit.append((int(x), int(y)))
                stack.extend(((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)))

            mask = pygame.Surface(hole.get_size(), pygame.SRCALPHA)
            mask.fill((0, 0, 0, 0))
            mask_bounds = mask.get_rect()
            for tx, ty in lit:
                r = self._world_tile_screen_rect(int(tx), int(ty), int(cam_x), int(cam_y))
                lr = r.move(-int(ox), -int(oy))
                lr = lr.clip(mask_bounds)
                if lr.w > 0 and lr.h > 0:
                    mask.fill((255, 255, 255, 255), lr)

            tmp = hole.copy()
            tmp.blit(mask, (0, 0), special_flags=pygame.BLEND_RGBA_MULT)
            overlay.blit(tmp, (int(ox), int(oy)), special_flags=pygame.BLEND_RGBA_SUB)

    def _carve_vehicle_headlights_from_night_overlay(
        self,
        overlay: pygame.Surface,
        cam_x: int,
        cam_y: int,
    ) -> None:
        if self.mount != "rv":
            return
        if bool(getattr(self, "rv_world_interior", False)):
            return
        if not bool(getattr(self, "rv_headlights_on", True)):
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return

        try:
            night_a = int(overlay.get_at((0, 0))[3])
        except Exception:
            night_a = int(overlay.get_alpha() or 0)
        if int(night_a) <= 0:
            return

        daylight, _tday = self._daylight_amount()
        if float(daylight) >= 0.92:
            return

        max_sub_alpha = int(clamp(int(round(float(night_a) * 1.25)), 0, int(night_a)))
        if max_sub_alpha <= 0:
            return

        forward = pygame.Vector2(math.cos(float(self.rv.heading)), math.sin(float(self.rv.heading)))
        if forward.length_squared() <= 0.001:
            forward = pygame.Vector2(1, 0)
        forward = forward.normalize()
        side = forward.rotate(90)

        rv_w = float(getattr(self.rv, "w", 80.0))
        rv_h = float(getattr(self.rv, "h", 40.0))
        front_off = max(10.0, rv_w * 0.5 - 10.0)
        head_sep = float(clamp(rv_h * 0.18, 8.0, 18.0))

        length = int(clamp(int(round(max(120.0, rv_w * 1.20))), 90, 220))
        base_half_ang = 26.0

        def carve_cone(origin_world: pygame.Vector2) -> None:
            sx = int(round(float(origin_world.x) - float(cam_x)))
            sy = int(round(float(origin_world.y) - float(cam_y)))

            left_dir = forward.rotate(-base_half_ang)
            right_dir = forward.rotate(base_half_ang)
            p1 = pygame.Vector2(sx, sy) + left_dir * float(length)
            p2 = pygame.Vector2(sx, sy) + right_dir * float(length)
            pad = 10
            minx = int(math.floor(min(float(sx), float(p1.x), float(p2.x)) - pad))
            miny = int(math.floor(min(float(sy), float(p1.y), float(p2.y)) - pad))
            maxx = int(math.ceil(max(float(sx), float(p1.x), float(p2.x)) + pad))
            maxy = int(math.ceil(max(float(sy), float(p1.y), float(p2.y)) + pad))

            bounds = overlay.get_rect()
            if maxx < bounds.left or maxy < bounds.top or minx > bounds.right or miny > bounds.bottom:
                return
            minx = int(clamp(minx, 0, bounds.w - 1))
            miny = int(clamp(miny, 0, bounds.h - 1))
            maxx = int(clamp(maxx, 0, bounds.w - 1))
            maxy = int(clamp(maxy, 0, bounds.h - 1))
            bw = int(maxx - minx + 1)
            bh = int(maxy - miny + 1)
            if bw <= 1 or bh <= 1:
                return

            beam = pygame.Surface((bw, bh), pygame.SRCALPHA)
            ox = sx - minx
            oy = sy - miny

            # Strong at the center, fades forward.
            steps = 8
            for i in range(steps):
                t = float(i) / float(max(1, steps - 1))
                a = int(round(float(max_sub_alpha) * ((1.0 - t) ** 2)))
                if a <= 0:
                    continue
                l = float(length) * (0.35 + 0.65 * t)
                ang = float(base_half_ang) * (0.55 + 0.45 * t)
                ld = forward.rotate(-ang)
                rd = forward.rotate(ang)
                q1 = pygame.Vector2(float(ox), float(oy)) + ld * l
                q2 = pygame.Vector2(float(ox), float(oy)) + rd * l
                pts = [(float(ox), float(oy)), (float(q1.x), float(q1.y)), (float(q2.x), float(q2.y))]
                pygame.draw.polygon(beam, (0, 0, 0, int(a)), pts)

            pygame.draw.circle(beam, (0, 0, 0, int(max_sub_alpha)), (int(ox), int(oy)), 6)
            overlay.blit(beam, (int(minx), int(miny)), special_flags=pygame.BLEND_RGBA_SUB)

        base = pygame.Vector2(self.rv.pos) + forward * float(front_off)
        carve_cone(base + side * head_sep)
        carve_cone(base - side * head_sep)

    def _draw_world_lighting(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
    ) -> None:
        overlay = self._make_day_night_overlay_surface(in_rv=False)
        if overlay is not None:
            try:
                self._carve_world_lamps_from_night_overlay(overlay, cam_x, cam_y, start_tx, end_tx, start_ty, end_ty)
                self._carve_vehicle_headlights_from_night_overlay(overlay, cam_x, cam_y)
            except Exception:
                pass
            surface.blit(overlay, (0, 0))
        # Soft halo (screen blend) is optional and should never wash out detail.
        self._draw_world_lamp_glows(surface, cam_x, cam_y, start_tx, end_tx, start_ty, end_ty)

    def _draw_world_lamp_glows(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
    ) -> None:
        if bool(getattr(self, "hr_interior", False)) or bool(getattr(self, "house_interior", False)) or bool(getattr(self, "sch_interior", False)):
            return

        daylight, _tday = self._daylight_amount()

        ts = int(self.TILE_SIZE)
        if ts <= 0:
            return

        home_on = bool(getattr(self, "home_light_on", True))

        # World lamps: home lamps (toggleable) + streetlamps (always on).
        lamps: list[tuple[int, int, bool]] = []  # (tx, ty, restrict_to_home)
        seen_lamps: set[tuple[int, int]] = set()
        for ty in range(int(start_ty), int(end_ty) + 1):
            for tx in range(int(start_tx), int(end_tx) + 1):
                if int(self.world.peek_tile(int(tx), int(ty))) != int(self.T_LAMP):
                    continue
                restrict_home = bool(self._tile_in_home_world(int(tx), int(ty)))
                if restrict_home and not home_on:
                    continue
                key = (int(tx), int(ty))
                if key in seen_lamps:
                    continue
                seen_lamps.add(key)
                lamps.append((int(tx), int(ty), bool(restrict_home)))

        # Streetlamps are props, not tiles (so sidewalks remain sidewalks).
        rv_hide: tuple[int, int, int, int] | None = None
        if bool(getattr(self, "rv_world_interior", False)):
            key = getattr(self, "_rv_world_int_active_key", None)
            if isinstance(key, tuple) and len(key) == 4:
                try:
                    rv_hide = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
                except Exception:
                    rv_hide = None

        start_cx = int(start_tx) // int(self.CHUNK_SIZE)
        end_cx = int(end_tx) // int(self.CHUNK_SIZE)
        start_cy = int(start_ty) // int(self.CHUNK_SIZE)
        end_cy = int(end_ty) // int(self.CHUNK_SIZE)
        for cy in range(int(start_cy), int(end_cy) + 1):
            for cx in range(int(start_cx), int(end_cx) + 1):
                chunk = self.world.peek_chunk(int(cx), int(cy))
                if chunk is None:
                    continue
                for pr in getattr(chunk, "props", []):
                    if str(getattr(pr, "prop_id", "")) != "streetlamp":
                        continue
                    px = float(getattr(getattr(pr, "pos", pygame.Vector2(0, 0)), "x", 0.0))
                    py = float(getattr(getattr(pr, "pos", pygame.Vector2(0, 0)), "y", 0.0))
                    tx = int(math.floor(px / float(ts)))
                    ty = int(math.floor(py / float(ts)))
                    if rv_hide is not None:
                        rx0, ry0, rw, rh = rv_hide
                        if int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh):
                            continue
                    if tx < int(start_tx) or tx > int(end_tx) or ty < int(start_ty) or ty > int(end_ty):
                        continue
                    key = (int(tx), int(ty))
                    if key in seen_lamps:
                        continue
                    seen_lamps.add(key)
                    lamps.append((int(tx), int(ty), False))
        if not lamps:
            return

        cfg = getattr(self.app, "config", None)
        radius_tiles = int(getattr(cfg, "lamp_world_radius_tiles", 3)) if cfg is not None else 3
        radius_tiles = int(clamp(int(radius_tiles), 2, 18))
        intensity = float(getattr(cfg, "lamp_world_intensity", 1.0)) if cfg is not None else 1.0
        intensity = float(clamp(float(intensity), 0.0, 3.0))
        radius_px = int(max(int(ts) * 2, int(ts) * int(radius_tiles)))
        halo = float(getattr(cfg, "lamp_world_halo", 0.35)) if cfg is not None else 0.35
        halo = float(clamp(float(halo), 0.0, 1.5))

        # Keep a visible (but subtle) bloom even in daytime.
        day_factor = float(clamp(0.45 + 0.55 * (1.0 - float(daylight)), 0.45, 1.0))
        halo_strength = float(halo) * float(day_factor) * float(clamp(float(intensity), 0.0, 1.0))
        halo_strength = float(clamp(float(halo_strength), 0.0, 1.0))
        halo_alpha = int(clamp(int(round(255.0 * float(halo_strength))), 0, 255))
        if halo_alpha <= 0:
            return

        # Bloom source stays the same size; transparency is applied at blit-time.
        cache: dict[int, pygame.Surface] = getattr(self, "_world_lamp_bloom_cache", {})
        glow = cache.get(int(radius_px))
        if glow is None:
            grad = self._radial_gray_gradient(int(radius_px))
            g = grad.copy()
            g.fill((90, 90, 90), special_flags=pygame.BLEND_RGB_MULT)
            g.fill((236, 222, 194), special_flags=pygame.BLEND_RGB_MULT)
            cache[int(radius_px)] = g
            self._world_lamp_bloom_cache = cache
            glow = g

        door_blocks = {
            int(self.T_DOOR),
            int(self.T_DOOR_HOME),
            int(self.T_DOOR_LOCKED),
            int(self.T_DOOR_HOME_LOCKED),
        }

        for lx, ly, restrict_home in lamps:
            base_rect = self._world_tile_screen_rect(int(lx), int(ly), int(cam_x), int(cam_y))
            cx, cy = int(base_rect.centerx), int(base_rect.centery)
            ox = int(cx - radius_px)
            oy = int(cy - radius_px)

            # Streetlamps (restrict_home=False) use simple glow without wall occlusion for performance.
            if not bool(restrict_home):
                self._blit_screen(surface, glow, pos=(int(ox), int(oy)), alpha=int(halo_alpha))
                continue

            # Home lamps use BFS for wall occlusion.
            seen: set[tuple[int, int]] = set()
            lit: list[tuple[int, int]] = []
            stack = [(int(lx), int(ly))]
            r2 = int(radius_tiles) * int(radius_tiles)
            while stack and len(lit) < 1400:
                x, y = stack.pop()
                x = int(x)
                y = int(y)
                if (x, y) in seen:
                    continue
                seen.add((x, y))
                dx = int(x - int(lx))
                dy = int(y - int(ly))
                if int(dx * dx + dy * dy) > int(r2):
                    continue
                if not self._tile_in_home_world(int(x), int(y)):
                    continue

                tid = int(self.world.peek_tile(int(x), int(y)))
                if int(tid) in door_blocks:
                    continue
                if bool(self._tile_solid(int(tid))):
                    continue
                lit.append((int(x), int(y)))
                stack.extend(((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)))

            # Build a local mask surface (white where visible tiles exist).
            mask = pygame.Surface(glow.get_size()).convert()
            mask.fill((0, 0, 0))
            mask_bounds = mask.get_rect()
            for tx, ty in lit:
                r = self._world_tile_screen_rect(int(tx), int(ty), int(cam_x), int(cam_y))
                lr = r.move(-int(ox), -int(oy))
                lr = lr.clip(mask_bounds)
                if lr.w > 0 and lr.h > 0:
                    mask.fill((255, 255, 255), lr)

            tmp = glow.copy()
            tmp.blit(mask, (0, 0), special_flags=pygame.BLEND_RGB_MULT)
            self._blit_screen(surface, tmp, pos=(int(ox), int(oy)), alpha=int(halo_alpha))

    def _season_index_for_day(self, day: int) -> int:
        return ((int(day) - 1) // max(1, int(self.SEASON_LENGTH_DAYS))) % len(self.SEASONS)

    @staticmethod
    def _pick_weighted_key(rng: random.Random, weights: dict[str, float], order: Sequence[str], default: str) -> str:
        total = 0.0
        for v in weights.values():
            total += max(0.0, float(v))
        if total <= 0.0001:
            return default
        r = rng.random() * total
        acc = 0.0
        for k in order:
            acc += max(0.0, float(weights.get(k, 0.0)))
            if r <= acc:
                return str(k)
        return default

    def _weather_for_day(self, day: int) -> tuple[str, float, float]:
        day = max(1, int(day))
        season_idx = int(self._season_index_for_day(day))
        seed = int(self._hash2_u32(day, season_idx, int(self.seed) ^ 0x2D5A61B9))
        rng = random.Random(seed)

        if season_idx == 0:  # spring
            weights = {"clear": 0.46, "cloudy": 0.30, "rain": 0.20, "storm": 0.04, "snow": 0.0}
        elif season_idx == 1:  # summer
            weights = {"clear": 0.55, "cloudy": 0.20, "rain": 0.16, "storm": 0.09, "snow": 0.0}
        elif season_idx == 2:  # autumn
            weights = {"clear": 0.38, "cloudy": 0.28, "rain": 0.22, "storm": 0.12, "snow": 0.0}
        else:  # winter
            weights = {"clear": 0.36, "cloudy": 0.30, "rain": 0.06, "storm": 0.08, "snow": 0.20}

        kind = self._pick_weighted_key(rng, weights, self.WEATHER_KINDS, "clear")
        if kind == "clear":
            intensity = 0.0
        elif kind == "cloudy":
            intensity = float(rng.uniform(0.30, 0.70))
        elif kind == "rain":
            intensity = float(rng.uniform(0.35, 0.80))
        elif kind == "storm":
            intensity = float(rng.uniform(0.75, 1.0))
        else:  # snow
            intensity = float(rng.uniform(0.35, 0.95))

        wind_scale = 14.0
        if kind in ("rain", "snow"):
            wind_scale = 28.0
        if kind == "storm":
            wind_scale = 44.0
        wind = float(rng.uniform(-1.0, 1.0) * wind_scale)
        return str(kind), float(intensity), float(wind)

    def _set_weather_targets_for_day(self, day: int) -> None:
        kind, intensity, wind = self._weather_for_day(day)
        self.weather_target_kind = str(kind)
        self.weather_target_intensity = float(clamp(float(intensity), 0.0, 1.0))
        self.weather_wind_target = float(clamp(float(wind), -60.0, 60.0))

    def _sync_weather_particles(self) -> None:
        kind = str(getattr(self, "weather_kind", "clear"))
        intensity = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))
        rng = getattr(self, "weather_rng", None) or random.Random(int(self.seed) ^ 0xA53C9F17)
        self.weather_rng = rng

        if kind in ("rain", "storm"):
            base = 70 if kind == "rain" else 110
            target = int(base + 120 * intensity)
            while len(self._rain_drops) < target:
                x = float(rng.uniform(-20.0, float(INTERNAL_W) + 20.0))
                y = float(rng.uniform(-float(INTERNAL_H), float(INTERNAL_H)))
                spd = float(rng.uniform(320.0, 620.0) * (0.65 + 0.45 * intensity))
                self._rain_drops.append([x, y, spd])
            if len(self._rain_drops) > target:
                self._rain_drops = self._rain_drops[:target]
        else:
            self._rain_drops.clear()

        if kind == "snow":
            target = int(40 + 90 * intensity)
            while len(self._snow_flakes) < target:
                x = float(rng.uniform(-10.0, float(INTERNAL_W) + 10.0))
                y = float(rng.uniform(-float(INTERNAL_H), float(INTERNAL_H)))
                spd = float(rng.uniform(18.0, 46.0) * (0.60 + 0.55 * intensity))
                drift = float(rng.uniform(-16.0, 16.0))
                self._snow_flakes.append([x, y, spd, drift])
            if len(self._snow_flakes) > target:
                self._snow_flakes = self._snow_flakes[:target]
        else:
            self._snow_flakes.clear()

    def _update_weather(self, dt: float) -> None:
        dt = float(max(0.0, dt))
        day = int(self.world_time_s / max(1e-6, float(self.DAY_LENGTH_S))) + 1
        if int(day) != int(getattr(self, "weather_day", 0)):
            self.weather_day = int(day)
            self._set_weather_targets_for_day(int(day))

        # Smooth wind.
        wind = float(getattr(self, "weather_wind", 0.0))
        wind_t = float(getattr(self, "weather_wind_target", 0.0))
        wind_step = 18.0 * dt
        if wind < wind_t:
            wind = min(wind_t, wind + wind_step)
        else:
            wind = max(wind_t, wind - wind_step)
        self.weather_wind = float(wind)

        kind = str(getattr(self, "weather_kind", "clear"))
        inten = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))
        target_kind = str(getattr(self, "weather_target_kind", kind))
        target_inten = float(clamp(float(getattr(self, "weather_target_intensity", inten)), 0.0, 1.0))

        step = dt / max(1e-6, float(self.WEATHER_TRANSITION_S))
        step = float(clamp(step, 0.0, 1.0))

        if kind != target_kind:
            inten = max(0.0, inten - step)
            if inten <= 0.02:
                kind = target_kind
        else:
            if inten < target_inten:
                inten = min(target_inten, inten + step)
            else:
                inten = max(target_inten, inten - step)

        self.weather_kind = str(kind)
        self.weather_intensity = float(inten)

        # Lightning (storm only).
        flash_left = float(getattr(self, "weather_flash_left", 0.0))
        if flash_left > 0.0:
            flash_left = max(0.0, flash_left - dt)
        elif kind == "storm" and inten > 0.55:
            rng = getattr(self, "weather_rng", None) or random.Random(int(self.seed) ^ 0xA53C9F17)
            if rng.random() < dt * (0.06 + 0.18 * inten):
                flash_left = 0.12
        self.weather_flash_left = float(flash_left)

        # Update particles positions.
        self._sync_weather_particles()
        if kind in ("rain", "storm") and self._rain_drops:
            dx = float(self.weather_wind) * 0.25
            for drop in self._rain_drops:
                drop[0] += dx * dt
                drop[1] += float(drop[2]) * dt
                if drop[1] > float(INTERNAL_H) + 16.0 or drop[0] < -40.0 or drop[0] > float(INTERNAL_W) + 40.0:
                    drop[0] = float(self.weather_rng.uniform(-20.0, float(INTERNAL_W) + 20.0))
                    drop[1] = float(self.weather_rng.uniform(-18.0, -2.0))
                    drop[2] = float(self.weather_rng.uniform(320.0, 620.0) * (0.65 + 0.45 * inten))

        if kind == "snow" and self._snow_flakes:
            dx = float(self.weather_wind) * 0.20
            for flake in self._snow_flakes:
                flake[0] += (dx + float(flake[3])) * dt
                flake[1] += float(flake[2]) * dt
                if flake[1] > float(INTERNAL_H) + 12.0:
                    flake[0] = float(self.weather_rng.uniform(-10.0, float(INTERNAL_W) + 10.0))
                    flake[1] = float(self.weather_rng.uniform(-16.0, -2.0))
                if flake[0] < -16.0:
                    flake[0] = float(INTERNAL_W) + 12.0
                elif flake[0] > float(INTERNAL_W) + 16.0:
                    flake[0] = -12.0

    def _weather_move_mult(self) -> float:
        kind = str(getattr(self, "weather_kind", "clear"))
        inten = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))
        if kind == "rain":
            return float(1.0 - 0.10 * inten)
        if kind == "storm":
            return float(1.0 - 0.16 * inten)
        if kind == "snow":
            return float(1.0 - 0.12 * inten)
        return 1.0

    def _draw_weather_effects(self, surface: pygame.Surface, *, in_rv: bool) -> None:
        kind = str(getattr(self, "weather_kind", "clear"))
        inten = float(clamp(float(getattr(self, "weather_intensity", 0.0)), 0.0, 1.0))
        if inten <= 0.01:
            return
        suppress_precip = bool(getattr(self, "rv_world_interior", False))
        layer: pygame.Surface = getattr(self, "_weather_layer", None) or pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        self._weather_layer = layer
        layer.fill((0, 0, 0, 0))

        daylight, _tday = self._daylight_amount()
        drop_col = (200, 200, 216) if daylight >= 0.55 else (140, 140, 155)
        tint_mult = 0.55 if in_rv else 1.0

        rv_clips: list[pygame.Rect] | None = None

        # If the player is inside their home on the world map, don't render rain
        # through the interior area (only outside the apartment footprint).
        home_clips: list[pygame.Rect] | None = None
        if (not in_rv) and bool(getattr(self, "home_highrise_world_key", None)):
            try:
                ptx, pty = self._player_tile()
                if self._tile_in_home_world(int(ptx), int(pty)):
                    home_key = getattr(self, "home_highrise_world_key", None)
                    if isinstance(home_key, tuple) and len(home_key) == 4:
                        tx0, ty0, w, h = (int(home_key[0]), int(home_key[1]), int(home_key[2]), int(home_key[3]))
                        cam_x, cam_y_draw = getattr(
                            self,
                            "_last_cam_draw",
                            (int(getattr(self, "cam_x", 0)), int(getattr(self, "cam_y", 0))),
                        )
                        ts = int(max(1, int(getattr(self, "TILE_SIZE", self.TILE_SIZE))))

                        start_y = int(ty0)
                        shift_px = 0

                        overlay = getattr(self, "_inside_highrise_floor_overlay", None)
                        if overlay is not None:
                            try:
                                otx0, oty0, ow, oh, floor_y0, offset_px = (
                                    int(overlay[0]),
                                    int(overlay[1]),
                                    int(overlay[2]),
                                    int(overlay[3]),
                                    int(overlay[4]),
                                    int(overlay[5]),
                                )
                                if (otx0, oty0, ow, oh) == (int(tx0), int(ty0), int(w), int(h)) and int(offset_px) > 0:
                                    start_y = int(max(int(oty0), int(floor_y0) - 1))
                                    shift_px = int(offset_px)
                            except Exception:
                                pass

                        if shift_px <= 0:
                            mask = getattr(self, "_inside_highrise_draw_mask", None)
                            if mask is not None:
                                try:
                                    mtx0, mty0, mw, mh, floor_y0 = (
                                        int(mask[0]),
                                        int(mask[1]),
                                        int(mask[2]),
                                        int(mask[3]),
                                        int(mask[4]),
                                    )
                                    if (mtx0, mty0, mw, mh) == (int(tx0), int(ty0), int(w), int(h)):
                                        start_y = int(max(int(mty0), int(floor_y0) - 1))
                                except Exception:
                                    pass

                        x_px = int(tx0) * ts - int(cam_x)
                        y_px = int(start_y) * ts - int(cam_y_draw) - int(shift_px)
                        w_px = int(w) * ts
                        h_px = int((int(ty0) + int(h) - int(start_y)) * ts)
                        block = pygame.Rect(int(x_px), int(y_px), int(w_px), int(h_px))
                        screen = pygame.Rect(0, 0, INTERNAL_W, INTERNAL_H)
                        block = block.clip(screen)

                        if block.w > 0 and block.h > 0:
                            home_clips = []
                            if block.top > 0:
                                home_clips.append(pygame.Rect(0, 0, INTERNAL_W, block.top))
                            if block.bottom < INTERNAL_H:
                                home_clips.append(pygame.Rect(0, block.bottom, INTERNAL_W, INTERNAL_H - block.bottom))
                            if block.left > 0:
                                home_clips.append(pygame.Rect(0, block.top, block.left, block.h))
                            if block.right < INTERNAL_W:
                                home_clips.append(pygame.Rect(block.right, block.top, INTERNAL_W - block.right, block.h))
            except Exception:
                home_clips = None

        precip_clips = rv_clips if rv_clips is not None else home_clips

        # Base tint per weather.
        if kind == "cloudy":
            a = int(round(40.0 * inten * tint_mult))
            pygame.draw.rect(layer, (40, 44, 52, a), layer.get_rect())
        elif kind == "rain":
            a = int(round(55.0 * inten * tint_mult))
            pygame.draw.rect(layer, (32, 40, 58, a), layer.get_rect())   
        elif kind == "storm":
            a = int(round(85.0 * inten * tint_mult))
            pygame.draw.rect(layer, (22, 26, 44, a), layer.get_rect())   
        elif kind == "snow":
            a = int(round(32.0 * inten * tint_mult))
            pygame.draw.rect(layer, (180, 190, 210, a), layer.get_rect())

        # Precipitation.
        if (not suppress_precip) and kind in ("rain", "storm") and self._rain_drops:
            alpha = int(round((120 if kind == "rain" else 160) * inten))
            alpha = int(clamp(alpha, 20, 210))
            dx = int(round(clamp(float(self.weather_wind) * 0.05, -4.0, 4.0)))
            ln = 6 + int(round(4.0 * inten))
            if precip_clips:
                for cr in precip_clips:
                    layer.set_clip(cr)
                    for x, y, _spd in self._rain_drops:
                        xi = int(x)
                        yi = int(y)
                        pygame.draw.line(layer, (drop_col[0], drop_col[1], drop_col[2], alpha), (xi, yi), (xi + dx, yi + ln), 1)
                layer.set_clip(None)
            else:
                for x, y, _spd in self._rain_drops:
                    xi = int(x)
                    yi = int(y)
                    pygame.draw.line(layer, (drop_col[0], drop_col[1], drop_col[2], alpha), (xi, yi), (xi + dx, yi + ln), 1)
        elif (not suppress_precip) and kind == "snow" and self._snow_flakes:
            alpha = int(round(170.0 * inten))
            alpha = int(clamp(alpha, 30, 230))
            if precip_clips:
                for cr in precip_clips:
                    layer.set_clip(cr)
                    for x, y, _spd, _drift in self._snow_flakes:
                        xi = int(x)
                        yi = int(y)
                        if 0 <= xi < INTERNAL_W and 0 <= yi < INTERNAL_H:
                            layer.fill((235, 235, 245, alpha), pygame.Rect(xi, yi, 1, 1))
                            if (xi + yi) % 7 == 0:
                                layer.fill((235, 235, 245, max(20, alpha - 60)), pygame.Rect(xi, yi + 1, 1, 1))
                layer.set_clip(None)
            else:
                for x, y, _spd, _drift in self._snow_flakes:
                    xi = int(x)
                    yi = int(y)
                    if 0 <= xi < INTERNAL_W and 0 <= yi < INTERNAL_H:
                        layer.fill((235, 235, 245, alpha), pygame.Rect(xi, yi, 1, 1))
                        if (xi + yi) % 7 == 0:
                            layer.fill((235, 235, 245, max(20, alpha - 60)), pygame.Rect(xi, yi + 1, 1, 1))

        # Lightning flash overlay.
        flash_left = float(getattr(self, "weather_flash_left", 0.0))
        if kind == "storm" and flash_left > 0.0:
            p = float(clamp(flash_left / 0.12, 0.0, 1.0))
            a = int(round(210.0 * p))
            pygame.draw.rect(layer, (255, 255, 255, a), layer.get_rect())

        surface.blit(layer, (0, 0))

    def _tile_color(self, tile_id: int) -> tuple[int, int, int]:
        t = self._TILES.get(int(tile_id))
        base = t.color if t is not None else (255, 0, 255)
        season = self._season_index()
        if tile_id in (self.T_GRASS, self.T_FOREST):
            if season == 0:  # spring
                return self._tint(base, add=(4, 10, 4))
            if season == 1:  # summer
                return self._tint(base, add=(0, 0, 0))
            if season == 2:  # autumn
                return self._tint(base, add=(18, 8, -10))
            return self._tint(base, add=(28, 28, 28))  # winter
        if tile_id == self.T_WATER and season == 3:
            return self._tint(base, add=(10, 10, 22))
        return base

    def _minimap_color(self, tile_id: int) -> tuple[int, int, int]:
        # Minimap / world map palette.
        # Do NOT reveal interior layouts: all building-interior tiles (walls/floors/doors/furniture)
        # are rendered as a solid "roof" blob.
        tile_id = int(tile_id)
        if tile_id in (
            int(self.T_WALL),
            int(self.T_FLOOR),
            int(self.T_DOOR),
            int(self.T_DOOR_HOME),
            int(self.T_DOOR_LOCKED),
            int(self.T_DOOR_HOME_LOCKED),
            int(self.T_DOOR_BROKEN),
            int(self.T_STAIRS_UP),
            int(self.T_STAIRS_DOWN),
            int(self.T_TABLE),
            int(self.T_SHELF),
            int(self.T_CABINET),
            int(self.T_SINK),
            int(self.T_BED),
            int(self.T_SOFA),
            int(self.T_FRIDGE),
            int(self.T_TV),
            int(self.T_CHAIR),
            int(self.T_PC),
            int(self.T_LAMP),
            int(self.T_SWITCH),
            int(self.T_STEER),
            int(self.T_TOILET),
            int(self.T_ELEVATOR),
            int(self.T_BARRICADE),
        ):
            return (72, 72, 92)
        if tile_id == int(self.T_ROAD):
            return (92, 92, 96)
        if tile_id == int(self.T_HIGHWAY):
            return (82, 82, 88)
        if tile_id == int(self.T_PAVEMENT):
            return (72, 72, 76)
        if tile_id == int(self.T_PARKING):
            return (62, 62, 70)
        if tile_id == int(self.T_COURT):
            return (126, 92, 70)
        if tile_id == int(self.T_SIDEWALK):
            return (174, 154, 104)
        if tile_id == int(self.T_BRICK):
            return (166, 112, 96)
        if tile_id == int(self.T_CONCRETE):
            return (118, 118, 128)
        if tile_id == int(self.T_SAND):
            return (194, 176, 112)
        if tile_id == int(self.T_BOARDWALK):
            return (156, 116, 68)
        if tile_id == int(self.T_MARSH):
            return (62, 98, 66)
        return self._tile_color(tile_id)

    def _peek_building_at_tile(self, tx: int, ty: int) -> tuple[int, int, int, int, int, int] | None:
        tx = int(tx)
        ty = int(ty)
        cx = int(tx) // int(self.CHUNK_SIZE)
        cy = int(ty) // int(self.CHUNK_SIZE)

        best: tuple[int, int, int, int, int, int] | None = None
        best_area: int | None = None

        def scan_chunk(chunk: "_Chunk") -> None:
            nonlocal best, best_area
            for b in getattr(chunk, "buildings", []):
                btx0, bty0, bw, bh = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                if not (int(btx0) <= int(tx) < int(btx0) + int(bw) and int(bty0) <= int(ty) < int(bty0) + int(bh)):
                    continue
                area = int(bw) * int(bh)
                if best_area is None or int(area) < int(best_area):
                    roof_kind = int(b[4]) if len(b) > 4 else 0
                    floors = int(b[5]) if len(b) > 5 else 0
                    best = (int(btx0), int(bty0), int(bw), int(bh), int(roof_kind), int(floors))
                    best_area = int(area)

        # Fast path: same chunk first.
        chunk0 = self.world.peek_chunk(int(cx), int(cy))
        if chunk0 is not None:
            scan_chunk(chunk0)
            if best is not None:
                return best

        # Fallback: scan adjacent chunks to cover buildings registered in their origin chunk.
        for oy in (-1, 0, 1):
            for ox in (-1, 0, 1):
                if ox == 0 and oy == 0:
                    continue
                chunk = self.world.peek_chunk(int(cx + ox), int(cy + oy))
                if chunk is None:
                    continue
                scan_chunk(chunk)
        return best

    def _draw_world_tile(
        self,
        surface: pygame.Surface,
        rect: pygame.Rect,
        *,
        tx: int,
        ty: int,
        tile_id: int,
        apply_mask: bool = True,
    ) -> None:
        tx = int(tx)
        ty = int(ty)
        tile_id = int(tile_id)

        if apply_mask:
            # High-rise 1F: when the player is inside, hide the non-floor "back"
            # filler area (so it doesn't show up as a black block). We draw it
            # as whatever is just outside the building's north edge, making it
            # look like "nothing" was built there.
            mask = getattr(self, "_inside_highrise_draw_mask", None)
            if mask is not None:
                try:
                    tx0, ty0, w, h, floor_y0 = mask
                    if (
                        int(tx0) <= int(tx) < int(tx0) + int(w)
                        and int(ty0) <= int(ty) < int(ty0) + int(h)
                        and int(ty) < int(floor_y0) - 1
                    ):
                        outside = int(self.world.peek_tile(int(tx), int(ty0) - 1, default=int(self.T_GRASS)))
                        tile_id = outside
                except Exception:
                    pass

            # High-rise upper floors: base layer shouldn't draw the interior at
            # ground level; it's rendered as an elevated overlay layer instead.
            overlay = getattr(self, "_inside_highrise_floor_overlay", None)
            if overlay is not None:
                try:
                    tx0, ty0, w, h, floor_y0 = overlay[:5]
                    if (
                        int(tx0) <= int(tx) < int(tx0) + int(w)
                        and int(ty0) <= int(ty) < int(ty0) + int(h)
                        and int(ty) >= int(floor_y0) - 1
                    ):
                        outside = int(self.world.peek_tile(int(tx), int(ty0) - 1, default=int(self.T_GRASS)))
                        tile_id = outside
                except Exception:
                    pass

            # Cutaway-roof buildings: don't reveal interiors unless the player is inside that building.
            if tile_id in (
                int(self.T_FLOOR),
                int(self.T_DOOR),
                int(self.T_DOOR_HOME),
                int(self.T_DOOR_LOCKED),
                int(self.T_DOOR_HOME_LOCKED),
                int(self.T_DOOR_BROKEN),
                int(self.T_ELEVATOR),
                int(self.T_STAIRS_UP),
                int(self.T_STAIRS_DOWN),
                int(self.T_TABLE),
                int(self.T_SHELF),
                int(self.T_CABINET),
                int(self.T_BED),
                int(self.T_SOFA),
                int(self.T_FRIDGE),
                int(self.T_TV),
                int(self.T_CHAIR),
                int(self.T_PC),
                int(self.T_LAMP),
                int(self.T_SWITCH),
                int(self.T_STEER),
                int(self.T_TOILET),
                int(self.T_SINK),
            ):
                inside_key = getattr(self, "_inside_building_key", None)
                try:
                    hit = self._peek_building_at_tile(int(tx), int(ty))
                    if hit is not None:
                        btx0, bty0, bw, bh, roof_kind, floors = hit
                        if inside_key is not None and (int(btx0), int(bty0), int(bw), int(bh)) == tuple(inside_key):
                            pass
                        elif int(tx) in (int(btx0), int(btx0) + int(bw) - 1) or int(ty) in (int(bty0), int(bty0) + int(bh) - 1):
                            pass
                        else:
                            style, _var = self._building_roof_style_var(int(roof_kind))
                            if int(style) == 6 or (int(style) == 1 and int(floors) > 1):
                                tile_id = int(self.T_WALL)
                except Exception:
                    pass

        # When inside a building, only show the reachable connected area.
        # This keeps neighbor apartments hidden unless you can actually enter.
        try:
            inside_key = getattr(self, "_inside_building_key", None)
            visible = getattr(self, "_inside_building_visible", None)
            if isinstance(inside_key, tuple) and len(inside_key) == 4 and isinstance(visible, set) and visible:
                tx0, ty0, w, h = (int(inside_key[0]), int(inside_key[1]), int(inside_key[2]), int(inside_key[3]))
                if int(tx0) <= int(tx) < int(tx0) + int(w) and int(ty0) <= int(ty) < int(ty0) + int(h):
                    if (int(tx), int(ty)) not in visible:
                        if tile_id in (
                            int(self.T_FLOOR),
                            int(self.T_DOOR),
                            int(self.T_DOOR_HOME),
                            int(self.T_DOOR_LOCKED),
                            int(self.T_DOOR_HOME_LOCKED),
                            int(self.T_DOOR_BROKEN),
                            int(self.T_ELEVATOR),
                            int(self.T_STAIRS_UP),
                            int(self.T_STAIRS_DOWN),
                            int(self.T_TABLE),
                            int(self.T_SHELF),
                            int(self.T_CABINET),
                            int(self.T_BED),
                            int(self.T_SOFA),
                            int(self.T_FRIDGE),
                            int(self.T_TV),
                            int(self.T_CHAIR),
                            int(self.T_PC),
                            int(self.T_LAMP),
                            int(self.T_SWITCH),
                            int(self.T_STEER),
                            int(self.T_TOILET),
                            int(self.T_SINK),
                        ):
                            # Never mask the outer border so doors/walls read correctly.
                            if int(tx) not in (int(tx0), int(tx0) + int(w) - 1) and int(ty) not in (int(ty0), int(ty0) + int(h) - 1):
                                tile_id = int(self.T_WALL)
        except Exception:
            pass

        # RV world-interior: draw the room border as thin lines so the RV doesn't
        # waste a full wall tile thickness on each edge.
        try:
            if bool(getattr(self, "rv_world_interior", False)):
                key = getattr(self, "_rv_world_int_active_key", None)
                if isinstance(key, tuple) and len(key) == 4:
                    rx0, ry0, rw, rh = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
                    if int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh):
                        relx = int(tx) - int(rx0)
                        rely = int(ty) - int(ry0)
                        if int(relx) in (0, int(rw) - 1) or int(rely) in (0, int(rh) - 1):
                            # Draw the actual tile on the border (e.g. steering wheel),
                            # then overlay a thin border line. Previously we forced border
                            # tiles to floor, which made border furniture invisible.
                            draw_id = int(tile_id)
                            if draw_id == int(self.T_WALL):
                                draw_id = int(self.T_FLOOR)
                            surface.fill(self._tile_color(int(draw_id)), rect)
                            line = (10, 10, 12)
                            # Border tiles used to early-return before furniture details were drawn.
                            # If the steering wheel sits on the border, draw its glyph here too.
                            if int(draw_id) == int(self.T_STEER):
                                cx, cy = int(rect.centerx), int(rect.centery)
                                outer = 4  # TILE_SIZE=10
                                wheel = (34, 34, 42)
                                wheel_hi = self._tint(wheel, add=(34, 34, 40))
                                wheel_lo = self._tint(wheel, add=(-18, -18, -18))
                                try:
                                    floor_col = self._tile_color(int(self.T_FLOOR))
                                except Exception:
                                    floor_col = (58, 56, 52)
                                pygame.draw.circle(surface, wheel, (cx, cy), int(outer))
                                pygame.draw.circle(surface, line, (cx, cy), int(outer), 1)
                                pygame.draw.circle(surface, floor_col, (cx, cy), int(max(1, outer - 2)))
                                pygame.draw.line(surface, wheel_lo, (cx, cy), (cx, rect.y + 2), 1)
                                pygame.draw.line(surface, wheel_lo, (cx, cy), (rect.x + 2, cy + 1), 1)
                                pygame.draw.line(surface, wheel_lo, (cx, cy), (rect.right - 3, cy + 1), 1)
                                hub = pygame.Rect(cx - 1, cy - 1, 3, 3)
                                surface.fill(wheel_hi, hub)
                                pygame.draw.rect(surface, line, hub, 1)
                                surface.fill(wheel_lo, pygame.Rect(cx, cy + 2, 1, 2))
                            if int(rely) == 0:
                                surface.fill(line, pygame.Rect(rect.x, rect.y, rect.w, 1))
                            if int(rely) == int(rh) - 1:
                                surface.fill(line, pygame.Rect(rect.x, rect.bottom - 1, rect.w, 1))
                            if int(relx) == 0:
                                surface.fill(line, pygame.Rect(rect.x, rect.y, 1, rect.h))
                            if int(relx) == int(rw) - 1:
                                surface.fill(line, pygame.Rect(rect.right - 1, rect.y, 1, rect.h))
                            return
        except Exception:
            pass

        col = self._tile_color(tile_id)
        surface.fill(col, rect)
        # RV world-interior: keep the interior floor perfectly flat (no noise/grit),
        # so it reads as a single uniform color.
        try:
            if bool(getattr(self, "rv_world_interior", False)) and int(tile_id) == int(self.T_FLOOR):
                key = getattr(self, "_rv_world_int_active_key", None)
                if isinstance(key, tuple) and len(key) == 4:
                    rx0, ry0, rw, rh = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
                    if int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh):
                        return
        except Exception:
            pass

        seed = int(self.seed) ^ (tile_id * 0x9E3779B9) ^ 0xB5297A4D
        h = int(self._hash2_u32(tx, ty, seed))

        # Simple gritty texture pass (cheap pixel-noise), inspired by the reference tone.
        hard = tile_id in (
            self.T_ROAD,
            self.T_HIGHWAY,
            self.T_PAVEMENT,
            self.T_PARKING,
            self.T_COURT,
            self.T_FLOOR,
            self.T_ELEVATOR,
            self.T_BARRICADE,
            self.T_SIDEWALK,
            self.T_BRICK,
            self.T_CONCRETE,
            self.T_BOARDWALK,
        )
        soft = tile_id in (self.T_GRASS, self.T_FOREST, self.T_WATER, self.T_SAND, self.T_MARSH)

        if hard or soft:
            for j in range(2):
                if ((h >> (j * 3)) & 7) != 0:
                    continue
                ox = int((h >> (8 + j * 6)) % max(1, int(self.TILE_SIZE)))
                oy = int((h >> (12 + j * 6)) % max(1, int(self.TILE_SIZE)))
                dv = -14 if ((h >> (20 + j)) & 1) else 12
                if tile_id in (self.T_GRASS, self.T_FOREST):
                    add = (dv // 4, dv, dv // 4)
                elif tile_id == self.T_WATER:
                    add = (dv // 5, dv // 5, dv)
                else:
                    add = (dv, dv, dv)
                surface.fill(self._tint(col, add=add), pygame.Rect(rect.x + ox, rect.y + oy, 1, 1))

        if tile_id == self.T_SIDEWALK:
            grout = self._tint(col, add=(-22, -18, -10))
            if (tx % 2) == 0:
                surface.fill(grout, pygame.Rect(rect.x, rect.y + 1, 1, rect.h - 2))
            if (ty % 2) == 0:
                surface.fill(grout, pygame.Rect(rect.x + 1, rect.y, rect.w - 2, 1))

        if tile_id == self.T_BRICK:
            mortar = self._tint(col, add=(-30, -22, -20))
            surface.fill(mortar, pygame.Rect(rect.x + 1, rect.y, rect.w - 2, 1))
            surface.fill(mortar, pygame.Rect(rect.x + 1, rect.y + rect.h // 2, rect.w - 2, 1))
            for row in range(2):
                y0 = rect.y + row * (rect.h // 2) + 1
                hgt = (rect.h // 2) - 1
                shift = 0 if ((tx + ty + row) % 2) == 0 else 2
                for x_off in (shift, (shift + 5) % self.TILE_SIZE):
                    surface.fill(mortar, pygame.Rect(rect.x + x_off, y0, 1, hgt))

        if tile_id == self.T_CONCRETE:
            seam = self._tint(col, add=(-18, -18, -22))
            if (tx % 4) == 0:
                surface.fill(seam, pygame.Rect(rect.x, rect.y + 1, 1, rect.h - 2))
            if (ty % 4) == 0:
                surface.fill(seam, pygame.Rect(rect.x + 1, rect.y, rect.w - 2, 1))

        if tile_id == self.T_SAND:
            # Beach speckles + dune hints.
            grain = self._tint(col, add=(18, 14, -8))
            if ((h >> 3) & 3) == 0:
                surface.fill(grain, pygame.Rect(rect.x + 2, rect.y + 2, 1, 1))
            if ((h >> 6) & 3) == 0:
                surface.fill(grain, pygame.Rect(rect.right - 3, rect.y + 3, 1, 1))
            if (ty % 5) == 0:
                dune = self._tint(col, add=(-14, -10, -6))
                surface.fill(dune, pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, 1))

        if tile_id == self.T_MARSH:
            # Mud + shallow puddles.
            mud = self._tint(col, add=(-16, -10, -16))
            if ((h >> 4) & 7) == 0:
                surface.fill(mud, pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, 1))
            if ((h >> 7) & 7) == 0:
                water = (40, 70, 96)
                surface.fill(water, pygame.Rect(rect.x + 2, rect.y + 3, 2, 1))

        if tile_id == self.T_BOARDWALK:
            # Wood planks.
            plank = self._tint(col, add=(-24, -18, -10))
            if (ty % 2) == 0:
                surface.fill(plank, pygame.Rect(rect.x + 1, rect.y + 2, rect.w - 2, 1))
            if (tx % 4) == 0:
                seam = self._tint(col, add=(-34, -26, -18))
                surface.fill(seam, pygame.Rect(rect.x + 1, rect.y + 1, 1, rect.h - 2))
            if ((h >> 5) & 31) == 0:
                nail = self._tint(col, add=(26, 18, 10))
                surface.fill(nail, pygame.Rect(rect.centerx, rect.centery, 1, 1))

        if tile_id == self.T_BARRICADE:
            # Simple boarded-up door/barricade tile (solid).
            base = self._tint(col, add=(10, 6, 0))
            plank1 = self._tint(base, add=(-18, -14, -10))
            plank2 = self._tint(base, add=(-30, -24, -18))
            nail = self._tint(base, add=(64, 64, 72))
            outline = (10, 10, 12)
            for i, y_off in enumerate((2, 5, 8)):
                rr = pygame.Rect(rect.x + 1, rect.y + int(y_off), rect.w - 2, 2)
                surface.fill(plank1 if (i % 2) == 0 else plank2, rr)
                pygame.draw.rect(surface, outline, rr, 1)
                if rr.w >= 8:
                    surface.fill(nail, pygame.Rect(rr.x + 2, rr.y + 1, 1, 1))
                    surface.fill(nail, pygame.Rect(rr.right - 3, rr.y + 1, 1, 1))

        if tile_id == self.T_PARKING:
            # Painted stall lines + curb edge so parking lots read clearly.
            line = self._tint(col, add=(86, 86, 92))
            line2 = self._tint(col, add=(58, 58, 64))
            if (tx % 3) == 0:
                surface.fill(line, pygame.Rect(rect.x + 1, rect.y + 1, 1, rect.h - 2))
            if (ty % 6) == 0:
                surface.fill(line, pygame.Rect(rect.x + 1, rect.y + 2, rect.w - 2, 1))
            # Occasional wheel-stop / marking block.
            if ((tx + ty + (h & 7)) % 17) == 0:
                surface.fill(line2, pygame.Rect(rect.centerx - 2, rect.centery + 2, 4, 1))

            curb = self._tint(col, add=(-34, -34, -34))
            if int(self.world.peek_tile(tx, ty - 1)) != int(self.T_PARKING):
                surface.fill(curb, pygame.Rect(rect.x, rect.y, rect.w, 1))
            if int(self.world.peek_tile(tx, ty + 1)) != int(self.T_PARKING):
                surface.fill(curb, pygame.Rect(rect.x, rect.bottom - 1, rect.w, 1))
            if int(self.world.peek_tile(tx - 1, ty)) != int(self.T_PARKING):
                surface.fill(curb, pygame.Rect(rect.x, rect.y, 1, rect.h))
            if int(self.world.peek_tile(tx + 1, ty)) != int(self.T_PARKING):
                surface.fill(curb, pygame.Rect(rect.right - 1, rect.y, 1, rect.h))

        if tile_id == self.T_HIGHWAY:
            # Abandoned highway: lane marks + cracks.
            mark = self._tint(col, add=(44, 44, 50))
            left = int(self.world.peek_tile(tx - 1, ty)) == int(self.T_HIGHWAY)
            right = int(self.world.peek_tile(tx + 1, ty)) == int(self.T_HIGHWAY)
            up = int(self.world.peek_tile(tx, ty - 1)) == int(self.T_HIGHWAY)
            down = int(self.world.peek_tile(tx, ty + 1)) == int(self.T_HIGHWAY)
            horiz = (left or right) and not (up or down)
            vert = (up or down) and not (left or right)
            if horiz and (tx % 6) == 0:
                surface.fill((210, 190, 110), pygame.Rect(rect.centerx - 2, rect.centery, 4, 1))
            elif vert and (ty % 6) == 0:
                surface.fill((210, 190, 110), pygame.Rect(rect.centerx, rect.centery - 2, 1, 4))
            # Shoulder edges.
            edge = self._tint(col, add=(32, 32, 36))
            if horiz:
                surface.fill(edge, pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, 1))
                surface.fill(edge, pygame.Rect(rect.x + 1, rect.bottom - 2, rect.w - 2, 1))
            elif vert:
                surface.fill(edge, pygame.Rect(rect.x + 1, rect.y + 1, 1, rect.h - 2))
                surface.fill(edge, pygame.Rect(rect.right - 2, rect.y + 1, 1, rect.h - 2))
            # Cracks.
            if (h & 31) == 0:
                crack = self._tint(col, add=(-30, -30, -30))
                pygame.draw.line(surface, crack, (rect.x + 2, rect.y + 7), (rect.right - 3, rect.y + 3), 1)

        if tile_id == self.T_ROAD:
            mark = self._tint(col, add=(32, 32, 36))
            left = int(self.world.peek_tile(tx - 1, ty)) == int(self.T_ROAD)
            right = int(self.world.peek_tile(tx + 1, ty)) == int(self.T_ROAD)
            up = int(self.world.peek_tile(tx, ty - 1)) == int(self.T_ROAD)
            down = int(self.world.peek_tile(tx, ty + 1)) == int(self.T_ROAD)
            horiz = (left or right) and not (up or down)
            vert = (up or down) and not (left or right)
            if horiz and (tx % 4) == 0:
                surface.fill(mark, pygame.Rect(rect.centerx - 2, rect.centery, 4, 1))
            elif vert and (ty % 4) == 0:
                surface.fill(mark, pygame.Rect(rect.centerx, rect.centery - 2, 1, 4))

        if tile_id in (self.T_PAVEMENT, self.T_SIDEWALK, self.T_BRICK, self.T_CONCRETE, self.T_BOARDWALK):
            curb = self._tint(col, add=(-26, -26, -26))
            if int(self.world.peek_tile(tx, ty - 1)) in (int(self.T_ROAD), int(self.T_HIGHWAY)):
                surface.fill(curb, pygame.Rect(rect.x, rect.y, rect.w, 1))
            if int(self.world.peek_tile(tx - 1, ty)) in (int(self.T_ROAD), int(self.T_HIGHWAY)):
                surface.fill(curb, pygame.Rect(rect.x, rect.y, 1, rect.h))
            curb_hi = self._tint(col, add=(16, 16, 16))
            if int(self.world.peek_tile(tx, ty + 1)) in (int(self.T_ROAD), int(self.T_HIGHWAY)):
                surface.fill(curb_hi, pygame.Rect(rect.x, rect.bottom - 1, rect.w, 1))
            if int(self.world.peek_tile(tx + 1, ty)) in (int(self.T_ROAD), int(self.T_HIGHWAY)):
                surface.fill(curb_hi, pygame.Rect(rect.right - 1, rect.y, 1, rect.h))

        if tile_id in (self.T_FLOOR, self.T_ELEVATOR, self.T_STAIRS_UP, self.T_STAIRS_DOWN):
            shadow = self._tint(col, add=(-18, -18, -18))
            if int(self.world.peek_tile(tx, ty - 1)) == int(self.T_WALL):
                surface.fill(shadow, pygame.Rect(rect.x, rect.y, rect.w, 1))
            if int(self.world.peek_tile(tx - 1, ty)) == int(self.T_WALL):
                surface.fill(shadow, pygame.Rect(rect.x, rect.y, 1, rect.h))

        if tile_id == self.T_ELEVATOR:
            edge = self._tint(col, add=(-34, -34, -34))
            hi = self._tint(col, add=(26, 26, 28))
            pygame.draw.rect(surface, edge, pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, rect.h - 2), 1)
            # Door split line + small top light.
            surface.fill(edge, pygame.Rect(rect.centerx, rect.y + 2, 1, max(1, rect.h - 4)))
            surface.fill(hi, pygame.Rect(rect.x + 2, rect.y + 2, max(1, rect.w - 4), 1))

        if tile_id in (self.T_STAIRS_UP, self.T_STAIRS_DOWN):
            step = self._tint(col, add=(34, 30, 24))
            edge = self._tint(col, add=(-28, -28, -28))
            pygame.draw.rect(surface, edge, pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, rect.h - 2), 1)
            for i in range(3):
                yy = int(rect.y + 2 + i * 2)
                surface.fill(step, pygame.Rect(int(rect.x + 2), int(yy), int(rect.w - 4), 1))
            ink = (230, 230, 240)
            if tile_id == self.T_STAIRS_UP:
                pygame.draw.polygon(surface, ink, [(rect.centerx, rect.y + 2), (rect.centerx - 2, rect.y + 6), (rect.centerx + 2, rect.y + 6)])
            else:
                pygame.draw.polygon(surface, ink, [(rect.centerx, rect.bottom - 3), (rect.centerx - 2, rect.bottom - 7), (rect.centerx + 2, rect.bottom - 7)])

        # World-map furniture (top-down pixel tiles).
        if tile_id in (
            self.T_TABLE,
            self.T_SHELF,
            self.T_CABINET,
            self.T_BED,
            self.T_SOFA,
            self.T_FRIDGE,
            self.T_TV,
            self.T_CHAIR,
            self.T_DOOR,
            self.T_DOOR_HOME,
            self.T_DOOR_LOCKED,
            self.T_DOOR_HOME_LOCKED,
            self.T_DOOR_BROKEN,
            self.T_PC,
            self.T_LAMP,
            self.T_SWITCH,
            self.T_TOILET,
            self.T_SINK,
            self.T_STEER,
        ):
            outline = (10, 10, 12)
            hi = self._tint(col, add=(24, 24, 26))
            lo = self._tint(col, add=(-28, -28, -30))

            # Furniture tiles should read as objects sitting on top of the floor,
            # not as full-tile colored blocks.
            if tile_id not in (self.T_DOOR, self.T_DOOR_HOME, self.T_DOOR_LOCKED, self.T_DOOR_HOME_LOCKED, self.T_DOOR_BROKEN):
                try:
                    floor_col = self._tile_color(int(self.T_FLOOR))
                    floor2 = self._tint(floor_col, add=(-6, -6, -8))
                    surface.fill(floor_col, rect)
                    if ((int(tx) + int(ty) + (int(h) & 3)) % 2) == 0:
                        surface.fill(floor2, pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, 1))
                except Exception:
                    pass

            if tile_id in (self.T_DOOR, self.T_DOOR_LOCKED, self.T_DOOR_BROKEN):
                inner = pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, rect.h - 2)
                pygame.draw.rect(surface, outline, inner, 1)
                panel = inner.inflate(-2, -2)
                if panel.w > 0 and panel.h > 0:
                    if tile_id == self.T_DOOR_BROKEN:
                        # Broken doorway: show a dark gap + splinters (passable).
                        gap = panel.inflate(-2, -2)
                        if gap.w > 0 and gap.h > 0:
                            surface.fill((10, 10, 12), gap)
                            surface.fill((24, 24, 30), pygame.Rect(gap.x + 1, gap.y + 1, max(1, gap.w - 2), 1))
                        # Remaining wood strips.
                        surface.fill(col, pygame.Rect(panel.x, panel.y, panel.w, 1))
                        surface.fill(col, pygame.Rect(panel.x, panel.bottom - 1, panel.w, 1))
                        surface.fill(col, pygame.Rect(panel.x, panel.y, 1, panel.h))
                        surface.fill(col, pygame.Rect(panel.right - 1, panel.y, 1, panel.h))
                        # Splinters.
                        surface.fill(lo, pygame.Rect(panel.centerx - 1, panel.y + 2, 1, max(1, panel.h - 4)))
                        surface.fill(hi, pygame.Rect(panel.centerx, panel.y + 3, 1, max(1, panel.h - 6)))
                        surface.fill(outline, pygame.Rect(panel.centerx - 1, panel.y + 2, 1, 1))
                    else:
                        open_p = 0.0
                        if tile_id == self.T_DOOR:
                            try:
                                open_p = float(getattr(self, "_door_open_anim", {}).get((int(tx), int(ty)), 0.0))
                            except Exception:
                                open_p = 0.0
                            open_p = float(min(1.0, max(0.0, open_p)))

                        if open_p > 0.001:
                            # Draw a small swinging leaf with a darker opening behind it.
                            gap = (12, 12, 14)
                            surface.fill(gap, panel)

                            left_wall = int(self.world.peek_tile(int(tx - 1), int(ty), default=int(self.T_WALL))) == int(self.T_WALL)
                            right_wall = int(self.world.peek_tile(int(tx + 1), int(ty), default=int(self.T_WALL))) == int(self.T_WALL)
                            up_wall = int(self.world.peek_tile(int(tx), int(ty - 1), default=int(self.T_WALL))) == int(self.T_WALL)
                            down_wall = int(self.world.peek_tile(int(tx), int(ty + 1), default=int(self.T_WALL))) == int(self.T_WALL)

                            shrink_w = True
                            if up_wall and down_wall and not (left_wall and right_wall):
                                shrink_w = False
                            elif left_wall and right_wall and not (up_wall and down_wall):
                                shrink_w = True
                            elif up_wall and down_wall:
                                shrink_w = False

                            hinge = (int(tx) ^ int(ty)) & 1
                            min_leaf = 2
                            if shrink_w:
                                leaf_w = max(int(min_leaf), int(round(float(panel.w) * (1.0 - 0.85 * float(open_p)))))
                                leaf = pygame.Rect(panel.x, panel.y, int(leaf_w), panel.h) if hinge == 0 else pygame.Rect(panel.right - int(leaf_w), panel.y, int(leaf_w), panel.h)
                            else:
                                leaf_h = max(int(min_leaf), int(round(float(panel.h) * (1.0 - 0.85 * float(open_p)))))
                                leaf = pygame.Rect(panel.x, panel.y, panel.w, int(leaf_h)) if hinge == 0 else pygame.Rect(panel.x, panel.bottom - int(leaf_h), panel.w, int(leaf_h))

                            surface.fill(col, leaf)
                            surface.fill(hi, pygame.Rect(leaf.x, leaf.y, leaf.w, 1))
                            surface.fill(lo, pygame.Rect(leaf.x, leaf.bottom - 1, leaf.w, 1))
                            if leaf.w > 3 and leaf.h > 3:
                                if shrink_w:
                                    surface.fill(lo, pygame.Rect(leaf.centerx, leaf.y + 1, 1, max(1, leaf.h - 2)))
                                else:
                                    surface.fill(lo, pygame.Rect(leaf.x + 1, leaf.centery, max(1, leaf.w - 2), 1))
                        else:
                            surface.fill(col, panel)
                            surface.fill(hi, pygame.Rect(panel.x, panel.y, panel.w, 1))
                            surface.fill(lo, pygame.Rect(panel.x, panel.bottom - 1, panel.w, 1))
                            surface.fill(lo, pygame.Rect(panel.centerx, panel.y + 1, 1, max(1, panel.h - 2)))
                surface.fill((30, 30, 34), pygame.Rect(inner.right - 2, inner.centery, 1, 1))
                if tile_id == self.T_DOOR_LOCKED:
                    lock = pygame.Rect(inner.centerx - 1, inner.centery - 1, 3, 3)
                    surface.fill((255, 220, 140), lock)
                    pygame.draw.rect(surface, outline, lock, 1)
            elif tile_id in (self.T_DOOR_HOME, self.T_DOOR_HOME_LOCKED):
                inner = pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, rect.h - 2)
                pygame.draw.rect(surface, outline, inner, 1)
                panel = inner.inflate(-2, -2)
                if panel.w > 0 and panel.h > 0:
                    open_p = 0.0
                    if tile_id == self.T_DOOR_HOME:
                        try:
                            open_p = float(getattr(self, "_door_open_anim", {}).get((int(tx), int(ty)), 0.0))
                        except Exception:
                            open_p = 0.0
                        open_p = float(min(1.0, max(0.0, open_p)))

                    if open_p > 0.001:
                        gap = (12, 12, 14)
                        surface.fill(gap, panel)

                        left_wall = int(self.world.peek_tile(int(tx - 1), int(ty), default=int(self.T_WALL))) == int(self.T_WALL)
                        right_wall = int(self.world.peek_tile(int(tx + 1), int(ty), default=int(self.T_WALL))) == int(self.T_WALL)
                        up_wall = int(self.world.peek_tile(int(tx), int(ty - 1), default=int(self.T_WALL))) == int(self.T_WALL)
                        down_wall = int(self.world.peek_tile(int(tx), int(ty + 1), default=int(self.T_WALL))) == int(self.T_WALL)

                        shrink_w = True
                        if up_wall and down_wall and not (left_wall and right_wall):
                            shrink_w = False
                        elif left_wall and right_wall and not (up_wall and down_wall):
                            shrink_w = True
                        elif up_wall and down_wall:
                            shrink_w = False

                        hinge = (int(tx) ^ int(ty)) & 1
                        min_leaf = 2
                        if shrink_w:
                            leaf_w = max(int(min_leaf), int(round(float(panel.w) * (1.0 - 0.85 * float(open_p)))))
                            leaf = pygame.Rect(panel.x, panel.y, int(leaf_w), panel.h) if hinge == 0 else pygame.Rect(panel.right - int(leaf_w), panel.y, int(leaf_w), panel.h)
                        else:
                            leaf_h = max(int(min_leaf), int(round(float(panel.h) * (1.0 - 0.85 * float(open_p)))))
                            leaf = pygame.Rect(panel.x, panel.y, panel.w, int(leaf_h)) if hinge == 0 else pygame.Rect(panel.x, panel.bottom - int(leaf_h), panel.w, int(leaf_h))

                        surface.fill(col, leaf)
                        surface.fill(hi, pygame.Rect(leaf.x, leaf.y, leaf.w, 1))
                        surface.fill(lo, pygame.Rect(leaf.x, leaf.bottom - 1, leaf.w, 1))
                        if leaf.w > 3 and leaf.h > 3:
                            if shrink_w:
                                surface.fill(lo, pygame.Rect(leaf.centerx, leaf.y + 1, 1, max(1, leaf.h - 2)))
                            else:
                                surface.fill(lo, pygame.Rect(leaf.x + 1, leaf.centery, max(1, leaf.w - 2), 1))
                    else:
                        surface.fill(col, panel)
                        surface.fill(hi, pygame.Rect(panel.x, panel.y, panel.w, 1))
                        surface.fill(lo, pygame.Rect(panel.x, panel.bottom - 1, panel.w, 1))
                        surface.fill(lo, pygame.Rect(panel.centerx, panel.y + 1, 1, max(1, panel.h - 2)))
                surface.fill((30, 30, 34), pygame.Rect(inner.right - 2, inner.centery, 1, 1))
                if tile_id == self.T_DOOR_HOME_LOCKED:
                    lock = pygame.Rect(inner.centerx - 1, inner.centery - 1, 3, 3)
                    surface.fill((255, 220, 140), lock)
                    pygame.draw.rect(surface, outline, lock, 1)
            elif tile_id == self.T_SWITCH:
                plate = pygame.Rect(rect.x + 3, rect.y + 3, rect.w - 6, rect.h - 6)
                pygame.draw.rect(surface, col, plate, border_radius=2)
                pygame.draw.rect(surface, outline, plate, 1, border_radius=2)
                on = bool(getattr(self, "home_light_on", True))
                dot = pygame.Rect(plate.centerx - 1, plate.centery - 1, 3, 3)
                surface.fill((120, 200, 140) if on else (220, 90, 70), dot)
                pygame.draw.rect(surface, outline, dot, 1)
            elif tile_id == self.T_STEER:
                # Steering wheel (cockpit). Used in the RV world-interior.
                cx, cy = int(rect.centerx), int(rect.centery)
                outer = 4  # fits TILE_SIZE=10 with a 1px margin
                wheel = (34, 34, 42)
                wheel_hi = self._tint(wheel, add=(34, 34, 40))
                wheel_lo = self._tint(wheel, add=(-18, -18, -18))
                try:
                    floor_col = self._tile_color(int(self.T_FLOOR))
                except Exception:
                    floor_col = (58, 56, 52)

                # Outer ring + inner hole (so it reads as a wheel, not a blob).
                pygame.draw.circle(surface, wheel, (cx, cy), int(outer))
                pygame.draw.circle(surface, outline, (cx, cy), int(outer), 1)
                pygame.draw.circle(surface, floor_col, (cx, cy), int(max(1, outer - 2)))

                # Spokes + hub.
                pygame.draw.line(surface, wheel_lo, (cx, cy), (cx, rect.y + 2), 1)
                pygame.draw.line(surface, wheel_lo, (cx, cy), (rect.x + 2, cy + 1), 1)
                pygame.draw.line(surface, wheel_lo, (cx, cy), (rect.right - 3, cy + 1), 1)
                hub = pygame.Rect(cx - 1, cy - 1, 3, 3)
                surface.fill(wheel_hi, hub)
                pygame.draw.rect(surface, outline, hub, 1)

                # Column hint (bottom).
                surface.fill(wheel_lo, pygame.Rect(cx, cy + 2, 1, 2))
            elif tile_id == self.T_LAMP:
                base = pygame.Rect(rect.centerx - 2, rect.bottom - 3, 4, 2)
                stem = pygame.Rect(rect.centerx, rect.y + 4, 1, rect.h - 7)
                shade = pygame.Rect(rect.centerx - 3, rect.y + 1, 6, 4)
                pygame.draw.rect(surface, outline, base, 1)
                surface.fill(lo, base.inflate(-2, -1))
                surface.fill(outline, stem)
                pygame.draw.rect(surface, (34, 34, 42), shade, border_radius=1)
                pygame.draw.rect(surface, outline, shade, 1, border_radius=1)
                if bool(getattr(self, "home_light_on", True)):
                    glow = shade.inflate(-2, -2)
                    if glow.w > 0 and glow.h > 0:
                        surface.fill((255, 240, 180), glow)
            elif tile_id == self.T_TOILET:
                # Toilet bowl (more readable than a plain white block).
                porcelain = (240, 240, 245)
                porcelain2 = (230, 230, 238)
                seat_col = (200, 200, 210)
                dark = (28, 28, 34)
                water = (64, 126, 190)
                water_hi = (120, 184, 220)

                bowl = pygame.Rect(rect.x + 2, rect.y + 4, rect.w - 4, rect.h - 5)
                pygame.draw.rect(surface, porcelain, bowl, border_radius=2)
                pygame.draw.rect(surface, outline, bowl, 1, border_radius=2)

                tank = pygame.Rect(rect.x + 3, rect.y + 1, rect.w - 6, 4)
                pygame.draw.rect(surface, porcelain2, tank, border_radius=2)
                pygame.draw.rect(surface, outline, tank, 1, border_radius=2)
                # Tiny handle.
                surface.fill((134, 140, 152), pygame.Rect(tank.right - 2, tank.y + 1, 1, 1))

                seat = bowl.inflate(-2, -2)
                if seat.w > 0 and seat.h > 0:
                    pygame.draw.rect(surface, seat_col, seat, border_radius=2)
                    pygame.draw.rect(surface, outline, seat, 1, border_radius=2)
                    hole = seat.inflate(-3, -3)
                    if hole.w > 0 and hole.h > 0:
                        pygame.draw.rect(surface, dark, hole, border_radius=2)
                        water_r = hole.inflate(-2, -2)
                        if water_r.w > 0 and water_r.h > 0:
                            pygame.draw.rect(surface, water, water_r, border_radius=2)
                            surface.fill(water_hi, pygame.Rect(water_r.x + 1, water_r.y + 1, max(1, water_r.w - 2), 1))
            elif tile_id == self.T_PC:
                # Simple 2-tile computer desk: left tile prefers monitor, right tile prefers tower.
                left_is_pc = int(self.world.peek_tile(int(tx - 1), int(ty))) == int(self.T_PC)
                right_is_pc = int(self.world.peek_tile(int(tx + 1), int(ty))) == int(self.T_PC)
                part = "single"
                if right_is_pc and not left_is_pc:
                    part = "left"
                elif left_is_pc and not right_is_pc:
                    part = "right"
                elif left_is_pc and right_is_pc:
                    part = "mid"

                # Desk body (top + front face).
                body = pygame.Rect(rect.x + 1, rect.y + 4, rect.w - 2, rect.h - 5)
                pygame.draw.rect(surface, outline, body, 1)
                surface.fill(hi, pygame.Rect(body.x + 1, body.y + 1, body.w - 2, 1))
                surface.fill(lo, pygame.Rect(body.x + 1, body.bottom - 2, body.w - 2, 1))
                # Legs.
                leg_y0 = int(body.bottom - 3)
                surface.fill(outline, pygame.Rect(body.x + 1, leg_y0, 1, 2))
                surface.fill(outline, pygame.Rect(body.right - 2, leg_y0, 1, 2))

                # Monitor (left side).
                if part in ("left", "single", "mid"):
                    mon = pygame.Rect(rect.x + 2, rect.y + 2, 5, 4)
                    pygame.draw.rect(surface, (34, 34, 42), mon, border_radius=1)
                    pygame.draw.rect(surface, outline, mon, 1, border_radius=1)
                    scr = mon.inflate(-2, -2)
                    surface.fill((14, 14, 18), scr)
                    surface.fill((120, 200, 240), pygame.Rect(scr.x + 1, scr.y + 1, 2, 1))
                    # Tiny stand.
                    surface.fill(outline, pygame.Rect(mon.centerx, mon.bottom, 1, 1))

                # Keyboard + tower (right side).
                if part in ("right", "single", "mid"):
                    kb = pygame.Rect(rect.x + 2, rect.y + 7, rect.w - 4, 2)
                    pygame.draw.rect(surface, (36, 36, 44), kb, border_radius=1)
                    pygame.draw.rect(surface, outline, kb, 1, border_radius=1)
                    if part in ("right", "single"):
                        tower = pygame.Rect(rect.right - 4, rect.y + 2, 3, 6)
                        pygame.draw.rect(surface, (26, 26, 32), tower, border_radius=1)
                        pygame.draw.rect(surface, outline, tower, 1, border_radius=1)
                        surface.fill((120, 200, 140), pygame.Rect(tower.x + 1, tower.y + 2, 1, 1))
            elif tile_id == self.T_FRIDGE:
                box = pygame.Rect(rect.x + 2, rect.y + 1, rect.w - 4, rect.h - 2)
                pygame.draw.rect(surface, col, box, border_radius=2)
                pygame.draw.rect(surface, outline, box, 1, border_radius=2)
                surface.fill(hi, pygame.Rect(box.x + 1, box.y + 1, box.w - 2, 1))
                surface.fill(lo, pygame.Rect(box.x + 1, box.bottom - 2, box.w - 2, 1))
                split_y = int(box.y + max(2, box.h // 3))
                surface.fill(outline, pygame.Rect(box.x + 1, split_y, box.w - 2, 1))
                # Handle.
                surface.fill((210, 210, 220), pygame.Rect(box.right - 2, box.y + 2, 1, max(2, box.h - 5)))
            elif tile_id == self.T_TV:
                frame_r = pygame.Rect(rect.x + 1, rect.y + 2, rect.w - 2, rect.h - 4)
                pygame.draw.rect(surface, (34, 34, 40), frame_r, border_radius=2)
                pygame.draw.rect(surface, outline, frame_r, 1, border_radius=2)
                screen = frame_r.inflate(-2, -3)
                tv_on = bool(getattr(self, "world_tv_states", {}).get((int(tx), int(ty)), False))
                surface.fill((14, 14, 18), screen)
                if tv_on and screen.w > 3 and screen.h > 2:
                    t = int(float(getattr(self, "world_time_s", 0.0)) * 8.0)
                    # Simple animated "show" (doesn't wash out the room).
                    c1 = (120, 200, 240)
                    c2 = (210, 180, 120)
                    for yy in range(screen.y + 1, screen.bottom - 1):
                        if ((yy + t) % 5) == 0:
                            surface.fill(c1, pygame.Rect(screen.x + 1, yy, screen.w - 2, 1))
                        elif ((yy + t) % 7) == 0:
                            surface.fill(c2, pygame.Rect(screen.x + 1, yy, screen.w - 2, 1))
                    surface.fill((240, 240, 250), pygame.Rect(screen.x + 1, screen.y + 1, 2, 1))
                else:
                    surface.fill((60, 110, 140), pygame.Rect(screen.x + 1, screen.y + 1, 2, 1))
                stand = pygame.Rect(rect.centerx - 1, rect.bottom - 2, 2, 1)
                surface.fill(outline, stand)
            elif tile_id == self.T_SOFA:
                left_sofa = int(self.world.peek_tile(int(tx - 1), int(ty))) == int(self.T_SOFA)
                right_sofa = int(self.world.peek_tile(int(tx + 1), int(ty))) == int(self.T_SOFA)
                edge_l = not left_sofa
                edge_r = not right_sofa
                inset_l = 2 if edge_l else 0
                inset_r = 2 if edge_r else 0
                back_w = int(max(1, int(rect.w) - int(inset_l) - int(inset_r)))
                back = pygame.Rect(rect.x + int(inset_l), rect.y + 2, int(back_w), 3)
                seat = pygame.Rect(back.x, rect.y + 5, back.w, 3)
                pygame.draw.rect(surface, col, back, border_radius=2)
                pygame.draw.rect(surface, outline, back, 1, border_radius=2)
                pygame.draw.rect(surface, lo, seat, border_radius=2)
                pygame.draw.rect(surface, outline, seat, 1, border_radius=2)
                surface.fill(hi, pygame.Rect(seat.x + 1, seat.y + 1, max(1, seat.w - 2), 1))
                if edge_l:
                    surface.fill(outline, pygame.Rect(back.x, back.y + 1, 1, back.h + 4))
                if edge_r:
                    surface.fill(outline, pygame.Rect(back.right - 1, back.y + 1, 1, back.h + 4))
            elif tile_id == self.T_BED:
                # Draw as a connected multi-tile object (no seam between tiles).
                left_is_bed = int(self.world.peek_tile(int(tx - 1), int(ty))) == int(self.T_BED)
                right_is_bed = int(self.world.peek_tile(int(tx + 1), int(ty))) == int(self.T_BED)
                inset_l = 0 if left_is_bed else 1
                inset_r = 0 if right_is_bed else 1
                bw = int(rect.w) - int(inset_l) - int(inset_r)
                if bw <= 0:
                    inset_l, inset_r = 1, 1
                    bw = max(1, int(rect.w) - 2)
                body = pygame.Rect(rect.x + int(inset_l), rect.y + 2, int(bw), rect.h - 3)
                surface.fill(col, body)
                surface.fill(hi, pygame.Rect(body.x + 1, body.y + 1, max(1, body.w - 2), 1))
                surface.fill(lo, pygame.Rect(body.x + 1, body.bottom - 2, max(1, body.w - 2), 1))
                # Outline (only on outer edges).
                pygame.draw.line(surface, outline, (body.left, body.top), (body.right - 1, body.top))
                pygame.draw.line(surface, outline, (body.left, body.bottom - 1), (body.right - 1, body.bottom - 1))
                if not left_is_bed:
                    pygame.draw.line(surface, outline, (body.left, body.top), (body.left, body.bottom - 1))
                if not right_is_bed:
                    pygame.draw.line(surface, outline, (body.right - 1, body.top), (body.right - 1, body.bottom - 1))

                # Pillow on the head side (prefer the "outer" end of a 2-tile bed).
                if right_is_bed and not left_is_bed:
                    pillow = pygame.Rect(body.x + 1, body.y + 1, 3, 2)
                elif left_is_bed and not right_is_bed:
                    pillow = pygame.Rect(body.right - 4, body.y + 1, 3, 2)
                else:
                    pillow = pygame.Rect(body.centerx - 1, body.y + 1, 2, 2)
                surface.fill((230, 230, 236), pillow)

                # Legs so the bed doesn't read as a flat block (outer corners only).
                if not left_is_bed:
                    surface.fill(outline, pygame.Rect(body.left + 1, body.bottom, 1, 1))
                if not right_is_bed:
                    surface.fill(outline, pygame.Rect(body.right - 2, body.bottom, 1, 1))
            elif tile_id == self.T_TABLE:
                top = pygame.Rect(rect.x + 1, rect.y + 2, rect.w - 2, 3)
                pygame.draw.rect(surface, col, top, border_radius=2)
                pygame.draw.rect(surface, outline, top, 1, border_radius=2)
                surface.fill(hi, pygame.Rect(top.x + 1, top.y + 1, max(1, top.w - 2), 1))
                surface.fill(lo, pygame.Rect(top.x + 1, top.bottom - 1, max(1, top.w - 2), 1))
                leg_y0 = int(top.bottom)
                leg_h = int(max(2, rect.bottom - 2 - leg_y0))
                surface.fill(outline, pygame.Rect(rect.x + 2, leg_y0, 1, leg_h))
                surface.fill(outline, pygame.Rect(rect.right - 3, leg_y0, 1, leg_h))
            elif tile_id == self.T_CHAIR:
                back = pygame.Rect(rect.x + 2, rect.y + 2, rect.w - 4, 2)
                seat = pygame.Rect(rect.x + 2, rect.y + 5, rect.w - 4, 3)
                pygame.draw.rect(surface, lo, back, border_radius=2)
                pygame.draw.rect(surface, outline, back, 1, border_radius=2)
                pygame.draw.rect(surface, col, seat, border_radius=2)
                pygame.draw.rect(surface, outline, seat, 1, border_radius=2)
                surface.fill(hi, pygame.Rect(seat.x + 1, seat.y + 1, max(1, seat.w - 2), 1))
                surface.fill(outline, pygame.Rect(seat.x + 1, rect.bottom - 2, 1, 1))
                surface.fill(outline, pygame.Rect(seat.right - 2, rect.bottom - 2, 1, 1))
            elif tile_id == self.T_SHELF:  # shelf
                box = pygame.Rect(rect.x + 1, rect.y + 1, rect.w - 2, rect.h - 2)
                pygame.draw.rect(surface, col, box, border_radius=2)
                pygame.draw.rect(surface, outline, box, 1, border_radius=2)
                surface.fill(lo, pygame.Rect(box.x + 1, box.y + 3, max(1, box.w - 2), 1))
                surface.fill(lo, pygame.Rect(box.x + 1, box.y + 6, max(1, box.w - 2), 1))
                surface.fill(hi, pygame.Rect(box.x + 1, box.bottom - 2, max(1, box.w - 2), 1))
                # Books hint.
                if ((int(tx) + int(ty)) % 3) == 0:
                    surface.fill((200, 120, 120), pygame.Rect(box.x + 2, box.y + 2, 1, 2))
                    surface.fill((120, 200, 140), pygame.Rect(box.x + 4, box.y + 2, 1, 2))
            elif tile_id == self.T_CABINET:
                # Kitchen cabinet (reads differently from bookshelf).
                counter = pygame.Rect(rect.x + 1, rect.y + 2, rect.w - 2, 2)
                body = pygame.Rect(rect.x + 1, rect.y + 4, rect.w - 2, rect.h - 5)
                surface.fill(hi, pygame.Rect(counter.x, counter.y, counter.w, 1))
                surface.fill(col, pygame.Rect(counter.x, counter.y + 1, counter.w, 1))
                pygame.draw.rect(surface, outline, pygame.Rect(counter.x, counter.y, counter.w, 2), 1)
                pygame.draw.rect(surface, col, body, border_radius=2)
                pygame.draw.rect(surface, outline, body, 1, border_radius=2)
                surface.fill(hi, pygame.Rect(body.x + 1, body.y + 1, max(1, body.w - 2), 1))
                surface.fill(lo, pygame.Rect(body.x + 1, body.bottom - 2, max(1, body.w - 2), 1))
                # Doors split + handles.
                surface.fill(outline, pygame.Rect(body.centerx, body.y + 1, 1, max(1, body.h - 2)))
                handle = (210, 210, 220)
                surface.fill(handle, pygame.Rect(body.centerx - 2, body.y + 2, 1, 1))
                surface.fill(handle, pygame.Rect(body.centerx + 1, body.y + 2, 1, 1))
            elif tile_id == self.T_SINK:
                # Bathroom/kitchen sink with a small faucet.
                rim = pygame.Rect(rect.x + 1, rect.y + 3, rect.w - 2, rect.h - 5)
                bowl = rim.inflate(-3, -4)
                steel = (200, 204, 214)
                steel2 = (150, 156, 170)
                water = (120, 170, 230)
                pygame.draw.rect(surface, outline, rim, 1, border_radius=2)
                pygame.draw.rect(surface, steel, bowl, border_radius=2)
                pygame.draw.rect(surface, outline, bowl, 1, border_radius=2)
                # Faucet
                fx = int(rect.centerx)
                surface.fill(steel2, pygame.Rect(fx - 1, rect.y + 1, 2, 3))
                surface.fill(steel2, pygame.Rect(fx - 3, rect.y + 3, 6, 1))
                surface.fill(outline, pygame.Rect(fx - 1, rect.y + 1, 2, 1))
                # Water hint
                surface.fill(water, pygame.Rect(bowl.x + 2, bowl.y + 2, max(1, bowl.w - 4), 1))
            elif tile_id == self.T_GAS_PUMP:
                # Simple gas pump (world-map prop tile).
                pump = pygame.Rect(rect.x + 2, rect.y + 1, rect.w - 4, rect.h - 2)
                red = (200, 70, 70)
                red2 = (150, 46, 46)
                glass = (120, 200, 240)
                pygame.draw.rect(surface, red2, pump, border_radius=2)
                pygame.draw.rect(surface, outline, pump, 1, border_radius=2)
                top = pygame.Rect(pump.x, pump.y, pump.w, 3)
                surface.fill(red, top)
                surface.fill(outline, pygame.Rect(top.x, top.bottom - 1, top.w, 1))
                # Display window.
                win = pygame.Rect(pump.x + 2, pump.y + 3, pump.w - 4, 3)
                pygame.draw.rect(surface, (20, 20, 24), win, border_radius=1)
                pygame.draw.rect(surface, outline, win, 1, border_radius=1)
                surface.fill(glass, pygame.Rect(win.x + 1, win.y + 1, max(1, win.w - 2), 1))
                # Hose.
                surface.fill(outline, pygame.Rect(pump.right - 2, pump.y + 4, 1, pump.h - 6))
                surface.fill(outline, pygame.Rect(pump.right - 3, pump.bottom - 3, 2, 1))
            else:
                pass

        # Proximity outline for interactable world tiles (keyboard-friendly).
        try:
            if (
                not self.inv_open
                and not bool(getattr(self, "world_map_open", False))
                and not bool(getattr(self, "home_ui_open", False))
                and not bool(getattr(self, "world_elevator_ui_open", False))
                and not (str(getattr(self, "player_pose_space", "")) == "world" and str(getattr(self, "player_pose", "")) in ("sleep", "sit"))
                and getattr(self, "mount", None) is None
            ):
                pt = getattr(self, "_draw_player_tile_xy", None)
                if isinstance(pt, tuple) and len(pt) == 2:
                    ptx, pty = int(pt[0]), int(pt[1])
                    if abs(int(tx) - int(ptx)) <= 1 and abs(int(ty) - int(pty)) <= 1:
                        if tile_id in (
                            int(self.T_DOOR),
                            int(self.T_DOOR_HOME),
                            int(self.T_DOOR_LOCKED),
                            int(self.T_DOOR_HOME_LOCKED),
                            int(self.T_BARRICADE),
                            int(self.T_ELEVATOR),
                            int(self.T_STAIRS_UP),
                            int(self.T_STAIRS_DOWN),
                            int(self.T_GAS_PUMP),
                        ):
                            pygame.draw.rect(surface, (120, 100, 60), rect, 1)
                            pygame.draw.rect(surface, (255, 220, 140), rect.inflate(-2, -2), 1)
        except Exception:
            pass

    def _draw_home_move_mode_overlay(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        if not bool(getattr(self, "home_move_mode", False)):
            return
        if getattr(self, "mount", None) is not None:
            return

        ts = int(self.TILE_SIZE)
        cur = getattr(self, "home_move_cursor", (0, 0))
        cx, cy = int(cur[0]), int(cur[1])
        px = int(cx * ts - int(cam_x))
        py = int(cy * ts - int(cam_y))
        r = pygame.Rect(px, py, ts, ts)

        # Ghost placement preview when carrying.
        carry = getattr(self, "home_move_carry", None)
        if isinstance(carry, dict):
            offsets = carry.get("offsets", [])
            home_key = getattr(self, "home_highrise_world_key", None)
            ok = True
            cells: list[tuple[int, int]] = []
            if not (isinstance(offsets, list) and isinstance(home_key, tuple) and len(home_key) == 4):
                ok = False
            else:
                cells = [(int(cx + int(dx)), int(cy + int(dy))) for dx, dy in offsets]
                for tx, ty in cells:
                    hit = self._peek_building_at_tile(int(tx), int(ty))
                    if hit is None:
                        ok = False
                        break
                    btx0, bty0, bw, bh = hit[:4]
                    if (int(btx0), int(bty0), int(bw), int(bh)) != tuple(int(v) for v in home_key):
                        ok = False
                        break
                    if int(self.world.peek_tile(int(tx), int(ty))) != int(self.T_FLOOR):
                        ok = False
                        break

            col = (120, 200, 140) if ok else (220, 90, 70)
            for tx, ty in cells:
                gx = int(tx * ts - int(cam_x))
                gy = int(ty * ts - int(cam_y))
                gr = pygame.Rect(gx, gy, ts, ts)
                ghost = pygame.Surface((ts, ts), pygame.SRCALPHA)
                ghost.fill((int(col[0]), int(col[1]), int(col[2]), 60))
                surface.blit(ghost, gr.topleft)
                pygame.draw.rect(surface, col, gr, 1)

        # Cursor outline + tiny "搬家小人".
        pygame.draw.rect(surface, (0, 0, 0), r, 2)
        pygame.draw.rect(surface, (255, 220, 140), r.inflate(-2, -2), 1)
        body_col = (255, 220, 140)
        head = pygame.Rect(r.centerx - 1, r.y + 2, 2, 2)
        torso = pygame.Rect(r.centerx - 1, r.y + 4, 2, 3)
        leg_l = pygame.Rect(r.centerx - 2, r.y + 7, 1, 2)
        leg_r = pygame.Rect(r.centerx + 1, r.y + 7, 1, 2)
        surface.fill(body_col, head)
        surface.fill(body_col, torso)
        surface.fill(body_col, leg_l)
        surface.fill(body_col, leg_r)

    def _tile_in_home_world(self, tx: int, ty: int) -> bool:
        tx = int(tx)
        ty = int(ty)
        home_key = getattr(self, "home_highrise_world_key", None)
        if not (isinstance(home_key, tuple) and len(home_key) == 4):
            return False
        hit = self._peek_building_at_tile(int(tx), int(ty))
        if hit is None:
            return False
        btx0, bty0, bw, bh = hit[:4]
        if (int(btx0), int(bty0), int(bw), int(bh)) != tuple(int(v) for v in home_key):
            return False
        home_floor = int(getattr(self, "home_highrise_world_floor", 0) or 0)
        if home_floor > 0:
            found = self._multi_house_at(int(tx), int(ty))
            if found is None:
                return False
            _ch, mh = found
            if int(getattr(mh, "cur_floor", 1)) != int(home_floor):
                return False
        return True

    def _tile_in_rv_world(self, tx: int, ty: int) -> bool:
        if not bool(getattr(self, "rv_world_interior", False)):
            return False
        key = getattr(self, "_rv_world_int_active_key", None)
        if not (isinstance(key, tuple) and len(key) == 4):
            return False
        try:
            rx0, ry0, rw, rh = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
        except Exception:
            return False
        tx = int(tx)
        ty = int(ty)
        return int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh)

    def _world_tile_screen_rect(self, tx: int, ty: int, cam_x: int, cam_y: int) -> pygame.Rect:
        tx = int(tx)
        ty = int(ty)
        ts = int(self.TILE_SIZE)
        x = int(tx) * int(ts) - int(cam_x)
        y = int(ty) * int(ts) - int(cam_y)
        overlay = getattr(self, "_inside_highrise_floor_overlay", None)
        if overlay is not None:
            try:
                tx0, ty0, w, h, floor_y0, offset_px = (
                    int(overlay[0]),
                    int(overlay[1]),
                    int(overlay[2]),
                    int(overlay[3]),
                    int(overlay[4]),
                    int(overlay[5]),
                )
                start_y = int(max(int(ty0), int(floor_y0) - 1))
                if int(offset_px) > 0 and int(tx0) <= int(tx) < int(tx0) + int(w) and int(ty0) <= int(ty) < int(ty0) + int(h) and int(ty) >= int(start_y):
                    y -= int(offset_px)
            except Exception:
                pass
        return pygame.Rect(int(x), int(y), int(ts), int(ts))

    def _screen_to_world_tile(self, mx: int, my: int, cam_x: int, cam_y: int) -> tuple[int, int]:
        mx = int(mx)
        my = int(my)
        ts = int(self.TILE_SIZE)
        if ts <= 0:
            return 0, 0
        tx = int(math.floor((float(cam_x) + float(mx)) / float(ts)))
        ty = int(math.floor((float(cam_y) + float(my)) / float(ts)))
        overlay = getattr(self, "_inside_highrise_floor_overlay", None)
        if overlay is not None:
            try:
                tx0, ty0, w, h, floor_y0, offset_px = (
                    int(overlay[0]),
                    int(overlay[1]),
                    int(overlay[2]),
                    int(overlay[3]),
                    int(overlay[4]),
                    int(overlay[5]),
                )
                start_y = int(max(int(ty0), int(floor_y0) - 1))
                if int(offset_px) > 0:
                    x0 = int(tx0) * int(ts) - int(cam_x)
                    x1 = int(x0 + int(w) * int(ts))
                    y0 = int(start_y) * int(ts) - int(cam_y) - int(offset_px)
                    y1 = int((int(ty0) + int(h)) * int(ts) - int(cam_y) - int(offset_px))
                    if int(x0) <= int(mx) < int(x1) and int(y0) <= int(my) < int(y1):
                        ty = int(math.floor((float(cam_y) + float(my) + float(offset_px)) / float(ts)))
            except Exception:
                pass
        return int(tx), int(ty)

    def _home_furniture_pickup_at(self, tx: int, ty: int) -> bool:
        if getattr(self, "mount", None) is not None:
            return False
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return False
        if isinstance(getattr(self, "home_move_carry", None), dict):
            return False

        tx = int(tx)
        ty = int(ty)
        ptx, pty = self._player_tile()
        if abs(int(tx) - int(ptx)) > 1 or abs(int(ty) - int(pty)) > 1:
            return False
        in_home = bool(self._tile_in_home_world(int(tx), int(ty)))
        in_rv = bool(self._tile_in_rv_world(int(tx), int(ty)))
        space = "rv" if in_rv else "home" if in_home else "world"

        movable = {
            int(self.T_TABLE),
            int(self.T_SHELF),
            int(self.T_CABINET),
            int(self.T_BED),
            int(self.T_SOFA),
            int(self.T_FRIDGE),
            int(self.T_TV),
            int(self.T_CHAIR),
            int(self.T_PC),
            int(self.T_LAMP),
            int(self.T_SWITCH),
            int(self.T_TOILET),
            int(self.T_SINK),
        }
        tid = int(self.world.get_tile(int(tx), int(ty)))
        if tid not in movable:
            return False
        if in_rv:
            fixed = getattr(self, "_rv_world_fixed_furniture", None)
            if isinstance(fixed, set) and (int(tx), int(ty)) in fixed:
                return False

        seen: set[tuple[int, int]] = set()
        stack = [(int(tx), int(ty))]
        cells: list[tuple[int, int]] = []
        while stack and len(cells) < 24:
            cx, cy = stack.pop()
            cx = int(cx)
            cy = int(cy)
            if (cx, cy) in seen:
                continue
            seen.add((cx, cy))
            if space == "rv":
                if not self._tile_in_rv_world(int(cx), int(cy)):
                    continue
            elif space == "home":
                if not self._tile_in_home_world(int(cx), int(cy)):
                    continue
            if int(self.world.get_tile(int(cx), int(cy))) != int(tid):
                continue
            if space == "rv":
                fixed = getattr(self, "_rv_world_fixed_furniture", None)
                if isinstance(fixed, set) and (int(cx), int(cy)) in fixed:
                    return False
            cells.append((int(cx), int(cy)))
            stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])

        if not cells:
            return False

        # Preserve durability for partially-damaged furniture blocks.
        hp = None
        try:
            anchor = min(cells)
            hp_key = self._world_furniture_hp_key(int(anchor[0]), int(anchor[1]))
            hp = self.world_furniture_hp.pop(hp_key, None)
            # Clear any stale per-cell keys too.
            for cx, cy in cells:
                self.world_furniture_hp.pop(self._world_furniture_hp_key(int(cx), int(cy)), None)
        except Exception:
            hp = None

        offsets = [(int(cx - tx), int(cy - ty)) for cx, cy in cells]
        carry: dict[str, object] = {"tid": int(tid), "offsets": offsets, "origin_cells": list(cells), "space": str(space)}
        if hp is not None:
            carry["hp"] = int(hp)
        self.home_move_carry = carry
        for cx, cy in cells:
            if space == "rv":
                base = getattr(self, "_rv_world_floor_base", None)
                base_tid = None
                if isinstance(base, dict):
                    base_tid = base.get((int(cx), int(cy)))
                if base_tid is None:
                    base_tid = int(self.T_FLOOR)
                self._world_set_tile(int(cx), int(cy), int(base_tid))
            elif space == "home":
                self._world_set_tile(int(cx), int(cy), int(self.T_FLOOR))
            else:
                base_tid = int(self._world_guess_base_tile_under_furniture(int(cx), int(cy)))
                self._world_set_tile(int(cx), int(cy), int(base_tid))
        self._set_hint("搬运：左键放下 | Shift+左键投掷 | 右键取消", seconds=1.6)
        return True

    def _home_furniture_can_place_at(self, anchor_tx: int, anchor_ty: int) -> tuple[bool, list[tuple[int, int]]]:
        carry = getattr(self, "home_move_carry", None)
        if not isinstance(carry, dict):
            return False, []
        tid = int(carry.get("tid", 0))
        offsets = carry.get("offsets", [])
        if not isinstance(offsets, list) or tid <= 0:
            return False, []

        space = str(carry.get("space", "home"))
        if space not in ("home", "rv", "world"):
            space = "world"
        anchor_tx = int(anchor_tx)
        anchor_ty = int(anchor_ty)
        cells = [(int(anchor_tx + int(dx)), int(anchor_ty + int(dy))) for dx, dy in offsets]
        for tx, ty in cells:
            if space == "rv":
                if not self._tile_in_rv_world(int(tx), int(ty)):
                    return False, cells
                base = getattr(self, "_rv_world_floor_base", None)
                if not isinstance(base, dict):
                    return False, cells
                want = base.get((int(tx), int(ty)))
                if want is None:
                    return False, cells
                if int(self.world.peek_tile(int(tx), int(ty))) != int(want):
                    return False, cells
            elif space == "home":
                if not self._tile_in_home_world(int(tx), int(ty)):
                    return False, cells
                if int(self.world.peek_tile(int(tx), int(ty))) != int(self.T_FLOOR):
                    return False, cells
            else:
                base_tid = int(self.world.peek_tile(int(tx), int(ty)))
                if int(base_tid) in self._WORLD_FURNITURE_HP_DEFAULTS:
                    return False, cells
                if int(base_tid) in (
                    int(self.T_DOOR),
                    int(self.T_DOOR_HOME),
                    int(self.T_DOOR_BROKEN),
                    int(self.T_STAIRS_UP),
                    int(self.T_STAIRS_DOWN),
                    int(self.T_ELEVATOR),
                ):
                    return False, cells
                if bool(self._tile_solid(int(base_tid))):
                    return False, cells
        return True, cells

    def _home_furniture_place_at(self, anchor_tx: int, anchor_ty: int) -> bool:
        ok, cells = self._home_furniture_can_place_at(int(anchor_tx), int(anchor_ty))
        if not ok:
            return False
        carry = getattr(self, "home_move_carry", None)
        if not isinstance(carry, dict):
            return False
        tid = int(carry.get("tid", 0))
        if tid <= 0:
            return False
        for tx, ty in cells:
            self._world_set_tile(int(tx), int(ty), int(tid))

        # Restore durability to the placed furniture block (if it was previously damaged).
        hp = carry.get("hp")
        if hp is not None:
            try:
                anchor = min(cells) if cells else (int(anchor_tx), int(anchor_ty))
                self.world_furniture_hp[self._world_furniture_hp_key(int(anchor[0]), int(anchor[1]))] = int(hp)
            except Exception:
                pass
        self.home_move_carry = None
        self._set_hint("已放下", seconds=0.9)
        return True

    def _world_furniture_throw_to(self, tx: int, ty: int) -> bool:
        carry = getattr(self, "home_move_carry", None)
        if not isinstance(carry, dict):
            return False
        tid = int(carry.get("tid", 0))
        offsets = carry.get("offsets", [])
        if tid <= 0 or not isinstance(offsets, list) or not offsets:
            return False

        space = str(carry.get("space", "world"))
        if space not in ("home", "rv", "world"):
            space = "world"

        # Aim at the target tile center.
        tx = int(tx)
        ty = int(ty)
        target = pygame.Vector2((tx + 0.5) * float(self.TILE_SIZE), (ty + 0.5) * float(self.TILE_SIZE))
        start = pygame.Vector2(self.player.pos)
        d = target - start
        if d.length_squared() <= 0.001:
            d = pygame.Vector2(self.player.facing)
        if d.length_squared() <= 0.001:
            d = pygame.Vector2(1, 0)
        d = d.normalize()

        size_bonus = int(min(len(offsets), 6))
        speed = 220.0 + 18.0 * float(size_bonus)
        spawn = start + d * 10.0
        hp = carry.get("hp")
        self.thrown_furniture.append(
            HardcoreSurvivalState._ThrownFurniture(
                pos=pygame.Vector2(spawn),
                vel=pygame.Vector2(d) * float(speed),
                ttl=1.25,
                tid=int(tid),
                offsets=[(int(o[0]), int(o[1])) for o in offsets if isinstance(o, tuple) and len(o) == 2],
                space=str(space),
                hp=(int(hp) if hp is not None else None),
            )
        )
        self.home_move_carry = None
        self.app.play_sfx("swing")
        self._set_hint("投掷！", seconds=0.7)
        return True

    def _draw_world_furniture_carry_preview(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        if bool(getattr(self, "home_move_mode", False)):
            return
        carry = getattr(self, "home_move_carry", None)
        if not isinstance(carry, dict):
            return
        if getattr(self, "mount", None) is not None:
            return

        mp = self.app.screen_to_internal(pygame.mouse.get_pos())
        if mp is None:
            return
        mx, my = int(mp[0]), int(mp[1])
        anchor_tx, anchor_ty = self._screen_to_world_tile(int(mx), int(my), int(cam_x), int(cam_y))
        ok, cells = self._home_furniture_can_place_at(int(anchor_tx), int(anchor_ty))
        col = (120, 200, 140) if ok else (220, 90, 70)
        ts = int(self.TILE_SIZE)
        ghost = pygame.Surface((ts, ts), pygame.SRCALPHA)
        ghost.fill((int(col[0]), int(col[1]), int(col[2]), 60))
        for tx, ty in cells:
            r = self._world_tile_screen_rect(int(tx), int(ty), int(cam_x), int(cam_y))
            surface.blit(ghost, r.topleft)
            pygame.draw.rect(surface, col, r, 1)

        # Tiny hint near the cursor (minimal text).
        hint = "放下/投掷/取消"
        font = self.app.font_s
        w = int(font.size(hint)[0]) + 10
        h = int(font.get_height()) + 6
        bx = int(clamp(int(mx + 14), 4, int(INTERNAL_W - 4 - w)))
        by = int(clamp(int(my + 14), 4, int(INTERNAL_H - 4 - h)))
        panel = pygame.Rect(bx, by, w, h)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=6)
        pygame.draw.rect(surface, (90, 90, 110), panel, 1, border_radius=6)
        draw_text(surface, font, hint, (panel.centerx, panel.centery - 1), pygame.Color(230, 230, 240), anchor="center")

    def _draw_world_context_menu(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        self.world_ctx_open = False
        self.world_ctx_target = None
        self.world_ctx_rects = []
        if bool(getattr(self, "lamp_cfg_open", False)):
            return
        if bool(getattr(self, "home_move_mode", False)):
            return
        if isinstance(getattr(self, "home_move_carry", None), dict):
            return
        if getattr(self, "mount", None) is not None:
            return
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "house_interior", False))
            or bool(getattr(self, "sch_interior", False))
        ):
            return
        if float(getattr(self, "world_ctx_cooldown_left", 0.0)) > 0.0:
            return
        if float(getattr(self, "speech_left", 0.0)) > 0.0:
            return
        if str(getattr(self, "player_pose_space", "")) == "world" and str(getattr(self, "player_pose", "")) in ("sleep", "sit"):
            return

        tx, ty = self._player_tile()
        # If the player moved after an auto-dismiss, allow the bubble again.
        sup = getattr(self, "world_ctx_suppressed", None)
        if isinstance(sup, dict):
            pt = sup.get("player_tile")
            if isinstance(pt, tuple) and len(pt) == 2 and (int(tx), int(ty)) != (int(pt[0]), int(pt[1])):
                self.world_ctx_suppressed = None

        candidates = [
            (tx, ty),
            (tx + 1, ty),
            (tx - 1, ty),
            (tx, ty + 1),
            (tx, ty - 1),
            (tx + 1, ty + 1),
            (tx + 1, ty - 1),
            (tx - 1, ty + 1),
            (tx - 1, ty - 1),
        ]
        interact = {
            int(self.T_TABLE),
            int(self.T_SOFA),
            int(self.T_CHAIR),
            int(self.T_BED),
            int(self.T_FRIDGE),
            int(self.T_SHELF),
            int(self.T_CABINET),
            int(self.T_TV),
            int(self.T_PC),
            int(self.T_LAMP),
            int(self.T_SWITCH),
            int(self.T_TOILET),
            int(self.T_SINK),
        }
        pri = {
            int(self.T_LAMP): 0,
            int(self.T_FRIDGE): 1,
            int(self.T_SHELF): 1,
            int(self.T_CABINET): 1,
            int(self.T_TABLE): 1,
            int(self.T_SINK): 1,
            int(self.T_BED): 2,
            int(self.T_TOILET): 2,
            int(self.T_SOFA): 3,
            int(self.T_CHAIR): 3,
            int(self.T_PC): 4,
            int(self.T_TV): 4,
            int(self.T_SWITCH): 5,
        }
        chosen: tuple[int, int, int] | None = None
        best = None
        for cx, cy in candidates:
            tid = int(self.world.get_tile(int(cx), int(cy)))
            if tid not in interact:
                continue
            d = max(abs(int(cx) - int(tx)), abs(int(cy) - int(ty)))
            key = (int(pri.get(int(tid), 9)), int(d), int(cy), int(cx))
            if best is None or key < best:
                best = key
                chosen = (int(cx), int(cy), int(tid))
        if chosen is None:
            return

        cx, cy, tid = chosen
        sup = getattr(self, "world_ctx_suppressed", None)
        if isinstance(sup, dict):
            stgt = sup.get("target")
            pt = sup.get("player_tile")
            if (
                isinstance(stgt, tuple)
                and len(stgt) == 3
                and isinstance(pt, tuple)
                and len(pt) == 2
                and (int(tx), int(ty)) == (int(pt[0]), int(pt[1]))
                and (int(cx), int(cy), int(tid)) == (int(stgt[0]), int(stgt[1]), int(stgt[2]))
            ):
                return

        # Outline the whole connected block (2-tile bed/sofa/pc).
        seen: set[tuple[int, int]] = set()
        stack = [(int(cx), int(cy))]
        block: list[tuple[int, int]] = []
        while stack and len(block) < 24:
            sx, sy = stack.pop()
            sx = int(sx)
            sy = int(sy)
            if (sx, sy) in seen:
                continue
            seen.add((sx, sy))
            if int(self.world.get_tile(int(sx), int(sy))) != int(tid):
                continue
            block.append((int(sx), int(sy)))
            stack.extend([(sx + 1, sy), (sx - 1, sy), (sx, sy + 1), (sx, sy - 1)])
        if not block:
            block = [(int(cx), int(cy))]

        tile_rect: pygame.Rect | None = None
        for bx, by in block:
            r = self._world_tile_screen_rect(int(bx), int(by), int(cam_x), int(cam_y))
            tile_rect = r if tile_rect is None else tile_rect.union(r)
        if tile_rect is None:
            return
        # Pixel-perfect outline (no rounded corners).
        pygame.draw.rect(surface, (120, 100, 60), tile_rect.inflate(2, 2), 1)
        pygame.draw.rect(surface, (255, 220, 140), tile_rect, 1)

        # Build options.
        in_owned_space = bool(self._tile_in_home_world(int(cx), int(cy)) or self._tile_in_rv_world(int(cx), int(cy)))
        opts: list[tuple[str, str]] = []
        if int(tid) in (int(self.T_SOFA), int(self.T_CHAIR)):
            opts = [("搬运", "move")]
            if in_owned_space:
                opts.insert(0, ("坐", "sit"))
        elif int(tid) == int(self.T_BED):
            opts = [("搬运", "move")]
            if in_owned_space:
                opts.insert(0, ("睡觉", "sleep"))
        elif int(tid) in (int(self.T_FRIDGE), int(self.T_SHELF), int(self.T_CABINET)):
            opts = [("搬运", "move")]
            if in_owned_space:
                opts.insert(0, ("打开", "open"))
        elif int(tid) == int(self.T_SINK):
            opts = [("搬运", "move")]
            if in_owned_space:
                opts.insert(0, ("接水", "water"))
        elif int(tid) == int(self.T_TABLE):
            opts = [("搬运", "move")]
        elif int(tid) == int(self.T_PC):
            opts = [("搬运", "move")]
            if in_owned_space:
                opts.insert(0, ("用电脑", "pc"))
        elif int(tid) == int(self.T_STEER):
            opts = [("开车", "drive")]
        elif int(tid) == int(self.T_TV):
            opts = [("搬运", "move")]
            if in_owned_space:
                tv_on = bool(getattr(self, "world_tv_states", {}).get((int(cx), int(cy)), False))
                opts.insert(0, ("关电视" if tv_on else "开电视", "tv"))
        elif int(tid) == int(self.T_LAMP):
            opts = [("搬运", "move")]
            if in_owned_space:
                opts.insert(0, ("设置", "lamp_cfg"))
                opts.insert(0, ("关灯" if bool(getattr(self, "home_light_on", True)) else "开灯", "light"))
        elif int(tid) == int(self.T_SWITCH):
            opts = [("搬运", "move")]
            if in_owned_space:
                opts.insert(0, ("设置", "lamp_cfg"))
                opts.insert(0, ("关灯" if bool(getattr(self, "home_light_on", True)) else "开灯", "light"))
        elif int(tid) == int(self.T_TOILET):
            opts = [("搬运", "move")]
            if in_owned_space:
                opts.insert(0, ("大便", "poop"))
                opts.insert(0, ("小便", "pee"))
        if not opts:
            return

        # Compact menu (doesn't cover the whole room).
        btn_w = 32
        btn_h = 14
        gap = 3
        panel_w = int(len(opts) * btn_w + max(0, len(opts) - 1) * gap + 8)
        panel_h = int(btn_h + 8)
        px = int(tile_rect.centerx - panel_w // 2)
        py = int(tile_rect.top - panel_h - 8)
        if py < 4:
            py = int(tile_rect.bottom + 8)
        px = int(clamp(int(px), 4, int(INTERNAL_W - 4 - panel_w)))
        py = int(clamp(int(py), 4, int(INTERNAL_H - 4 - panel_h)))
        panel = pygame.Rect(px, py, panel_w, panel_h)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=5)
        pygame.draw.rect(surface, (90, 90, 110), panel, 1, border_radius=5)

        x0 = int(panel.x + 4)
        y0 = int(panel.y + 4)
        font = self.app.font_s
        rects: list[tuple[pygame.Rect, str]] = []
        for i, (label, action) in enumerate(opts):
            br = pygame.Rect(int(x0 + i * (btn_w + gap)), int(y0), int(btn_w), int(btn_h))
            pygame.draw.rect(surface, (28, 28, 34), br, border_radius=4)
            pygame.draw.rect(surface, (160, 160, 180), br, 1, border_radius=4)
            draw_text(surface, font, str(label), (br.centerx, br.centery - 1), pygame.Color(230, 230, 240), anchor="center")
            rects.append((br, str(action)))

        self.world_ctx_open = True
        self.world_ctx_target = (int(cx), int(cy), int(tid))
        self.world_ctx_rects = rects

    def _blit_sprite_outline(self, surface: pygame.Surface, spr: pygame.Surface, rect: pygame.Rect, *, color: tuple[int, int, int]) -> None:
        r, g, b = (int(color[0]), int(color[1]), int(color[2]))
        key = (id(spr), int(r), int(g), int(b))
        cache: dict[tuple[int, int, int, int], pygame.Surface] = getattr(self, "_sprite_outline_cache", {})
        out = cache.get(key)
        if out is None:
            mask = pygame.mask.from_surface(spr)
            shape = mask.to_surface(setcolor=(r, g, b, 255), unsetcolor=(0, 0, 0, 0))
            out = pygame.Surface((spr.get_width() + 2, spr.get_height() + 2), pygame.SRCALPHA)
            # 1px outline by stamping the silhouette around the sprite.
            out.blit(shape, (0, 1))
            out.blit(shape, (2, 1))
            out.blit(shape, (1, 0))
            out.blit(shape, (1, 2))
            cache[key] = out
            self._sprite_outline_cache = cache
        surface.blit(out, (int(rect.left) - 1, int(rect.top) - 1))
        surface.blit(spr, rect)

    def _draw_hover_tooltip(self, surface: pygame.Surface) -> None:
        tip = getattr(self, "_hover_tooltip", None)
        if tip is None:
            return
        lines, pos = tip
        if not lines:
            return
        mx, my = int(pos[0]), int(pos[1])

        font = self.app.font_s
        pad = 6
        line_h = max(10, int(font.get_height()))
        w = 0
        for ln in lines:
            w = max(w, int(font.size(str(ln))[0]))
        w = int(w + pad * 2)
        h = int(len(lines) * line_h + pad * 2)

        x = mx + 12
        y = my + 12
        if x + w > INTERNAL_W - 4:
            x = max(4, INTERNAL_W - 4 - w)
        if y + h > INTERNAL_H - 4:
            y = max(4, INTERNAL_H - 4 - h)

        panel = pygame.Rect(int(x), int(y), int(w), int(h))
        ui = pygame.Surface((panel.w, panel.h), pygame.SRCALPHA)
        ui.fill((10, 10, 14, 220))
        pygame.draw.rect(ui, (90, 90, 110, 235), ui.get_rect(), 1, border_radius=8)
        surface.blit(ui, panel.topleft)

        for i, ln in enumerate(lines):
            col = pygame.Color(240, 240, 244) if i == 0 else pygame.Color(180, 180, 190)
            draw_text(surface, font, str(ln), (panel.left + pad, panel.top + pad + i * line_h), col, anchor="topleft")

    def _draw_vehicle_props(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
    ) -> None:
        start_cx = start_tx // self.CHUNK_SIZE
        end_cx = end_tx // self.CHUNK_SIZE
        start_cy = start_ty // self.CHUNK_SIZE
        end_cy = end_ty // self.CHUNK_SIZE

        hovered = None  # (d2, spr, rect, lines, (mx,my))
        mouse = None
        if (
            not self.inv_open
            and not bool(getattr(self, "rv_ui_open", False))
            and not bool(getattr(self, "world_map_open", False))
        ):
            mouse = self.app.screen_to_internal(pygame.mouse.get_pos())

        for cy in range(start_cy, end_cy + 1):
            for cx in range(start_cx, end_cx + 1):
                chunk = self.world.peek_chunk(cx, cy)
                if chunk is None:
                    continue

                for car in getattr(chunk, "cars", []):
                    p = pygame.Vector2(getattr(car, "pos", pygame.Vector2(0, 0))) - pygame.Vector2(cam_x, cam_y)
                    sx = iround(float(p.x))
                    sy = iround(float(p.y))
                    if sx < -80 or sx > INTERNAL_W + 80 or sy < -80 or sy > INTERNAL_H + 80:
                        continue
                    mid = str(getattr(car, "model_id", "schoolbus"))
                    steer_state = int(getattr(car, "steer_state", 0))
                    frame = int(getattr(car, "frame", 0)) % 2
                    base = self._CAR_BASE.get((mid, int(steer_state), int(frame)))
                    shadow_base = self._CAR_SHADOW.get((mid, int(steer_state), int(frame)))
                    if base is None:
                        base = self._CAR_BASE.get(("schoolbus", 0, 0))
                        shadow_base = self._CAR_SHADOW.get(("schoolbus", 0, 0))
                        if base is None:
                            continue
                    deg = -math.degrees(float(getattr(car, "heading", 0.0)))
                    spr = rotate_pixel_sprite(base, deg, step_deg=5.0)
                    rect = spr.get_rect(center=(sx, sy))
                    if shadow_base is not None:
                        sh = rotate_pixel_sprite(shadow_base, deg, step_deg=5.0)
                        srect = sh.get_rect(center=(rect.centerx + 2, rect.centery + 6))
                        surface.blit(sh, srect)
                    surface.blit(spr, rect)
                    if mouse is not None:
                        mx, my = int(mouse[0]), int(mouse[1])
                        if rect.collidepoint(mx, my):
                            model = self._CAR_MODELS.get(str(mid))
                            name = model.name if model is not None else str(mid)
                            wpos = pygame.Vector2(getattr(car, "pos", pygame.Vector2(0, 0)))
                            try:
                                pad = 22
                                cmodel = self._CAR_MODELS.get(str(mid)) or self._CAR_MODELS.get("rv")
                                cw, ch = (cmodel.collider if cmodel is not None else (22, 14))
                                chead = float(getattr(car, "heading", 0.0))
                                c = abs(math.cos(float(chead)))
                                s = abs(math.sin(float(chead)))
                                ww = float(cw) * c + float(ch) * s
                                hh = float(cw) * s + float(ch) * c
                                aabb = pygame.Rect(
                                    iround(float(wpos.x) - float(ww) / 2.0),
                                    iround(float(wpos.y) - float(hh) / 2.0),
                                    int(max(2, int(round(float(ww))))),
                                    int(max(2, int(round(float(hh))))),
                                )
                                near = bool(
                                    aabb.inflate(int(pad * 2), int(pad * 2)).collidepoint(
                                        int(round(float(self.player.pos.x))), int(round(float(self.player.pos.y)))
                                    )
                                )
                            except Exception:
                                near = (self.player.pos - wpos).length_squared() <= (22.0 * 22.0)
                            if self.mount is None:
                                prompt = "F 开车" if near else "靠近后: F 开车"
                            else:
                                prompt = "先下车再换车"
                            lines = [f"{name}", "类型: 载具(停放)", prompt]
                            if hasattr(car, "fuel"):
                                lines.insert(1, f"燃油: {int(getattr(car, 'fuel', 0.0))}")
                            d2 = float((mx - sx) * (mx - sx) + (my - sy) * (my - sy))
                            if hovered is None or d2 < float(hovered[0]):
                                hovered = (d2, spr, rect.copy(), lines, (mx, my))

                for b in getattr(chunk, "bikes", []):
                    p = pygame.Vector2(getattr(b, "pos", pygame.Vector2(0, 0))) - pygame.Vector2(cam_x, cam_y)
                    sx = iround(float(p.x))
                    sy = iround(float(p.y))
                    if sx < -40 or sx > INTERNAL_W + 40 or sy < -40 or sy > INTERNAL_H + 40:
                        continue
                    mid = str(getattr(b, "model_id", "bike"))
                    d = str(getattr(b, "dir", "right"))
                    frm = int(getattr(b, "frame", 0)) % 2
                    model = self._TWO_WHEEL_FRAMES.get(mid) or self._TWO_WHEEL_FRAMES.get("bike") or {}
                    frames = model.get(d) or model.get("right") or self._BIKE_FRAMES.get("right", [])
                    if not frames:
                        continue
                    spr = frames[min(int(frm), len(frames) - 1)]
                    _cw, ch = self._two_wheel_collider_px(mid)
                    ground_y = iround(float(sy) + float(ch) / 2.0)
                    rect = spr.get_rect()
                    baseline_y = int(self._sprite_baseline_y(spr))
                    rect.centerx = int(sx)
                    rect.bottom = iround(float(ground_y) + float(rect.h - baseline_y))
                    shadow = self._two_wheel_shadow_rect(rect, d, ground_y=int(ground_y))
                    sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
                    pygame.draw.ellipse(sh, (0, 0, 0, 120), sh.get_rect())
                    surface.blit(sh, shadow.topleft)
                    surface.blit(spr, rect)
                    if mouse is not None:
                        mx, my = int(mouse[0]), int(mouse[1])
                        if rect.collidepoint(mx, my):
                            name = self._two_wheel_name(str(mid))
                            wpos = pygame.Vector2(getattr(b, "pos", pygame.Vector2(0, 0)))
                            near = (self.player.pos - wpos).length_squared() <= (18.0 * 18.0)
                            if self.mount is None:
                                prompt = "F 骑车" if near else "靠近后: F 骑车"
                            else:
                                prompt = "先下车再换车"
                            lines = [f"{name}", "类型: 载具(停放)", prompt]
                            if str(mid).startswith("moto"):
                                lines.insert(1, f"燃油: {int(getattr(b, 'fuel', 0.0))}")
                            d2 = float((mx - sx) * (mx - sx) + (my - sy) * (my - sy))
                            if hovered is None or d2 < float(hovered[0]):
                                hovered = (d2, spr, rect.copy(), lines, (mx, my))

        if hovered is None or mouse is None:
            return
        _d2, spr, rect, lines, mpos = hovered
        hi = (255, 245, 140)
        self._blit_sprite_outline(surface, spr, rect, color=hi)
        self._hover_tooltip = (list(lines), (int(mpos[0]), int(mpos[1])))

    def _draw_world_props(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
    ) -> None:
        # Mouse hover: outline + tooltip.
        hovered = None  # (d2, prop, sprite|None, rect, sx, sy)
        mouse = None
        if not self.inv_open and not bool(getattr(self, "rv_ui_open", False)) and not bool(
            getattr(self, "world_map_open", False)
        ):
            mouse = self.app.screen_to_internal(pygame.mouse.get_pos())

        # RV world-interior: hide outside props that fall inside the stamped interior area
        # (e.g., streetlamps on the sidewalk shouldn't appear inside the RV).
        rv_hide: tuple[int, int, int, int] | None = None
        if bool(getattr(self, "rv_world_interior", False)):
            key = getattr(self, "_rv_world_int_active_key", None)
            if isinstance(key, tuple) and len(key) == 4:
                try:
                    rv_hide = (int(key[0]), int(key[1]), int(key[2]), int(key[3]))
                except Exception:
                    rv_hide = None

        ts = int(self.TILE_SIZE)
        start_cx = start_tx // self.CHUNK_SIZE
        end_cx = end_tx // self.CHUNK_SIZE
        start_cy = start_ty // self.CHUNK_SIZE
        end_cy = end_ty // self.CHUNK_SIZE

        for cy in range(start_cy, end_cy + 1):
            for cx in range(start_cx, end_cx + 1):
                chunk = self.world.peek_chunk(cx, cy)
                if chunk is None:
                    continue
                for pr in getattr(chunk, "props", []):
                    if rv_hide is not None and ts > 0:
                        try:
                            px = float(getattr(getattr(pr, "pos", pygame.Vector2(0, 0)), "x", 0.0))
                            py = float(getattr(getattr(pr, "pos", pygame.Vector2(0, 0)), "y", 0.0))
                            tx = int(math.floor(px / float(ts)))
                            ty = int(math.floor(py / float(ts)))
                            rx0, ry0, rw, rh = rv_hide
                            if int(rx0) <= int(tx) < int(rx0) + int(rw) and int(ry0) <= int(ty) < int(ry0) + int(rh):
                                continue
                        except Exception:
                            pass
                    sx = int(round(pr.pos.x - cam_x))
                    sy = int(round(pr.pos.y - cam_y))
                    if sx < -64 or sx > INTERNAL_W + 64 or sy < -64 or sy > INTERNAL_H + 64:
                        continue

                    pdef = self._PROP_DEFS.get(str(getattr(pr, "prop_id", "")))
                    spr = None
                    if pdef is not None:
                        sprites = getattr(pdef, "sprites", ())
                        if sprites:
                            idx = int(getattr(pr, "variant", 0)) % len(sprites)
                            spr = sprites[int(idx)]

                    if spr is not None:
                        rect = spr.get_rect(center=(sx, sy))
                        sw = max(4, int(rect.w) - 6)
                        shadow = pygame.Rect(0, 0, sw, 4)
                        shadow.center = (rect.centerx, rect.bottom - 1)
                        sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
                        pygame.draw.ellipse(sh, (0, 0, 0, 100), sh.get_rect())
                        surface.blit(sh, shadow.topleft)
                        surface.blit(spr, rect)
                    else:
                        rect = pygame.Rect(sx - 4, sy - 4, 8, 8)
                        pygame.draw.rect(surface, (0, 0, 0), rect)
                        pygame.draw.rect(surface, (210, 80, 220), rect.inflate(-2, -2))

                    if mouse is not None:
                        mx, my = int(mouse[0]), int(mouse[1])
                        if rect.collidepoint(mx, my):
                            d2 = float((mx - sx) * (mx - sx) + (my - sy) * (my - sy))
                            if hovered is None or d2 < float(hovered[0]):
                                hovered = (d2, pr, spr if spr is not None else None, rect.copy(), int(sx), int(sy))

        if hovered is None or mouse is None:
            return

        _d2, pr, spr, rect, _sx, _sy = hovered
        hi = (255, 245, 140)
        if spr is not None:
            self._blit_sprite_outline(surface, spr, rect, color=hi)
        else:
            pygame.draw.rect(surface, hi, rect, 1)

        pdef = self._PROP_DEFS.get(str(getattr(pr, "prop_id", "")))
        name = pdef.name if pdef is not None else str(getattr(pr, "prop_id", "prop"))
        cat = pdef.category if pdef is not None else "场景道具"
        self._hover_tooltip = ([name, f"类型: {cat}"], (int(mouse[0]), int(mouse[1])))

    def _draw_world_items(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
    ) -> None:
        # Mouse hover: outline + tooltip.
        hovered = None  # (d2, item, sprite|None, rect, sx, sy)
        mouse = None
        if not self.inv_open and not bool(getattr(self, "rv_ui_open", False)) and not bool(getattr(self, "world_map_open", False)):
            mouse = self.app.screen_to_internal(pygame.mouse.get_pos())

        # Proximity highlight: nearest pickup (keyboard-friendly).
        near_item: HardcoreSurvivalState._WorldItem | None = None
        near_spr: pygame.Surface | None = None
        near_rect: pygame.Rect | None = None
        if not self.inv_open and not bool(getattr(self, "rv_ui_open", False)) and not bool(getattr(self, "world_map_open", False)):
            _nchunk, near_item = self._find_nearest_item(radius_px=20.0)

        start_cx = start_tx // self.CHUNK_SIZE
        end_cx = end_tx // self.CHUNK_SIZE
        start_cy = start_ty // self.CHUNK_SIZE
        end_cy = end_ty // self.CHUNK_SIZE

        for cy in range(start_cy, end_cy + 1):
            for cx in range(start_cx, end_cx + 1):
                chunk = self.world.peek_chunk(cx, cy)
                if chunk is None:
                    continue
                for it in chunk.items:
                    sx = iround(float(it.pos.x) - float(cam_x))
                    sy = iround(float(it.pos.y) - float(cam_y))
                    if sx < -8 or sx > INTERNAL_W + 8 or sy < -8 or sy > INTERNAL_H + 8:
                        continue
                    self._ensure_item_visuals(it.item_id)
                    spr = self._ITEM_SPRITES_WORLD.get(it.item_id) or self._ITEM_SPRITES.get(it.item_id)
                    if spr is not None:
                        rect = spr.get_rect()
                        rect.midbottom = (sx, sy + 6)
                        sw = max(4, rect.w - 8)
                        shadow = pygame.Rect(0, 0, sw, 5)
                        shadow.center = (sx, sy + 4)
                        pygame.draw.ellipse(surface, (0, 0, 0), shadow)  
                        surface.blit(spr, rect)
                    else:
                        icon = self._ITEM_ICONS.get(it.item_id)
                        if icon is None:
                            idef = self._ITEMS.get(it.item_id)
                            col = idef.color if idef is not None else (255, 0, 255)
                            rect = pygame.Rect(sx - 3, sy - 3, 6, 6)
                            pygame.draw.rect(surface, (0, 0, 0), rect)
                            pygame.draw.rect(surface, col, rect.inflate(-2, -2))
                        else:
                            bg = pygame.Rect(sx - 5, sy - 5, 10, 10)
                            pygame.draw.rect(surface, (0, 0, 0), bg, border_radius=3)
                            rect = icon.get_rect(center=(sx, sy))
                            surface.blit(icon, rect)

                    if near_item is not None and it is near_item and rect is not None:
                        near_spr = spr if spr is not None else None
                        near_rect = rect.copy()

                    if mouse is not None and rect is not None:
                        mx, my = int(mouse[0]), int(mouse[1])
                        if rect.collidepoint(mx, my):
                            d2 = float((mx - sx) * (mx - sx) + (my - sy) * (my - sy))
                            if hovered is None or d2 < float(hovered[0]):
                                hovered = (d2, it, spr if spr is not None else None, rect.copy(), int(sx), int(sy))

        if near_item is not None and near_rect is not None:
            hi_near = (120, 200, 140)
            hovered_item = hovered[1] if hovered is not None else None
            if hovered_item is not near_item:
                if near_spr is not None:
                    self._blit_sprite_outline(surface, near_spr, near_rect, color=hi_near)
                else:
                    pygame.draw.rect(surface, (0, 0, 0), near_rect.inflate(6, 6), 1)
                    pygame.draw.rect(surface, hi_near, near_rect.inflate(4, 4), 1)

        if hovered is None or mouse is None:
            return

        _d2, it, spr, rect, _sx, _sy = hovered
        hi = (255, 245, 140)
        if spr is not None:
            self._blit_sprite_outline(surface, spr, rect, color=hi)
        else:
            pygame.draw.rect(surface, (0, 0, 0), rect.inflate(6, 6), 1)
            pygame.draw.rect(surface, hi, rect.inflate(4, 4), 1)

        idef = self._ITEMS.get(it.item_id)
        name = idef.name if idef is not None else str(it.item_id)
        qty = int(getattr(it, "qty", 1))
        kind = str(getattr(idef, "kind", "")) if idef is not None else ""
        kind_map = {
            "food": "食物",
            "drink": "饮料",
            "med": "医疗",
            "ammo": "弹药",
            "mat": "材料",
            "gun": "武器",
        }
        klabel = kind_map.get(kind, "物品") if kind else "物品"
        first = f"{name}  x{qty}" if qty > 1 else name
        self._hover_tooltip = ([first, f"类型: {klabel}", "E 拾取"], (int(mouse[0]), int(mouse[1])))

    def _draw_rv(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        # When inside the RV interior (world-tile mode), hide the exterior sprite
        # so the stamped interior space is visible and walkable.
        if bool(getattr(self, "rv_world_interior", False)):
            return
        rvp = pygame.Vector2(self.rv.pos) - pygame.Vector2(cam_x, cam_y)        
        moving = self.mount == "rv" and abs(float(self.rv.speed)) > 6.0
        frame = int(self.rv_anim) % 2 if moving else 0
        steer_state = 0
        if abs(float(self.rv.steer)) > 0.08:
            steer_state = 1 if float(self.rv.steer) > 0.0 else -1
        mid = getattr(self.rv, "model_id", "schoolbus")
        base = self._CAR_BASE.get((str(mid), int(steer_state), int(frame)))
        shadow_base = self._CAR_SHADOW.get((str(mid), int(steer_state), int(frame)))
        if base is None:
            base = self._CAR_BASE.get(("schoolbus", int(steer_state), int(frame)))
            shadow_base = self._CAR_SHADOW.get(("schoolbus", int(steer_state), int(frame)))
            if base is None:
                return
        deg = -math.degrees(float(self.rv.heading))
        spr = rotate_pixel_sprite(base, deg, step_deg=5.0)

        rect = spr.get_rect(center=(int(round(rvp.x)), int(round(rvp.y))))
        if shadow_base is not None:
            shadow = rotate_pixel_sprite(shadow_base, deg, step_deg=5.0)        
            srect = shadow.get_rect(center=(rect.centerx + 2, rect.centery + 6))
            surface.blit(shadow, srect)
        surface.blit(spr, rect)

        mouse = None
        if (
            not self.inv_open
            and not bool(getattr(self, "rv_ui_open", False))
            and not bool(getattr(self, "world_map_open", False))
        ):
            mouse = self.app.screen_to_internal(pygame.mouse.get_pos())
        if mouse is not None:
            mx, my = int(mouse[0]), int(mouse[1])
            if rect.collidepoint(mx, my):
                model = self._CAR_MODELS.get(str(mid))
                name = model.name if model is not None else str(mid)
                is_rv_model = str(mid) == "rv"
                try:
                    pad = 22
                    near = bool(
                        self._rv_collider_rect_at()
                        .inflate(int(pad * 2), int(pad * 2))
                        .collidepoint(int(round(float(self.player.pos.x))), int(round(float(self.player.pos.y))))
                    )
                except Exception:
                    near = (self.player.pos - self.rv.pos).length_squared() <= (22.0 * 22.0)
                if self.mount == "rv":
                    prompt = "F 下车  |  H 车灯"
                else:
                    if is_rv_model:
                        prompt = "F 上车  |  H 内部" if near else "靠近后: F 上车 / H 内部"
                    else:
                        prompt = "F 上车" if near else "靠近后: F 上车"
                lines = [f"车辆：{name}", f"燃油: {int(self.rv.fuel)}", prompt]
                hi = (255, 245, 140)
                self._blit_sprite_outline(surface, spr, rect, color=hi)
                self._hover_tooltip = (lines, (mx, my))

    def _draw_rv_drive_overlay(self, surface: pygame.Surface) -> None:
        # Disabled: RV cabin driving view removed (outside view only).
        return

    def _draw_bike(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        bp = pygame.Vector2(self.bike.pos) - pygame.Vector2(cam_x, cam_y)       
        moving = self.mount == "bike" and self.bike.vel.length_squared() > 0.1
        frame = int(self.bike_anim) % 2 if moving else 0
        d = getattr(self, "bike_dir", "right")
        mid = str(getattr(self.bike, "model_id", "bike"))
        model = self._TWO_WHEEL_FRAMES.get(mid) or self._TWO_WHEEL_FRAMES.get("bike") or {}
        frames = model.get(str(d)) or model.get("right") or self._BIKE_FRAMES.get("right", [])
        if not frames:
            return
        spr = frames[min(int(frame), len(frames) - 1)]
        ground_y = int(round(float(bp.y) + float(getattr(self.bike, "h", 10)) / 2.0))
        rect = spr.get_rect()
        baseline_y = int(self._sprite_baseline_y(spr))
        rect.centerx = int(round(bp.x))
        rect.bottom = int(round(float(ground_y) + float(rect.h - baseline_y)))

        # Soft ground shadow so the two-wheeler doesn't look like it's floating.
        shadow = self._two_wheel_shadow_rect(rect, str(d), ground_y=int(ground_y))
        sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)       
        pygame.draw.ellipse(sh, (0, 0, 0, 130), sh.get_rect())
        surface.blit(sh, shadow.topleft)
        surface.blit(spr, rect)

        mouse = None
        if (
            not self.inv_open
            and not bool(getattr(self, "rv_ui_open", False))
            and not bool(getattr(self, "world_map_open", False))
        ):
            mouse = self.app.screen_to_internal(pygame.mouse.get_pos())
        if mouse is not None:
            mx, my = int(mouse[0]), int(mouse[1])
            if rect.collidepoint(mx, my):
                near = (self.player.pos - self.bike.pos).length_squared() <= (18.0 * 18.0)
                if self.mount == "bike":
                    prompt = "F 下车"
                else:
                    prompt = "F 骑车" if near else "靠近后: F 骑车"
                lines = [self._two_wheel_name(mid), "类型: 载具", prompt]
                if str(mid).startswith("moto"):
                    lines.insert(1, f"燃油: {int(getattr(self.bike, 'fuel', 0.0))}")
                hi = (255, 245, 140)
                self._blit_sprite_outline(surface, spr, rect, color=hi)
                self._hover_tooltip = (lines, (mx, my))

        if self.mount == "bike":
            rider: pygame.Surface | None = None
            rf = getattr(self, "cyclist_frames", getattr(self, "_CYCLIST_FRAMES", {})).get(d)
            if rf:
                rider = rf[int(frame) % len(rf)]
            else:
                pf = getattr(self, "player_frames", self._PLAYER_FRAMES)
                frames = pf.get(d, pf["down"])
                if frames:
                    if moving and len(frames) > 1:
                        walk = frames[1:]
                        rider = walk[int(self.bike_anim) % len(walk)]     
                    else:
                        rider = frames[0]

            if rider is not None:
                rrect = rider.get_rect()
                seat_off = 5 if d in ("up", "down") else 4
                if str(mid).startswith("moto"):
                    seat_off = max(2, int(seat_off) - 1)
                rrect.midbottom = (rect.centerx, rect.centery + int(seat_off))
                surface.blit(rider, rrect)
            else:
                hair = self._PLAYER_PAL["H"]
                skin = self._PLAYER_PAL["S"]
                coat = self._PLAYER_PAL["C"]
                hx = rect.centerx
                hy = rect.centery - 6
                pygame.draw.rect(surface, hair, pygame.Rect(hx - 2, hy - 3, 4, 3))
                pygame.draw.rect(surface, skin, pygame.Rect(hx - 2, hy, 4, 3))
                pygame.draw.rect(surface, coat, pygame.Rect(hx - 3, hy + 3, 6, 4))

    def _roof_surface(self, w_tiles: int, h_tiles: int, alpha: int, *, roof_kind: int = 0) -> pygame.Surface:
        w_tiles = max(1, int(w_tiles))
        h_tiles = max(1, int(h_tiles))
        alpha = int(clamp(int(alpha), 0, 255))
        w_px = w_tiles * self.TILE_SIZE
        h_px = h_tiles * self.TILE_SIZE
        roof_kind = int(roof_kind) & 0xFFFFFFFF
        key = (w_px, h_px, alpha, roof_kind)
        cached = self._roof_cache.get(key)
        if cached is not None:
            return cached

        style = int((roof_kind >> 8) & 0xFF)
        var = int(roof_kind & 0xFF)

        def tint(c: tuple[int, int, int], dv: int) -> tuple[int, int, int]:
            return (
                int(clamp(int(c[0]) + dv, 0, 255)),
                int(clamp(int(c[1]) + dv, 0, 255)),
                int(clamp(int(c[2]) + dv, 0, 255)),
            )

        # Stronger per-building roof palette so city blocks read distinctly.
        dv = (var % 9) - 4
        base_rgb = (28, 28, 34)
        stripe_rgb = (44, 44, 54)
        accent_rgb = (70, 70, 86)
        outline_rgb = (10, 10, 12)
        if style == 1:  # 住宅
            base_rgb = (62, 48, 36)
            stripe_rgb = (82, 60, 44)
            accent_rgb = (110, 80, 58)
        elif style == 2:  # 超市
            base_rgb = (34, 36, 40)
            stripe_rgb = (52, 54, 60)
            accent_rgb = (90, 92, 98)
        elif style == 3:  # 医院
            base_rgb = (74, 78, 88)
            stripe_rgb = (106, 110, 122)
            accent_rgb = (170, 174, 186)
        elif style == 4:  # 监狱
            base_rgb = (18, 18, 22)
            stripe_rgb = (34, 34, 40)
            accent_rgb = (66, 66, 78)
        elif style == 5:  # 学校
            base_rgb = (72, 54, 34)
            stripe_rgb = (98, 72, 44)
            accent_rgb = (134, 100, 62)
        elif style == 6:  # 高层住宅
            base_rgb = (42, 46, 62)
            stripe_rgb = (62, 66, 86)
            accent_rgb = (104, 110, 142)
        elif style == 7:  # 新华书店
            base_rgb = (36, 44, 66)
            stripe_rgb = (56, 66, 98)
            accent_rgb = (232, 200, 120)
        elif style == 8:  # 中式建筑
            base_rgb = (34, 64, 44)
            stripe_rgb = (52, 92, 62)
            accent_rgb = (200, 170, 110)
        elif style == 9:  # 枪械店
            base_rgb = (34, 34, 40)
            stripe_rgb = (62, 52, 52)
            accent_rgb = (220, 140, 90)

        base_rgb = tint(base_rgb, dv)
        stripe_rgb = tint(stripe_rgb, dv)
        accent_rgb = tint(accent_rgb, dv)

        roof = pygame.Surface((w_px, h_px), pygame.SRCALPHA)
        roof.fill((*base_rgb, alpha))

        if style == 2:
            # Flat roof + HVAC units.
            for y in range(0, h_px, 5):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (0, y), (w_px - 1, y), 1)
            unit = (*accent_rgb, alpha)
            for uy in range(6 + (var % 3), h_px - 6, 14):
                for ux in range(6 + ((var >> 2) % 5), w_px - 8, 18):
                    if ((ux + uy + var) % 3) != 0:
                        continue
                    pygame.draw.rect(roof, unit, pygame.Rect(ux, uy, 7, 4), border_radius=1)
            # Long skylight strips (makes supermarkets read big/flat).
            if w_px >= 26 and h_px >= 16:
                glass = (110, 140, 168, alpha)
                frame = (*outline_rgb, alpha)
                for sy in range(8 + (var % 7), h_px - 10, 18):
                    if ((sy + var) % 2) != 0:
                        continue
                    sky = pygame.Rect(6, sy, w_px - 12, 5)
                    roof.fill(glass, sky)
                    pygame.draw.rect(roof, frame, sky, 1, border_radius=1)
        elif style == 3:
            # Medical roof: light + cross marks.
            for y in range(0, h_px, 4):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (0, y), (w_px - 1, y), 1)
            cross = (*accent_rgb, alpha)
            for cy in range(8, h_px - 8, 18):
                for cx in range(8, w_px - 8, 18):
                    if ((cx + cy + var) % 2) != 0:
                        continue
                    roof.fill(cross, pygame.Rect(cx - 1, cy - 3, 2, 7))
                    roof.fill(cross, pygame.Rect(cx - 3, cy - 1, 7, 2))
        elif style == 4:
            # Bars / grid.
            for x in range(0, w_px, 4):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (x, 0), (x, h_px - 1), 1)
            for y in range(0, h_px, 8):
                pygame.draw.line(roof, (*accent_rgb, alpha), (0, y), (w_px - 1, y), 1)
        elif style == 5:
            # Skylights.
            for y in range(0, h_px, 4):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (0, y), (w_px - 1, y), 1)
            sky = (*accent_rgb, alpha)
            for uy in range(6, h_px - 8, 12):
                for ux in range(6, w_px - 10, 20):
                    if ((ux * 3 + uy * 5 + var) % 4) != 0:
                        continue
                    roof.fill(sky, pygame.Rect(ux, uy, 10, 4))
            # Small solar-panel array for schools.
            if w_px >= 26 and h_px >= 18:
                panel = (46, 70, 88, alpha)
                frame = (*outline_rgb, alpha)
                px0 = 6
                py0 = int(h_px - 12)
                for i in range(0, min(4, int((w_px - 12) // 10))):
                    r = pygame.Rect(px0 + i * 10, py0, 8, 4)
                    roof.fill(panel, r)
                    pygame.draw.rect(roof, frame, r, 1, border_radius=1)
        elif style == 1:
            # Two-tone gable shading + shingles.
            ridge_y = int(h_px // 2)
            roof.fill((*tint(base_rgb, -10), alpha), pygame.Rect(0, 0, w_px, ridge_y))
            roof.fill((*tint(base_rgb, 8), alpha), pygame.Rect(0, ridge_y, w_px, h_px - ridge_y))
            # Shingles diagonal.
            for y in range(-w_px, h_px, 4):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (0, y), (w_px - 1, y + w_px - 1), 1)
            # A subtle ridge line to sell "house roof" at small sizes.
            if w_px >= 16 and h_px >= 12:
                ridge = (*tint(accent_rgb, 16), alpha)
                ry = int(h_px // 2)
                pygame.draw.line(roof, ridge, (1, ry), (w_px - 2, ry), 1)
            # Chimney.
            if w_px >= 26 and h_px >= 18:
                cx = 6 if (var & 1) == 0 else (w_px - 11)
                cy = 6 + (var % 5)
                chim = pygame.Rect(int(cx), int(cy), 5, 7)
                roof.fill((*tint(accent_rgb, 26), alpha), chim)
                pygame.draw.rect(roof, (*outline_rgb, alpha), chim, 1)
                roof.fill((*tint(accent_rgb, 42), alpha), pygame.Rect(chim.x + 1, chim.y + 1, chim.w - 2, 1))
        elif style == 6:
            # High-rise: service roof (vents + access hatches).
            for y in range(0, h_px, 6):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (0, y), (w_px - 1, y), 1)
            vent = (*accent_rgb, alpha)
            hatch = (*tint(accent_rgb, 22), alpha)
            for uy in range(6 + (var % 3), h_px - 6, 12):
                for ux in range(6 + ((var >> 2) % 4), w_px - 6, 12):
                    if ((ux + uy + var) % 3) != 0:
                        continue
                    roof.fill(vent, pygame.Rect(ux, uy, 4, 3))
                    roof.fill(vent, pygame.Rect(ux + 1, uy + 1, 2, 1))
            if w_px >= 26 and h_px >= 18:
                hx = int(w_px - 14)
                hy = int(6 + (var % 5))
                pygame.draw.rect(roof, hatch, pygame.Rect(hx, hy, 10, 6), border_radius=1)
                pygame.draw.rect(
                    roof,
                    (*tint(outline_rgb, 24), alpha),
                    pygame.Rect(hx, hy, 10, 6),
                    1,
                    border_radius=1,
                )
            # Elevator core / roof access (makes high-rises instantly recognizable).
            if w_px >= 28 and h_px >= 28:
                cx = int(w_px // 2 - 6)
                cy = int(h_px // 2 - 6)
                core = pygame.Rect(cx, cy, 12, 12)
                roof.fill((*tint(accent_rgb, 30), alpha), core)
                pygame.draw.rect(roof, (*outline_rgb, alpha), core, 1, border_radius=1)
                roof.fill((*tint(accent_rgb, 52), alpha), pygame.Rect(core.x + 3, core.y + 3, core.w - 6, 1))
        elif style == 7:
            # Bookstore: flat roof + small skylights.
            for y in range(0, h_px, 5):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (0, y), (w_px - 1, y), 1)
            if w_px >= 22 and h_px >= 16:
                glass = (110, 140, 168, alpha)
                frame = (*outline_rgb, alpha)
                for uy in range(6 + (var % 4), h_px - 8, 14):
                    for ux in range(6 + ((var >> 2) % 4), w_px - 10, 18):
                        if ((ux + uy + var) % 3) != 0:
                            continue
                        sky = pygame.Rect(int(ux), int(uy), 8, 4)
                        roof.fill(glass, sky)
                        pygame.draw.rect(roof, frame, sky, 1, border_radius=1)
        elif style == 8:
            # Chinese-style tiled roof + ridge line.
            for y in range(0, h_px, 3):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (0, y), (w_px - 1, y), 1)
            if w_px >= 16 and h_px >= 12:
                ry = int(h_px // 2)
                ridge = (*tint(accent_rgb, 18), alpha)
                pygame.draw.line(roof, ridge, (2, ry), (w_px - 3, ry), 1)
                eave = (*tint(accent_rgb, 34), alpha)
                roof.fill(eave, pygame.Rect(1, 1, 2, 2))
                roof.fill(eave, pygame.Rect(w_px - 3, 1, 2, 2))
                roof.fill(eave, pygame.Rect(1, h_px - 3, 2, 2))
                roof.fill(eave, pygame.Rect(w_px - 3, h_px - 3, 2, 2))
        elif style == 9:
            # Gun shop: darker roof with "warning" diagonals + a few vents.
            for x in range(-h_px, w_px + h_px, 6):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (x, 0), (x + h_px, h_px - 1), 1)
            vent = (*accent_rgb, alpha)
            frame = (*outline_rgb, alpha)
            for uy in range(6 + (var % 3), h_px - 6, 14):
                for ux in range(6 + ((var >> 2) % 5), w_px - 10, 18):
                    if ((ux + uy + var) % 3) != 0:
                        continue
                    r = pygame.Rect(int(ux), int(uy), 7, 4)
                    roof.fill(vent, r)
                    pygame.draw.rect(roof, frame, r, 1, border_radius=1)
        else:
            # Default subtle stripes.
            for y in range(0, h_px, 4):
                pygame.draw.line(roof, (*stripe_rgb, alpha), (0, y), (w_px - 1, y), 1)

        # Big visual identifiers per building type so roofs don't all read the same.
        if alpha > 0:
            if style == 3 and w_px >= 22 and h_px >= 22:
                # Hospital: central cross pad.
                cx = int(w_px // 2)
                cy = int(h_px // 2)
                pad = pygame.Rect(int(cx - 8), int(cy - 8), 17, 17)
                pygame.draw.rect(roof, (232, 232, 238, alpha), pad, border_radius=2)
                pygame.draw.rect(roof, (*outline_rgb, alpha), pad, 1, border_radius=2)
                red = (190, 56, 56, alpha)
                roof.fill(red, pygame.Rect(int(cx - 2), int(cy - 7), 5, 15))
                roof.fill(red, pygame.Rect(int(cx - 7), int(cy - 2), 15, 5))
                ring = (210, 210, 220, alpha)
                pygame.draw.circle(roof, ring, (int(cx), int(cy)), 9, 1)
            elif style == 2 and w_px >= 22 and h_px >= 14:
                # Supermarket: bold stripe + logo block.
                band = pygame.Rect(0, int(h_px // 2 - 2), int(w_px), 5)
                roof.fill((34, 92, 56, alpha), band)
                roof.fill((170, 54, 54, alpha), pygame.Rect(0, int(band.y), int(w_px), 1))
                logo = pygame.Rect(int(w_px // 2 - 4), int(h_px // 2 - 4), 8, 8)
                pygame.draw.rect(roof, (232, 190, 88, alpha), logo, border_radius=2)
                pygame.draw.rect(roof, (*outline_rgb, alpha), logo, 1, border_radius=2)
            elif style == 7 and w_px >= 18 and h_px >= 18:
                # Bookstore: simple "book" mark.
                cx = int(w_px // 2)
                cy = int(h_px // 2)
                ink = (232, 200, 120, alpha)
                pygame.draw.rect(roof, ink, pygame.Rect(cx - 8, cy - 5, 7, 10), 1, border_radius=1)
                pygame.draw.rect(roof, ink, pygame.Rect(cx + 1, cy - 5, 7, 10), 1, border_radius=1)
                roof.fill((10, 10, 12, alpha), pygame.Rect(cx - 1, cy - 5, 2, 10))
            elif style == 8 and w_px >= 18 and h_px >= 18:
                # Chinese roof: central ridge ornament.
                cx = int(w_px // 2)
                cy = int(h_px // 2)
                gold = (210, 180, 110, alpha)
                roof.fill(gold, pygame.Rect(cx - 1, cy - 7, 2, 15))
                roof.fill(gold, pygame.Rect(cx - 5, cy - 1, 10, 2))
            elif style == 4 and w_px >= 18 and h_px >= 18:
                # Prison: perimeter wire marks.
                wire = (*tint(stripe_rgb, 28), alpha)
                pygame.draw.rect(roof, wire, pygame.Rect(1, 1, w_px - 2, h_px - 2), 1)
                for x in range(3, w_px - 3, 5):
                    roof.fill(wire, pygame.Rect(x, 1, 1, 1))
                    roof.fill(wire, pygame.Rect(x, h_px - 2, 1, 1))
                for y in range(3, h_px - 3, 5):
                    roof.fill(wire, pygame.Rect(1, y, 1, 1))
                    roof.fill(wire, pygame.Rect(w_px - 2, y, 1, 1))
                # Corner watch-tower blocks.
                tower = (*tint(accent_rgb, 24), alpha)
                for ox, oy in ((2, 2), (w_px - 8, 2), (2, h_px - 8), (w_px - 8, h_px - 8)):
                    if ((ox + oy + var) % 2) != 0:
                        continue
                    r = pygame.Rect(int(ox), int(oy), 6, 6)
                    roof.fill(tower, r)
                    pygame.draw.rect(roof, (*outline_rgb, alpha), r, 1, border_radius=1)
                    roof.fill((*tint(accent_rgb, 54), alpha), pygame.Rect(r.x + 2, r.y + 2, 2, 2))
            elif style == 5 and w_px >= 22 and h_px >= 16:
                # School: a bright gym roof patch.
                gym = pygame.Rect(4, 4, w_px - 8, max(6, h_px // 2 - 2))
                pygame.draw.rect(roof, (*tint(accent_rgb, 34), alpha), gym, border_radius=2)
                pygame.draw.rect(roof, (*outline_rgb, alpha), gym, 1, border_radius=2)
                # Tiny "S" mark to make schools readable even in clusters.
                if gym.w >= 18 and gym.h >= 10:
                    sx = int(gym.centerx)
                    sy = int(gym.centery)
                    ink = (*outline_rgb, alpha)
                    roof.fill(ink, pygame.Rect(sx - 5, sy - 3, 10, 2))
                    roof.fill(ink, pygame.Rect(sx - 5, sy + 1, 10, 2))
                    roof.fill(ink, pygame.Rect(sx - 5, sy - 1, 2, 2))
                    roof.fill(ink, pygame.Rect(sx + 3, sy - 1, 2, 2))

        # Hint storefront/facade signage to make city blocks read more like the reference.
        if alpha > 0 and w_px >= 18 and h_px >= 14:
            face = int(var) & 3  # 0=top,1=bottom,2=left,3=right
            if style in (2, 3):
                sign_rgb = tint(accent_rgb, 26)
                text_rgb = tint(accent_rgb, 44)
            elif style == 6:
                sign_rgb = tint(accent_rgb, 18)
                text_rgb = tint(accent_rgb, 34)
            else:
                sign_rgb = tint(stripe_rgb, 18)
                text_rgb = tint(stripe_rgb, 34)

            sw = int(min(w_px - 6, 34 + (var % 10)))
            sh = 5
            if face == 0:
                sign = pygame.Rect(3, 3, sw, sh)
            elif face == 1:
                sign = pygame.Rect(3, h_px - 3 - sh, sw, sh)
            elif face == 2:
                sign = pygame.Rect(3, 3, sh, int(min(h_px - 6, 26 + (var % 8))))
            else:
                sign = pygame.Rect(w_px - 3 - sh, 3, sh, int(min(h_px - 6, 26 + (var % 8))))
            roof.fill((*sign_rgb, alpha), sign)

            # Tiny pseudo-text pixels.
            if sign.w >= sign.h:
                ty = sign.y + 2
                for x in range(sign.x + 2, sign.right - 2, 3):
                    if ((x + var) % 5) == 0:
                        roof.fill((*text_rgb, alpha), pygame.Rect(x, ty, 2, 1))
            else:
                tx = sign.x + 2
                for y in range(sign.y + 2, sign.bottom - 2, 3):
                    if ((y + var) % 5) == 0:
                        roof.fill((*text_rgb, alpha), pygame.Rect(tx, y, 1, 2))

        # Extra rooftop props for high-rises.
        if style == 6 and w_px >= 20 and h_px >= 20:
            tank = (*accent_rgb, alpha)
            for ox, oy in ((6, 6), (w_px - 11, 6), (6, h_px - 11), (w_px - 11, h_px - 11)):
                if ((ox + oy + var) % 3) != 0:
                    continue
                pygame.draw.rect(roof, tank, pygame.Rect(int(ox), int(oy), 5, 5), border_radius=1)

        # Roof outline + subtle highlight edge so different roof palettes pop.
        if alpha > 0 and w_px >= 3 and h_px >= 3:
            pygame.draw.rect(roof, (*outline_rgb, alpha), roof.get_rect(), 1)
            hi = (*tint(base_rgb, 22), alpha)
            roof.fill(hi, pygame.Rect(1, h_px - 2, w_px - 2, 1))
            roof.fill(hi, pygame.Rect(w_px - 2, 1, 1, h_px - 2))
        self._roof_cache[key] = roof
        return roof

    def _building_roof_style_var(self, roof_kind: int) -> tuple[int, int]:
        roof_kind = int(roof_kind) & 0xFFFFFFFF
        style = int((roof_kind >> 8) & 0xFF)
        var = int(roof_kind & 0xFF)
        return style, var

    def _building_face_height_px(self, *, style: int, w: int, h: int, var: int, floors: int = 0) -> int:
        style = int(style)
        w = int(w)
        h = int(h)
        var = int(var)
        floors = int(floors)
        area = int(w) * int(h)
        # Wall extrusion height: makes building height readable at a glance.
        # High-rises should read "very tall" even at small internal resolution.
        if style == 6:
            # Match requested "layer height" logic: facade height is derived
            # from floor count and player height (each floor ≈ 1.5× player).
            max_f = int(max(2, int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
            f = int(floors) if int(floors) > 0 else int(max_f)
            f = int(max(1, min(int(f), int(max_f))))
            floor_h = int(
                clamp(
                    int(round(float(getattr(getattr(self, "player", None), "h", 12)) * 1.5)),
                    14,
                    26,
                )
            )
            desired_total = int(f) * int(floor_h)
            face_h = int(max(0, int(desired_total) - int(self.TILE_SIZE)))
            return int(max(0, int(face_h)))

        if style == 1:
            # Houses: use the same "layer height" logic as high-rises so the
            # first floor reads taller (≈ 1.5× player height per floor).
            f = int(clamp(int(floors) if int(floors) > 0 else 1, 1, 3))
            floor_h = int(
                clamp(
                    int(round(float(getattr(getattr(self, "player", None), "h", 12)) * 1.5)),
                    14,
                    26,
                )
            )
            desired_total = int(f) * int(floor_h)
            face_h = int(max(0, int(desired_total) - int(self.TILE_SIZE)))
            return int(clamp(int(face_h), 3, 56))

        # All other (usually single-floor) buildings: enforce the same requested
        # "1F height ≈ player height × 1.5" rule so shops/schools/etc are not flat.
        f = int(max(1, int(floors))) if int(floors) > 0 else 1
        f = int(clamp(int(f), 1, 3))
        floor_h = int(
            clamp(
                int(round(float(getattr(getattr(self, "player", None), "h", 12)) * 1.5)),
                14,
                26,
            )
        )
        desired_total = int(f) * int(floor_h)
        face_h = int(max(0, int(desired_total) - int(self.TILE_SIZE)))
        return int(clamp(int(face_h), 3, 56))

    def _roof_cut_px(self, *, style: int, w: int, h: int, var: int, floors: int = 0) -> int:
        style = int(style)
        w = int(w)
        h = int(h)
        var = int(var)
        floors = int(floors)
        if not (int(style) == 6 or (int(style) == 1 and int(floors) > 1)):
            return 0

        face_h = int(self._building_face_height_px(style=int(style), w=int(w), h=int(h), var=int(var), floors=int(floors)))
        # Cutaway depth: don't remove the full facade height for high-rises,
        # otherwise apartments become too shallow (hard to fit 1厅2室1卫1厨).
        if int(style) == 6:
            cut = int(max(0, int(round(float(face_h) * 0.55)) - 2))
        else:
            cut = int(max(0, int(face_h) - 2))
        min_vis = 18 if int(style) == 6 else 14
        roof_h_px = int(max(1, (int(h) - 2) * int(self.TILE_SIZE)))
        max_cut = int(max(0, int(roof_h_px) - int(min_vis)))

        ts = int(max(1, int(self.TILE_SIZE)))
        max_cut = int((int(max_cut) // int(ts)) * int(ts))
        cut = int(min(int(cut), int(max_cut)))
        if cut <= 0 or max_cut <= 0:
            return 0
        cut = int(min(int(math.ceil(float(cut) / float(ts))) * int(ts), int(max_cut)))
        return int(max(0, int(cut)))

    def _building_wall_palette(self, *, style: int, var: int) -> tuple[tuple[int, int, int], tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]]:
        style = int(style)
        var = int(var)
        # (front, side, trim, shadow) – tuned for a dirty city feel like the reference.
        front = (88, 84, 78)
        side = (64, 62, 58)
        trim = (140, 140, 146)
        shadow = (14, 14, 18)
        if style == 1:  # 住宅
            front, side, trim = (118, 102, 82), (92, 78, 62), (170, 148, 118)
        elif style == 2:  # 超市/商店
            front, side, trim = (86, 88, 94), (64, 66, 72), (130, 132, 140)
        elif style == 3:  # 医院
            front, side, trim = (184, 186, 196), (148, 150, 160), (236, 236, 242)
        elif style == 4:  # 监狱
            front, side, trim = (58, 58, 66), (40, 40, 46), (98, 98, 110)
        elif style == 5:  # 学校
            front, side, trim = (132, 102, 68), (102, 76, 50), (186, 146, 96)
        elif style == 6:  # 高层住宅
            front, side, trim = (88, 92, 122), (66, 70, 94), (142, 150, 186)
        elif style == 7:  # 书店
            front, side, trim = (72, 80, 108), (52, 58, 78), (210, 180, 110)
        elif style == 8:  # 中式建筑
            front, side, trim = (148, 58, 46), (112, 42, 34), (210, 180, 110)
        dv = (int(var) % 7) - 3
        dv2 = (int(var) % 5) - 2
        front = self._tint(front, add=(dv * 2, dv * 2, dv * 2))
        side = self._tint(side, add=(dv2 * 2, dv2 * 2, dv2 * 2))
        trim = self._tint(trim, add=(dv, dv, dv))
        return front, side, trim, shadow

    def _find_building_exterior_door(self, tx0: int, ty0: int, w: int, h: int) -> tuple[str, list[tuple[int, int]]] | None:
        tx0 = int(tx0)
        ty0 = int(ty0)
        w = int(w)
        h = int(h)
        doors: list[tuple[int, int]] = []
        door_ids = {
            int(self.T_DOOR),
            int(self.T_DOOR_HOME),
            int(self.T_DOOR_LOCKED),
            int(self.T_DOOR_HOME_LOCKED),
            int(self.T_DOOR_BROKEN),
        }
        # Perimeter only (skip interior doors).
        for x in range(tx0, tx0 + w):
            if int(self.world.peek_tile(x, ty0)) in door_ids:
                doors.append((x, ty0))
            if int(self.world.peek_tile(x, ty0 + h - 1)) in door_ids:
                doors.append((x, ty0 + h - 1))
        for y in range(ty0 + 1, ty0 + h - 1):
            if int(self.world.peek_tile(tx0, y)) in door_ids:
                doors.append((tx0, y))
            if int(self.world.peek_tile(tx0 + w - 1, y)) in door_ids:
                doors.append((tx0 + w - 1, y))
        if not doors:
            return None
        side_votes = {"N": 0, "S": 0, "W": 0, "E": 0}
        for x, y in doors:
            if y == ty0:
                side_votes["N"] += 1
            elif y == ty0 + h - 1:
                side_votes["S"] += 1
            elif x == tx0:
                side_votes["W"] += 1
            elif x == tx0 + w - 1:
                side_votes["E"] += 1
        side = max(side_votes.items(), key=lambda kv: kv[1])[0]
        return side, doors

    def _draw_facade_furniture_silhouette(
        self,
        surface: pygame.Surface,
        *,
        kind: str,
        x: int,
        floor_y: int,
        w: int,
        max_h: int,
        seed: int,
        depth: int = 0,
    ) -> None:
        kind = str(kind)
        x = int(x)
        floor_y = int(floor_y)
        w = int(w)
        max_h = int(max_h)
        seed = int(seed) & 0xFFFFFFFF
        depth = int(depth)

        if w <= 2 or max_h <= 2:
            return

        outline = (10, 10, 12)
        shade = int(-58 - depth * 10)
        add = (shade, shade, shade)
        hi_add = (shade + 18, shade + 18, shade + 18)
        lo_add = (shade - 14, shade - 14, shade - 14)

        if kind == "table":
            wood = self._tint((118, 92, 66), add=add)
            wood_hi = self._tint((118, 92, 66), add=hi_add)
            wood_lo = self._tint((118, 92, 66), add=lo_add)

            top_h = 2 if max_h >= 6 else 1
            legs_len = int(clamp(max_h - top_h - 1, 2, 4))
            top_y = int(floor_y - (legs_len + top_h))
            top = pygame.Rect(int(x), int(top_y), int(w), int(top_h))

            surface.fill(wood, top)
            surface.fill(wood_hi, pygame.Rect(top.x, top.y, top.w, 1))
            pygame.draw.rect(surface, outline, top, 1)

            leg_h = int(floor_y - top.bottom)
            if leg_h > 0:
                lx0 = int(x + 2)
                lx1 = int(x + w - 3)
                for lx in (lx0, lx1):
                    if int(x) <= lx < int(x + w):
                        surface.fill(wood_lo, pygame.Rect(lx, top.bottom, 1, leg_h))
                        surface.fill(outline, pygame.Rect(lx, top.bottom, 1, leg_h))
                if leg_h >= 3 and lx1 - lx0 >= 3:
                    yb = int(floor_y - 2)
                    surface.fill(wood_lo, pygame.Rect(int(lx0), yb, int(lx1 - lx0 + 1), 1))

            # Chair silhouette (legs visible).
            if w >= 7 and max_h >= 6 and (seed & 3) == 0:
                seat_c = self._tint((92, 120, 154), add=add)
                seat_hi = self._tint((92, 120, 154), add=hi_add)
                seat_lo = self._tint((92, 120, 154), add=lo_add)
                cw = int(clamp(w - 2, 5, 7))
                cx = int(x + (1 if (seed & 4) == 0 else (w - cw - 1)))
                seat_y = int(floor_y - 3)
                seat_r = pygame.Rect(cx, seat_y, cw, 2)
                surface.fill(seat_c, seat_r)
                surface.fill(seat_hi, pygame.Rect(seat_r.x, seat_r.y, seat_r.w, 1))
                pygame.draw.rect(surface, outline, seat_r, 1)

                back_h = 3
                if (seed & 4) == 0:
                    back = pygame.Rect(seat_r.x, seat_r.y - back_h, 2, back_h)
                else:
                    back = pygame.Rect(seat_r.right - 2, seat_r.y - back_h, 2, back_h)
                surface.fill(seat_lo, back)
                pygame.draw.rect(surface, outline, back, 1)

                leg_h = int(floor_y - seat_r.bottom)
                if leg_h > 0:
                    for lx in (seat_r.x + 1, seat_r.right - 2):
                        surface.fill(seat_lo, pygame.Rect(int(lx), int(seat_r.bottom), 1, leg_h))
                        surface.fill(outline, pygame.Rect(int(lx), int(seat_r.bottom), 1, leg_h))

            return

        if kind == "shelf":
            cab = self._tint((98, 96, 112), add=add)
            cab_hi = self._tint((98, 96, 112), add=hi_add)
            cab_lo = self._tint((98, 96, 112), add=lo_add)

            h = int(clamp(max_h, 4, 8))
            y0 = int(floor_y - h)
            body = pygame.Rect(int(x), int(y0), int(w), int(h))
            surface.fill(cab, body)
            surface.fill(cab_hi, pygame.Rect(body.x, body.y, body.w, 1))
            pygame.draw.rect(surface, outline, body, 1)

            for sy in range(body.y + 2, body.bottom - 2, 2):
                surface.fill(cab_lo, pygame.Rect(body.x + 1, sy, max(1, body.w - 2), 1))

            # Feet.
            surface.fill(cab_lo, pygame.Rect(body.x + 1, floor_y - 1, 1, 1))
            surface.fill(cab_lo, pygame.Rect(body.right - 2, floor_y - 1, 1, 1))

            # Items: small colored pixels on shelves (deterministic).
            if body.w >= 6 and body.h >= 5:
                for i in range(3):
                    # IMPORTANT: don't use screen coordinates here, otherwise it flickers while walking.
                    hh = int(
                        self._hash2_u32(
                            int((seed ^ 0xA1F3C9D7) + i * 131),
                            int((seed >> 8) + i * 313),
                            int(seed ^ 0x9E3779B9),
                        )
                    )
                    ix = int(body.x + 2 + (hh % max(1, body.w - 4)))
                    iy = int(body.y + 2 + ((hh >> 5) % max(1, body.h - 4)))
                    col = (200, 86, 86) if (hh & 1) else (86, 210, 130)
                    col = self._tint(col, add=(shade + 10, shade + 10, shade + 10))
                    surface.fill(col, pygame.Rect(ix, iy, 1, 1))
            return

        if kind == "bed":
            matt = self._tint((156, 150, 170), add=add)
            matt_hi = self._tint((156, 150, 170), add=hi_add)
            matt_lo = self._tint((156, 150, 170), add=lo_add)
            wood = self._tint((118, 92, 66), add=lo_add)

            h = int(clamp(max_h, 4, 7))
            y0 = int(floor_y - h)
            bed = pygame.Rect(int(x), int(y0), int(w), int(h))
            surface.fill(matt, bed)
            surface.fill(matt_hi, pygame.Rect(bed.x, bed.y, bed.w, 1))
            pygame.draw.rect(surface, outline, bed, 1)

            if (seed & 1) == 0:
                hb = pygame.Rect(bed.x, bed.y, 2, bed.h)
            else:
                hb = pygame.Rect(bed.right - 2, bed.y, 2, bed.h)
            surface.fill(wood, hb)
            pygame.draw.rect(surface, outline, hb, 1)

            px = bed.x + 3 if hb.x == bed.x else bed.right - 6
            py = bed.y + 2
            pillow = pygame.Rect(int(px), int(py), 3, 2)
            surface.fill(matt_hi, pillow)
            pygame.draw.rect(surface, outline, pillow, 1)

            if bed.w >= 6 and bed.h >= 5:
                fold_y = bed.y + bed.h // 2
                surface.fill(matt_lo, pygame.Rect(bed.x + 2, fold_y, max(1, bed.w - 4), 1))

            surface.fill(matt_lo, pygame.Rect(bed.x + 1, floor_y - 1, 1, 1))
            surface.fill(matt_lo, pygame.Rect(bed.right - 2, floor_y - 1, 1, 1))
            return

    def _draw_building_facades(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
        *,
        min_ground_y: int | None = None,
        skip_building: tuple[int, int, int, int] | None = None,
    ) -> None:
        # Expand by a full chunk in each direction so facades from large
        # buildings don't pop in/out at the screen edges while walking.
        chunk_pad = 1
        start_cx = start_tx // self.CHUNK_SIZE - chunk_pad
        end_cx = end_tx // self.CHUNK_SIZE + chunk_pad
        start_cy = start_ty // self.CHUNK_SIZE - chunk_pad
        end_cy = end_ty // self.CHUNK_SIZE + chunk_pad
        floor_slice_h = int(clamp(int(round(float(getattr(self.player, "body_h", getattr(self.player, "h", 12))) * 1.5)), 14, 26))
        max_floors = int(max(2, int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))

        forced_slice: tuple[int, int, int, int, int, int] | None = getattr(self, "_inside_highrise_facade_slice", None)
        forced_mh: tuple[int, int, int, int] | None = None
        forced_floor = 1
        forced_floors = 1
        if forced_slice is not None:
            try:
                ftx0, fty0, fw, fh, ffloor, ffloors = forced_slice
                forced_mh = (int(ftx0), int(fty0), int(fw), int(fh))
                forced_floors = int(max(1, int(ffloors)))
                forced_floors = int(min(int(forced_floors), int(max_floors)))
                forced_floor = int(clamp(int(ffloor), 1, int(forced_floors)))
            except Exception:
                forced_mh = None
                forced_floor = 1
                forced_floors = 1

        # If the player is inside a multi-floor building, slice its facade to the current floor.
        inside_mh: tuple[int, int, int, int] | None = None
        inside_mh_floor = 1
        inside_mh_floors = 1
        inside_building: tuple[int, int, int, int] | None = None
        inside_building_style = 0
        inside_building_floors = 1
        try:
            ptx = int(math.floor(self.player.pos.x / self.TILE_SIZE))
            pty = int(math.floor(self.player.pos.y / self.TILE_SIZE))
            p_tile = int(self.world.peek_tile(int(ptx), int(pty)))
            can_be_inside = int(p_tile) in (
                int(self.T_FLOOR),
                int(self.T_DOOR),
                int(self.T_DOOR_HOME),
                int(self.T_ELEVATOR),
                int(self.T_STAIRS_UP),
                int(self.T_STAIRS_DOWN),
            )
            if can_be_inside:
                pchunk = self.world.peek_chunk(int(ptx) // int(self.CHUNK_SIZE), int(pty) // int(self.CHUNK_SIZE))
                if pchunk is not None:
                    for mh in getattr(pchunk, "multi_houses", []):
                        tx0 = int(getattr(mh, "tx0", 0))
                        ty0 = int(getattr(mh, "ty0", 0))
                        w = int(getattr(mh, "w", 0))
                        h = int(getattr(mh, "h", 0))
                        if int(tx0) <= int(ptx) < int(tx0) + int(w) and int(ty0) <= int(pty) < int(ty0) + int(h):
                            inside_mh = (int(tx0), int(ty0), int(w), int(h))
                            inside_mh_floors = int(max(1, int(getattr(mh, "floors", 1))))
                            inside_mh_floors = int(min(int(inside_mh_floors), int(max_floors)))
                            inside_mh_floor = int(clamp(int(getattr(mh, "cur_floor", 1)), 1, int(inside_mh_floors)))
                            break

                    # Fallback for any other multi-floor building footprint (e.g., non-registered 2F houses).
                    for b in getattr(pchunk, "buildings", []):
                        btx0, bty0, bw, bh = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                        if int(btx0) <= int(ptx) < int(btx0) + int(bw) and int(bty0) <= int(pty) < int(bty0) + int(bh):
                            roof_kind = int(b[4]) if len(b) > 4 else 0
                            b_style, _bvar = self._building_roof_style_var(int(roof_kind))
                            b_floors = int(b[5]) if len(b) > 5 else 1
                            if int(b_style) in (1, 6) and int(b_floors) > 1:
                                inside_building = (int(btx0), int(bty0), int(bw), int(bh))
                                inside_building_style = int(b_style)
                                inside_building_floors = int(min(int(b_floors), int(max_floors)))
                            break
        except Exception:
            inside_mh = None
            inside_mh_floor = 1
            inside_mh_floors = 1
            inside_building = None
            inside_building_style = 0
            inside_building_floors = 1
 
        for cy in range(start_cy, end_cy + 1):
            for cx in range(start_cx, end_cx + 1):
                chunk = self.world.peek_chunk(cx, cy)
                if chunk is None:
                    continue
                for b in getattr(chunk, "buildings", []):
                    tx0, ty0, w, h = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                    if skip_building is not None and (int(tx0), int(ty0), int(w), int(h)) == tuple(skip_building):
                        continue
                    roof_kind = int(b[4]) if len(b) > 4 else 0
                    style, var = self._building_roof_style_var(int(roof_kind))

                    floors = int(b[5]) if len(b) > 5 else 0
                    if int(style) == 6:
                        if int(floors) <= 0:
                            floors = int(max_floors)
                        floors = int(min(int(floors), int(max_floors)))
                    face_h = int(self._building_face_height_px(style=style, w=w, h=h, var=var, floors=floors))
                    # Only draw the *front* facade (bottom/S) as requested.
                    # Keep visibility checks stable to avoid popping at edges while walking.
                    bx = int(tx0 * self.TILE_SIZE - cam_x)
                    by = int(ty0 * self.TILE_SIZE - cam_y)
                    bw = int(w * self.TILE_SIZE)
                    bh = int(h * self.TILE_SIZE)
                    # IMPORTANT: facades can extend above the building footprint (face_h),
                    # so cull using an expanded bound, otherwise facades/doors pop or disappear
                    # when the footprint is barely off-screen.
                    ground_y_cull = int(by + bh)
                    top_y_cull = int(min(int(by), int(ground_y_cull - self.TILE_SIZE - max(0, int(face_h)))))
                    bottom_y_cull = int(ground_y_cull)
                    if bx > INTERNAL_W or top_y_cull > INTERNAL_H:
                        continue
                    if (bx + bw) < 0 or bottom_y_cull < 0:
                        continue

                    front, side, trim, shadow = self._building_wall_palette(style=style, var=var)
                    outline = (10, 10, 12)

                    # Door detection (used for storefront detail).
                    door_info = self._find_building_exterior_door(tx0, ty0, w, h)
                    door_side = ""
                    door_tiles: list[tuple[int, int]] = []
                    if door_info is not None:
                        door_side, door_tiles = door_info

                    slice_floor: int | None = None
                    slice_floors = 0
                    if int(style) == 6:
                        if forced_mh is not None and (int(tx0), int(ty0), int(w), int(h)) == forced_mh:
                            slice_floor = int(forced_floor)
                            slice_floors = int(forced_floors)
                    if inside_mh is not None and int(style) in (1, 6):
                        itx0, ity0, iw, ih = inside_mh
                        if (int(itx0), int(ity0), int(iw), int(ih)) == (int(tx0), int(ty0), int(w), int(h)):
                            slice_floor = int(inside_mh_floor)
                            slice_floors = int(inside_mh_floors)
                    if slice_floor is None and inside_building is not None and int(style) in (1, 6) and int(inside_building_floors) > 1:
                        btx0, bty0, bw, bh = inside_building
                        if (int(btx0), int(bty0), int(bw), int(bh)) == (int(tx0), int(ty0), int(w), int(h)):
                            slice_floor = 1
                            slice_floors = int(inside_building_floors)

                    door_px: pygame.Rect | None = None
                    if door_tiles and door_side == "S":
                        xs = [p[0] for p in door_tiles]
                        ys = [p[1] for p in door_tiles]
                        dx0 = int(min(xs))
                        dx1 = int(max(xs))
                        dy = int(max(ys))
                        door_px = pygame.Rect(
                            int(dx0 * self.TILE_SIZE - cam_x),
                            int(dy * self.TILE_SIZE - cam_y),
                            int((dx1 - dx0 + 1) * self.TILE_SIZE),
                            int(self.TILE_SIZE + face_h),
                        )

                    ground_y = int(by + bh)
                    # Optional occlusion pass: only draw facades that are "in front"
                    # of a given screen-space y (used to keep vehicles from looking
                    # like they're on top of the building when behind it).
                    if min_ground_y is not None and int(ground_y) <= int(min_ground_y):
                        continue
                    # South (bottom) face: draw the "front facade".
                    # Extend upward for tall facades (high-rises and houses).
                    south_y = int(ground_y - self.TILE_SIZE)
                    south_h = int(self.TILE_SIZE)
                    if int(face_h) > 0:
                        south_y = int(ground_y - self.TILE_SIZE - int(face_h))
                        south_h = int(self.TILE_SIZE + int(face_h))      
                    if int(style) in (1, 6) and slice_floor is not None and int(slice_floors) > 1:
                        floor_h = int(floor_slice_h)
                        floors_total = int(max(1, int(slice_floors)))
                        floor_i = int(clamp(int(slice_floor), 1, int(floors_total)))
                        # Show this floor + all floors below it (same as high-rise),
                        # so on 2F you still see the 1F facade band.
                        south_h = int(max(1, int(floor_h) * int(floor_i)))
                        south_y = int(ground_y - int(south_h))
                    south = pygame.Rect(int(bx), int(south_y), int(bw), int(south_h))
                    pygame.draw.rect(surface, front, south)
                    pygame.draw.rect(surface, outline, south, 1)
                    # Ground shadow under the facade.
                    shadow_h = int(clamp(2 + int(face_h) // 10, 2, 5))
                    if int(south.bottom) == int(ground_y):
                        sh = pygame.Rect(int(south.x + 2), int(south.bottom), int(south.w - 2), int(shadow_h))
                        pygame.draw.rect(surface, shadow, sh)
                    # Lower-half shade for depth (independent of "building height").
                    shade_h = int(max(2, int(south.h) // 2))
                    shade = self._tint(front, add=(-18, -18, -18))
                    surface.fill(shade, pygame.Rect(int(south.x), int(south.bottom - shade_h), int(south.w), int(shade_h)))

                    # Trim line under the roof (or a separator when slicing to a lower floor).
                    if slice_floor is not None and int(slice_floors) > 0 and int(slice_floor) < int(slice_floors):
                        sep = self._tint(trim, add=(-34, -34, -38))
                        surface.fill(sep, pygame.Rect(south.x, south.y + 1, south.w, 1))
                    else:
                        surface.fill(trim, pygame.Rect(south.x, south.y + 1, south.w, 2))

                    # High-rise floor label (for very tall buildings).
                    if int(style) == 6 and int(floors) >= 11:
                        label = f"1234-{int(floors)}"
                        lx = int(south.x + 6)
                        ly = int(south.y + 6)
                        draw_text(surface, self.app.font_s, label, (lx + 1, ly + 1), pygame.Color(12, 12, 16), anchor="topleft")
                        draw_text(surface, self.app.font_s, label, (lx, ly), pygame.Color(240, 240, 240), anchor="topleft")

                    # High-rise floor separators (one line per floor).
                    if int(style) == 6:
                        floors_total = int(max(1, int(floors)))
                        if slice_floor is not None and int(slice_floors) > 0:
                            floors_total = int(max(1, int(slice_floors)))
                        if int(floors_total) > 1:
                            floor_h = int(max(1, int(floor_slice_h)))
                            sep = self._tint(trim, add=(-34, -34, -38))
                            for fi in range(1, int(floors_total)):
                                yy = int(south.bottom - int(fi) * int(floor_h))
                                if int(yy) <= int(south.y) or int(yy) >= int(south.bottom):
                                    continue
                                surface.fill(sep, pygame.Rect(int(south.x + 1), int(yy), max(1, int(south.w - 2)), 1))

                    # Facade details by building type.
                    store_header_bottom = int(south.y + 3)
                    if style in (2, 3, 5, 7):  # shop/hospital/school/bookstore: sign + band
                        sign_h = int(clamp(int(south.h // 3), 5, 7))
                        sign = pygame.Rect(south.x + 3, south.y + 2, south.w - 6, sign_h)
                        if style == 2:
                            base = (78, 118, 176) if ((var >> 1) & 1) == 0 else (176, 132, 78)
                            sign_bg = self._tint(base, add=(-10, -10, -10))
                        elif style == 7:
                            base = (46, 70, 110)
                            sign_bg = self._tint(base, add=(-8, -8, -8))
                        elif style == 5:
                            base = (168, 132, 92)
                            sign_bg = self._tint(base, add=(-18, -14, -10))
                        elif style == 3:
                            sign_bg = self._tint(trim, add=(-4, -4, -4))
                        else:
                            sign_bg = self._tint(trim, add=(-22, -22, -22))
                        pygame.draw.rect(surface, sign_bg, sign, border_radius=2)
                        pygame.draw.rect(surface, outline, sign, 1, border_radius=2)
                        # Tiny pseudo text blocks
                        for xx in range(sign.x + 4 + (var % 3), sign.right - 6, 4):
                            # IMPORTANT: use local x (not screen coordinates) so it doesn't flicker while walking.
                            if (((xx - sign.x) + var) % 5) == 0:
                                continue
                            surface.fill(self._tint(sign_bg, add=(38, 38, 42)), pygame.Rect(xx, sign.y + 2, 2, 1))
                        if style == 3 and sign.w >= 18:
                            # Red cross
                            cx = sign.centerx
                            cy = sign.centery
                            red = (190, 60, 60)
                            surface.fill(red, pygame.Rect(cx - 1, cy - 3, 2, 7))
                            surface.fill(red, pygame.Rect(cx - 3, cy - 1, 7, 2))
                            pygame.draw.rect(surface, outline, pygame.Rect(cx - 3, cy - 3, 7, 7), 1)
                        if style == 7 and sign.w >= 18:
                            # Tiny book icon.
                            cx = sign.centerx
                            cy = sign.centery
                            ink = (232, 200, 120)
                            pygame.draw.rect(surface, ink, pygame.Rect(cx - 6, cy - 3, 5, 7), 1, border_radius=1)
                            pygame.draw.rect(surface, ink, pygame.Rect(cx + 1, cy - 3, 5, 7), 1, border_radius=1)
                            surface.fill(outline, pygame.Rect(cx, cy - 3, 1, 7))

                        # Awning stripes just below sign for shops.
                        store_header_bottom = int(sign.bottom)
                        if style == 2:
                            awn_h = 5 if int(south.h) >= 16 else 4
                            awn = pygame.Rect(south.x + 3, sign.bottom + 1, south.w - 6, awn_h)
                            a1 = (190, 190, 196)
                            a2 = (170, 80, 80)
                            for i in range(awn.w):
                                col = a1 if ((i + var) % 6) < 3 else a2
                                surface.fill(col, pygame.Rect(awn.x + i, awn.y, 1, awn.h))
                            pygame.draw.rect(surface, outline, awn, 1)
                            store_header_bottom = int(awn.bottom)
                            # Small hanging placard on the right.
                            if awn.w >= 34:
                                plac = pygame.Rect(int(awn.right - 14), int(awn.bottom + 2), 10, 10)
                                pygame.draw.rect(surface, self._tint(sign_bg, add=(18, 18, 18)), plac, border_radius=2)
                                pygame.draw.rect(surface, outline, plac, 1, border_radius=2)
                                surface.fill((240, 220, 140), pygame.Rect(plac.x + 3, plac.y + 4, 4, 1))

                    if style == 3:
                        # Hospital: clean stripe band.
                        stripe = (92, 138, 206)
                        sy = int(store_header_bottom + 2)
                        if sy + 2 < south.bottom - 4:
                            surface.fill(stripe, pygame.Rect(int(south.x + 3), int(sy), int(south.w - 6), 2))

                    if style == 5:
                        # School: brick columns.
                        col = self._tint(front, add=(-26, -20, -16))     
                        if south.w >= 26 and south.h >= 14:
                            surface.fill(col, pygame.Rect(int(south.x + 2), int(south.y + 3), 3, int(south.h - 6)))
                            surface.fill(col, pygame.Rect(int(south.right - 5), int(south.y + 3), 3, int(south.h - 6)))
                            # Small banner tabs.
                            surface.fill(self._tint(trim, add=(-30, -30, -30)), pygame.Rect(int(sign.x + 6), int(sign.bottom), 2, 3))
                            surface.fill(self._tint(trim, add=(-30, -30, -30)), pygame.Rect(int(sign.right - 8), int(sign.bottom), 2, 3))

                    if style == 8:
                        # Chinese: red pillars + a small plaque.
                        if south.w >= 24 and south.h >= 14:
                            pillar = self._tint(front, add=(18, 0, 0))
                            surface.fill(pillar, pygame.Rect(int(south.x + 2), int(south.y + 3), 3, int(south.h - 6)))
                            surface.fill(pillar, pygame.Rect(int(south.right - 5), int(south.y + 3), 3, int(south.h - 6)))
                            plaque = pygame.Rect(int(south.centerx - 8), int(south.y + 2), 16, 6)
                            bg = self._tint(trim, add=(-26, -26, -26))
                            pygame.draw.rect(surface, bg, plaque, border_radius=2)
                            pygame.draw.rect(surface, outline, plaque, 1, border_radius=2)
                            ink = self._tint(trim, add=(22, 18, 0))
                            for xx in range(int(plaque.x + 4), int(plaque.right - 4), 3):
                                if ((xx + var) % 4) == 0:
                                    continue
                                surface.fill(ink, pygame.Rect(int(xx), int(plaque.y + 3), 2, 1))

                    if style == 4:
                        # Prison: barred windows.
                        bar = self._tint(trim, add=(-30, -30, -30))      
                        for xx in range(south.x + 6, south.right - 6, 6):
                            surface.fill(bar, pygame.Rect(xx, south.y + 3, 1, south.h - 6))

                    if style in (1, 6):
                        # Residential/high-rise windows.
                        detail_floors = int(floors)
                        if int(style) == 1 and slice_floor is not None and int(slice_floors) > 1:
                            # When inside a multi-floor house we slice to a single floor strip.
                            detail_floors = 1
                        win = self._tint(trim, add=(-40, -40, -46))
                        frame = outline
                        start_x = int(south.x + 6 + (var % 4))
                        if style == 6:
                            # Multiple rows so height reads as "high-rise".
                            step_x = 10
                            step_y = 8
                            y0w = int(south.y + 4)
                            y1w = int(south.bottom - 7)
                            for row_i, yy in enumerate(range(y0w, y1w, step_y)):
                                for col_i, xx in enumerate(range(start_x, south.right - 10, step_x)):
                                    # IMPORTANT: use local indices (not screen coords) so it doesn't flicker.
                                    if ((col_i + row_i + var) % 4) == 0:
                                        continue
                                    r = pygame.Rect(int(xx), int(yy), 6, 4)
                                    pygame.draw.rect(surface, win, r, border_radius=1)
                                    pygame.draw.rect(surface, frame, r, 1, border_radius=1)
                        else:
                            step_x = 12
                            if int(detail_floors) > 1 and south.h >= 18:
                                # Multi-floor house: 2–3 window rows so the facade reads taller.
                                rows = int(clamp(int(detail_floors), 2, 3))
                                y0w = int(south.y + 4)
                                y1w = int(south.bottom - 18)
                                if y1w <= y0w:
                                    y1w = int(south.y + 4)
                                span = int(max(0, int(y1w - y0w)))
                                for row_i in range(int(rows)):
                                    yy = int(y0w + (span * int(row_i)) / max(1, int(rows - 1)))
                                    for col_i, xx in enumerate(range(start_x, south.right - 10, step_x)):
                                        # IMPORTANT: use local indices (not screen coords) so it doesn't flicker.
                                        if ((col_i + row_i + var) % 4) == 0:
                                            continue
                                        r = pygame.Rect(int(xx), int(yy), 6, 4)
                                        pygame.draw.rect(surface, win, r, border_radius=1)
                                        pygame.draw.rect(surface, frame, r, 1, border_radius=1)
                            else:
                                # Single row for small residential buildings.
                                y1 = int(south.y + 4)
                                for i, xx in enumerate(range(start_x, south.right - 10, step_x)):
                                    # IMPORTANT: use local window index (not screen coordinates) so it doesn't flicker.
                                    if ((i + var) % 3) == 0:
                                        continue
                                    r = pygame.Rect(int(xx), int(y1), 6, 4)
                                    pygame.draw.rect(surface, win, r, border_radius=1)
                                    pygame.draw.rect(surface, frame, r, 1, border_radius=1)

                    # "Front interior" storefront hint (like the reference): show a cutout window strip with
                    # silhouettes of shelves/props synced to the actual interior tiles.
                    if style in (2, 3, 5, 7):
                        open_y = int(store_header_bottom + 1)
                        open_h = int(south.bottom - 2 - open_y)
                        open_x = int(south.x + 4)
                        open_w = int(south.w - 8)
                        if open_w >= int(self.TILE_SIZE * 2) and open_h >= 4:
                            open_rect = pygame.Rect(int(open_x), int(open_y), int(open_w), int(open_h))
                            interior = self._tint(side, add=(-30, -30, -30))
                            if style == 3:
                                interior = self._tint(front, add=(-34, -34, -30))
                            elif style == 5:
                                interior = self._tint(front, add=(-36, -30, -26))
                            pygame.draw.rect(surface, interior, open_rect, border_radius=2)
                            pygame.draw.rect(surface, outline, open_rect, 1, border_radius=2)

                            # Glass highlight + mullions.
                            glass_hi = self._tint(trim, add=(48, 48, 54))
                            surface.fill(
                                glass_hi,
                                pygame.Rect(open_rect.x + 1, open_rect.y + 1, max(1, open_rect.w - 2), 1),
                            )
                            mull = self._tint(interior, add=(18, 18, 18))
                            step = 12 if open_rect.w >= 80 else 10
                            for xx in range(open_rect.x + 8 + (var % 5), open_rect.right - 6, step):
                                surface.fill(mull, pygame.Rect(int(xx), open_rect.y + 2, 1, max(1, open_rect.h - 4)))

                            prev_clip = surface.get_clip()
                            surface.set_clip(open_rect.inflate(-1, -1))

                            # Interior silhouettes near the front wall.
                            if open_rect.h >= 6 and int(w) >= 4 and int(h) >= 4:
                                sample_ys = [int(ty0 + h - 2), int(ty0 + h - 3)]
                                seed = int(self.seed) ^ 0x51F2A1B3
                                for row_i, sy in enumerate(sample_ys):
                                    if not (int(ty0) < int(sy) < int(ty0 + h - 1)):
                                        continue
                                    y_off = int(row_i)
                                    for tx in range(int(tx0 + 1), int(tx0 + w - 1)):
                                        px = int(tx * self.TILE_SIZE - cam_x)
                                        if px + self.TILE_SIZE <= open_rect.x or px >= open_rect.right:
                                            continue
                                        tid = int(self.world.peek_tile(tx, sy))
                                        if tid == int(self.T_FLOOR):
                                            if style != 2:
                                                continue
                                            hh = int(self._hash2_u32(int(tx), int(sy), seed))
                                            if (hh & 15) != 0:
                                                continue
                                            crate = (132, 92, 62) if ((hh >> 4) & 1) else (92, 70, 52)
                                            rr = pygame.Rect(
                                                int(px + 2),
                                                int(open_rect.bottom - 3 - y_off),
                                                max(1, int(self.TILE_SIZE - 4)),
                                                2,
                                            )
                                            surface.fill(crate, rr)
                                            pygame.draw.rect(surface, outline, rr, 1)
                                            if rr.w >= 5:
                                                g1 = (196, 120, 86) if ((hh >> 6) & 1) else (86, 190, 120)
                                                surface.fill(g1, pygame.Rect(rr.x + 2, rr.y, 1, 1))
                                            continue

                                        if tid in (int(self.T_TABLE), int(self.T_SHELF), int(self.T_BED)):
                                            # More detailed facade furniture silhouettes (legs, shelves, pillows).
                                            fh = int(self._hash2_u32(int(tx), int(sy), seed ^ 0x9E3779B9))
                                            floor_y = int(open_rect.bottom - 2 - y_off)
                                            max_h = int(max(3, open_rect.h - 3))
                                            if tid == int(self.T_TABLE):
                                                self._draw_facade_furniture_silhouette(
                                                    surface,
                                                    kind="table",
                                                    x=int(px + 1),
                                                    floor_y=floor_y,
                                                    w=int(self.TILE_SIZE - 2),
                                                    max_h=max_h,
                                                    seed=fh,
                                                    depth=y_off,
                                                )
                                            elif tid == int(self.T_SHELF):
                                                self._draw_facade_furniture_silhouette(
                                                    surface,
                                                    kind="shelf",
                                                    x=int(px + 1),
                                                    floor_y=floor_y,
                                                    w=int(self.TILE_SIZE - 2),
                                                    max_h=max_h,
                                                    seed=fh,
                                                    depth=y_off,
                                                )
                                            else:
                                                self._draw_facade_furniture_silhouette(
                                                    surface,
                                                    kind="bed",
                                                    x=int(px + 1),
                                                    floor_y=floor_y,
                                                    w=int(self.TILE_SIZE - 2),
                                                    max_h=max_h,
                                                    seed=fh,
                                                    depth=y_off,
                                                )
                                            continue

                                            # Keep facade interior silhouettes readable even if minimap hides interiors.
                                            if tid == int(self.T_TABLE):
                                                c = (104, 82, 62)
                                            elif tid == int(self.T_SHELF):
                                                c = (92, 92, 104)
                                            else:
                                                c = (126, 126, 164)
                                            c = self._tint(c, add=(-56, -56, -56))
                                            bh = 3 if tid != int(self.T_BED) else 4
                                            rr = pygame.Rect(
                                                int(px + 1),
                                                int(open_rect.bottom - 2 - bh - y_off),
                                                max(1, int(self.TILE_SIZE - 2)),
                                                int(bh),
                                            )
                                            surface.fill(c, rr)
                                            pygame.draw.rect(surface, outline, rr, 1)
                                            if tid == int(self.T_SHELF) and rr.w >= 6 and rr.h >= 3:
                                                hh = int(self._hash2_u32(int(tx), int(sy), seed ^ 0x9E3779B9))
                                                g1 = (200, 86, 86) if ((hh >> 1) & 1) else (86, 210, 130)
                                                g2 = (210, 200, 120) if ((hh >> 2) & 1) else (140, 140, 220)
                                                surface.fill(g1, pygame.Rect(rr.x + 2, rr.y + 1, 1, 1))
                                                surface.fill(g2, pygame.Rect(rr.right - 3, rr.y + 1, 1, 1))

                            # Type accents for quick read.
                            if style == 5 and open_rect.w >= 22 and open_rect.h >= 7:
                                board = pygame.Rect(open_rect.x + 3, open_rect.y + 2, min(18, open_rect.w - 6), 4)
                                surface.fill((22, 34, 26), board)
                                pygame.draw.rect(surface, outline, board, 1)
                            if style == 3 and open_rect.w >= 18 and open_rect.h >= 7:
                                cx = open_rect.x + 8
                                cy = open_rect.y + 4
                                red = (190, 60, 60)
                                surface.fill(red, pygame.Rect(int(cx - 1), int(cy - 3), 2, 7))
                                surface.fill(red, pygame.Rect(int(cx - 3), int(cy - 1), 7, 2))
                                pygame.draw.rect(surface, outline, pygame.Rect(int(cx - 3), int(cy - 3), 7, 7), 1)

                            surface.set_clip(prev_clip)

                    # Re-draw the exterior door if our *front* facade covers it (south only).
                    if isinstance(door_px, pygame.Rect):
                        # Door visual should not scale with the full facade height (especially for high-rises).
                        # Anchor to the ground (bottom of facade) and clamp size by building type.
                        door_open_w = int(door_px.w)
                        if style == 1:  # house
                            door_w = int(clamp(door_open_w - 10, 10, 14))       
                        elif style in (2, 3, 4, 7):  # shop/hospital/prison/bookstore
                            door_w = int(clamp(door_open_w - 2, 16, 20))        
                        elif style in (5, 8):  # school/chinese
                            door_w = int(clamp(door_open_w - 4, 14, 18))        
                        elif style == 6:  # high-rise lobby
                            door_w = int(clamp(door_open_w - 4, 14, 18))        
                        else:
                            door_w = int(clamp(door_open_w - 6, 12, 18))        

                        if style == 6:
                            # High-rise lobby: keep it single-story (do not scale with the whole facade height).
                            door_h = int(clamp(16 + ((int(var) >> 2) % 3) - 1, 14, 18))
                        elif style == 1:
                            # Houses: keep door height consistent between 1F/2F.
                            door_h = int(self.TILE_SIZE)
                        else:
                            door_h = int(clamp(10 + int(face_h) // 3, 12, 18))
                        door_h = int(min(int(door_h), max(10, int(south.h - 6))))

                        dr = pygame.Rect(0, 0, int(door_w), int(door_h))
                        # Door bottom line should align with the tile baseline (no "floating").
                        dr.midbottom = (int(door_px.centerx), int(south.bottom))
                        min_x = int(south.x + 2)
                        max_x = int(south.right - dr.w - 2)
                        if max_x >= min_x:
                            dr.x = int(clamp(int(dr.x), min_x, max_x))

                        if style == 2:
                            # Shop: glass sliding doors.
                            door_bg = self._tint(trim, add=(-78, -78, -84))     
                            pygame.draw.rect(surface, door_bg, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            hi = self._tint(trim, add=(48, 48, 54))
                            surface.fill(hi, pygame.Rect(dr.x + 2, dr.y + 3, max(1, dr.w - 4), 1))
                            mid = int(dr.centerx)
                            surface.fill(outline, pygame.Rect(mid, dr.y + 2, 1, max(1, dr.h - 4)))
                            handle = (230, 230, 236)
                            surface.fill(handle, pygame.Rect(mid - 3, dr.centery - 1, 1, 2))
                            surface.fill(handle, pygame.Rect(mid + 2, dr.centery - 1, 1, 2))
                        elif style == 7:
                            # Bookstore: glass door + small book decal.
                            door_bg = self._tint(trim, add=(-82, -82, -90))
                            pygame.draw.rect(surface, door_bg, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            hi = self._tint(trim, add=(52, 52, 56))
                            surface.fill(hi, pygame.Rect(dr.x + 2, dr.y + 3, max(1, dr.w - 4), 1))
                            mid = int(dr.centerx)
                            surface.fill(outline, pygame.Rect(mid, dr.y + 2, 1, max(1, dr.h - 4)))
                            ink = (232, 200, 120)
                            bx = int(dr.centerx)
                            by = int(dr.y + 5)
                            pygame.draw.rect(surface, ink, pygame.Rect(bx - 5, by, 4, 6), 1, border_radius=1)
                            pygame.draw.rect(surface, ink, pygame.Rect(bx + 2, by, 4, 6), 1, border_radius=1)
                            surface.fill(outline, pygame.Rect(bx, by, 1, 6))
                        elif style == 3:
                            # Hospital: glass door + red cross.
                            door_bg = self._tint(front, add=(-46, -46, -40))
                            pygame.draw.rect(surface, door_bg, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            hi = self._tint(trim, add=(52, 52, 56))
                            surface.fill(hi, pygame.Rect(dr.x + 2, dr.y + 3, max(1, dr.w - 4), 1))
                            mid = int(dr.centerx)
                            surface.fill(outline, pygame.Rect(mid, dr.y + 2, 1, max(1, dr.h - 4)))
                            red = (190, 60, 60)
                            cx = int(dr.x + min(10, max(6, dr.w // 2)))
                            cy = int(clamp(int(dr.y + dr.h // 2), int(dr.y + 4), int(dr.bottom - 4)))
                            surface.fill(red, pygame.Rect(cx - 1, cy - 3, 2, 7))
                            surface.fill(red, pygame.Rect(cx - 3, cy - 1, 7, 2))
                            pygame.draw.rect(surface, outline, pygame.Rect(cx - 3, cy - 3, 7, 7), 1)
                        elif style == 4:
                            # Prison: heavy gate + bars + caution band.
                            metal = self._tint(front, add=(-22, -22, -28))
                            pygame.draw.rect(surface, metal, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            bar = self._tint(trim, add=(-46, -46, -52))
                            for xx in range(int(dr.x + 2), int(dr.right - 2), 3):
                                surface.fill(bar, pygame.Rect(int(xx), int(dr.y + 2), 1, max(1, int(dr.h - 4))))
                            # Caution stripe at the top of the gate.
                            band = pygame.Rect(int(dr.x + 2), int(dr.y + 2), max(1, int(dr.w - 4)), 4)
                            a = (210, 190, 90)
                            bcol = (50, 50, 56)
                            for i in range(int(band.w)):
                                col = a if ((i + var) % 6) < 3 else bcol
                                surface.fill(col, pygame.Rect(int(band.x + i), int(band.y), 1, int(band.h)))
                            pygame.draw.rect(surface, outline, band, 1)
                        elif style == 5:
                            # School: wooden double doors.
                            wood = self._tint(front, add=(-36, -26, -18))
                            pygame.draw.rect(surface, wood, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            for xx in range(int(dr.x + 3), int(dr.right - 3), 4):
                                surface.fill(self._tint(wood, add=(18, 12, 6)), pygame.Rect(int(xx), int(dr.y + 2), 1, max(1, int(dr.h - 4))))
                            mid = int(dr.centerx)
                            surface.fill(outline, pygame.Rect(mid, dr.y + 2, 1, max(1, dr.h - 4)))
                            knob = (18, 18, 22)
                            surface.fill(knob, pygame.Rect(mid - 3, dr.centery, 1, 1))
                            surface.fill(knob, pygame.Rect(mid + 2, dr.centery, 1, 1))
                        elif style == 8:
                            # Chinese: red double door + gold studs.
                            red = self._tint(front, add=(10, -4, -6))
                            pygame.draw.rect(surface, red, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            mid = int(dr.centerx)
                            surface.fill(outline, pygame.Rect(mid, dr.y + 2, 1, max(1, dr.h - 4)))
                            gold = (210, 180, 110)
                            for yy in range(int(dr.y + 4), int(dr.bottom - 4), 4):
                                surface.fill(gold, pygame.Rect(int(mid - 3), int(yy), 1, 1))
                                surface.fill(gold, pygame.Rect(int(mid + 2), int(yy), 1, 1))
                            surface.fill(gold, pygame.Rect(int(mid - 3), int(dr.centery), 1, 1))
                            surface.fill(gold, pygame.Rect(int(mid + 2), int(dr.centery), 1, 1))
                        elif style == 1:
                            # Residential: simple wood door + small window.
                            wood = self._tint(front, add=(-34, -22, -14))
                            pygame.draw.rect(surface, wood, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            winr = pygame.Rect(int(dr.centerx - 3), int(dr.y + 4), 6, 4)
                            pygame.draw.rect(surface, self._tint(trim, add=(-30, -30, -34)), winr, border_radius=1)
                            pygame.draw.rect(surface, outline, winr, 1, border_radius=1)
                            pygame.draw.circle(surface, (18, 18, 22), (dr.right - 4, dr.centery), 1)
                            # Doormat.
                            mat = pygame.Rect(int(dr.x + 1), int(dr.bottom - 4), max(1, int(dr.w - 2)), 2)
                            surface.fill(self._tint(front, add=(-44, -44, -44)), mat)
                        elif style == 6:
                            # High-rise lobby: big glass door.
                            door_bg = self._tint(trim, add=(-86, -86, -92))
                            pygame.draw.rect(surface, door_bg, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            hi = self._tint(trim, add=(52, 52, 56))
                            surface.fill(hi, pygame.Rect(dr.x + 2, dr.y + 3, max(1, dr.w - 4), 1))
                            for xx in range(int(dr.x + 3), int(dr.right - 3), 4):
                                surface.fill(outline, pygame.Rect(int(xx), int(dr.y + 2), 1, max(1, int(dr.h - 4))))
                        else:
                            # Default: simple door.
                            door_bg = self._tint(front, add=(-34, -30, -24))
                            pygame.draw.rect(surface, door_bg, dr, border_radius=2)
                            pygame.draw.rect(surface, outline, dr, 1, border_radius=2)
                            surface.fill(self._tint(door_bg, add=(18, 14, 10)), pygame.Rect(dr.x + 2, dr.y + 2, max(1, dr.w - 4), 3))
                            pygame.draw.circle(surface, (18, 18, 22), (dr.right - 4, dr.y + dr.h // 2), 1)

                        # Threshold shadow for depth.
                        surface.fill(self._tint(front, add=(-26, -26, -30)), pygame.Rect(dr.x + 1, dr.bottom - 2, max(1, dr.w - 2), 1))

    def _draw_roofs(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
    ) -> None:
        inside_key: tuple[int, int, int, int] | None = getattr(self, "_inside_building_key", None)

        start_cx = start_tx // self.CHUNK_SIZE
        end_cx = end_tx // self.CHUNK_SIZE
        start_cy = start_ty // self.CHUNK_SIZE
        end_cy = end_ty // self.CHUNK_SIZE

        for cy in range(start_cy, end_cy + 1):
            for cx in range(start_cx, end_cx + 1):
                chunk = self.world.peek_chunk(cx, cy)
                if chunk is None:
                    continue
                for b in chunk.buildings:
                    tx0, ty0, w, h = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                    roof_kind = int(b[4]) if len(b) > 4 else 0
                    style, var = self._building_roof_style_var(int(roof_kind))
                    floors = int(b[5]) if len(b) > 5 else 0
                    if int(style) == 6:
                        max_floors = int(max(2, int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
                        if int(floors) <= 0:
                            floors = int(max_floors)
                        floors = int(min(int(floors), int(max_floors)))
                    face_h = int(self._building_face_height_px(style=style, w=w, h=h, var=var, floors=floors))
                    if inside_key is not None and (int(tx0), int(ty0), int(w), int(h)) == inside_key:
                        # When the player is inside a building, hide that building's roof completely.
                        continue
                    alpha = 255
                    rw = max(1, int(w) - 2)
                    rh = max(1, int(h) - 2)
                    roof = self._roof_surface(rw, rh, alpha, roof_kind=roof_kind)
                    roof_draw = roof
                    cut = int(self._roof_cut_px(style=int(style), w=int(w), h=int(h), var=int(var), floors=int(floors)))
                    if cut > 0:
                        roof_draw = roof.subsurface(pygame.Rect(0, 0, int(roof.get_width()), int(roof.get_height() - cut)))
                    roof_lift = 0
                    if cut > 0:
                        roof_lift = int(max(0, int(face_h) - int(cut) - 2))

                    sx = (int(tx0) + 1) * self.TILE_SIZE - int(cam_x)
                    sy = (int(ty0) + 1) * self.TILE_SIZE - int(cam_y)
                    # Slight roof offset to reveal the "front" (bottom/right) walls like MiniDayZ.
                    roof_off_x = -2
                    roof_off_y = -2
                    rx = int(sx + roof_off_x)
                    ry = int(sy + roof_off_y - int(roof_lift))
                    if rx > INTERNAL_W or ry > INTERNAL_H:
                        continue
                    if rx + roof_draw.get_width() < 0 or ry + roof_draw.get_height() < 0:
                        continue
                    if inside_key is None or (int(tx0), int(ty0), int(w), int(h)) != inside_key:
                        sh = pygame.Surface((roof_draw.get_width(), roof_draw.get_height()), pygame.SRCALPHA)
                        sh.fill((0, 0, 0, 70))
                        surface.blit(sh, (int(rx + 2), int(ry + 2)))
                    surface.blit(roof_draw, (int(rx), int(ry)))

    def _draw_zombies(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        *,
        corpses: bool = True,
        alive: bool = True,
    ) -> None:
        for z in self.zombies:
            p = pygame.Vector2(z.pos) - pygame.Vector2(cam_x, cam_y)
            sx = iround(float(p.x))
            sy = iround(float(p.y))

            kind = str(getattr(z, "kind", "walker"))
            by_kind = self._MONSTER_FRAMES.get(kind) or self._MONSTER_FRAMES.get("walker")
            if not by_kind:
                continue
            d = str(getattr(z, "dir", "down"))
            frames = by_kind.get(d) or by_kind.get("down")
            if not frames:
                continue

            # Corpse rendering (do not despawn immediately).
            is_corpse = int(getattr(z, "hp", 0)) <= 0 and float(getattr(z, "corpse_left", 0.0)) > 0.0
            if bool(is_corpse):
                if not bool(corpses):
                    continue
                spr = frames[0]
                sx2 = int(sx)
                sy2 = int(sy)
                ground_y = iround(float(sy2) + float(getattr(z, "h", 0)) / 2.0)

                total = float(getattr(z, "corpse_total", 0.0)) or float(getattr(self, "_ZOMBIE_CORPSE_TOTAL_S", 14.0))
                left = float(getattr(z, "corpse_left", 0.0))
                fade = float(clamp(left / max(1e-6, float(total)), 0.0, 1.0))
                alpha = int(round(255.0 * (fade**0.45)))

                fall_s = float(getattr(self, "_ZOMBIE_FALL_S", 0.22))
                t_dead = float(getattr(z, "death_t", 0.0))
                corpse_surf: pygame.Surface
                if fall_s > 1e-6 and t_dead < fall_s:
                    t = float(clamp(t_dead / float(fall_s), 0.0, 1.0))
                    sx_scale = 1.0 + 0.18 * t
                    sy_scale = 1.0 - 0.58 * t
                    ww = max(1, int(round(float(spr.get_width()) * float(sx_scale))))
                    hh = max(1, int(round(float(spr.get_height()) * float(sy_scale))))
                    corpse_surf = pygame.transform.scale(spr, (int(ww), int(hh)))
                else:
                    corpse_surf = pygame.transform.rotate(spr, 90)

                corpse_surf = corpse_surf.copy()
                # Darken as it "rots", keep alpha shape.
                mul = int(round(140.0 + 115.0 * float(fade)))
                corpse_surf.fill((mul, mul, mul, 255), special_flags=pygame.BLEND_RGBA_MULT)
                corpse_surf.set_alpha(alpha)

                rect = corpse_surf.get_rect()
                rect.midbottom = (int(sx2), int(ground_y))
                # Corpse shadow: anchor to the *opaque* pixel bounds so it stays glued to the body
                # even after rotate/scale (surfaces include transparent margins).
                try:
                    br = corpse_surf.get_bounding_rect()  # local to corpse_surf
                    body_rect = br.move(int(rect.left), int(rect.top))
                except Exception:
                    body_rect = rect
                shadow = pygame.Rect(0, 0, max(6, int(body_rect.w) - 2), 4)
                shadow.center = (int(body_rect.centerx), int(body_rect.centery + max(1, int(body_rect.h) // 6)))
                pygame.draw.ellipse(surface, (0, 0, 0), shadow)
                surface.blit(corpse_surf, rect)
                continue

            if not bool(alive):
                continue

            moving = z.vel.length_squared() > 1.0
            idx = 0 if not moving else 1 + (int(float(getattr(z, "anim", 0.0))) % 2)
            idx = max(0, min(int(idx), len(frames) - 1))
            spr = frames[idx]

            # Wobble when walking: visual-only sway (doesn't affect collisions).
            wob_x = 0
            wob_y = 0
            if moving:
                phase = float(getattr(z, "anim", 0.0))
                if kind == "walker":
                    freq = 2.2
                    sway_amp = 2.2
                    bob_amp = 1.2
                elif kind == "screamer":
                    freq = 2.4
                    sway_amp = 2.0
                    bob_amp = 1.1
                else:
                    freq = 2.8
                    sway_amp = 1.4
                    bob_amp = 0.8
                sway = int(round(math.sin(phase * float(freq)) * float(sway_amp)))
                bob = int(round(math.cos(phase * float(freq)) * float(bob_amp)))
                if d in ("left", "right"):
                    wob_y = int(sway)
                    wob_x = int(bob)
                else:
                    wob_x = int(sway)
                    wob_y = int(bob)
            sx2 = int(sx + wob_x)
            sy2 = int(sy + wob_y)

            rect = spr.get_rect()
            rect.midbottom = (int(sx2), iround(float(sy2) + float(z.h) / 2.0))

            shadow = pygame.Rect(0, 0, max(6, rect.w - 4), 4)
            shadow.center = (int(sx2), iround(float(sy2) + float(z.h) / 2.0 - 1.0))
            pygame.draw.ellipse(surface, (0, 0, 0), shadow)
            surface.blit(spr, rect)

            if self._debug:
                mdef = self._MONSTER_DEFS.get(kind, self._MONSTER_DEFS["walker"])
                max_hp = max(1, int(mdef.hp) + 6)
                hp = int(clamp(int(z.hp), 0, max_hp))
                bar = pygame.Rect(rect.left, rect.top - 4, rect.w, 3)
                pygame.draw.rect(surface, (10, 10, 14), bar)
                fill_w = int((bar.w - 1) * (hp / max(1, max_hp)))
                if fill_w > 0:
                    pygame.draw.rect(surface, (220, 90, 90), pygame.Rect(bar.x + 1, bar.y + 1, fill_w, bar.h - 1))

    def _draw_bullets(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        for b in self.bullets:
            p = pygame.Vector2(b.pos) - pygame.Vector2(cam_x, cam_y)
            x = iround(float(p.x))
            y = iround(float(p.y))
            if 0 <= x < INTERNAL_W and 0 <= y < INTERNAL_H:
                surface.set_at((x, y), (250, 250, 250))

    def _draw_thrown_furniture(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        thrown = getattr(self, "thrown_furniture", None)
        if not isinstance(thrown, list) or not thrown:
            return
        for tf in thrown:
            if not isinstance(tf, HardcoreSurvivalState._ThrownFurniture):
                continue
            p = pygame.Vector2(getattr(tf, "pos", pygame.Vector2(0, 0))) - pygame.Vector2(cam_x, cam_y)
            x = iround(float(p.x))
            y = iround(float(p.y))
            if not (0 <= x < INTERNAL_W and 0 <= y < INTERNAL_H):
                continue
            tid = int(getattr(tf, "tid", 0))
            col = (210, 200, 180)
            tdef = self._TILES.get(int(tid))
            if tdef is not None:
                col = tuple(getattr(tdef, "color", col))
            r = pygame.Rect(int(x - 3), int(y - 3), 6, 6)
            pygame.draw.rect(surface, (10, 10, 12), r.inflate(2, 2))
            pygame.draw.rect(surface, col, r)
            pygame.draw.rect(surface, (0, 0, 0), r, 1)

    def _draw_inventory_ui(self, surface: pygame.Surface) -> None:
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 170))
        surface.blit(overlay, (0, 0))

        cols = max(1, int(self.inventory.cols))
        rows = int(math.ceil(len(self.inventory.slots) / cols))
        slot = 30
        gap = 4
        grid_w = cols * slot + (cols - 1) * gap
        grid_h = rows * slot + (rows - 1) * gap
        x0 = (INTERNAL_W - grid_w) // 2
        y0 = (INTERNAL_H - grid_h) // 2 - 10

        panel = pygame.Rect(x0 - 10, y0 - 26, grid_w + 20, grid_h + 58)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=10)
        pygame.draw.rect(surface, (80, 80, 96), panel, 2, border_radius=10)
        draw_text(surface, self.app.font_m, "背包", (panel.centerx, panel.top + 14), pygame.Color(240, 240, 240), anchor="center")

        for i, st in enumerate(self.inventory.slots):
            cx = i % cols
            cy = i // cols
            r = pygame.Rect(x0 + cx * (slot + gap), y0 + cy * (slot + gap), slot, slot)
            selected = i == int(self.inv_index)
            bg = (44, 44, 52) if selected else (26, 26, 32)
            border = (220, 220, 240) if selected else (90, 90, 110)
            pygame.draw.rect(surface, bg, r, border_radius=6)
            pygame.draw.rect(surface, border, r, 2, border_radius=6)
            if st is None:
                continue
            self._ensure_item_visuals(st.item_id)
            img: pygame.Surface | None = None
            spr = self._ITEM_SPRITES.get(st.item_id)
            if spr is not None:
                factor = 2 if (spr.get_width() * 2 <= r.w - 2 and spr.get_height() * 2 <= r.h - 2) else 1
                if factor != 1:
                    img = pygame.transform.scale(spr, (spr.get_width() * factor, spr.get_height() * factor))
                else:
                    img = spr
            else:
                icon = self._ITEM_ICONS.get(st.item_id)
                if icon is None:
                    idef = self._ITEMS.get(st.item_id)
                    col = idef.color if idef is not None else (255, 0, 255)
                    icon_rect = pygame.Rect(0, 0, 10, 10)
                    icon_rect.center = r.center
                    pygame.draw.rect(surface, col, icon_rect)
                else:
                    img = icon
                    if img.get_width() <= 8:
                        img = pygame.transform.scale(img, (img.get_width() * 2, img.get_height() * 2))
            if img is not None:
                surface.blit(img, img.get_rect(center=r.center))
            draw_text(surface, self.app.font_s, str(int(st.qty)), (r.right - 2, r.bottom - 2), pygame.Color(240, 240, 240), anchor="topright")

        sel = self.inventory.slots[int(self.inv_index)]
        line1 = "空"
        line2 = ""
        if sel is not None:
            idef = self._ITEMS.get(sel.item_id)
            name = idef.name if idef is not None else sel.item_id
            line1 = f"{name} x{int(sel.qty)}"
            if idef is not None and str(getattr(idef, "desc", "")).strip():
                line2 = str(getattr(idef, "desc", "")).strip()
                if len(line2) > 42:
                    line2 = line2[:42] + "…"
        draw_text(surface, self.app.font_s, line1, (panel.centerx, panel.bottom - 36), pygame.Color(210, 210, 220), anchor="center")
        if line2:
            draw_text(surface, self.app.font_s, line2, (panel.centerx, panel.bottom - 22), pygame.Color(200, 200, 210), anchor="center")
        draw_text(surface, self.app.font_s, "鼠标左键选择/双击使用  右键使用/装备  Q丢弃  Tab关闭", (panel.centerx, panel.bottom - 8), pygame.Color(160, 160, 175), anchor="center")

    def _draw_sprite_gallery_ui(self, surface: pygame.Surface) -> None:
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 210))
        surface.blit(overlay, (0, 0))

        panel = pygame.Rect(10, 10, INTERNAL_W - 20, INTERNAL_H - 20)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (90, 90, 110), panel, 2, border_radius=12)

        page = int(getattr(self, "_gallery_page", 0)) % 2
        title = "Sprite Gallery: Cars" if page == 0 else "Sprite Gallery: Bike"
        draw_text(surface, self.app.font_m, title, (panel.centerx, panel.top + 12), pygame.Color(240, 240, 240), anchor="center")

        if page == 0:
            ids = list(self._CAR_MODELS.keys())
            if not ids:
                draw_text(surface, self.app.font_s, "No car models", (panel.centerx, panel.centery), pygame.Color(200, 200, 210), anchor="center")
            else:
                maxw = 1
                maxh = 1
                for mid in ids:
                    base = self._CAR_BASE.get((str(mid), 0, 0))
                    if base is None:
                        continue
                    maxw = max(maxw, int(base.get_width()))
                    maxh = max(maxh, int(base.get_height()))

                scale = 3
                cols = 3
                cell_pad = 10
                label_h = 14
                cell_w = maxw * scale + cell_pad
                cell_h = maxh * scale + label_h + cell_pad
                rows = int((len(ids) + cols - 1) // cols)
                grid_w = cols * cell_w
                grid_h = rows * cell_h
                x0 = int(panel.centerx - grid_w // 2)
                y0 = int(panel.top + 30)
                if y0 + grid_h > panel.bottom - 16:
                    y0 = max(int(panel.top + 30), int(panel.bottom - 16 - grid_h))

                for idx, mid in enumerate(ids):
                    base = self._CAR_BASE.get((str(mid), 0, 0))
                    if base is None:
                        continue
                    spr = pygame.transform.scale(base, (int(base.get_width()) * scale, int(base.get_height()) * scale))
                    cx = idx % cols
                    cy = idx // cols
                    cell_x = x0 + cx * cell_w
                    cell_y = y0 + cy * cell_h
                    bg = pygame.Rect(cell_x + 4, cell_y + 2, cell_w - 8, maxh * scale + 4)
                    pygame.draw.rect(surface, (24, 24, 30), bg, border_radius=10)
                    pygame.draw.rect(surface, (50, 50, 64), bg, 1, border_radius=10)
                    x = cell_x + (cell_w - spr.get_width()) // 2
                    y = cell_y + 4
                    surface.blit(spr, (x, y))
                    draw_text(surface, self.app.font_s, str(mid), (cell_x + cell_w // 2, cell_y + maxh * scale + 8), pygame.Color(200, 200, 210), anchor="midtop")
        else:
            dirs = ["up", "down", "left", "right"]
            scale = 5
            cell = 18 * scale
            x0 = int(panel.centerx - (len(dirs) * cell) // 2)
            y0 = int(panel.top + 34)

            for di, d in enumerate(dirs):
                for fi in range(2):
                    b = self._BIKE_FRAMES.get(d, self._BIKE_FRAMES["right"])[fi]
                    rider_frames = getattr(self, "cyclist_frames", getattr(self, "_CYCLIST_FRAMES", {})).get(d)
                    if rider_frames is None:
                        pf = getattr(self, "player_frames", self._PLAYER_FRAMES)
                        rider_frames = pf.get(d, pf["down"])[:2]
                    r = rider_frames[fi % len(rider_frames)]

                    bs = pygame.transform.scale(b, (int(b.get_width()) * scale, int(b.get_height()) * scale))
                    rs = pygame.transform.scale(r, (int(r.get_width()) * scale, int(r.get_height()) * scale))
                    x = x0 + di * cell + (cell - bs.get_width()) // 2
                    y = y0 + fi * cell + (cell - bs.get_height()) // 2
                    surface.blit(bs, (x, y))
                    rr = rs.get_rect()
                    off = (5 if d in ("up", "down") else 4) * scale
                    rr.midbottom = (x + bs.get_width() // 2, y + bs.get_height() // 2 + off)
                    surface.blit(rs, rr)

                draw_text(surface, self.app.font_s, d, (x0 + di * cell + cell // 2, y0 + 2 * cell - 10), pygame.Color(200, 200, 210), anchor="center")

        draw_text(surface, self.app.font_s, "Tab/←/→ 翻页 | F2/Esc 关闭", (panel.centerx, panel.bottom - 8), pygame.Color(160, 160, 175), anchor="center")

    def _draw_rv_interior_ui(self, surface: pygame.Surface) -> None:
        # Removed: full-screen RV interior UI.
        return
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)     
        overlay.fill((0, 0, 0, 190))
        surface.blit(overlay, (0, 0))

        panel = pygame.Rect(16, 14, INTERNAL_W - 32, INTERNAL_H - 28)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (90, 90, 110), panel, 2, border_radius=12)

        label = "房车" if str(getattr(self.rv, "model_id", "rv")) == "rv" else "汽车"
        draw_text(surface, self.app.font_m, f"{label}内部", (panel.centerx, panel.top + 14), pygame.Color(240, 240, 240), anchor="center")

        # Floor plan (tile map).
        tile_px = 14
        map_w = int(self._RV_INT_W) * tile_px
        map_h = int(self._RV_INT_H) * tile_px
        map_x = int(panel.centerx - map_w // 2)
        map_y = int(panel.top + 28)
        map_rect = pygame.Rect(map_x, map_y, map_w, map_h)
        pygame.draw.rect(surface, (24, 24, 30), map_rect.inflate(8, 8), border_radius=10)
        pygame.draw.rect(surface, (60, 60, 76), map_rect.inflate(8, 8), 2, border_radius=10)

        layout = self._vehicle_int_layout()
        for y, row in enumerate(layout):
            for x, ch in enumerate(row[: int(self._RV_INT_W)]):
                tid = int(self._RV_INT_LEGEND.get(ch, int(self.T_FLOOR)))
                tdef = self._TILES.get(tid)
                col = tdef.color if tdef is not None else (255, 0, 255)
                if tid == int(self.T_FLOOR):
                    col = (62, 60, 56)
                elif tid == int(self.T_WALL):
                    col = (22, 22, 26)
                r = pygame.Rect(map_x + x * tile_px, map_y + y * tile_px, tile_px, tile_px)
                pygame.draw.rect(surface, col, r)
                pygame.draw.rect(surface, (10, 10, 14), r, 1)
                # Tiny glyph for special tiles.
                if ch == "D":
                    pygame.draw.line(surface, (240, 220, 140), (r.left + 3, r.centery), (r.right - 3, r.centery), 2)
                elif ch == "B":
                    pygame.draw.rect(surface, (240, 240, 240), pygame.Rect(r.left + 3, r.top + 3, r.w - 6, 3))
                elif ch == "S":
                    pygame.draw.rect(surface, (200, 200, 210), pygame.Rect(r.left + 3, r.top + 3, r.w - 6, r.h - 6), 1)
                elif ch == "T":
                    pygame.draw.rect(surface, (12, 12, 16), pygame.Rect(r.left + 3, r.top + 5, r.w - 6, r.h - 10))
                elif ch == "V":
                    g = pygame.Rect(r.left + 3, r.top + 4, r.w - 6, r.h - 8)
                    pygame.draw.rect(surface, (90, 140, 190), g, 1)
                    pygame.draw.line(surface, (180, 210, 240), (g.left + 1, g.top + 1), (g.right - 2, g.top + 1), 1)
                elif ch == "R":
                    pygame.draw.circle(surface, (34, 34, 42), (r.centerx, r.centery), 4, 1)
                    pygame.draw.circle(surface, (34, 34, 42), (r.centerx, r.centery), 1)

        focus = str(getattr(self, "rv_ui_focus", "map"))
        cx, cy = self.rv_ui_map
        if 0 <= int(cx) < int(self._RV_INT_W) and 0 <= int(cy) < int(self._RV_INT_H):
            cur_r = pygame.Rect(map_x + int(cx) * tile_px, map_y + int(cy) * tile_px, tile_px, tile_px)
            col = (240, 240, 240) if focus == "map" else (130, 130, 150)
            pygame.draw.rect(surface, col, cur_r, 2)

        # Inventories.
        slot = 22
        gap = 4

        pcols = max(1, int(self.inventory.cols))
        prows = int(math.ceil(len(self.inventory.slots) / pcols))
        pgrid_w = pcols * slot + (pcols - 1) * gap
        pgrid_h = prows * slot + (prows - 1) * gap

        scols = max(1, int(self.rv_storage.cols))
        srows = int(math.ceil(len(self.rv_storage.slots) / scols))
        sgrid_w = scols * slot + (scols - 1) * gap
        sgrid_h = srows * slot + (srows - 1) * gap

        inv_y = map_rect.bottom + 22
        left_x = panel.left + 14
        right_x = panel.right - 14 - sgrid_w

        draw_text(surface, self.app.font_s, "背包", (left_x, inv_y - 14), pygame.Color(200, 200, 210), anchor="topleft")
        draw_text(surface, self.app.font_s, "房车储物", (right_x, inv_y - 14), pygame.Color(200, 200, 210), anchor="topleft")

        def draw_inv(inv: HardcoreSurvivalState._Inventory, *, x0: int, y0: int, cols: int, sel_idx: int, focused: bool) -> None:
            for i, st in enumerate(inv.slots):
                cx = i % cols
                cy = i // cols
                r = pygame.Rect(x0 + cx * (slot + gap), y0 + cy * (slot + gap), slot, slot)
                selected = focused and i == int(sel_idx)
                bg = (44, 44, 52) if selected else (26, 26, 32)
                border = (220, 220, 240) if selected else (90, 90, 110)
                pygame.draw.rect(surface, bg, r, border_radius=6)
                pygame.draw.rect(surface, border, r, 2, border_radius=6)
                if st is None:
                    continue
                self._ensure_item_visuals(st.item_id)
                img: pygame.Surface | None = None
                spr = self._ITEM_SPRITES.get(st.item_id)
                if spr is not None:
                    img = spr
                    max_w = r.w - 4
                    max_h = r.h - 4
                    if img.get_width() > max_w or img.get_height() > max_h:
                        scale = min(max_w / max(1, img.get_width()), max_h / max(1, img.get_height()))
                        iw = max(1, int(round(img.get_width() * scale)))
                        ih = max(1, int(round(img.get_height() * scale)))
                        img = pygame.transform.scale(img, (iw, ih))
                else:
                    icon = self._ITEM_ICONS.get(st.item_id)
                    if icon is None:
                        idef = self._ITEMS.get(st.item_id)
                        col = idef.color if idef is not None else (255, 0, 255)
                        icon_rect = pygame.Rect(0, 0, 10, 10)
                        icon_rect.center = r.center
                        pygame.draw.rect(surface, col, icon_rect)
                    else:
                        img = icon
                        if img.get_width() <= 8:
                            img = pygame.transform.scale(img, (img.get_width() * 2, img.get_height() * 2))
                if img is not None:
                    surface.blit(img, img.get_rect(center=r.center))
                draw_text(surface, self.app.font_s, str(int(st.qty)), (r.right - 2, r.bottom - 2), pygame.Color(240, 240, 240), anchor="topright")

        draw_inv(self.inventory, x0=left_x, y0=inv_y, cols=pcols, sel_idx=int(self.rv_ui_player_index), focused=(focus == "player"))
        draw_inv(self.rv_storage, x0=right_x, y0=inv_y, cols=scols, sel_idx=int(self.rv_ui_storage_index), focused=(focus == "storage"))

        # Description / help.
        desc = ""
        if focus == "map":
            ch = self._rv_ui_char_at(int(cx), int(cy))
            if ch == "D":
                desc = "门：Enter 离开"
            elif ch == "B":
                desc = "床：Enter 休息（体力恢复/心态提升）"
            elif ch == "S":
                desc = "储物柜：Enter 打开（转移物品）"
            elif ch == "T":
                desc = "工作台：占位（后续做加工/修理）"
            elif ch == "C":
                desc = "驾驶舱：占位"
            else:
                desc = "走动区域"
        elif focus == "player":
            st = self.inventory.slots[int(self.rv_ui_player_index)]
            if st is None:
                desc = "背包：空"
            else:
                idef = self._ITEMS.get(st.item_id)
                name = idef.name if idef is not None else st.item_id
                desc = f"背包：{name} x{int(st.qty)}（Enter 转移到储物）"
        else:
            st = self.rv_storage.slots[int(self.rv_ui_storage_index)]
            if st is None:
                desc = "储物：空"
            else:
                idef = self._ITEMS.get(st.item_id)
                name = idef.name if idef is not None else st.item_id
                desc = f"储物：{name} x{int(st.qty)}（Enter 转移到背包）"

        if self.rv_ui_status:
            draw_text(surface, self.app.font_s, self.rv_ui_status, (panel.centerx, panel.bottom - 24), pygame.Color(255, 220, 140), anchor="center")
        draw_text(surface, self.app.font_s, desc, (panel.centerx, panel.bottom - 12), pygame.Color(200, 200, 210), anchor="center")
        draw_text(surface, self.app.font_s, "Tab切换区域 | Enter互动/转移 | Esc关闭", (panel.centerx, panel.bottom - 2), pygame.Color(160, 160, 175), anchor="center")

    def _draw_home_storage_ui(self, surface: pygame.Surface) -> None:
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 190))
        surface.blit(overlay, (0, 0))

        panel = pygame.Rect(16, 14, INTERNAL_W - 32, INTERNAL_H - 28)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (90, 90, 110), panel, 2, border_radius=12)

        storage = self._home_ui_storage_inv()
        storage_label = self._home_ui_storage_label()
        draw_text(surface, self.app.font_m, self._home_ui_storage_title(), (panel.centerx, panel.top + 14), pygame.Color(240, 240, 240), anchor="center")

        focus = str(getattr(self, "home_ui_focus", "storage"))
        slot = 22
        gap = 4

        pcols = max(1, int(self.inventory.cols))
        prows = int(math.ceil(len(self.inventory.slots) / pcols))
        pgrid_w = pcols * slot + (pcols - 1) * gap
        pgrid_h = prows * slot + (prows - 1) * gap

        scols = max(1, int(storage.cols))
        srows = int(math.ceil(len(storage.slots) / scols))
        sgrid_w = scols * slot + (scols - 1) * gap
        sgrid_h = srows * slot + (srows - 1) * gap

        inv_y = panel.top + 46
        left_x = panel.left + 14
        right_x = panel.right - 14 - sgrid_w

        content_h = max(pgrid_h, sgrid_h) + 20
        inv_y = int(clamp(inv_y, panel.top + 42, panel.bottom - 52 - content_h))

        draw_text(surface, self.app.font_s, "背包", (left_x, inv_y - 14), pygame.Color(200, 200, 210), anchor="topleft")
        draw_text(surface, self.app.font_s, storage_label, (right_x, inv_y - 14), pygame.Color(200, 200, 210), anchor="topleft")

        def draw_inv(
            inv: HardcoreSurvivalState._Inventory,
            *,
            x0: int,
            y0: int,
            cols: int,
            sel_idx: int,
            focused: bool,
        ) -> None:
            for i, st in enumerate(inv.slots):
                cx = i % cols
                cy = i // cols
                r = pygame.Rect(x0 + cx * (slot + gap), y0 + cy * (slot + gap), slot, slot)
                selected = focused and i == int(sel_idx)
                bg = (44, 44, 52) if selected else (26, 26, 32)
                border = (220, 220, 240) if selected else (90, 90, 110)
                pygame.draw.rect(surface, bg, r, border_radius=6)
                pygame.draw.rect(surface, border, r, 2, border_radius=6)
                if st is None:
                    continue
                self._ensure_item_visuals(st.item_id)
                img: pygame.Surface | None = None
                spr = self._ITEM_SPRITES.get(st.item_id)
                if spr is not None:
                    img = spr
                    max_w = r.w - 4
                    max_h = r.h - 4
                    if img.get_width() > max_w or img.get_height() > max_h:
                        scale = min(max_w / max(1, img.get_width()), max_h / max(1, img.get_height()))
                        iw = max(1, int(round(img.get_width() * scale)))
                        ih = max(1, int(round(img.get_height() * scale)))
                        img = pygame.transform.scale(img, (iw, ih))
                else:
                    icon = self._ITEM_ICONS.get(st.item_id)
                    if icon is None:
                        idef = self._ITEMS.get(st.item_id)
                        col = idef.color if idef is not None else (255, 0, 255)
                        icon_rect = pygame.Rect(0, 0, 10, 10)
                        icon_rect.center = r.center
                        pygame.draw.rect(surface, col, icon_rect)
                    else:
                        img = icon
                        if img.get_width() <= 8:
                            img = pygame.transform.scale(img, (img.get_width() * 2, img.get_height() * 2))
                if img is not None:
                    surface.blit(img, img.get_rect(center=r.center))
                draw_text(surface, self.app.font_s, str(int(st.qty)), (r.right - 2, r.bottom - 2), pygame.Color(240, 240, 240), anchor="topright")

        draw_inv(
            self.inventory,
            x0=left_x,
            y0=inv_y,
            cols=pcols,
            sel_idx=int(getattr(self, "home_ui_player_index", 0)),
            focused=(focus == "player"),
        )
        draw_inv(
            storage,
            x0=right_x,
            y0=inv_y,
            cols=scols,
            sel_idx=int(getattr(self, "home_ui_storage_index", 0)),
            focused=(focus == "storage"),
        )

        desc = ""
        if focus == "player":
            st = self.inventory.slots[int(getattr(self, "home_ui_player_index", 0))]
            if st is None:
                desc = "背包：空"
            else:
                idef = self._ITEMS.get(st.item_id)
                name = idef.name if idef is not None else st.item_id
                desc = f"背包: {name} x{int(st.qty)} (Enter → {storage_label})"
        else:
            st = storage.slots[int(getattr(self, "home_ui_storage_index", 0))]
            if st is None:
                desc = f"{storage_label}：空"
            else:
                idef = self._ITEMS.get(st.item_id)
                name = idef.name if idef is not None else st.item_id
                desc = f"{storage_label}: {name} x{int(st.qty)} (Enter → 背包)"

        if getattr(self, "home_ui_status", ""):
            draw_text(surface, self.app.font_s, str(self.home_ui_status), (panel.centerx, panel.bottom - 24), pygame.Color(255, 220, 140), anchor="center")
        draw_text(surface, self.app.font_s, desc, (panel.centerx, panel.bottom - 12), pygame.Color(200, 200, 210), anchor="center")
        draw_text(surface, self.app.font_s, f"Tab 切换 背包/{storage_label} | Enter 转移 | Esc 关闭", (panel.centerx, panel.bottom - 2), pygame.Color(160, 160, 175), anchor="center")

    def draw(self, surface: pygame.Surface) -> None:
        surface.fill((0, 0, 0))
        # Updated by player draw routines; used for speech-bubble dialogs.
        self._last_player_screen_rect = None
        if getattr(self, "house_interior", False):
            self._hover_tooltip = None
            self._draw_house_interior_scene(surface)
            self._draw_day_night_overlay(surface, in_rv=True)
            self._draw_survival_ui(surface)
            if getattr(self, "world_map_open", False):
                self._draw_world_map_ui(surface)
                return
            self._draw_hover_tooltip(surface)
            if self.inv_open:
                self._draw_inventory_ui(surface)
            if getattr(self, "_gallery_open", False):
                self._draw_sprite_gallery_ui(surface)
            self._draw_speech_bubble(surface)
            self._draw_dialog(surface)
            return
        if getattr(self, "sch_interior", False):
            self._hover_tooltip = None
            self._draw_sch_interior_scene(surface)
            self._draw_day_night_overlay(surface, in_rv=True)
            self._draw_survival_ui(surface)
            if getattr(self, "world_map_open", False):
                self._draw_world_map_ui(surface)
                return
            self._draw_hover_tooltip(surface)
            if getattr(self, "sch_elevator_ui_open", False):
                self._draw_sch_elevator_ui(surface)
            elif self.inv_open:
                self._draw_inventory_ui(surface)
            if getattr(self, "_gallery_open", False):
                self._draw_sprite_gallery_ui(surface)
            self._draw_speech_bubble(surface)
            self._draw_dialog(surface)
            return
        if getattr(self, "hr_interior", False):
            self._hover_tooltip = None
            self._draw_hr_interior_scene(surface)
            self._draw_day_night_overlay(surface, in_rv=True)
            self._draw_survival_ui(surface)
            if getattr(self, "world_map_open", False):
                self._draw_world_map_ui(surface)
                return
            if getattr(self, "home_ui_open", False):
                self._draw_home_storage_ui(surface)
                return
            self._draw_hover_tooltip(surface)
            if bool(getattr(self, "hr_travel_active", False)):
                self._draw_hr_travel_ui(surface)
                return
            if getattr(self, "hr_elevator_ui_open", False):
                self._draw_hr_elevator_ui(surface)
            elif self.inv_open:
                self._draw_inventory_ui(surface)
            if getattr(self, "_gallery_open", False):
                self._draw_sprite_gallery_ui(surface)
            self._draw_speech_bubble(surface)
            self._draw_dialog(surface)
            return
        cam_x = int(getattr(self, "cam_x", 0))
        cam_y = int(getattr(self, "cam_y", 0))

        # Hover tooltip is populated during world draws (items / vehicles).
        self._hover_tooltip = None

        # High-rise 1F draw mask: used by _draw_world_tile to hide the
        # non-floor "back" filler area while inside.
        prev_inside_key = getattr(self, "_inside_building_key", None)
        self._inside_highrise_draw_mask = None
        self._inside_highrise_floor_overlay = None
        self._inside_highrise_facade_slice = None
        self._inside_building_key = None
        self._inside_building_visible = None
        self._draw_player_tile_xy = None
        try:
            ptx = int(math.floor(self.player.pos.x / self.TILE_SIZE))
            pty = int(math.floor(self.player.pos.y / self.TILE_SIZE))
            self._draw_player_tile_xy = (int(ptx), int(pty))
            p_tile = int(self.world.peek_tile(int(ptx), int(pty)))
            can_be_inside = p_tile in (
                int(self.T_FLOOR),
                int(self.T_DOOR),
                int(self.T_DOOR_HOME),
                int(self.T_DOOR_LOCKED),
                int(self.T_DOOR_HOME_LOCKED),
                int(self.T_DOOR_BROKEN),
                int(self.T_ELEVATOR),
                int(self.T_STAIRS_UP),
                int(self.T_STAIRS_DOWN),
                int(self.T_TABLE),
                int(self.T_SHELF),
                int(self.T_BED),
                int(self.T_SOFA),
                int(self.T_FRIDGE),
                int(self.T_TV),
                int(self.T_CHAIR),
                int(self.T_PC),
                int(self.T_LAMP),
                int(self.T_SWITCH),
            )
            if can_be_inside:
                pchunk = self.world.peek_chunk(int(ptx) // int(self.CHUNK_SIZE), int(pty) // int(self.CHUNK_SIZE))
                if pchunk is None:
                    pchunk = self.world.get_chunk(int(ptx) // int(self.CHUNK_SIZE), int(pty) // int(self.CHUNK_SIZE))
                if pchunk is not None:
                    hit = self._peek_building_at_tile(int(ptx), int(pty))
                    if hit is None:
                        self._inside_building_key = None
                    else:
                        tx0, ty0, w, h, roof_kind, floors = hit
                        self._inside_building_key = (int(tx0), int(ty0), int(w), int(h))

                        style, var = self._building_roof_style_var(int(roof_kind))
                        if int(style) == 6:
                            max_floors = int(max(2, int(getattr(self, "HIGHRISE_MAX_FLOORS", 10))))
                            if int(floors) <= 0:
                                floors = int(max_floors)
                            floors = int(min(int(floors), int(max_floors)))
                            cut_px = int(self._roof_cut_px(style=int(style), w=int(w), h=int(h), var=int(var), floors=int(floors)))
                            ts = int(max(1, int(self.TILE_SIZE)))
                            cut_tiles = int(cut_px) // ts
                            core_h = int(max(2, int(h) - 2 - int(cut_tiles)))
                            min_core_h = int(max(6, int(getattr(self, "HIGHRISE_MIN_FLOOR_TILES", 9))))
                            core_h = int(min(int(max(int(core_h), int(min_core_h))), int(max(2, int(h) - 2))))
                            top_cut = int(max(0, (int(h) - 2) - int(core_h)))
                            floor_y0 = int(ty0 + 1 + int(top_cut))
                            self._inside_highrise_draw_mask = (int(tx0), int(ty0), int(w), int(h), int(floor_y0))

                            # High-rise upper floors: draw the interior as an
                            # elevated layer so the floor aligns to the facade
                            # band of the current floor.
                            floor_slice_h = int(
                                clamp(
                                    int(round(float(getattr(self.player, "body_h", getattr(self.player, "h", 12))) * 1.5)),
                                    14,
                                    26,
                                )
                            )
                            cur_floor = 1
                            floors_total = int(max(1, int(min(int(floors), int(max_floors)))))

                            # multi_house records live on the origin chunk; scan around it.
                            origin_cx = int(tx0) // int(self.CHUNK_SIZE)
                            origin_cy = int(ty0) // int(self.CHUNK_SIZE)
                            mh_found = False
                            for oy in (-1, 0, 1):
                                for ox in (-1, 0, 1):
                                    c2 = self.world.peek_chunk(int(origin_cx + ox), int(origin_cy + oy))
                                    if c2 is None:
                                        continue
                                    for mh in getattr(c2, "multi_houses", []):
                                        if (
                                            int(getattr(mh, "tx0", -999999)) == int(tx0)
                                            and int(getattr(mh, "ty0", -999999)) == int(ty0)
                                            and int(getattr(mh, "w", -1)) == int(w)
                                            and int(getattr(mh, "h", -1)) == int(h)
                                        ):
                                            cur_floor = int(max(1, int(getattr(mh, "cur_floor", 1))))
                                            floors_total = int(
                                                max(1, int(min(int(getattr(mh, "floors", floors_total)), int(max_floors))))
                                            )
                                            mh_found = True
                                            break
                                    if mh_found:
                                        break
                                if mh_found:
                                    break

                            cur_floor = int(clamp(int(cur_floor), 1, int(floors_total)))
                            if int(floors_total) > 1:
                                self._inside_highrise_facade_slice = (
                                    int(tx0),
                                    int(ty0),
                                    int(w),
                                    int(h),
                                    int(cur_floor),
                                    int(floors_total),
                                )
                            if int(floors_total) > 1 and int(cur_floor) > 1:
                                offset = int(cur_floor - 1) * int(floor_slice_h)
                                offset_max = int(max(0, int(floors_total - 1) * int(floor_slice_h)))
                                if offset > offset_max:
                                    offset = int(offset_max)
                                self._inside_highrise_floor_overlay = (
                                    int(tx0),
                                    int(ty0),
                                    int(w),
                                    int(h),
                                    int(floor_y0),
                                    int(offset),
                                    int(floor_slice_h),
                                )

            # Stabilize inside-building detection across frames.
            # If we were inside a building last frame and we're still within its
            # footprint, keep that building as "inside" even if the current tile
            # classification briefly fails (prevents nearby buildings' facades
            # popping/disappearing when entering houses).
            try:
                if isinstance(prev_inside_key, tuple) and len(prev_inside_key) == 4:
                    bx0, by0, bw, bh = (
                        int(prev_inside_key[0]),
                        int(prev_inside_key[1]),
                        int(prev_inside_key[2]),
                        int(prev_inside_key[3]),
                    )
                    if int(bw) > 0 and int(bh) > 0 and int(bx0) <= int(ptx) < int(bx0) + int(bw) and int(by0) <= int(pty) < int(by0) + int(bh):
                        self._inside_building_key = (int(bx0), int(by0), int(bw), int(bh))
            except Exception:
                pass
        except Exception:
            self._inside_highrise_draw_mask = None
            self._inside_highrise_floor_overlay = None
            self._inside_highrise_facade_slice = None
            self._inside_building_key = None
            self._inside_building_visible = None
            self._draw_player_tile_xy = None

        # When inside a cutaway building, only reveal the connected area the
        # player can actually reach (prevents seeing neighbors through roofs).
        try:
            inside_key = getattr(self, "_inside_building_key", None)
            pt = getattr(self, "_draw_player_tile_xy", None)
            if isinstance(inside_key, tuple) and len(inside_key) == 4 and isinstance(pt, tuple) and len(pt) == 2:
                tx0, ty0, w, h = (int(inside_key[0]), int(inside_key[1]), int(inside_key[2]), int(inside_key[3]))
                ptx, pty = int(pt[0]), int(pt[1])
                if int(w) > 0 and int(h) > 0 and int(tx0) <= int(ptx) < int(tx0) + int(w) and int(ty0) <= int(pty) < int(ty0) + int(h):
                    # Reveal only the reachable connected component. This keeps
                    # other apartments hidden in high-rises unless you can enter them.
                    passable: set[tuple[int, int]] = set()
                    stack = [(int(ptx), int(pty))]
                    seen: set[tuple[int, int]] = set()
                    while stack and len(passable) < int(w) * int(h):
                        sx, sy = stack.pop()
                        sx = int(sx)
                        sy = int(sy)
                        if (sx, sy) in seen:
                            continue
                        seen.add((sx, sy))
                        if not (int(tx0) <= int(sx) < int(tx0) + int(w) and int(ty0) <= int(sy) < int(ty0) + int(h)):
                            continue
                        tid = int(self.world.peek_tile(int(sx), int(sy)))
                        if bool(self._tile_solid(int(tid))):
                            continue
                        passable.add((sx, sy))
                        stack.extend([(sx + 1, sy), (sx - 1, sy), (sx, sy + 1), (sx, sy - 1)])

                    visible: set[tuple[int, int]] = set(passable)
                    # Include adjacent furniture/doors so rooms look complete.
                    for sx, sy in tuple(passable):
                        for ox, oy in ((0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)):
                            nx, ny = int(sx + ox), int(sy + oy)
                            if not (int(tx0) <= int(nx) < int(tx0) + int(w) and int(ty0) <= int(ny) < int(ty0) + int(h)):
                                continue
                            visible.add((nx, ny))

                    self._inside_building_visible = visible
        except Exception:
            self._inside_building_visible = None

        # High-rise upper floors: shift the camera up slightly so the elevated
        # interior/player doesn't leave the screen on very high floors.
        overlay_tmp = getattr(self, "_inside_highrise_floor_overlay", None)
        cam_y_draw = int(cam_y)
        if overlay_tmp is not None:
            try:
                offset_px = int(overlay_tmp[5])
                if offset_px > 0:
                    target_y = int(INTERNAL_H // 3)
                    lift = int(max(0, int(offset_px) - int((INTERNAL_H // 2) - int(target_y))))
                    cam_y_draw = int(cam_y_draw - int(lift))
            except Exception:
                cam_y_draw = int(cam_y)
        self._last_cam_draw = (int(cam_x), int(cam_y_draw))

        start_tx = int(math.floor(cam_x / self.TILE_SIZE)) - 1
        start_ty = int(math.floor(cam_y_draw / self.TILE_SIZE)) - 1
        end_tx = int(math.floor((cam_x + INTERNAL_W) / self.TILE_SIZE)) + 1
        end_ty = int(math.floor((cam_y_draw + INTERNAL_H) / self.TILE_SIZE)) + 1

        for ty in range(start_ty, end_ty + 1):
            py = ty * self.TILE_SIZE - cam_y_draw
            if py >= INTERNAL_H:
                break
            for tx in range(start_tx, end_tx + 1):
                px = tx * self.TILE_SIZE - cam_x
                if px >= INTERNAL_W:
                    break
                tile = self.world.peek_tile(tx, ty)
                rect = pygame.Rect(int(px), int(py), self.TILE_SIZE, self.TILE_SIZE)
                self._draw_world_tile(surface, rect, tx=tx, ty=ty, tile_id=int(tile))

        # Include a small off-screen margin so facade extrusions (face_h) don't pop at screen edges.
        self._draw_building_facades(surface, cam_x, cam_y_draw, start_tx - 3, end_tx + 3, start_ty - 3, end_ty + 3)
        self._draw_vehicle_props(surface, cam_x, cam_y_draw, start_tx, end_tx, start_ty, end_ty)
        self._draw_world_props(surface, cam_x, cam_y_draw, start_tx, end_tx, start_ty, end_ty)
        self._draw_world_items(surface, cam_x, cam_y_draw, start_tx, end_tx, start_ty, end_ty)
        # Corpses are "on the ground": draw them under vehicles so they don't appear on top of the RV.
        self._draw_zombies(surface, cam_x, cam_y_draw, corpses=True, alive=False)
        self._draw_rv(surface, cam_x, cam_y_draw)
        self._draw_bike(surface, cam_x, cam_y_draw)
        self._draw_zombies(surface, cam_x, cam_y_draw, corpses=False, alive=True)
        self._draw_bullets(surface, cam_x, cam_y_draw)
        self._draw_thrown_furniture(surface, cam_x, cam_y_draw)
        overlay = getattr(self, "_inside_highrise_floor_overlay", None)
        if self.mount is None and overlay is None:
            self._draw_player(surface, cam_x, cam_y_draw)
        self._draw_hit_fx(surface, cam_x, cam_y_draw)
        # Occlude the player/mount by front facades when behind buildings.
        # NOTE: On high-rise upper floors the player is drawn with an extra
        # vertical offset; we run the occlusion pass after the offset draw.
        if overlay is None or self.mount is not None:
            self._occlude_mounted_vehicle_with_facades(
                surface,
                cam_x,
                cam_y_draw,
                start_tx - 3,
                end_tx + 3,
                start_ty - 3,
                end_ty + 3,
            )
        if overlay is not None:
            try:
                tx0, ty0, w, h, floor_y0, offset_px, floor_h = overlay  
                tx0 = int(tx0)
                ty0 = int(ty0)
                w = int(w)
                h = int(h)
                floor_y0 = int(floor_y0)
                offset_px = int(offset_px)
                floor_h = int(floor_h)
                if w > 0 and h > 0 and offset_px > 0:
                    ts = int(self.TILE_SIZE)

                    # Elevated interior tile layer.
                    start_y = int(max(int(ty0), int(floor_y0) - 1))
                    end_y = int(ty0 + h)
                    end_x = int(tx0 + w)
                    for ty in range(start_y, end_y):
                        py = int(ty) * int(ts) - int(cam_y_draw) - int(offset_px)
                        if py >= INTERNAL_H:
                            continue
                        if py + ts < 0:
                            continue
                        for tx in range(int(tx0), int(end_x)):
                            px = int(tx) * int(ts) - int(cam_x)
                            if px >= INTERNAL_W:
                                continue
                            if px + ts < 0:
                                continue
                            tile = self.world.peek_tile(int(tx), int(ty))
                            rect = pygame.Rect(int(px), int(py), int(ts), int(ts))
                            self._draw_world_tile(surface, rect, tx=int(tx), ty=int(ty), tile_id=int(tile), apply_mask=False)

                    if self.mount is None:
                        self._draw_player(surface, int(cam_x), int(cam_y_draw) + int(offset_px))
                        # Occlude the elevated player with the current-floor facade band.
                        try:
                            bx = int(tx0) * int(ts) - int(cam_x)
                            by = int(ty0) * int(ts) - int(cam_y_draw)
                            ground_y = int(by + int(h) * int(ts))
                            south_h = int(max(1, int(floor_h)))
                            south_y = int(ground_y - int(offset_px) - int(south_h))
                            clip = pygame.Rect(int(bx - 3), int(south_y - 3), int(w) * int(ts) + 6, int(south_h) + 6)
                            prev_clip = surface.get_clip()
                            surface.set_clip(clip)
                            try:
                                self._draw_building_facades(
                                    surface,
                                    int(cam_x),
                                    int(cam_y_draw),
                                    int(tx0) - 3,
                                    int(tx0) + int(w) + 3,
                                    int(ty0) - 3,
                                    int(ty0) + int(h) + 3,
                                )
                            finally:
                                surface.set_clip(prev_clip)
                        except Exception:
                            pass
                        self._occlude_mounted_vehicle_with_facades(
                            surface,
                            int(cam_x),
                            int(cam_y_draw),
                            int(start_tx - 3),
                            int(end_tx + 3),
                            int(start_ty - 3),
                            int(end_ty + 3),
                            entity_cam_y=int(cam_y_draw) + int(offset_px),
                        )
            except Exception:
                pass
        self._draw_roofs(surface, cam_x, cam_y_draw, start_tx, end_tx, start_ty, end_ty)
        self._draw_world_lighting(surface, cam_x, cam_y_draw, start_tx, end_tx, start_ty, end_ty)
        self._draw_weather_effects(surface, in_rv=False)
        self._draw_home_move_mode_overlay(surface, cam_x, cam_y_draw)
        self._draw_survival_ui(surface)
        if getattr(self, "world_map_open", False):
            self._draw_world_map_ui(surface)
            return
        if getattr(self, "world_elevator_ui_open", False):
            self._draw_world_elevator_ui(surface)
            return
        if getattr(self, "home_ui_open", False):
            self._draw_home_storage_ui(surface)
            return

        self._draw_world_furniture_carry_preview(surface, cam_x, cam_y_draw)
        self._draw_world_context_menu(surface, cam_x, cam_y_draw)
        self._draw_lamp_cfg_ui(surface, cam_x, cam_y_draw)
        self._draw_toilet_task_ui(surface)
        self._draw_hover_tooltip(surface)
        self._draw_speech_bubble(surface)
        self._draw_dialog(surface)

        if self._debug:
            self._draw_debug(surface, cam_x, cam_y_draw)
        if self.inv_open:
            self._draw_inventory_ui(surface)
        if getattr(self, "_gallery_open", False):
            self._draw_sprite_gallery_ui(surface)

        self._draw_pause_menu(surface)

    def _occlude_mounted_vehicle_with_facades(
        self,
        surface: pygame.Surface,
        cam_x: int,
        cam_y: int,
        start_tx: int,
        end_tx: int,
        start_ty: int,
        end_ty: int,
        *,
        entity_cam_y: int | None = None,
    ) -> None:
        entity_cam_y_i = int(cam_y) if entity_cam_y is None else int(entity_cam_y)
        skip_building: tuple[int, int, int, int] | None = None
        if entity_cam_y is not None:
            overlay = getattr(self, "_inside_highrise_floor_overlay", None)
            if overlay is not None:
                try:
                    tx0, ty0, w, h = overlay[:4]
                    skip_building = (int(tx0), int(ty0), int(w), int(h))
                except Exception:
                    skip_building = None
        mount = getattr(self, "mount", None)
        if mount is None:
            if not hasattr(self, "player") or self.player is None:
                return
            rect = self.player.rect_at(self.player.pos).move(-int(cam_x), -int(entity_cam_y_i)).inflate(18, 18)
            ground_y = int(round((float(self.player.pos.y) - float(entity_cam_y_i)) + float(self.player.h) / 2.0))
        elif mount == "bike":
            if not hasattr(self, "bike") or self.bike is None:
                return
            w = int(getattr(self.bike, "w", 14))
            h = int(getattr(self.bike, "h", 10))
            rect = self.bike.rect().move(-int(cam_x), -int(entity_cam_y_i)).inflate(36, 46)
            ground_y = int(round((float(self.bike.pos.y) - float(entity_cam_y_i)) + float(h) / 2.0))
        elif mount == "rv":
            if not hasattr(self, "rv") or self.rv is None:
                return
            rect = self.rv.rect().move(-int(cam_x), -int(entity_cam_y_i)).inflate(72, 62)
            ground_y = int(round((float(self.rv.pos.y) - float(entity_cam_y_i)) + float(self.rv.h) / 2.0))
        else:
            return

        clip = rect.clip(pygame.Rect(0, 0, INTERNAL_W, INTERNAL_H))
        if clip.w <= 0 or clip.h <= 0:
            return
        prev_clip = surface.get_clip()
        surface.set_clip(clip)
        try:
            self._draw_building_facades(
                surface,
                int(cam_x),
                int(cam_y),
                int(start_tx),
                int(end_tx),
                int(start_ty),
                int(end_ty),
                min_ground_y=int(ground_y) + 1,
                skip_building=skip_building,
            )
        finally:
            surface.set_clip(prev_clip)

    def _draw_player_held_item(
        self,
        surface: pygame.Surface,
        player_rect: pygame.Rect,
        *,
        direction: str,
        step: int,
        idle: bool,
        run: bool,
        height_delta: int,
    ) -> None:
        if self.gun is not None:
            return
        if getattr(self, "mount", None) is not None:
            return

        held = getattr(self, "held_item", None)
        item_id = ""
        is_melee = False
        if isinstance(held, HardcoreSurvivalState._ItemStack) and int(getattr(held, "qty", 0)) > 0:
            item_id = str(getattr(held, "item_id", ""))
        else:
            mid = str(getattr(self, "melee_weapon_id", "") or "")
            if mid:
                idef = self._ITEMS.get(mid)
                if idef is not None and str(getattr(idef, "kind", "")) == "melee":
                    item_id = str(mid)
                    is_melee = True
        if not item_id:
            return

        self._ensure_item_visuals(item_id)
        spr = self._ITEM_SPRITES_WORLD.get(item_id) or self._ITEM_SPRITES.get(item_id)
        if spr is None:
            return

        img = spr
        # Flip some tools/weapons so the "held" side matches the player's hand.
        flipped = False
        if (item_id in ("cup", "cup_water") or bool(is_melee)) and str(direction) == "left":
            img = flip_x_pixel_sprite(img)
            flipped = True

        d = str(direction)
        nodes = HardcoreSurvivalState._survivor_skeleton_nodes(
            str(d),
            int(step),
            idle=bool(idle),
            height_delta=int(height_delta),
            run=bool(run),
        )
        hand = nodes.get("r_hand")
        r = img.get_rect()
        if isinstance(hand, tuple) and len(hand) == 2:
            hx = int(player_rect.left + int(hand[0]))
            hy = int(player_rect.top + int(hand[1]))
            hold: tuple[int, int] | None = None
            if item_id in ("cup", "cup_water"):
                # Anchor at the handle center so it actually sits in the hand.
                hold = (9, 7)
                if flipped:
                    hold = (int(img.get_width() - 1 - int(hold[0])), int(hold[1]))
            elif bool(is_melee):
                # Anchor near the grip end (our melee icons are diagonal).
                hold = (3, 9)
                if flipped:
                    hold = (int(img.get_width() - 1 - int(hold[0])), int(hold[1]))

            if hold is not None:
                r.topleft = (int(hx - int(hold[0])), int(hy - int(hold[1])))
            else:
                if d == "left":
                    r.midright = (int(hx), int(hy))
                elif d == "right":
                    r.midleft = (int(hx), int(hy))
                elif d == "up":
                    r.midbottom = (int(hx), int(hy))
                else:
                    r.midtop = (int(hx), int(hy))
        else:
            # Fallback: old offsets if skeleton nodes are unavailable.
            if d == "left":
                r.midright = (int(player_rect.left + 2), int(player_rect.centery + 4))
            elif d == "right":
                r.midleft = (int(player_rect.right - 2), int(player_rect.centery + 4))
            elif d == "up":
                r.midbottom = (int(player_rect.centerx), int(player_rect.top + 6))
            else:
                r.midtop = (int(player_rect.centerx), int(player_rect.bottom - 2))

        surface.blit(img, r)

    def _draw_player_back_carry(self, surface: pygame.Surface, player_rect: pygame.Rect, *, direction: str) -> None:
        if not bool(self._world_furniture_carry_active()):
            return
        carry = getattr(self, "home_move_carry", None)
        if not isinstance(carry, dict):
            return
        tid = int(carry.get("tid", 0))
        if tid <= 0:
            return
        tdef = self._TILES.get(int(tid))
        col = tuple(getattr(tdef, "color", (210, 200, 180))) if tdef is not None else (210, 200, 180)
        offsets = carry.get("offsets", [])
        n = int(len(offsets)) if isinstance(offsets, list) else 1
        w = int(clamp(8 + 2 * min(3, max(0, n - 1)), 8, 14))
        h = int(clamp(6 + 2 * min(3, max(0, n - 1)), 6, 14))
        r = pygame.Rect(0, 0, int(w), int(h))
        d = str(direction)
        if d == "down":
            r.midtop = (int(player_rect.centerx), int(player_rect.top + 1))
        elif d == "up":
            r.midbottom = (int(player_rect.centerx), int(player_rect.bottom - 10))
        elif d == "left":
            r.midright = (int(player_rect.left + 3), int(player_rect.centery))
        else:
            r.midleft = (int(player_rect.right - 3), int(player_rect.centery))
        pygame.draw.rect(surface, (10, 10, 12), r.inflate(2, 2))
        pygame.draw.rect(surface, col, r)
        pygame.draw.rect(surface, (0, 0, 0), r, 1)

    def _draw_player(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        p = self.player.pos - pygame.Vector2(cam_x, cam_y)
        px = iround(float(p.x))
        py = iround(float(p.y))

        pose = str(getattr(self, "player_pose", "")).strip()
        pose_space = str(getattr(self, "player_pose_space", "")).strip()
        pose_anchor = getattr(self, "player_pose_anchor", None)
        use_pose = bool(pose and pose_space == "world" and pose_anchor is not None)
        if use_pose:
            ap = pygame.Vector2(float(pose_anchor[0]) - float(cam_x), float(pose_anchor[1]) - float(cam_y))
            ax = iround(float(ap.x))
            ay = iround(float(ap.y))
            if pose == "sleep":
                frame = int(float(getattr(self, "player_pose_phase", 0.0)) * 2.0) % 2
                spr = self._get_pose_sprite("sleep", frame=frame)
                shadow = pygame.Rect(0, 0, 18, 7)
                shadow.center = (ax, ay + 4)
                sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
                pygame.draw.ellipse(sh, (0, 0, 0, 100), sh.get_rect())
                surface.blit(sh, shadow.topleft)
                rect = spr.get_rect(center=(ax, ay + 2))
                surface.blit(spr, rect)
                self._last_player_screen_rect = pygame.Rect(rect)
                return
            if pose == "sit":
                spr = self._get_pose_sprite("sit", direction=str(getattr(self.player, "dir", "down")), frame=0)
                shadow = pygame.Rect(0, 0, 16, 6)
                shadow.center = (ax, ay + 7)
                sh = pygame.Surface((shadow.w, shadow.h), pygame.SRCALPHA)
                pygame.draw.ellipse(sh, (0, 0, 0, 115), sh.get_rect())
                surface.blit(sh, shadow.topleft)
                rect = spr.get_rect(center=(ax, ay + 5))
                surface.blit(spr, rect)
                self._last_player_screen_rect = pygame.Rect(rect)
                return

        face = pygame.Vector2(self.player.facing)
        if self.gun is not None:
            face = pygame.Vector2(self.aim_dir)
        if face.length_squared() <= 0.001:
            face = pygame.Vector2(0, 1)
        punch_left = float(getattr(self, "punch_left", 0.0))
        if punch_left > 0.0:
            pd = pygame.Vector2(getattr(self, "punch_dir", face))
            if pd.length_squared() > 0.001:
                face = pd.normalize()

        prev_d = str(getattr(self.player, "dir", "down"))
        ax = abs(float(face.x))
        ay = abs(float(face.y))
        bias = 1.12
        if ax <= 1e-6 and ay <= 1e-6:
            d = prev_d
        elif prev_d in ("up", "down"):
            # Stick to vertical unless X is clearly dominant.
            if ax > ay * float(bias):
                d = "right" if float(face.x) >= 0.0 else "left"
            else:
                d = "down" if float(face.y) >= 0.0 else "up"
        elif prev_d in ("left", "right"):
            # Stick to horizontal unless Y is clearly dominant.
            if ay > ax * float(bias):
                d = "down" if float(face.y) >= 0.0 else "up"
            else:
                d = "right" if float(face.x) >= 0.0 else "left"
        else:
            # Fallback: choose the dominant axis.
            if ay >= ax:
                d = "down" if float(face.y) >= 0.0 else "up"
            else:
                d = "right" if float(face.x) >= 0.0 else "left"
        self.player.dir = d

        height_delta = 0
        av = getattr(self, "avatar", None)
        if av is not None:
            hidx = int(getattr(av, "height", 1))
            height_delta = 1 if hidx == 0 else -1 if hidx == 2 else 0

        pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
        pf_run = getattr(self, "player_frames_run", None)
        is_run = bool(getattr(self, "player_sprinting", False))
        pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
        frames = pf.get(d, pf["down"])
        moving = self.player.vel.length_squared() > 1.0
        walk_idx = 0
        idle_anim = True
        if not moving or len(frames) <= 1:
            spr = frames[0]
        else:
            idle_anim = False
            walk = frames[1:]
            phase = (float(self.player.walk_phase) % math.tau) / math.tau
            idx = int(phase * len(walk)) % len(walk)
            walk_idx = int(idx)
            spr = walk[idx]
        rect = spr.get_rect()
        rect.midbottom = (px, iround(float(p.y) + float(self.player.h) / 2.0))
        surface.blit(spr, rect)
        self._last_player_screen_rect = pygame.Rect(rect)
        self._draw_player_back_carry(surface, rect, direction=str(d))
        self._draw_player_held_item(
            surface,
            rect,
            direction=str(d),
            step=int(walk_idx),
            idle=bool(idle_anim),
            run=bool(is_run),
            height_delta=int(height_delta),
        )

        if self.gun is not None:
            aim = pygame.Vector2(self.aim_dir)
            if aim.length_squared() <= 0.001:
                aim = pygame.Vector2(1, 0)
            aim = aim.normalize()
            sk = self._survivor_skeleton_nodes(
                d,
                int(walk_idx),
                idle=bool(idle_anim),
                height_delta=int(height_delta),
                run=bool(is_run),
            )
            hand_node = sk.get("r_hand")
            if hand_node is not None:
                hx, hy = hand_node
                base_hand = pygame.Vector2(int(rect.left + hx), int(rect.top + hy))
            else:
                base_hand = pygame.Vector2(rect.centerx, rect.centery + 3)
            hand = base_hand + aim * 4.0
            base = self._GUN_HAND_SPRITES.get(self.gun.gun_id)
            if base is not None:
                flip = float(aim.x) < 0.0
                if flip:
                    base = flip_x_pixel_sprite(base)
                deg = -math.degrees(math.atan2(float(aim.y), float(aim.x)))
                if flip:
                    deg -= 180.0
                if float(self.gun.reload_left) > 0.0 and float(self.gun.reload_total) > 0.0:
                    p = 1.0 - float(self.gun.reload_left) / max(1e-6, float(self.gun.reload_total))
                    deg += float(p) * 360.0
                gun_spr = rotate_pixel_sprite_crisp(base, deg, step_deg=5.0) 
                grect = gun_spr.get_rect(center=(int(round(hand.x)), int(round(hand.y))))
                surface.blit(gun_spr, grect)
            else:
                tip = hand + aim * 12.0
                col = (240, 240, 240) if self.gun.reload_left <= 0.0 else (200, 200, 220)
                pygame.draw.line(surface, col, (int(hand.x), int(hand.y)), (int(tip.x), int(tip.y)), 2)

            if getattr(self, "muzzle_flash_left", 0.0) > 0.0 and self.gun.reload_left <= 0.0:
                muzzle = hand + aim * 13.0
                r = 3 if self.muzzle_flash_left > 0.03 else 2
                pygame.draw.circle(surface, (255, 240, 190), (int(round(muzzle.x)), int(round(muzzle.y))), r)
                pygame.draw.circle(surface, (255, 200, 120), (int(round(muzzle.x)), int(round(muzzle.y))), max(1, r - 1))

        if punch_left > 0.0:
            total = float(self._PUNCH_TOTAL_S)
            t = 1.0 - float(punch_left) / max(1e-6, total)
            ext = math.sin(float(clamp(t, 0.0, 1.0)) * math.pi)
            # Keep the fist close to the body (match 12x16 sprite scale).
            reach = 1.0 + ext * 4.0

            pdir = pygame.Vector2(getattr(self, "punch_dir", pygame.Vector2(1, 0)))
            if pdir.length_squared() <= 0.001:
                pdir = pygame.Vector2(1, 0)
            pdir = pdir.normalize()

            height_delta = 0
            av = getattr(self, "avatar", None)
            if av is not None:
                hidx = int(getattr(av, "height", 1))
                height_delta = 1 if hidx == 0 else -1 if hidx == 2 else 0

            sk = self._survivor_skeleton_nodes(
                d,
                int(walk_idx),
                idle=bool(idle_anim),
                height_delta=int(height_delta),
                run=bool(is_run),
            )
            # Pick a sane punch anchor from the skeleton:
            # - left/right punches use the hand on that side
            # - up/down punches alternate left/right hand (feels more natural)
            lh = sk.get("l_hand")
            rh = sk.get("r_hand")
            base_hand: pygame.Vector2
            if lh is not None and rh is not None:
                lhx, lhy = int(lh[0]), int(lh[1])
                rhx, rhy = int(rh[0]), int(rh[1])
                left_pt = (lhx, lhy) if lhx <= rhx else (rhx, rhy)
                right_pt = (lhx, lhy) if lhx >= rhx else (rhx, rhy)
                if abs(float(pdir.x)) >= abs(float(pdir.y)) and float(pdir.x) != 0.0:
                    # Horizontal punch: choose the hand on the punch side.
                    if float(pdir.x) < 0.0:
                        hx, hy = left_pt
                    else:
                        hx, hy = right_pt
                    base_hand = pygame.Vector2(int(rect.left + hx), int(rect.top + hy))
                else:
                    # Vertical punch: alternate which hand "leads".
                    use_right = bool(getattr(self, "punch_hand", 0))
                    hx, hy = (right_pt if use_right else left_pt)
                    base_hand = pygame.Vector2(int(rect.left + hx), int(rect.top + hy))
            else:
                hand_key = "r_hand"
                hand_node = sk.get(hand_key)
                if hand_node is not None:
                    hx, hy = hand_node
                    base_hand = pygame.Vector2(int(rect.left + hx), int(rect.top + hy))
                else:
                    base_hand = pygame.Vector2(rect.centerx, rect.centery + 3)

            fist = base_hand + pdir * float(reach)
            outline = (10, 10, 12)
            skin = tuple(getattr(self, "_PLAYER_PAL", {}).get("S", (220, 190, 160)))

            fx = int(round(float(fist.x)))
            fy = int(round(float(fist.y)))
            # Arm connection: bridge pixels (cute, less "stick-arm" than lines).
            step_n = int(clamp(int(round(float(reach))), 0, 6))
            for s in range(1, int(step_n)):
                bx = int(round(float(base_hand.x) + float(pdir.x) * float(s)))
                by = int(round(float(base_hand.y) + float(pdir.y) * float(s)))
                if 0 <= bx < INTERNAL_W and 0 <= by < INTERNAL_H:
                    surface.set_at((bx, by), skin)
            fr = pygame.Rect(int(fx - 1), int(fy - 1), 3, 3)
            surface.fill(skin, fr)
            pygame.draw.rect(surface, outline, fr, 1)
            # If a melee weapon is equipped, draw a quick "stick" so the swing reads.
            try:
                swing_id = str(getattr(self, "_melee_swing_id", "fist"))
                mdef = self._MELEE_DEFS.get(swing_id)
                if mdef is not None and float(getattr(mdef, "visual_len", 0.0)) > 0.5:
                    idef = self._ITEMS.get(swing_id)
                    wcol = tuple(getattr(idef, "color", (200, 200, 210))) if idef is not None else (200, 200, 210)
                    thick = int(clamp(int(getattr(mdef, "visual_thick", 2)), 1, 4))
                    wlen = float(getattr(mdef, "visual_len", 10.0)) * max(0.25, float(ext))
                    a = base_hand + pdir * 1.0
                    b = base_hand + pdir * (1.0 + float(wlen))
                    ax2 = int(round(float(a.x)))
                    ay2 = int(round(float(a.y)))
                    bx2 = int(round(float(b.x)))
                    by2 = int(round(float(b.y)))
                    pygame.draw.line(surface, outline, (ax2, ay2), (bx2, by2), int(thick + 2))
                    pygame.draw.line(surface, wcol, (ax2, ay2), (bx2, by2), int(thick))
                    if 0 <= bx2 < INTERNAL_W and 0 <= by2 < INTERNAL_H:
                        surface.set_at((bx2, by2), (255, 220, 160))
            except Exception:
                pass
            # Tiny motion trail (doesn't add a long "stick arm").
            tx = int(clamp(fx - int(round(float(pdir.x))), 0, INTERNAL_W - 1))
            ty = int(clamp(fy - int(round(float(pdir.y))), 0, INTERNAL_H - 1))
            surface.set_at((tx, ty), outline)
            if ext > 0.6:
                hlx = int(clamp(fx + int(round(pdir.x)), 0, INTERNAL_W - 1))
                hly = int(clamp(fy + int(round(pdir.y)), 0, INTERNAL_H - 1))
                surface.set_at((hlx, hly), (255, 220, 160))

    def _draw_sun_moon_widget(self, surface: pygame.Surface, *, tday: float) -> None:
        rect = pygame.Rect(0, 0, 116, 22)
        rect.topright = (INTERNAL_W - 6, 34)
        pygame.draw.rect(surface, (18, 18, 22), rect, border_radius=8)
        pygame.draw.rect(surface, (70, 70, 86), rect, 2, border_radius=8)

        horizon_y = rect.bottom - 6
        pygame.draw.line(surface, (40, 40, 50), (rect.left + 6, horizon_y), (rect.right - 7, horizon_y), 1)

        amp = 9
        track_w = rect.w - 16
        sun_x = rect.left + 8 + int(round(float(track_w) * float(tday)))
        h_sun = float(math.sin((float(tday) - 0.25) * math.tau))
        sun_y = int(round(horizon_y - h_sun * float(amp)))

        moon_t = (float(tday) + 0.5) % 1.0
        moon_x = rect.left + 8 + int(round(float(track_w) * float(moon_t)))
        moon_y = int(round(horizon_y + h_sun * float(amp)))

        if h_sun > 0.0:
            pygame.draw.circle(surface, (240, 220, 140), (sun_x, sun_y), 4)
            pygame.draw.circle(surface, (0, 0, 0), (sun_x, sun_y), 4, 1)
            for dx, dy in ((-6, 0), (6, 0), (0, -6), (0, 6), (-4, -4), (4, -4), (-4, 4), (4, 4)):
                surface.set_at((int(clamp(sun_x + dx, rect.left + 2, rect.right - 3)), int(clamp(sun_y + dy, rect.top + 2, rect.bottom - 3))), (240, 220, 140))
        else:
            pygame.draw.circle(surface, (220, 220, 230), (moon_x, moon_y), 4)
            pygame.draw.circle(surface, (0, 0, 0), (moon_x, moon_y), 4, 1)
            cut_x = moon_x + 2
            cut_y = moon_y - 1
            pygame.draw.circle(surface, (18, 18, 22), (cut_x, cut_y), 4)

    def _draw_minimap(self, surface: pygame.Surface) -> pygame.Rect | None:
        if (
            bool(getattr(self, "hr_interior", False))
            or bool(getattr(self, "sch_interior", False))
            or bool(getattr(self, "house_interior", False))
        ):
            return None

        # Keep the minimap panel size similar (player-centric).
        radius = 15  # tiles
        scale = 3  # px per tile
        tiles = int(radius) * 2 + 1
        map_px = int(tiles) * int(scale)
        pad = 6
        label_h = 12

        panel = pygame.Rect(0, 0, map_px + pad * 2 + 2, map_px + pad * 2 + label_h + 2)
        panel.topright = (INTERNAL_W - 6, 60)
        pygame.draw.rect(surface, (18, 18, 22), panel, border_radius=12)
        pygame.draw.rect(surface, (70, 70, 86), panel, 2, border_radius=12)

        tx = int(math.floor(self.player.pos.x / self.TILE_SIZE))
        ty = int(math.floor(self.player.pos.y / self.TILE_SIZE))

        # Refresh POI cache periodically (used for edge indicators when POIs are off-screen).
        try:
            now = float(time.monotonic())
            last = float(getattr(self, "_poi_cache_t", 0.0))
            if (now - last) >= 0.70:
                cache = getattr(self, "_poi_cache", None)
                if not isinstance(cache, dict):
                    cache = {}
                    self._poi_cache = cache
                scanned = getattr(self, "_poi_scanned_chunks", None)
                if not isinstance(scanned, set):
                    scanned = set()
                    self._poi_scanned_chunks = scanned

                style_to_kind = {2: "market", 3: "hospital", 4: "prison", 5: "school", 7: "bookstore", 9: "gunshop"}
                for (ccx, ccy), chunk in getattr(self.world, "chunks", {}).items():
                    key = (int(ccx), int(ccy))
                    if key in scanned:
                        continue
                    scanned.add(key)
                    for b in getattr(chunk, "buildings", []):
                        if len(b) < 5:
                            continue
                        roof_kind = int(b[4])
                        style = int((roof_kind >> 8) & 0xFF)
                        kind = style_to_kind.get(int(style))
                        if kind is None:
                            continue
                        tx0, ty0, bw, bh = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                        c_tx = int(tx0 + max(1, int(bw)) // 2)
                        c_ty = int(ty0 + max(1, int(bh)) // 2)
                        cache.setdefault(str(kind), []).append((int(c_tx), int(c_ty)))

                self._poi_cache_t = float(now)
        except Exception:
            pass
        season = int(self._season_index())
        key = (int(tx), int(ty), int(radius), int(scale), int(season))

        cached_key = getattr(self, "_minimap_cache_key", None)
        cached_scaled: pygame.Surface | None = getattr(self, "_minimap_cache_scaled", None)
        size_ok = isinstance(cached_scaled, pygame.Surface) and cached_scaled.get_size() == (map_px, map_px)
        need_rebuild = (cached_key != key) or (not size_ok)
        if need_rebuild:
            moving = False
            if getattr(self, "mount", None) == "rv" and getattr(self, "rv", None) is not None:
                moving = self.rv.vel.length_squared() > 0.1
            elif getattr(self, "mount", None) == "bike" and getattr(self, "bike", None) is not None:
                moving = self.bike.vel.length_squared() > 0.1
            else:
                moving = self.player.vel.length_squared() > 0.1

            # Throttle minimap rebuilds while moving to avoid stutter.
            now = float(time.monotonic())
            last_t = float(getattr(self, "_minimap_cache_t", 0.0))
            min_interval = 0.12 if moving else 0.0
            if size_ok and min_interval > 0.0 and (now - last_t) < float(min_interval):
                pass
            else:
                base = pygame.Surface((tiles, tiles))
                base.lock()
                for oy in range(-int(radius), int(radius) + 1):
                    wy = int(ty) + int(oy)
                    py = int(oy) + int(radius)
                    for ox in range(-int(radius), int(radius) + 1):
                        wx = int(tx) + int(ox)
                        px = int(ox) + int(radius)
                        tid = self.world.peek_tile(wx, wy)
                        base.set_at((px, py), self._minimap_color(tid))
                base.unlock()
                cached_scaled = pygame.transform.scale(base, (map_px, map_px))
                self._minimap_cache_key = key
                self._minimap_cache_scaled = cached_scaled
                self._minimap_cache_t = float(now)

        draw_text(surface, self.app.font_s, "小地图", (panel.left + pad, panel.top + 3), pygame.Color(200, 200, 210), anchor="topleft")

        home = getattr(self, "home_highrise_door", None)
        if isinstance(home, tuple) and len(home) == 2:
            hx, hy = int(home[0]), int(home[1])
            dx = float(hx - int(tx))
            dy = float(hy - int(ty))
            dist = float(math.hypot(dx, dy))
            if dist < 1000.0:
                dist_text = f"家 {int(round(dist))}m"
            else:
                dist_text = f"家 {dist / 1000.0:.1f}km"
            draw_text(surface, self.app.font_s, dist_text, (panel.right - pad, panel.top + 3), pygame.Color(255, 220, 140), anchor="topright")

        map_x0 = panel.left + pad
        map_y0 = panel.top + pad + label_h
        if isinstance(cached_scaled, pygame.Surface):
            surface.blit(cached_scaled, (map_x0, map_y0))

        # POI icons (public buildings) inside the minimap view.
        # (Do not reveal interiors; we only show a symbol per building footprint.)
        start_tx = int(tx) - int(radius)
        start_ty = int(ty) - int(radius)
        end_tx = int(tx) + int(radius)
        end_ty = int(ty) + int(radius)
        start_cx = int(start_tx) // int(self.CHUNK_SIZE)
        end_cx = int(end_tx) // int(self.CHUNK_SIZE)
        start_cy = int(start_ty) // int(self.CHUNK_SIZE)
        end_cy = int(end_ty) // int(self.CHUNK_SIZE)
        style_to_kind = {2: "market", 3: "hospital", 4: "prison", 5: "school", 7: "bookstore", 9: "gunshop"}
        seen_gunshop = False
        seen_bookstore = False
        drawn_pois = 0
        for ccy in range(int(start_cy), int(end_cy) + 1):
            for ccx in range(int(start_cx), int(end_cx) + 1):
                # Cached minimap frames may skip rebuilding tile colors, so ensure nearby chunks exist.
                chunk = self.world.peek_chunk(int(ccx), int(ccy))
                if chunk is None:
                    chunk = self.world.get_chunk(int(ccx), int(ccy))
                for b in getattr(chunk, "buildings", []):
                    if len(b) < 5:
                        continue
                    btx0, bty0, bw, bh = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                    roof_kind = int(b[4])
                    style = int((roof_kind >> 8) & 0xFF)
                    kind = style_to_kind.get(int(style))
                    if kind is None:
                        continue
                    if kind == "gunshop":
                        seen_gunshop = True
                    elif kind == "bookstore":
                        seen_bookstore = True
                    x1 = int(btx0 + max(1, int(bw)) - 1)
                    y1 = int(bty0 + max(1, int(bh)) - 1)
                    if x1 < int(start_tx) or int(btx0) > int(end_tx) or y1 < int(start_ty) or int(bty0) > int(end_ty):
                        continue
                    # Place the icon at the nearest point of the building to the player
                    # so it shows up even if the building is only partially in view.
                    icon_tx = int(clamp(float(tx), float(btx0), float(x1)))
                    icon_ty = int(clamp(float(ty), float(bty0), float(y1)))
                    mx = int(map_x0 + (int(icon_tx) - int(start_tx)) * int(scale) + int(scale) // 2)
                    my = int(map_y0 + (int(icon_ty) - int(start_ty)) * int(scale) + int(scale) // 2)
                    # Use the same icon scale as the big-map legend so symbols match.
                    self._draw_world_map_icon(surface, mx, my, str(kind), scale=2)
                    drawn_pois += 1
                    if drawn_pois >= 16:
                        break
                if drawn_pois >= 16:
                    break
            if drawn_pois >= 16:
                break

        # Border for the map area.
        pygame.draw.rect(surface, (10, 10, 12), pygame.Rect(map_x0 - 1, map_y0 - 1, map_px + 2, map_px + 2), 1)

        # Player marker.
        cx = int(map_x0 + int(radius) * int(scale) + int(scale) // 2)
        cy = int(map_y0 + int(radius) * int(scale) + int(scale) // 2)
        pygame.draw.circle(surface, (240, 240, 244), (cx, cy), 3)
        pygame.draw.circle(surface, (0, 0, 0), (cx, cy), 3, 1)

        # Home marker (inside map) or arrow (off-screen).
        if isinstance(home, tuple) and len(home) == 2:
            hx, hy = int(home[0]), int(home[1])
            dx_t = int(hx - int(tx))
            dy_t = int(hy - int(ty))
            if abs(dx_t) <= int(radius) and abs(dy_t) <= int(radius):
                mx = int(map_x0 + (dx_t + int(radius)) * int(scale) + int(scale) // 2)
                my = int(map_y0 + (dy_t + int(radius)) * int(scale) + int(scale) // 2)
                pygame.draw.circle(surface, (255, 220, 140), (mx, my), 4)
                pygame.draw.circle(surface, (0, 0, 0), (mx, my), 4, 1)
                surface.fill((255, 245, 190), pygame.Rect(int(mx - 1), int(my - 1), 2, 2))
            else:
                m = max(abs(dx_t), abs(dy_t))
                if m <= 0:
                    ux = 0.0
                    uy = 0.0
                else:
                    ux = float(dx_t) / float(m)
                    uy = float(dy_t) / float(m)
                    l = float(math.hypot(ux, uy))
                    if l > 1e-6:
                        ux /= l
                        uy /= l
                inset = float(radius) - 0.8
                tip_x = float(map_x0) + (float(radius) + ux * inset) * float(scale) + float(scale) * 0.5
                tip_y = float(map_y0) + (float(radius) + uy * inset) * float(scale) + float(scale) * 0.5
                base_x = tip_x - ux * 8.0
                base_y = tip_y - uy * 8.0
                px = -uy
                py = ux
                left = (base_x + px * 4.0, base_y + py * 4.0)
                right = (base_x - px * 4.0, base_y - py * 4.0)
                tip = (tip_x, tip_y)
                pygame.draw.polygon(surface, (255, 220, 140), [tip, left, right])
                pygame.draw.polygon(surface, (0, 0, 0), [tip, left, right], 1)
                lx = int(round(base_x + px * 5.0))
                ly = int(round(base_y + py * 5.0))
                draw_text(surface, self.app.font_s, "家", (lx, ly), pygame.Color(240, 240, 244), anchor="center")

        def draw_edge_arrow(
            *,
            dx_t: int,
            dy_t: int,
            color: tuple[int, int, int],
            label: str | None = None,
        ) -> None:
            m = max(abs(int(dx_t)), abs(int(dy_t)))
            if m <= 0:
                return
            ux = float(dx_t) / float(m)
            uy = float(dy_t) / float(m)
            l = float(math.hypot(ux, uy))
            if l > 1e-6:
                ux /= l
                uy /= l
            inset = float(radius) - 0.8
            tip_x = float(map_x0) + (float(radius) + ux * inset) * float(scale) + float(scale) * 0.5
            tip_y = float(map_y0) + (float(radius) + uy * inset) * float(scale) + float(scale) * 0.5
            base_x = tip_x - ux * 7.0
            base_y = tip_y - uy * 7.0
            px = -uy
            py = ux
            left = (base_x + px * 3.5, base_y + py * 3.5)
            right = (base_x - px * 3.5, base_y - py * 3.5)
            tip = (tip_x, tip_y)
            pygame.draw.polygon(surface, tuple(color), [tip, left, right])
            pygame.draw.polygon(surface, (0, 0, 0), [tip, left, right], 1)
            if label:
                lx = int(round(base_x + px * 5.0))
                ly = int(round(base_y + py * 5.0))
                draw_text(surface, self.app.font_s, label, (lx, ly), pygame.Color(240, 240, 240), anchor="center")

        def draw_edge_poi(*, kind: str, dx_t: int, dy_t: int, color: tuple[int, int, int]) -> None:
            # Arrow + the same POI icon used in the world-map legend.
            m = max(abs(int(dx_t)), abs(int(dy_t)))
            if m <= 0:
                return
            ux = float(dx_t) / float(m)
            uy = float(dy_t) / float(m)
            l = float(math.hypot(ux, uy))
            if l > 1e-6:
                ux /= l
                uy /= l
            inset = float(radius) - 0.8
            tip_x = float(map_x0) + (float(radius) + ux * inset) * float(scale) + float(scale) * 0.5
            tip_y = float(map_y0) + (float(radius) + uy * inset) * float(scale) + float(scale) * 0.5

            base_x = tip_x - ux * 9.0
            base_y = tip_y - uy * 9.0
            px = -uy
            py = ux
            left = (base_x + px * 4.0, base_y + py * 4.0)
            right = (base_x - px * 4.0, base_y - py * 4.0)
            tip = (tip_x, tip_y)
            pygame.draw.polygon(surface, tuple(color), [tip, left, right])
            pygame.draw.polygon(surface, (0, 0, 0), [tip, left, right], 1)
            self._draw_world_map_icon(surface, int(round(tip_x)), int(round(tip_y)), str(kind), scale=2)

        # POI edge indicators: show direction to nearest gunshop/bookstore even when outside the minimap window.
        cache = getattr(self, "_poi_cache", None)
        if isinstance(cache, dict):
            def nearest_dxdy(kind: str) -> tuple[int, int] | None:
                pts = cache.get(str(kind))
                if not isinstance(pts, list) or not pts:
                    return None
                best_d2 = 1e30
                best: tuple[int, int] | None = None
                for px, py in pts:
                    dx = int(px) - int(tx)
                    dy = int(py) - int(ty)
                    d2 = float(dx * dx + dy * dy)
                    if d2 < best_d2:
                        best_d2 = d2
                        best = (dx, dy)
                return best

            if not bool(seen_gunshop):
                dd = nearest_dxdy("gunshop")
                if dd is not None and (abs(int(dd[0])) > int(radius) or abs(int(dd[1])) > int(radius)):
                    draw_edge_poi(kind="gunshop", dx_t=int(dd[0]), dy_t=int(dd[1]), color=(220, 140, 90))
            if not bool(seen_bookstore):
                dd = nearest_dxdy("bookstore")
                if dd is not None and (abs(int(dd[0])) > int(radius) or abs(int(dd[1])) > int(radius)):
                    draw_edge_poi(kind="bookstore", dx_t=int(dd[0]), dy_t=int(dd[1]), color=(232, 200, 120))

        # Player-made markers from the big map (dot inside radius, arrow when off-screen).
        markers = getattr(self, "world_map_markers", None)
        if isinstance(markers, list) and markers:
            inside: list[tuple[int, int, tuple[int, int, int], str]] = []
            outside: list[tuple[int, int, float, tuple[int, int, int], str]] = []
            for m in markers:
                mx_t = int(getattr(m, "tx", 0))
                my_t = int(getattr(m, "ty", 0))
                dx_t = int(mx_t - int(tx))
                dy_t = int(my_t - int(ty))
                col = tuple(getattr(m, "color", (255, 220, 140)))
                lab = str(getattr(m, "label", ""))
                if abs(int(dx_t)) <= int(radius) and abs(int(dy_t)) <= int(radius):
                    inside.append((dx_t, dy_t, col, lab))
                else:
                    d2 = float(dx_t * dx_t + dy_t * dy_t)
                    outside.append((dx_t, dy_t, d2, col, lab))

            for dx_t, dy_t, col, _lab in inside[:24]:
                mx = int(map_x0 + (int(dx_t) + int(radius)) * int(scale) + int(scale) // 2)
                my = int(map_y0 + (int(dy_t) + int(radius)) * int(scale) + int(scale) // 2)
                pygame.draw.circle(surface, tuple(col), (mx, my), 2)
                pygame.draw.circle(surface, (0, 0, 0), (mx, my), 2, 1)

            outside.sort(key=lambda t: t[2])
            for dx_t, dy_t, _d2, col, lab in outside[:3]:
                draw_edge_arrow(dx_t=int(dx_t), dy_t=int(dy_t), color=tuple(col), label=str(lab) if lab else None)

        return panel

    def _toggle_world_map(self, *, open: bool | None = None) -> None:
        if open is None:
            open = not bool(getattr(self, "world_map_open", False))
        self.world_map_open = bool(open)
        if not self.world_map_open:
            return

        # Close other overlays when opening the big map.
        self.inv_open = False
        self.rv_ui_open = False
        self.hr_elevator_ui_open = False
        self._gallery_open = False
        self.world_map_center = self._player_tile()
        self._world_map_cache_key = None
        self.world_map_dragging = False

    def _world_map_tile_from_point(self, x: int, y: int) -> tuple[int, int] | None:
        rect = getattr(self, "_world_map_draw_rect", None)
        if not isinstance(rect, pygame.Rect):
            return None
        if not rect.collidepoint(int(x), int(y)):
            return None
        scale = max(1, int(getattr(self, "world_map_scale", 1)))
        start_tx, start_ty = getattr(self, "_world_map_start_tile", (0, 0))
        tx = int(start_tx) + int((int(x) - int(rect.x)) // scale)
        ty = int(start_ty) + int((int(y) - int(rect.y)) // scale)
        return int(tx), int(ty)

    def _add_world_map_marker(self, tx: int, ty: int) -> None:
        tx = int(tx)
        ty = int(ty)
        markers = getattr(self, "world_map_markers", None)
        if not isinstance(markers, list):
            self.world_map_markers = []
            markers = self.world_map_markers
        # Replace any marker on the same tile.
        self.world_map_markers = [m for m in markers if not (int(m.tx) == tx and int(m.ty) == ty)]

        idx = int(getattr(self, "world_map_marker_next", 0))
        self.world_map_marker_next = idx + 1
        label = chr(ord("A") + (idx % 26)) if idx < 26 else str(idx + 1)
        palette = [(255, 220, 140), (140, 220, 255), (220, 140, 255), (220, 255, 140)]
        color = palette[idx % len(palette)]
        self.world_map_markers.append(HardcoreSurvivalState._MapMarker(tx=tx, ty=ty, label=label, color=color))
        self._set_hint(f"已标记 {label}", seconds=1.2)

    def _remove_world_map_marker_near(self, tx: int, ty: int) -> None:
        tx = int(tx)
        ty = int(ty)
        markers = getattr(self, "world_map_markers", None)
        if not isinstance(markers, list) or not markers:
            return
        best_i = -1
        best_d2 = 999999
        for i, m in enumerate(markers):
            d2 = (int(m.tx) - tx) ** 2 + (int(m.ty) - ty) ** 2
            if d2 < best_d2:
                best_d2 = int(d2)
                best_i = int(i)
        if best_i < 0 or best_d2 > 36:
            return
        label = str(getattr(markers[best_i], "label", "?"))
        try:
            del markers[best_i]
        except Exception:
            self.world_map_markers = [m for i, m in enumerate(markers) if i != best_i]
        self._set_hint(f"删除标记 {label}", seconds=1.0)

    def _draw_world_map_icon(self, surface: pygame.Surface, cx: int, cy: int, kind: str, *, scale: int) -> None:
        scale = max(1, int(scale))
        s = int(max(5, min(15, 3 + scale * 3)))
        half = s // 2
        x = int(cx)
        y = int(cy)

        if kind == "hospital":
            col = (220, 70, 70)
            w = max(1, int(round(s / 5)))
            pygame.draw.line(surface, (0, 0, 0), (x, y - half), (x, y + half), w + 2)
            pygame.draw.line(surface, (0, 0, 0), (x - half, y), (x + half, y), w + 2)
            pygame.draw.line(surface, col, (x, y - half), (x, y + half), w)
            pygame.draw.line(surface, col, (x - half, y), (x + half, y), w)
            return

        if kind == "market":
            col = (220, 200, 120)
            r = pygame.Rect(0, 0, s, s)
            r.center = (x, y)
            pygame.draw.rect(surface, (0, 0, 0), r)
            pygame.draw.rect(surface, col, r.inflate(-2, -2))
            # Handle
            pygame.draw.line(surface, (0, 0, 0), (r.left + 2, r.top + 3), (r.right - 3, r.top + 3), 2)
            pygame.draw.line(surface, col, (r.left + 2, r.top + 3), (r.right - 3, r.top + 3), 1)
            return

        if kind == "gunshop":
            col = (220, 140, 90)
            r = pygame.Rect(0, 0, s, s)
            r.center = (x, y)
            pygame.draw.rect(surface, (0, 0, 0), r)
            pygame.draw.rect(surface, (60, 60, 72), r.inflate(-2, -2))
            # Tiny pistol silhouette that still reads at small sizes.
            body_w = max(3, int(r.w) - 4)
            body_h = max(2, int(r.h) // 3)
            body = pygame.Rect(0, 0, int(body_w), int(body_h))
            body.center = (int(r.centerx), int(r.centery) - 1)
            barrel_w = max(2, int(body.w) // 3)
            barrel = pygame.Rect(int(body.right) - 1, int(body.top), int(barrel_w), 1)
            grip_w = max(2, int(body.w) // 4)
            grip_h = max(3, int(r.h) - int(body.h) - 2)
            grip = pygame.Rect(0, 0, int(grip_w), int(grip_h))
            grip.midtop = (int(body.centerx), int(body.bottom) - 1)

            pygame.draw.rect(surface, col, body)
            pygame.draw.rect(surface, col, barrel)
            pygame.draw.rect(surface, col, grip)
            pygame.draw.rect(surface, (0, 0, 0), body, 1)
            pygame.draw.rect(surface, (0, 0, 0), barrel, 1)
            pygame.draw.rect(surface, (0, 0, 0), grip, 1)
            return

        if kind == "bookstore":
            col = (232, 200, 120)
            r = pygame.Rect(0, 0, s, s)
            r.center = (x, y)
            pygame.draw.rect(surface, (0, 0, 0), r)
            pygame.draw.rect(surface, (80, 100, 150), r.inflate(-2, -2))
            # Book
            bx = int(r.centerx)
            by = int(r.centery)
            pygame.draw.rect(surface, col, pygame.Rect(bx - 5, by - 4, 4, 8), 1, border_radius=1)
            pygame.draw.rect(surface, col, pygame.Rect(bx + 1, by - 4, 4, 8), 1, border_radius=1)
            surface.fill((0, 0, 0), pygame.Rect(bx, by - 4, 1, 8))
            return

        if kind == "chinese":
            col = (210, 180, 110)
            r = pygame.Rect(0, 0, s, s)
            r.center = (x, y)
            pygame.draw.rect(surface, (0, 0, 0), r)
            pygame.draw.rect(surface, (150, 60, 50), r.inflate(-2, -2))
            # Roof + pillars
            pygame.draw.line(surface, col, (r.left + 2, r.top + 3), (r.right - 3, r.top + 3), 1)
            pygame.draw.line(surface, col, (r.left + 3, r.top + 2), (r.right - 4, r.top + 2), 1)
            surface.fill(col, pygame.Rect(r.left + 3, r.top + 4, 1, max(1, s - 7)))
            surface.fill(col, pygame.Rect(r.right - 4, r.top + 4, 1, max(1, s - 7)))
            return

        if kind == "school":
            col = (110, 170, 240)
            r = pygame.Rect(0, 0, s, s)
            r.center = (x, y)
            pygame.draw.rect(surface, (0, 0, 0), r)
            pygame.draw.rect(surface, col, r.inflate(-2, -2))
            # Flag
            pygame.draw.line(surface, (0, 0, 0), (r.centerx - 2, r.top + 1), (r.centerx - 2, r.top + 5), 1)
            pygame.draw.rect(surface, (0, 0, 0), pygame.Rect(r.centerx - 1, r.top + 1, 3, 2))
            pygame.draw.rect(surface, (250, 240, 200), pygame.Rect(r.centerx, r.top + 2, 1, 1))
            return

        if kind == "prison":
            col = (150, 150, 160)
            r = pygame.Rect(0, 0, s, s)
            r.center = (x, y)
            pygame.draw.rect(surface, (0, 0, 0), r)
            pygame.draw.rect(surface, col, r.inflate(-2, -2))
            for i in range(r.left + 2, r.right - 2, 3):
                pygame.draw.line(surface, (0, 0, 0), (i, r.top + 2), (i, r.bottom - 3), 1)
            return

        if kind == "highrise":
            col = (210, 210, 220)
            w = max(3, s // 2)
            h = s + max(2, s // 3)
            r = pygame.Rect(0, 0, w, h)
            r.center = (x, y)
            pygame.draw.rect(surface, (0, 0, 0), r)
            pygame.draw.rect(surface, col, r.inflate(-2, -2))
            # Windows
            for wy in range(r.top + 3, r.bottom - 2, 3):
                surface.fill((0, 0, 0), pygame.Rect(r.centerx, wy, 1, 1))
            return

    def _draw_world_map_pois(
        self,
        surface: pygame.Surface,
        *,
        draw_x: int,
        draw_y: int,
        start_tx: int,
        start_ty: int,
        view_w: int,
        view_h: int,
        scale: int,
    ) -> None:
        scale = max(1, int(scale))
        start_tx = int(start_tx)
        start_ty = int(start_ty)
        view_w = int(max(1, view_w))
        view_h = int(max(1, view_h))

        end_tx = start_tx + view_w - 1
        end_ty = start_ty + view_h - 1
        start_cx = start_tx // self.CHUNK_SIZE
        end_cx = end_tx // self.CHUNK_SIZE
        start_cy = start_ty // self.CHUNK_SIZE
        end_cy = end_ty // self.CHUNK_SIZE

        style_to_kind = {
            2: "market",
            9: "gunshop",
            3: "hospital",
            4: "prison",
            5: "school",
            6: "highrise",
            7: "bookstore",
            8: "chinese",
        }

        for cy in range(int(start_cy), int(end_cy) + 1):
            for cx in range(int(start_cx), int(end_cx) + 1):
                chunk = self.world.peek_chunk(cx, cy)
                if chunk is None:
                    continue
                for b in getattr(chunk, "buildings", []):
                    if len(b) < 5:
                        continue
                    tx0, ty0, w, h = int(b[0]), int(b[1]), int(b[2]), int(b[3])
                    roof_kind = int(b[4])
                    style = int((roof_kind >> 8) & 0xFF)
                    kind = style_to_kind.get(int(style))
                    if kind is None:
                        continue

                    c_tx = int(tx0 + max(1, w) // 2)
                    c_ty = int(ty0 + max(1, h) // 2)
                    if not (start_tx <= c_tx <= end_tx and start_ty <= c_ty <= end_ty):
                        continue
                    mx = int(draw_x + (c_tx - start_tx) * scale + scale // 2)
                    my = int(draw_y + (c_ty - start_ty) * scale + scale // 2)
                    self._draw_world_map_icon(surface, mx, my, str(kind), scale=scale)

    def _draw_world_map_legend(self, surface: pygame.Surface, *, map_area: pygame.Rect) -> None:
        legend = pygame.Rect(0, 0, 162, 132)
        legend.bottomright = (int(map_area.right) - 8, int(map_area.bottom) - 8)

        ui = pygame.Surface((legend.w, legend.h), pygame.SRCALPHA)
        ui.fill((12, 12, 16, 210))
        pygame.draw.rect(ui, (90, 90, 110, 220), ui.get_rect(), 1, border_radius=10)
        surface.blit(ui, legend.topleft)

        draw_text(surface, self.app.font_s, "图例", (legend.left + 10, legend.top + 6), pygame.Color(240, 240, 240), anchor="topleft")

        # Clickable toggle button (hide legend).
        btn = pygame.Rect(0, 0, 14, 12)
        btn.topright = (legend.right - 8, legend.top + 6)
        pygame.draw.rect(surface, (24, 24, 30), btn, border_radius=4)
        pygame.draw.rect(surface, (90, 90, 110), btn, 1, border_radius=4)
        draw_text(surface, self.app.font_s, "x", (btn.centerx, btn.centery - 1), pygame.Color(210, 210, 220), anchor="center")
        self._world_map_legend_toggle_rect = btn.copy()

        # Icons (fixed size independent of zoom).
        icon_scale = 2
        x0 = legend.left + 12
        y = legend.top + 22
        step = 14

        entries: list[tuple[str, str]] = [
            ("hospital", "医院"),
            ("market", "超市"),
            ("gunshop", "枪械店"),
            ("bookstore", "书店"),
            ("school", "学校"),
            ("prison", "监狱"),
            ("highrise", "高层"),
            ("chinese", "中式"),
        ]
        for kind, label in entries:
            self._draw_world_map_icon(surface, x0 + 6, y + 6, kind, scale=icon_scale)
            draw_text(surface, self.app.font_s, label, (x0 + 18, y + 1), pygame.Color(210, 210, 220), anchor="topleft")
            y += step

        # Player / home / RV / markers.
        y2 = legend.top + 22
        x1 = legend.left + 92
        pygame.draw.circle(surface, (240, 240, 244), (x1 + 6, y2 + 6), 3)
        pygame.draw.circle(surface, (0, 0, 0), (x1 + 6, y2 + 6), 3, 1)
        draw_text(surface, self.app.font_s, "你", (x1 + 16, y2 + 1), pygame.Color(210, 210, 220), anchor="topleft")

        y2 += step
        pygame.draw.circle(surface, (255, 220, 140), (x1 + 6, y2 + 6), 3)
        pygame.draw.circle(surface, (0, 0, 0), (x1 + 6, y2 + 6), 3, 1)
        draw_text(surface, self.app.font_s, "家", (x1 + 16, y2 + 1), pygame.Color(210, 210, 220), anchor="topleft")

        y2 += step
        pygame.draw.circle(surface, (140, 220, 255), (x1 + 6, y2 + 6), 3)
        pygame.draw.circle(surface, (0, 0, 0), (x1 + 6, y2 + 6), 3, 1)
        draw_text(surface, self.app.font_s, "房车", (x1 + 16, y2 + 1), pygame.Color(210, 210, 220), anchor="topleft")

        y2 += step
        pygame.draw.circle(surface, (220, 140, 255), (x1 + 6, y2 + 6), 3)
        pygame.draw.circle(surface, (0, 0, 0), (x1 + 6, y2 + 6), 3, 1)
        draw_text(surface, self.app.font_s, "标记", (x1 + 16, y2 + 1), pygame.Color(210, 210, 220), anchor="topleft")

    def _handle_world_map_key(self, key: int) -> None:
        key = int(key)
        if key in (pygame.K_ESCAPE, pygame.K_m, pygame.K_TAB):
            self.world_map_open = False
            return
        if key in (pygame.K_l,):
            self.world_map_legend_open = not bool(getattr(self, "world_map_legend_open", True))
            return

        mods = int(pygame.key.get_mods())
        fast = bool(mods & pygame.KMOD_SHIFT)
        step = 40 if fast else 14
        cx, cy = getattr(self, "world_map_center", (0, 0))
        cx = int(cx)
        cy = int(cy)

        if key in (pygame.K_LEFT, pygame.K_a):
            cx -= step
        elif key in (pygame.K_RIGHT, pygame.K_d):
            cx += step
        elif key in (pygame.K_UP, pygame.K_w):
            cy -= step
        elif key in (pygame.K_DOWN, pygame.K_s):
            cy += step
        elif key in (pygame.K_HOME, pygame.K_0):
            cx, cy = self._player_tile()
        elif key in (pygame.K_EQUALS, pygame.K_KP_PLUS):
            self.world_map_scale = int(clamp(int(getattr(self, "world_map_scale", 1))) + 1, 1, 4)
        elif key in (pygame.K_MINUS, pygame.K_KP_MINUS):
            self.world_map_scale = int(clamp(int(getattr(self, "world_map_scale", 1))) - 1, 1, 4)
        else:
            return

        self.world_map_center = (int(cx), int(cy))
        self._world_map_cache_key = None

    def _handle_world_map_mouse(self, event: pygame.event.Event) -> None:
        if event.type == pygame.MOUSEWHEEL:
            dy = int(getattr(event, "y", 0))
            if dy != 0:
                self.world_map_scale = int(clamp(int(getattr(self, "world_map_scale", 1)) + (1 if dy > 0 else -1), 1, 4))
                self._world_map_cache_key = None
            return

        if event.type == pygame.MOUSEBUTTONUP:
            btn = int(getattr(event, "button", 0))
            if btn == 3:
                self.world_map_dragging = False
            return

        if event.type not in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEMOTION):
            return
        internal = self.app.screen_to_internal(getattr(event, "pos", (0, 0)))
        if internal is None:
            return
        ix = int(internal[0])
        iy = int(internal[1])

        if event.type == pygame.MOUSEBUTTONDOWN and int(getattr(event, "button", 0)) == 1:
            toggle = getattr(self, "_world_map_legend_toggle_rect", None)
            if isinstance(toggle, pygame.Rect) and toggle.collidepoint(ix, iy):
                self.world_map_legend_open = not bool(getattr(self, "world_map_legend_open", True))
                return

        if event.type == pygame.MOUSEMOTION:
            if not bool(getattr(self, "world_map_dragging", False)):
                return
            scale = max(1, int(getattr(self, "world_map_scale", 1)))
            sx, sy = getattr(self, "world_map_drag_start", (ix, iy))
            cx0, cy0 = getattr(self, "world_map_drag_center", getattr(self, "world_map_center", (0, 0)))
            dx = int(ix) - int(sx)
            dy = int(iy) - int(sy)
            tcx = int(cx0) - int(round(float(dx) / float(scale)))
            tcy = int(cy0) - int(round(float(dy) / float(scale)))
            self.world_map_center = (int(tcx), int(tcy))
            self._world_map_cache_key = None
            return

        tx_ty = self._world_map_tile_from_point(ix, iy)
        if tx_ty is None:
            return
        tx, ty = tx_ty

        btn = int(getattr(event, "button", 0))
        if btn == 1:
            self._add_world_map_marker(tx, ty)
        elif btn == 3:
            mods = int(pygame.key.get_mods())
            if mods & pygame.KMOD_CTRL:
                self._remove_world_map_marker_near(tx, ty)
                return
            self.world_map_dragging = True
            self.world_map_drag_start = (int(ix), int(iy))
            self.world_map_drag_center = tuple(getattr(self, "world_map_center", (0, 0)))
        elif btn in (4, 5):
            self.world_map_scale = int(clamp(int(getattr(self, "world_map_scale", 1)) + (1 if btn == 4 else -1), 1, 4))
            self._world_map_cache_key = None

    def _draw_world_map_ui(self, surface: pygame.Surface) -> None:
        panel = pygame.Rect(10, 10, INTERNAL_W - 20, INTERNAL_H - 20)
        pygame.draw.rect(surface, (12, 12, 16), panel, border_radius=12)
        pygame.draw.rect(surface, (90, 90, 110), panel, 2, border_radius=12)

        title = "大地图"
        draw_text(surface, self.app.font_m, title, (panel.centerx, panel.top + 12), pygame.Color(240, 240, 240), anchor="center")
        hint = "左键标记  右键拖动  Ctrl+右键删除  滚轮缩放  WASD/方向键移动  L 图例  M/Esc关闭"
        draw_text(surface, self.app.font_s, hint, (panel.centerx, panel.bottom - 10), pygame.Color(170, 170, 180), anchor="center")

        map_area = pygame.Rect(panel.left + 10, panel.top + 26, panel.w - 20, panel.h - 44)
        pygame.draw.rect(surface, (18, 18, 22), map_area, border_radius=10)
        pygame.draw.rect(surface, (40, 40, 50), map_area, 1, border_radius=10)

        scale = max(1, int(getattr(self, "world_map_scale", 1)))
        view_w = max(1, map_area.w // scale)
        view_h = max(1, map_area.h // scale)
        cx, cy = getattr(self, "world_map_center", (0, 0))
        cx = int(cx)
        cy = int(cy)
        start_tx = int(cx - view_w // 2)
        start_ty = int(cy - view_h // 2)

        season = int(self._season_index())
        key = (start_tx, start_ty, view_w, view_h, int(scale), int(season))
        cached_scaled: pygame.Surface | None = getattr(self, "_world_map_cache_scaled", None)
        if getattr(self, "_world_map_cache_key", None) != key or cached_scaled is None:
            base = pygame.Surface((view_w, view_h))
            base.lock()
            for py in range(view_h):
                wy = start_ty + py
                for px in range(view_w):
                    wx = start_tx + px
                    tid = self.world.peek_tile(wx, wy)
                    base.set_at((px, py), self._minimap_color(tid))
            base.unlock()
            cached_scaled = pygame.transform.scale(base, (view_w * scale, view_h * scale))
            self._world_map_cache_key = key
            self._world_map_cache_scaled = cached_scaled

        draw_x = int(map_area.x + (map_area.w - cached_scaled.get_width()) // 2)
        draw_y = int(map_area.y + (map_area.h - cached_scaled.get_height()) // 2)
        self._world_map_draw_rect = pygame.Rect(draw_x, draw_y, cached_scaled.get_width(), cached_scaled.get_height())
        self._world_map_start_tile = (start_tx, start_ty)
        surface.blit(cached_scaled, (draw_x, draw_y))

        # POI icons (public buildings): hospital/market/school/etc.
        self._draw_world_map_pois(
            surface,
            draw_x=int(draw_x),
            draw_y=int(draw_y),
            start_tx=int(start_tx),
            start_ty=int(start_ty),
            view_w=int(view_w),
            view_h=int(view_h),
            scale=int(scale),
        )

        def draw_marker(tx: int, ty: int, col: tuple[int, int, int], label: str | None = None, *, r: int = 3) -> None:
            if not (start_tx <= int(tx) < start_tx + view_w and start_ty <= int(ty) < start_ty + view_h):
                return
            mx = int(draw_x + (int(tx) - start_tx) * scale + scale // 2)
            my = int(draw_y + (int(ty) - start_ty) * scale + scale // 2)
            rr = int(max(2, int(r)))
            pygame.draw.circle(surface, col, (mx, my), rr)
            pygame.draw.circle(surface, (0, 0, 0), (mx, my), rr, 1)
            if label:
                draw_text(surface, self.app.font_s, label, (mx + 6, my - 6), pygame.Color(240, 240, 240), anchor="topleft")

        # Player + key landmarks.
        ptx, pty = self._player_tile()
        draw_marker(ptx, pty, (240, 240, 244), None)

        rtx = int(math.floor(self.rv.pos.x / self.TILE_SIZE))
        rty = int(math.floor(self.rv.pos.y / self.TILE_SIZE))
        draw_marker(rtx, rty, (140, 220, 255), "房车")

        home = getattr(self, "home_highrise_door", None)
        if isinstance(home, tuple) and len(home) == 2:
            draw_marker(int(home[0]), int(home[1]), (255, 220, 140), "家", r=4)

        for m in getattr(self, "world_map_markers", []):
            draw_marker(int(getattr(m, "tx", 0)), int(getattr(m, "ty", 0)), tuple(getattr(m, "color", (255, 220, 140))), str(getattr(m, "label", "")))

        # Legend (icon key): bottom-right, toggleable.
        self._world_map_legend_toggle_rect = None
        if bool(getattr(self, "world_map_legend_open", True)):
            self._draw_world_map_legend(surface, map_area=map_area)
        else:
            btn = pygame.Rect(0, 0, 58, 14)
            btn.bottomright = (int(map_area.right) - 8, int(map_area.bottom) - 8)
            ui = pygame.Surface((btn.w, btn.h), pygame.SRCALPHA)
            ui.fill((12, 12, 16, 210))
            pygame.draw.rect(ui, (90, 90, 110, 220), ui.get_rect(), 1, border_radius=8)
            surface.blit(ui, btn.topleft)
            draw_text(surface, self.app.font_s, "图例(L)", (btn.centerx, btn.centery - 1), pygame.Color(210, 210, 220), anchor="center")
            self._world_map_legend_toggle_rect = btn.copy()

    def _draw_survival_ui(self, surface: pygame.Surface) -> None:
        day = int(self.world_time_s / max(1e-6, self.DAY_LENGTH_S)) + 1
        season = self.SEASONS[self._season_index()]
        _daylight, tday = self._daylight_amount()
        hh = int(tday * 24) % 24
        mm = int(tday * 24 * 60) % 60
        w = self.WEATHER_NAMES.get(str(getattr(self, "weather_kind", "clear")), "?")
        info = f"DAY {day}  {season}  {hh:02d}:{mm:02d}  {w}"
        draw_text(surface, self.app.font_s, info, (6, 6), pygame.Color(230, 230, 240), anchor="topleft")

        def stat_line(y: int, label: str, value: float, *, fg: tuple[int, int, int]) -> None:
            value = float(clamp(value, 0.0, 100.0))
            draw_text(surface, self.app.font_s, f"{label} {int(round(value)):3d}", (6, y), pygame.Color(220, 220, 230), anchor="topleft")
            bar = pygame.Rect(56, y + 4, 74, 6)
            pygame.draw.rect(surface, (10, 10, 14), bar)
            pygame.draw.rect(surface, (70, 70, 86), bar, 1)
            fill_w = int((bar.w - 2) * (value / 100.0))
            if fill_w > 0:
                pygame.draw.rect(surface, fg, pygame.Rect(bar.x + 1, bar.y + 1, fill_w, bar.h - 2))

        stat_line(20, "HP", float(self.player.hp), fg=(220, 90, 90))    
        try:
            bleed_rate = float(self._bleed_total_rate())
            if bleed_rate > 0.0 and isinstance(getattr(self, "bleed_wounds", None), dict) and self.bleed_wounds:
                parts = [self._BODY_PART_NAMES.get(str(p), str(p)) for p in self.bleed_wounds.keys()]
                txt = "流血 " + "/".join(parts[:3])
                draw_text(surface, self.app.font_s, txt, (140, 20), pygame.Color(220, 90, 90), anchor="topleft")
        except Exception:
            pass
        stat_line(32, "饿", self.player.hunger, fg=(210, 170, 90))      
        stat_line(44, "渴", self.player.thirst, fg=(120, 170, 230))     
        stat_line(56, "健", self.player.condition, fg=(120, 210, 140))  
        stat_line(68, "心", self.player.morale, fg=(200, 160, 240))
        stat_line(80, "体", self.player.stamina, fg=(240, 240, 240))

        if self.gun is None:
            draw_text(surface, self.app.font_s, "枪：无", (INTERNAL_W - 6, 6), pygame.Color(200, 200, 210), anchor="topright")
        else:
            gdef = self._gun_effective_def(self.gun)
            if gdef is None:
                draw_text(surface, self.app.font_s, "枪：未知", (INTERNAL_W - 6, 6), pygame.Color(200, 200, 210), anchor="topright")
            else:
                reserve = self.inventory.count(gdef.ammo_item)
                extra = " 换弹" if self.gun.reload_left > 0.0 else ""
                draw_text(
                    surface,
                    self.app.font_s,
                    f"{gdef.name}{(' [' + self._gun_mod_label(self.gun) + ']') if self._gun_mod_label(self.gun) else ''} {int(self.gun.mag)}/{reserve}{extra}",
                    (INTERNAL_W - 6, 6),
                    pygame.Color(230, 230, 240),
                    anchor="topright",
                )
        draw_text(surface, self.app.font_s, f"房车油 {int(self.rv.fuel)}", (INTERNAL_W - 6, 20), pygame.Color(180, 180, 190), anchor="topright")
        if self.mount == "bike" and str(getattr(self.bike, "model_id", "bike")).startswith("moto"):
            draw_text(
                surface,
                self.app.font_s,
                f"摩托油 {int(getattr(self.bike, 'fuel', 0.0))}",
                (INTERNAL_W - 6, 32),
                pygame.Color(180, 180, 190),
                anchor="topright",
            )
        self._draw_sun_moon_widget(surface, tday=float(tday))

        minimap_rect = self._draw_minimap(surface)
        self.minimap_rect = minimap_rect if isinstance(minimap_rect, pygame.Rect) else None

        _chunk, it = self._find_nearest_item(radius_px=20.0)
        if it is not None:
            idef = self._ITEMS.get(it.item_id)
            name = idef.name if idef is not None else it.item_id
            draw_text(surface, self.app.font_s, f"E 拾取：{name} x{int(it.qty)}", (6, 96), pygame.Color(220, 220, 230), anchor="topleft")

        if self.hint_text:
            draw_text(surface, self.app.font_s, self.hint_text, (INTERNAL_W // 2, INTERNAL_H - 30), pygame.Color(255, 220, 140), anchor="center")

        y0 = 34
        if isinstance(minimap_rect, pygame.Rect):
            y0 = max(int(y0), int(minimap_rect.bottom + 6))

        # RV mode toggle buttons (life vs drive).
        self._rv_mode_btn_rects = {}
        if str(getattr(self.rv, "model_id", "rv")) == "rv" and self.mount in (None, "rv"):
            near_rv_btn = bool(self._can_access_rv())
            if near_rv_btn or bool(getattr(self, "rv_world_interior", False)) or self.mount == "rv":
                btn_w = 54
                btn_h = 16
                gap = 4
                bx = int(INTERNAL_W - 6 - btn_w)
                by = int(y0)
                life_selected = bool(getattr(self, "rv_world_interior", False))
                drive_selected = self.mount == "rv"
                r_life = pygame.Rect(bx, by, int(btn_w), int(btn_h))
                r_drive = pygame.Rect(bx, by + int(btn_h + gap), int(btn_w), int(btn_h))
                draw_button(surface, self.app.font_s, "生活", r_life, selected=bool(life_selected), disabled=bool(life_selected))
                draw_button(surface, self.app.font_s, "开车", r_drive, selected=bool(drive_selected), disabled=bool(drive_selected))
                self._rv_mode_btn_rects = {"life": r_life.copy(), "drive": r_drive.copy()}
                y0 = int(r_drive.bottom + 6)

        if self.mount is not None:
            if self.mount == "rv":
                mid = str(getattr(self.rv, "model_id", "rv"))
                model = self._CAR_MODELS.get(mid)
                kind = model.name if model is not None else mid
            else:
                kind = self._two_wheel_name(getattr(self.bike, "model_id", "bike"))
            draw_text(surface, self.app.font_s, f"F 下车({kind})", (INTERNAL_W - 6, int(y0)), pygame.Color(220, 220, 230), anchor="topright")
            if self.mount == "rv":
                draw_text(surface, self.app.font_s, "H 车灯", (INTERNAL_W - 6, int(y0 + 12)), pygame.Color(220, 220, 230), anchor="topright")
                draw_text(surface, self.app.font_s, "V 换车型", (INTERNAL_W - 6, int(y0 + 24)), pygame.Color(180, 180, 190), anchor="topright")
        else:
            y = int(y0)
            near_rv = bool(self._can_access_rv())
            if near_rv:
                mid = str(getattr(self.rv, "model_id", "rv"))
                model = self._CAR_MODELS.get(mid)
                name = model.name if model is not None else mid
                draw_text(surface, self.app.font_s, f"F 上车({name})", (INTERNAL_W - 6, y), pygame.Color(220, 220, 230), anchor="topright")
                y += 12
                if str(mid) == "rv":
                    draw_text(surface, self.app.font_s, "H 房车内部", (INTERNAL_W - 6, y), pygame.Color(220, 220, 230), anchor="topright")
                    y += 12
                draw_text(surface, self.app.font_s, "V 换车型", (INTERNAL_W - 6, y), pygame.Color(180, 180, 190), anchor="topright")
                y += 12
            if (self.player.pos - self.bike.pos).length_squared() <= (18.0 * 18.0):
                draw_text(surface, self.app.font_s, f"F 骑车({self._two_wheel_name(getattr(self.bike, 'model_id', 'bike'))})", (INTERNAL_W - 6, y), pygame.Color(220, 220, 230), anchor="topright")
        draw_text(
            surface,
            self.app.font_s,
            "WASD移动  Shift冲刺  E拾取  鼠标左键射击  R换弹  J近战  Tab背包(枪/配件/衣服)  Esc菜单",
            (6, INTERNAL_H - 14),
            pygame.Color(170, 170, 180),
            anchor="topleft",
        )

    def _draw_debug(self, surface: pygame.Surface, cam_x: int, cam_y: int) -> None:
        tx = int(math.floor(self.player.pos.x / self.TILE_SIZE))
        ty = int(math.floor(self.player.pos.y / self.TILE_SIZE))
        cx = tx // self.CHUNK_SIZE
        cy = ty // self.CHUNK_SIZE
        chunk = self.world.get_chunk(cx, cy)
        info = f"seed {self.seed}  tile {tx},{ty}  chunk {cx},{cy}  town {chunk.town_kind or '-'}"
        draw_text(surface, self.app.font_s, info, (6, INTERNAL_H - 6), pygame.Color(180, 180, 190), anchor="topleft")

        # Player skeleton overlay (helps tuning side-walk + gun anchors).
        p = self.player.pos - pygame.Vector2(cam_x, cam_y)
        px = int(round(p.x))
        py = int(round(p.y))

        face = pygame.Vector2(self.player.facing)
        if self.gun is not None:
            face = pygame.Vector2(self.aim_dir)
        if face.length_squared() <= 0.001:
            face = pygame.Vector2(0, 1)

        if abs(face.y) >= abs(face.x):
            d = "down" if face.y >= 0 else "up"
        else:
            d = "right" if face.x >= 0 else "left"

        pf_walk = getattr(self, "player_frames", self._PLAYER_FRAMES)
        pf_run = getattr(self, "player_frames_run", None)
        is_run = bool(getattr(self, "player_sprinting", False))
        pf = pf_run if (is_run and isinstance(pf_run, dict)) else pf_walk
        frames = pf.get(d, pf["down"])
        moving = self.player.vel.length_squared() > 1.0
        bob = 0
        walk_idx = 0
        idle_anim = True
        if moving and len(frames) > 1:
            idle_anim = False
            walk = frames[1:]
            phase = (float(self.player.walk_phase) % math.tau) / math.tau
            walk_idx = int(phase * len(walk)) % len(walk)
            spr = walk[walk_idx]
            if is_run and walk_idx in (1, 4):
                bob = 1
        else:
            spr = frames[0]

        rect = spr.get_rect()
        rect.midbottom = (px, iround(float(p.y) + float(self.player.h) / 2.0))
        rect.y += bob

        height_delta = 0
        av = getattr(self, "avatar", None)
        if av is not None:
            hidx = int(getattr(av, "height", 1))
            height_delta = 1 if hidx == 0 else -1 if hidx == 2 else 0

        sk = self._survivor_skeleton_nodes(
            d,
            int(walk_idx),
            idle=bool(idle_anim),
            height_delta=int(height_delta),
            run=bool(is_run),
        )
        line_col = (255, 0, 200)
        node_col = (255, 240, 120)
        for a, b in self._SURVIVOR_SKELETON_BONES:
            pa = sk.get(a)
            pb = sk.get(b)
            if pa is None or pb is None:
                continue
            ax, ay = pa
            bx, by = pb
            pygame.draw.line(surface, line_col, (rect.left + ax, rect.top + ay), (rect.left + bx, rect.top + by), 1)

        for key in ("head", "chest", "hip", "l_knee", "r_knee", "l_foot", "r_foot", "r_hand"):
            pt = sk.get(key)
            if pt is None:
                continue
            x, y = pt
            pygame.draw.rect(surface, node_col, pygame.Rect(rect.left + x - 1, rect.top + y - 1, 3, 3), 1)


class SettingsState(State):
    def on_enter(self) -> None:
        self.items = ["网格", "返回"]
        self.index = 0
        self.item_rects: list[pygame.Rect] = []

    def _activate(self) -> None:
        if self.index == 0:
            self.app.set_config(show_grid=not self.app.config.show_grid)
        else:
            self.app.set_state(MainMenuState(self.app))

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            if event.key in (pygame.K_ESCAPE,):
                self.app.set_state(MainMenuState(self.app))
                return

            if event.key in (pygame.K_UP, pygame.K_w):
                self.index = (self.index - 1) % len(self.items)
            elif event.key in (pygame.K_DOWN, pygame.K_s):
                self.index = (self.index + 1) % len(self.items)
            elif event.key in (pygame.K_LEFT, pygame.K_a):
                if self.index == 0:
                    self.app.set_config(show_grid=not self.app.config.show_grid)
            elif event.key in (pygame.K_RIGHT, pygame.K_d):
                if self.index == 0:
                    self.app.set_config(show_grid=not self.app.config.show_grid)
            elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                self._activate()
            return

        if event.type not in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONDOWN):
            return
        if not hasattr(event, "pos"):
            return

        internal = self.app.screen_to_internal(event.pos)
        if internal is None:
            return

        for i, rect in enumerate(self.item_rects):
            if rect.collidepoint(internal):
                self.index = i
                if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
                    self._activate()
                break

    def draw(self, surface: pygame.Surface) -> None:
        surface.fill((16, 16, 20))
        draw_text(surface, self.app.font_l, "设置", (INTERNAL_W // 2, 30), pygame.Color(240, 240, 240), anchor="center")

        self.item_rects = []
        y0 = 80
        for i, label in enumerate(self.items):
            selected = i == self.index
            value = ""
            if label == "网格":
                value = "开" if self.app.config.show_grid else "关"
            text = f"{label}  {value}".rstrip()
            rect = pygame.Rect(0, 0, 220, 22)
            rect.center = (INTERNAL_W // 2, y0 + i * 28)
            self.item_rects.append(draw_button(surface, self.app.font_m, text, rect, selected=selected))

        draw_text(
            surface,
            self.app.font_s,
            "左右或点击切换；Esc返回",
            (INTERNAL_W // 2, INTERNAL_H - 22),
            pygame.Color(170, 170, 180),
            anchor="center",
        )


class CharacterSelectState(State):
    def on_enter(self) -> None:
        self.index = 0
        self.dot_rects: list[pygame.Rect] = []
        self.btn_back_rect = pygame.Rect(0, 0, 0, 0)
        self.btn_ok_rect = pygame.Rect(0, 0, 0, 0)
        self.panel_rect = pygame.Rect(0, 0, 0, 0)

    def _confirm(self) -> None:
        self.app.set_state(MapSelectState(self.app, character=CHARS[self.index]))

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            if event.key in (pygame.K_ESCAPE,):
                self.app.set_state(MainMenuState(self.app))
            elif event.key in (pygame.K_LEFT, pygame.K_a):
                self.index = (self.index - 1) % len(CHARS)
            elif event.key in (pygame.K_RIGHT, pygame.K_d):
                self.index = (self.index + 1) % len(CHARS)
            elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                self._confirm()
            elif pygame.K_1 <= event.key <= pygame.K_9:
                n = event.key - pygame.K_1
                if 0 <= n < len(CHARS):
                    self.index = n
            return

        if event.type not in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONDOWN):
            return
        if not hasattr(event, "pos"):
            return

        internal = self.app.screen_to_internal(event.pos)
        if internal is None:
            return

        for i, r in enumerate(self.dot_rects):
            if r.collidepoint(internal):
                self.index = i
                break

        if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
            if self.btn_back_rect.collidepoint(internal):
                self.app.set_state(MainMenuState(self.app))
                return
            if self.btn_ok_rect.collidepoint(internal) or self.panel_rect.collidepoint(internal):
                self._confirm()

    def draw(self, surface: pygame.Surface) -> None:
        surface.fill((14, 14, 18))
        draw_text(surface, self.app.font_l, "选择角色", (INTERNAL_W // 2, 18), pygame.Color(240, 240, 240), anchor="center")
        draw_text(
            surface,
            self.app.font_s,
            "左右/鼠标选择 | Enter/左键确认 | Esc返回",
            (INTERNAL_W // 2, 34),
            pygame.Color(180, 180, 190),
            anchor="center",
        )

        char_def = CHARS[self.index]
        panel = pygame.Rect(10, 44, INTERNAL_W - 20, 88)
        self.panel_rect = panel.copy()
        pygame.draw.rect(surface, (24, 24, 30), panel, border_radius=8)
        pygame.draw.rect(surface, (50, 50, 60), panel, 2, border_radius=8)

        spr_scale = 4
        spr = pygame.transform.scale(
            char_def.sprite,
            (char_def.sprite.get_width() * spr_scale, char_def.sprite.get_height() * spr_scale),
        )
        spr_pos = (panel.left + 10, panel.top + 10)
        surface.blit(spr, spr_pos)

        tx = spr_pos[0] + spr.get_width() + 10
        ty = panel.top + 8
        draw_text(surface, self.app.font_m, f"{char_def.name}", (tx, ty), pygame.Color(240, 240, 240))
        draw_text(surface, self.app.font_s, char_def.desc, (tx, ty + 18), pygame.Color(180, 180, 190))

        stats = [
            f"生命: {char_def.base_hp}",
            f"移速: {int(char_def.move_speed)}",
            f"起手武器: {WEAPON_DEFS[char_def.start_weapon].name}",
        ]
        for i, line in enumerate(stats):
            draw_text(surface, self.app.font_s, line, (tx, ty + 34 + i * 14), pygame.Color(200, 200, 210))

        self.dot_rects = []
        dot_w, dot_h, dot_gap = 14, 8, 10
        total_w = len(CHARS) * dot_w + max(0, (len(CHARS) - 1) * dot_gap)
        start_x = (INTERNAL_W - total_w) // 2
        dots_y = panel.bottom + 6
        for i in range(len(CHARS)):
            c = (240, 240, 240) if i == self.index else (90, 90, 100)
            r = pygame.Rect(start_x + i * (dot_w + dot_gap), dots_y, dot_w, dot_h)
            self.dot_rects.append(r)
            pygame.draw.rect(surface, c, r)

        self.btn_back_rect = pygame.Rect(0, 0, 120, 22)
        self.btn_back_rect.center = (INTERNAL_W // 2 - 70, 160)
        self.btn_ok_rect = pygame.Rect(0, 0, 120, 22)
        self.btn_ok_rect.center = (INTERNAL_W // 2 + 70, 160)
        draw_button(surface, self.app.font_m, "返回", self.btn_back_rect)
        draw_button(surface, self.app.font_m, "确认", self.btn_ok_rect)


class MapSelectState(State):
    def __init__(self, app: App, *, character: CharacterDef) -> None:
        super().__init__(app)
        self.character = character

    def on_enter(self) -> None:
        self.index = 0
        self.dot_rects: list[pygame.Rect] = []
        self.btn_back_rect = pygame.Rect(0, 0, 0, 0)
        self.btn_ok_rect = pygame.Rect(0, 0, 0, 0)
        self.panel_rect = pygame.Rect(0, 0, 0, 0)

    def _confirm(self) -> None:
        self.app.set_state(GameState(self.app, character=self.character, map_def=MAPS[self.index]))

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            if event.key in (pygame.K_ESCAPE,):
                self.app.set_state(CharacterSelectState(self.app))
            elif event.key in (pygame.K_LEFT, pygame.K_a):
                self.index = (self.index - 1) % len(MAPS)
            elif event.key in (pygame.K_RIGHT, pygame.K_d):
                self.index = (self.index + 1) % len(MAPS)
            elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                self._confirm()
            elif pygame.K_1 <= event.key <= pygame.K_9:
                n = event.key - pygame.K_1
                if 0 <= n < len(MAPS):
                    self.index = n
            return

        if event.type not in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONDOWN):
            return
        if not hasattr(event, "pos"):
            return

        internal = self.app.screen_to_internal(event.pos)
        if internal is None:
            return

        for i, r in enumerate(self.dot_rects):
            if r.collidepoint(internal):
                self.index = i
                break

        if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
            if self.btn_back_rect.collidepoint(internal):
                self.app.set_state(CharacterSelectState(self.app))
                return
            if self.btn_ok_rect.collidepoint(internal) or self.panel_rect.collidepoint(internal):
                self._confirm()

    def draw(self, surface: pygame.Surface) -> None:
        surface.fill((14, 14, 18))
        draw_text(surface, self.app.font_l, "选择场景", (INTERNAL_W // 2, 18), pygame.Color(240, 240, 240), anchor="center")
        draw_text(surface, self.app.font_s, f"角色：{self.character.name}", (INTERNAL_W // 2, 34), pygame.Color(180, 180, 190), anchor="center")

        m = MAPS[self.index]
        panel = pygame.Rect(10, 44, INTERNAL_W - 20, 88)
        self.panel_rect = panel.copy()
        pygame.draw.rect(surface, (24, 24, 30), panel, border_radius=8)
        pygame.draw.rect(surface, (50, 50, 60), panel, 2, border_radius=8)

        preview = pygame.Surface((panel.width - 20, 38))
        preview.fill(m.base_color)
        rng = random.Random(hash(m.id) & 0xFFFF)
        for _ in range(140):
            x = rng.randrange(0, preview.get_width())
            y = rng.randrange(0, preview.get_height())
            preview.set_at((x, y), m.accent_color)
        surface.blit(preview, (panel.left + 10, panel.top + 10))

        draw_text(surface, self.app.font_m, m.name, (panel.left + 10, panel.top + 52), pygame.Color(240, 240, 240))
        draw_text(surface, self.app.font_s, m.desc, (panel.left + 10, panel.top + 68), pygame.Color(180, 180, 190))

        self.dot_rects = []
        dot_w, dot_h, dot_gap = 14, 8, 10
        total_w = len(MAPS) * dot_w + max(0, (len(MAPS) - 1) * dot_gap)
        start_x = (INTERNAL_W - total_w) // 2
        dots_y = panel.bottom + 6
        for i in range(len(MAPS)):
            c = (240, 240, 240) if i == self.index else (90, 90, 100)
            r = pygame.Rect(start_x + i * (dot_w + dot_gap), dots_y, dot_w, dot_h)
            self.dot_rects.append(r)
            pygame.draw.rect(surface, c, r)

        self.btn_back_rect = pygame.Rect(0, 0, 120, 22)
        self.btn_back_rect.center = (INTERNAL_W // 2 - 70, 160)
        self.btn_ok_rect = pygame.Rect(0, 0, 120, 22)
        self.btn_ok_rect.center = (INTERNAL_W // 2 + 70, 160)
        draw_button(surface, self.app.font_m, "返回", self.btn_back_rect)
        draw_button(surface, self.app.font_m, "开始", self.btn_ok_rect)


class GameState(State):
    def __init__(self, app: App, *, character: CharacterDef, map_def: MapDef) -> None:
        super().__init__(app)
        self.character = character
        self.map_def = map_def

        self.player = Player(character)
        self.enemies: list[Enemy] = []
        self.projectiles: list[Projectile] = []
        self.swings: list[Swing] = []
        self.weapon_drops: list[WeaponDrop] = []
        self.damage_texts: list[DamageText] = []
        self.explosions: list[ExplosionFx] = []

        self.elapsed_s = 0.0
        self.kills = 0

        self.spawn_cd = 0.0
        self.rng = random.Random(time.time_ns() & 0xFFFFFFFF)
        self.background = self._make_background(map_def)

        self.paused = False
        self.pause_index = 0

        self.level_up_options: list[Upgrade] | None = None
        self.level_up_index = 0
        self.level_up_rects: list[pygame.Rect] = []
        self.pause_item_rects: list[pygame.Rect] = []
        self.grid_btn_rect = pygame.Rect(0, 0, 0, 0)
        self.grid_btn_hover = False

    def on_enter(self) -> None:
        self.player.weapons = [WeaponInstance(WEAPON_DEFS[self.character.start_weapon])]
        self._arrange_weapon_angles()
        c = self.player.center()
        self.weapon_drops = [WeaponDrop("pistol", pygame.Vector2(c.x + 24, c.y))]

    def _arrange_weapon_angles(self) -> None:
        n = len(self.player.weapons)
        if n <= 0:
            return
        for idx, w in enumerate(self.player.weapons):
            w.angle = (idx * (math.tau / n)) % math.tau

    def _make_background(self, map_def: MapDef) -> pygame.Surface:
        bg = pygame.Surface((INTERNAL_W, INTERNAL_H))
        bg.fill(map_def.base_color)
        rng = random.Random(hash(map_def.id) & 0xFFFF)
        for _ in range(2200):
            x = rng.randrange(0, INTERNAL_W)
            y = rng.randrange(0, INTERNAL_H)
            bg.set_at((x, y), map_def.accent_color)
        return bg

    def closest_enemy_to(self, p: pygame.Vector2) -> Enemy | None:
        closest: Enemy | None = None
        best_d2 = 1e18
        for e in self.enemies:
            d2 = (e.center() - p).length_squared()
            if d2 < best_d2:
                best_d2 = d2
                closest = e
        return closest

    def add_damage_text(
        self,
        pos: pygame.Vector2,
        amount: float,
        *,
        color: tuple[int, int, int] = (240, 240, 240),
    ) -> None:
        self.damage_texts.append(DamageText(pos, amount, color=pygame.Color(*color)))

    def _explode(self, pos: pygame.Vector2, proj: Projectile) -> None:
        radius = float(proj.aoe_radius)
        if radius <= 0.0:
            return
        base_damage = float(proj.damage) * float(proj.aoe_damage_mult)
        kb = float(proj.knockback)
        self.explosions.append(ExplosionFx(pos, radius=radius, color=(255, 170, 90)))

        for e in self.enemies:
            d = e.center() - pos
            dist = d.length()
            if dist > radius:
                continue
            t = 1.0 if radius <= 0.001 else clamp(1.0 - dist / radius, 0.0, 1.0)
            dmg = base_damage * (0.6 + 0.4 * t)
            e.hp -= dmg
            self.add_damage_text(e.center(), dmg, color=(255, 210, 160))
            if kb > 0.0:
                if d.length_squared() > 0.01:
                    e.vel += d.normalize() * kb * (0.5 + 0.8 * t)
                else:
                    e.vel += pygame.Vector2(1, 0) * kb * 0.5

    def _spawn_enemy(self) -> None:
        enemy_id = self.rng.choice(self.map_def.enemy_pool)
        enemy_def = ENEMY_DEFS[enemy_id]

        side = self.rng.randrange(4)
        if side == 0:
            pos = pygame.Vector2(-enemy_def.size - 2, self.rng.randrange(0, INTERNAL_H - enemy_def.size))
        elif side == 1:
            pos = pygame.Vector2(INTERNAL_W + 2, self.rng.randrange(0, INTERNAL_H - enemy_def.size))
        elif side == 2:
            pos = pygame.Vector2(self.rng.randrange(0, INTERNAL_W - enemy_def.size), -enemy_def.size - 2)
        else:
            pos = pygame.Vector2(self.rng.randrange(0, INTERNAL_W - enemy_def.size), INTERNAL_H + 2)

        self.enemies.append(Enemy(enemy_def, pos))

    def _game_over(self) -> None:
        self.app.set_state(
            GameOverState(
                self.app,
                character=self.character,
                map_def=self.map_def,
                level=self.player.level,
                kills=self.kills,
                elapsed_s=self.elapsed_s,
            )
        )

    def _add_weapon(self, weapon_id: str) -> bool:
        if len(self.player.weapons) >= 6:
            return False
        self.player.weapons.append(WeaponInstance(WEAPON_DEFS[weapon_id]))
        self._arrange_weapon_angles()
        return True

    def _upgrade_weapon(self, weapon: WeaponInstance) -> None:
        weapon.level += 1

    def _generate_upgrades(self) -> list[Upgrade]:
        p = self.player
        pool: list[Upgrade] = []

        def add(u: Upgrade, weight: int = 1) -> None:
            for _ in range(weight):
                pool.append(u)

        def vitality(pl: Player, _g: GameState) -> None:
            pl.max_hp += 12
            pl.hp = min(pl.max_hp, pl.hp + 12)

        def power(pl: Player, _g: GameState) -> None:
            pl.damage_mult *= 1.10

        def haste(pl: Player, _g: GameState) -> None:
            pl.cooldown_mult *= 0.90

        def agility(pl: Player, _g: GameState) -> None:
            pl.move_speed *= 1.10

        def regen(pl: Player, _g: GameState) -> None:
            pl.regen += 0.25

        def xp_gain(pl: Player, _g: GameState) -> None:
            pl.xp_mult *= 1.15

        def heal(pl: Player, _g: GameState) -> None:
            pl.hp = min(pl.max_hp, pl.hp + pl.max_hp * 0.30)

        add(Upgrade("力量 +10%", "所有武器伤害提高。", power), weight=4)
        add(Upgrade("急速 -10%", "所有武器冷却降低。", haste), weight=4)
        add(Upgrade("体魄 +12", "最大生命提高并回复同等生命。", vitality), weight=3)
        add(Upgrade("敏捷 +10%", "移动速度提高。", agility), weight=3)
        add(Upgrade("回复 +0.25/s", "每秒恢复更多生命。", regen), weight=2)
        add(Upgrade("经验 +15%", "击杀获得更多经验。", xp_gain), weight=2)
        add(Upgrade("治疗 30%", "立刻回复 30% 最大生命。", heal), weight=2)

        if p.weapons:
            w = self.rng.choice(p.weapons)

            def up_weapon(_pl: Player, g: GameState, ww: WeaponInstance = w) -> None:
                g._upgrade_weapon(ww)

            add(Upgrade(f"升级：{w.weapon_def.name} +1", "提升该武器等级（伤害/冷却更强）。", up_weapon), weight=5)

        picked: list[Upgrade] = []
        seen: set[str] = set()
        for _ in range(200):
            if len(picked) >= 3 or not pool:
                break
            u = self.rng.choice(pool)
            if u.title in seen:
                continue
            seen.add(u.title)
            picked.append(u)

        while len(picked) < 3:
            picked.append(Upgrade("空选项", "（demo占位）", lambda _pl, _g: None))
        return picked

    def _level_up(self) -> None:
        self.level_up_options = self._generate_upgrades()
        self.level_up_index = 0

    def _pick_level_up(self) -> None:
        if self.level_up_options is None:
            return
        choice = self.level_up_options[self.level_up_index]
        choice.apply(self.player, self)
        self.level_up_options = None

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            if self.level_up_options is not None:
                if event.key in (pygame.K_LEFT, pygame.K_a):
                    self.level_up_index = (self.level_up_index - 1) % 3
                elif event.key in (pygame.K_RIGHT, pygame.K_d):
                    self.level_up_index = (self.level_up_index + 1) % 3
                elif event.key in (pygame.K_1, pygame.K_2, pygame.K_3):
                    self.level_up_index = event.key - pygame.K_1
                    self._pick_level_up()
                elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                    self._pick_level_up()
                return

            if event.key in (pygame.K_ESCAPE,):
                self.paused = not self.paused
                self.pause_index = 0
                return

            if not self.paused:
                return

            if event.key in (pygame.K_UP, pygame.K_w):
                self.pause_index = (self.pause_index - 1) % 2
            elif event.key in (pygame.K_DOWN, pygame.K_s):
                self.pause_index = (self.pause_index + 1) % 2
            elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                if self.pause_index == 0:
                    self.paused = False
                else:
                    self.app.set_state(MainMenuState(self.app))
            return

        if event.type not in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONDOWN):
            return
        if not hasattr(event, "pos"):
            return

        internal = self.app.screen_to_internal(event.pos)
        if internal is None:
            return

        self.grid_btn_hover = self.grid_btn_rect.collidepoint(internal)
        if (
            event.type == pygame.MOUSEBUTTONDOWN
            and getattr(event, "button", 0) == 1
            and self.grid_btn_hover
        ):
            self.app.set_config(show_grid=not self.app.config.show_grid)
            return

        if self.level_up_options is not None:
            for i, rect in enumerate(self.level_up_rects):
                if rect.collidepoint(internal):
                    self.level_up_index = i
                    if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
                        self._pick_level_up()
                    break
            return

        if not self.paused:
            return

        for i, rect in enumerate(self.pause_item_rects):
            if rect.collidepoint(internal):
                self.pause_index = i
                if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
                    if i == 0:
                        self.paused = False
                    else:
                        self.app.set_state(MainMenuState(self.app))
                break

    def update(self, dt: float) -> None:
        if self.paused or self.level_up_options is not None:
            return

        self.elapsed_s += dt

        p = self.player
        keys = pygame.key.get_pressed()
        move = pygame.Vector2(0, 0)
        if keys[pygame.K_a] or keys[pygame.K_LEFT]:
            move.x -= 1
        if keys[pygame.K_d] or keys[pygame.K_RIGHT]:
            move.x += 1
        if keys[pygame.K_w] or keys[pygame.K_UP]:
            move.y -= 1
        if keys[pygame.K_s] or keys[pygame.K_DOWN]:
            move.y += 1
        if move.length_squared() > 0:
            move = move.normalize()
            p.last_move_dir = pygame.Vector2(move)

        p.update_visual(dt, move)
        p.pos += move * p.move_speed * dt
        p.pos.x = clamp(p.pos.x, 0, INTERNAL_W - p.w)
        p.pos.y = clamp(p.pos.y, 0, INTERNAL_H - p.h)

        pr_pick = p.rect()
        for drop in list(self.weapon_drops):
            drop.bob_t += dt
            if drop.rect().colliderect(pr_pick):
                if self._add_weapon(drop.weapon_id):
                    self.weapon_drops.remove(drop)

        p.invuln_s = max(0.0, p.invuln_s - dt)
        p.hurt_s = max(0.0, p.hurt_s - dt)
        if p.regen > 0:
            p.hp = min(p.max_hp, p.hp + p.regen * dt)

        for w in p.weapons:
            w.update(dt, p, self)

        cap = 90
        self.spawn_cd -= dt
        if self.spawn_cd <= 0.0 and len(self.enemies) < cap:
            self._spawn_enemy()
            base = 0.7
            accel = min(0.55, self.elapsed_s * 0.01 + (p.level - 1) * 0.01)
            self.spawn_cd = max(0.12, base - accel)

        pr = p.rect()
        for e in self.enemies:
            e.update_visual(dt)
            to_p = (p.center() - e.center())
            v = pygame.Vector2(0, 0)
            if to_p.length_squared() > 0.01:
                v = to_p.normalize() * e.enemy_def.speed

            e.pos += (v + e.vel) * dt
            drag = math.pow(0.82, dt * 60.0)
            e.vel *= drag
            if e.vel.length_squared() < 0.01:
                e.vel.update(0.0, 0.0)
            if e.rect().colliderect(pr) and p.invuln_s <= 0.0:
                p.hp -= e.enemy_def.contact_damage
                p.invuln_s = 0.45
                p.hurt_s = 0.20
                if to_p.length_squared() > 0.01:
                    p.pos += to_p.normalize() * 10
                    p.pos.x = clamp(p.pos.x, 0, INTERNAL_W - p.w)
                    p.pos.y = clamp(p.pos.y, 0, INTERNAL_H - p.h)

        for s in list(self.swings):
            s.ttl_s -= dt
            if s.ttl_s <= 0:
                self.swings.remove(s)
                continue
            for e in self.enemies:
                if e.uid in s.hit_uids:
                    continue
                if s.rect.colliderect(e.rect()):
                    s.hit_uids.add(e.uid)
                    e.hp -= s.damage
                    self.add_damage_text(e.center(), s.damage, color=(255, 240, 200))

        for proj in list(self.projectiles):
            proj.ttl_s -= dt
            if proj.ttl_s <= 0:
                self.projectiles.remove(proj)
                continue

            proj.pos += proj.vel * dt
            if proj.pos.x < -10 or proj.pos.x > INTERNAL_W + 10 or proj.pos.y < -10 or proj.pos.y > INTERNAL_H + 10:
                self.projectiles.remove(proj)
                continue

            r = proj.rect()
            for e in self.enemies:
                if e.uid in proj.hit_uids:
                    continue
                if r.colliderect(e.rect()):
                    proj.hit_uids.add(e.uid)
                    if proj.aoe_radius > 0.0:
                        self._explode(e.center(), proj)
                        if proj in self.projectiles:
                            self.projectiles.remove(proj)
                        break
                    dmg = proj.damage
                    e.hp -= dmg
                    self.add_damage_text(e.center(), dmg, color=(255, 255, 255))
                    if proj.knockback > 0.0:
                        d = pygame.Vector2(proj.vel)
                        if d.length_squared() > 0.01:
                            d = d.normalize()
                        else:
                            d = pygame.Vector2(1, 0)
                        kb = proj.knockback * (1.25 if e.enemy_def.id == "slime" else 1.0)
                        e.vel += d * kb
                    if proj.pierce > 0:
                        proj.pierce -= 1
                    else:
                        self.projectiles.remove(proj)
                    break

        for t in list(self.damage_texts):
            t.ttl_s -= dt
            if t.ttl_s <= 0:
                self.damage_texts.remove(t)
                continue
            t.vel.y += 70.0 * dt
            t.pos += t.vel * dt

        for fx in list(self.explosions):
            fx.ttl_s -= dt
            if fx.ttl_s <= 0:
                self.explosions.remove(fx)

        for e in list(self.enemies):
            if e.hp > 0:
                continue
            self.enemies.remove(e)
            self.kills += 1
            p.xp += e.enemy_def.xp_value * p.xp_mult
            if len(self.weapon_drops) < 12 and self.rng.random() < 0.18:
                weapon_id = self.rng.choice(tuple(WEAPON_DEFS.keys()))
                self.weapon_drops.append(WeaponDrop(weapon_id, pygame.Vector2(e.center())))

        if p.hp <= 0:
            self._game_over()
            return

        if p.xp >= p.xp_to_next:
            p.xp -= p.xp_to_next
            p.level += 1
            p.xp_to_next = p.xp_to_next * 1.20 + 3.0
            self._level_up()

    def draw(self, surface: pygame.Surface) -> None:
        surface.blit(self.background, (0, 0))

        for drop in self.weapon_drops:
            weapon_def = WEAPON_DEFS.get(drop.weapon_id)
            color = (200, 200, 200) if weapon_def is None else weapon_def.color
            bob = math.sin(drop.bob_t * 4.0) * 1.5
            cx, cy = int(drop.pos.x), int(drop.pos.y + bob)
            if weapon_def is not None and weapon_def.sprite is not None:
                spr = weapon_def.sprite
                r = spr.get_rect(center=(cx, cy))
                bg = r.inflate(4, 4)
                pygame.draw.rect(surface, (20, 20, 24), bg)
                pygame.draw.rect(surface, (0, 0, 0), bg, 1)
                surface.blit(spr, r)
            else:
                r = pygame.Rect(0, 0, 8, 8)
                r.center = (cx, cy)
                pygame.draw.rect(surface, color, r)
                pygame.draw.rect(surface, (0, 0, 0), r, 1)

        for e in self.enemies:
            if e.sprite is not None:
                surface.blit(e.sprite, (int(e.pos.x), int(e.pos.y)))
            else:
                pygame.draw.rect(surface, e.enemy_def.color, e.rect())

        for proj in self.projectiles:
            r = proj.rect()
            pygame.draw.rect(surface, proj.color, r)
            pygame.draw.rect(surface, (0, 0, 0), r, 1)
            if proj.vel.length_squared() > 0.01:
                speed2 = proj.vel.length_squared()
                tail_len = 3.0
                if proj.aoe_radius > 0.0:
                    tail_len = 7.0
                elif proj.pierce >= 3 or speed2 >= 600.0 * 600.0:
                    tail_len = 10.0
                elif proj.size <= 1:
                    tail_len = 4.0
                tail = proj.vel.normalize() * -tail_len
                pygame.draw.line(
                    surface,
                    (255, 255, 255),
                    (int(proj.pos.x), int(proj.pos.y)),
                    (int(proj.pos.x + tail.x), int(proj.pos.y + tail.y)),       
                    1,
                )

        p = self.player
        ppos = (int(p.pos.x + p.draw_offset.x), int(p.pos.y + p.draw_offset.y))
        spr = p.sprite
        if p.hurt_s > 0.0:
            img = spr.copy()
            img.fill((140, 20, 20), special_flags=pygame.BLEND_RGB_ADD)
            surface.blit(img, ppos)
        elif p.invuln_s > 0.0 and int(p.invuln_s * 20) % 2 == 0:
            img = spr.copy()
            img.fill((90, 10, 10), special_flags=pygame.BLEND_RGB_ADD)
            surface.blit(img, ppos)
        else:
            surface.blit(spr, ppos)
        fx = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)     
        for boom in self.explosions:
            t = clamp(boom.ttl_s / 0.22, 0.0, 1.0)
            a0 = int(120 * t)
            a1 = int(220 * t)
            x, y = int(boom.pos.x), int(boom.pos.y)
            r = max(1, int(boom.radius))
            pygame.draw.circle(fx, (boom.color.r, boom.color.g, boom.color.b, a0), (x, y), r)
            pygame.draw.circle(fx, (255, 255, 255, a1), (x, y), max(1, int(r * 0.35)))
        for w in p.weapons:
            if w.weapon_def.kind != "melee" or len(w.trail) < 2:
                continue
            for i in range(1, len(w.trail)):
                p0, age0 = w.trail[i - 1]
                p1, age1 = w.trail[i]
                age = max(age0, age1)
                a = int(220 * (1.0 - age / 0.18))
                if a <= 0:
                    continue
                x0, y0 = int(p0.x), int(p0.y)
                x1, y1 = int(p1.x), int(p1.y)
                pygame.draw.line(fx, (255, 255, 255, max(0, a // 4)), (x0, y0), (x1, y1), 6)
                pygame.draw.line(fx, (255, 255, 255, a), (x0, y0), (x1, y1), 3)
        surface.blit(fx, (0, 0))

        for w in p.weapons:
            if w.weapon_def.kind == "melee":
                if w.sword_poly:
                    d = w.sword_tip - w.sword_base
                    if d.length_squared() > 0.01:
                        d = d.normalize()
                        pygame.draw.line(surface, (160, 120, 80), w.sword_base, w.sword_base + d * 3, 3)
                    pygame.draw.polygon(surface, w.weapon_def.color, w.sword_poly)
                    pygame.draw.polygon(surface, (0, 0, 0), w.sword_poly, 1)
                else:
                    pygame.draw.rect(surface, w.weapon_def.color, w.orbit_rect)
                    pygame.draw.rect(surface, (0, 0, 0), w.orbit_rect, 1)
            elif w.weapon_def.kind == "gun":
                center = pygame.Vector2(w.orbit_rect.centerx, w.orbit_rect.centery)
                ang = w.aim_angle + (w.reload_spin if w.reload_left > 0.0 else 0.0)
                aim_dir = pygame.Vector2(math.cos(w.aim_angle), math.sin(w.aim_angle))
                if aim_dir.length_squared() <= 0.0001:
                    aim_dir = pygame.Vector2(1, 0)
                spr = w.weapon_def.sprite
                if spr is not None:
                    flip = float(aim_dir.x) < 0.0
                    if flip:
                        spr = flip_x_pixel_sprite(spr)
                    deg = -math.degrees(ang)
                    if flip:
                        deg -= 180.0
                    step = 15.0 if w.reload_left > 0.0 else 5.0
                    rot = rotate_pixel_sprite_crisp(spr, deg, step_deg=step) 
                    kick = 0.0
                    if w.muzzle_flash_s > 0.0 and w.reload_left <= 0.0:
                        flash_total = 0.10 if w.weapon_def.aoe_radius > 0.0 else 0.06
                        t = clamp(w.muzzle_flash_s / max(0.001, flash_total), 0.0, 1.0)
                        kick = 2.0 * t
                    draw_center = center - aim_dir * kick
                    surface.blit(rot, rot.get_rect(center=(int(round(draw_center.x)), int(round(draw_center.y)))))

                    if w.muzzle_flash_s > 0.0 and w.reload_left <= 0.0:
                        flash_total = 0.10 if w.weapon_def.aoe_radius > 0.0 else 0.06
                        t = clamp(w.muzzle_flash_s / max(0.001, flash_total), 0.0, 1.0)
                        tip_dist = max(6.0, spr.get_width() * 0.5 - 1.0)
                        tip = draw_center + aim_dir * tip_dist
                        x, y = int(round(tip.x)), int(round(tip.y))
                        rad = 1 + int(2 * t)
                        core = (255, 255, 255)
                        glow = (255, 220, 120) if w.weapon_def.aoe_radius <= 0.0 else (255, 160, 90)
                        pygame.draw.circle(surface, glow, (x, y), rad)
                        pygame.draw.circle(surface, core, (x, y), max(1, rad - 1))
                else:
                    pygame.draw.rect(surface, w.weapon_def.color, w.orbit_rect) 
                    pygame.draw.rect(surface, (0, 0, 0), w.orbit_rect, 1)       

                if w.reload_left > 0.0 and w.reload_total > 0.0:
                    t = 1.0 - (w.reload_left / max(0.001, w.reload_total))
                    t = clamp(t, 0.0, 1.0)
                    bar = pygame.Rect(0, 0, 16, 3)
                    bar.center = (int(center.x), int(center.y - 9))
                    pygame.draw.rect(surface, (10, 10, 12), bar)
                    fill = pygame.Rect(bar.x + 1, bar.y + 1, int((bar.w - 2) * t), bar.h - 2)
                    pygame.draw.rect(surface, (120, 220, 140), fill)
                    pygame.draw.rect(surface, (0, 0, 0), bar, 1)
            else:
                pygame.draw.rect(surface, w.weapon_def.color, w.orbit_rect)
                pygame.draw.rect(surface, (0, 0, 0), w.orbit_rect, 1)

        for t in self.damage_texts:
            x, y = int(t.pos.x), int(t.pos.y)
            draw_text(surface, self.app.font_s, t.text, (x + 1, y + 1), pygame.Color(0, 0, 0), anchor="center")
            draw_text(surface, self.app.font_s, t.text, (x, y), t.color, anchor="center")

        self._draw_ui(surface)
        if self.paused:
            self._draw_pause(surface)
        if self.level_up_options is not None:
            self._draw_level_up(surface)

    def _draw_ui(self, surface: pygame.Surface) -> None:
        p = self.player

        hp_w, hp_h = 150, 8
        x, y = 10, 10
        pygame.draw.rect(surface, (20, 20, 24), pygame.Rect(x, y, hp_w, hp_h))
        fill = int(hp_w * (p.hp / max(1, p.max_hp)))
        pygame.draw.rect(surface, (220, 70, 70), pygame.Rect(x, y, fill, hp_h))
        pygame.draw.rect(surface, (70, 70, 80), pygame.Rect(x, y, hp_w, hp_h), 1)
        draw_text(surface, self.app.font_s, f"HP {int(p.hp)}/{p.max_hp}", (x + hp_w + 8, y - 2), pygame.Color(230, 230, 240))

        xp_w, xp_h = 220, 6
        x2, y2 = 10, 22
        pygame.draw.rect(surface, (20, 20, 24), pygame.Rect(x2, y2, xp_w, xp_h))
        fill2 = int(xp_w * (p.xp / max(1.0, p.xp_to_next)))
        pygame.draw.rect(surface, (90, 190, 120), pygame.Rect(x2, y2, fill2, xp_h))
        pygame.draw.rect(surface, (70, 70, 80), pygame.Rect(x2, y2, xp_w, xp_h), 1)
        draw_text(surface, self.app.font_s, f"Lv {p.level}", (x2 + xp_w + 8, y2 - 3), pygame.Color(230, 230, 240))

        draw_text(surface, self.app.font_s, f"{self.map_def.name}", (INTERNAL_W - 10, 10), pygame.Color(230, 230, 240), anchor="topright")
        draw_text(surface, self.app.font_s, f"时间 {format_time(self.elapsed_s)}", (INTERNAL_W - 10, 26), pygame.Color(200, 200, 210), anchor="topright")       
        draw_text(surface, self.app.font_s, f"击杀 {self.kills}", (INTERNAL_W - 10, 42), pygame.Color(200, 200, 210), anchor="topright")
        self.grid_btn_rect = pygame.Rect(0, 0, 84, 18)
        self.grid_btn_rect.topright = (INTERNAL_W - 10, 54)
        draw_button(
            surface,
            self.app.font_s,
            f"网格:{'开' if self.app.config.show_grid else '关'}",
            self.grid_btn_rect,
            selected=self.grid_btn_hover or self.app.config.show_grid,
        )

        wx = 10
        wy = INTERNAL_H - 18
        for w in p.weapons[:6]:
            pygame.draw.rect(surface, w.weapon_def.color, pygame.Rect(wx, wy, 12, 8))
            pygame.draw.rect(surface, (0, 0, 0), pygame.Rect(wx, wy, 12, 8), 1)
            draw_text(surface, self.app.font_s, f"{w.level}", (wx + 6, wy - 12), pygame.Color(240, 240, 240), anchor="center")
            wx += 18

    def _draw_pause(self, surface: pygame.Surface) -> None:
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 160))
        surface.blit(overlay, (0, 0))

        draw_text(surface, self.app.font_l, "暂停", (INTERNAL_W // 2, 40), pygame.Color(240, 240, 240), anchor="center")

        self.pause_item_rects = []
        items = ["继续", "返回主菜单"]
        y0 = 84
        for i, label in enumerate(items):
            rect = pygame.Rect(0, 0, 200, 22)
            rect.center = (INTERNAL_W // 2, y0 + i * 30)
            self.pause_item_rects.append(draw_button(surface, self.app.font_m, label, rect, selected=(i == self.pause_index)))

        draw_text(surface, self.app.font_s, "方向键/鼠标选择 | Enter/左键确认 | Esc返回", (INTERNAL_W // 2, INTERNAL_H - 12), pygame.Color(180, 180, 190), anchor="center")

    def _draw_level_up(self, surface: pygame.Surface) -> None:
        if self.level_up_options is None:
            return
        overlay = pygame.Surface((INTERNAL_W, INTERNAL_H), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))

        draw_text(surface, self.app.font_l, "升级！选择一项", (INTERNAL_W // 2, 18), pygame.Color(240, 240, 240), anchor="center")

        card_w, card_h = INTERNAL_W - 20, 36
        x = 10
        y0 = 38
        gap = 8
        self.level_up_rects = []
        for i, u in enumerate(self.level_up_options):
            y = y0 + i * (card_h + gap)
            rect = pygame.Rect(x, y, card_w, card_h)
            self.level_up_rects.append(rect)
            bg = (34, 34, 42) if i == self.level_up_index else (24, 24, 30)
            pygame.draw.rect(surface, bg, rect, border_radius=8)
            border = (90, 90, 110) if i == self.level_up_index else (60, 60, 74)
            pygame.draw.rect(surface, border, rect, 2, border_radius=8)

            draw_text(surface, self.app.font_m, u.title, (rect.left + 10, rect.top + 4), pygame.Color(240, 240, 240))
            draw_text(surface, self.app.font_s, u.desc, (rect.left + 10, rect.top + 22), pygame.Color(200, 200, 210))
            draw_text(surface, self.app.font_s, f"[{i+1}]", (rect.right - 12, rect.centery), pygame.Color(160, 160, 170), anchor="center")

        draw_text(surface, self.app.font_s, "按 1/2/3 或点击选择", (INTERNAL_W // 2, INTERNAL_H - 12), pygame.Color(180, 180, 190), anchor="center")


class GameOverState(State):
    def __init__(self, app: App, *, character: CharacterDef, map_def: MapDef, level: int, kills: int, elapsed_s: float) -> None:
        super().__init__(app)
        self.character = character
        self.map_def = map_def
        self.level = level
        self.kills = kills
        self.elapsed_s = elapsed_s
        self.index = 0
        self.item_rects: list[pygame.Rect] = []

    def _activate(self) -> None:
        if self.index == 0:
            self.app.set_state(GameState(self.app, character=self.character, map_def=self.map_def))
        else:
            self.app.set_state(MainMenuState(self.app))

    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.KEYDOWN:
            if event.key in (pygame.K_UP, pygame.K_w):
                self.index = (self.index - 1) % 2
            elif event.key in (pygame.K_DOWN, pygame.K_s):
                self.index = (self.index + 1) % 2
            elif event.key in (pygame.K_RETURN, pygame.K_SPACE):
                self._activate()
            return

        if event.type not in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONDOWN):
            return
        if not hasattr(event, "pos"):
            return

        internal = self.app.screen_to_internal(event.pos)
        if internal is None:
            return

        for i, rect in enumerate(self.item_rects):
            if rect.collidepoint(internal):
                self.index = i
                if event.type == pygame.MOUSEBUTTONDOWN and getattr(event, "button", 0) == 1:
                    self._activate()
                break

    def draw(self, surface: pygame.Surface) -> None:
        surface.fill((10, 10, 14))
        draw_text(surface, self.app.font_l, "游戏结束", (INTERNAL_W // 2, 26), pygame.Color(240, 240, 240), anchor="center")
        draw_text(
            surface,
            self.app.font_s,
            f"角色：{self.character.name}  场景：{self.map_def.name}",
            (INTERNAL_W // 2, 46),
            pygame.Color(180, 180, 190),
            anchor="center",
        )
        draw_text(surface, self.app.font_s, f"时间：{format_time(self.elapsed_s)}", (INTERNAL_W // 2, 62), pygame.Color(200, 200, 210), anchor="center")
        draw_text(surface, self.app.font_s, f"击杀：{self.kills}  等级：{self.level}", (INTERNAL_W // 2, 78), pygame.Color(200, 200, 210), anchor="center")

        self.item_rects = []
        items = ["再来一局", "返回主菜单"]
        y0 = 112
        for i, label in enumerate(items):
            rect = pygame.Rect(0, 0, 200, 22)
            rect.center = (INTERNAL_W // 2, y0 + i * 30)
            self.item_rects.append(draw_button(surface, self.app.font_m, label, rect, selected=(i == self.index)))

        draw_text(surface, self.app.font_s, "方向键/鼠标选择 | Enter/左键确认", (INTERNAL_W // 2, INTERNAL_H - 12), pygame.Color(170, 170, 180), anchor="center")


def main() -> int:
    try:
        App().run()
        return 0
    except Exception as exc:
        try:
            pygame.quit()
        except Exception:
            pass
        print("Fatal error:", exc, file=sys.stderr)
        return 1


if __name__ == "__main__":
    raise SystemExit(main())
